<!DOCTYPE html>

<html lang="zh-CN" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="初始化，最终化和线程" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/c-api/init.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="请参阅 Python 初始化配置 了解如何在初始化之前配置解释器的详情。 在Python初始化之前: 在一个植入了 Python 的应用程序中， Py_Initialize() 函数必须在任何其他 Python/C API 函数之前被调用；例外的只有个别函数和 全局配置变量 。 在初始化Python之前，可以安全地调用以下函数： 初始化解释器的函数：- Py_Initialize(), Py..." />
<meta property="og:image:width" content="1146" />
<meta property="og:image:height" content="600" />
<meta property="og:image" content="https://docs.python.org/3.14/zh-cn/_images/social_previews/summary_c-api_init_db22e127.png" />
<meta property="og:image:alt" content="请参阅 Python 初始化配置 了解如何在初始化之前配置解释器的详情。 在Python初始化之前: 在一个植入了 Python 的应用程序中， Py_Initialize() 函数必须在任何其他 Python/C API 函数之前被调用；例外的只有个别函数和 全局配置变量 。 在初始化Python之前，可以安全地调用以下函数： 初始化解释器的函数：- Py_Initialize(), Py..." />
<meta name="description" content="请参阅 Python 初始化配置 了解如何在初始化之前配置解释器的详情。 在Python初始化之前: 在一个植入了 Python 的应用程序中， Py_Initialize() 函数必须在任何其他 Python/C API 函数之前被调用；例外的只有个别函数和 全局配置变量 。 在初始化Python之前，可以安全地调用以下函数： 初始化解释器的函数：- Py_Initialize(), Py..." />
<meta name="twitter:card" content="summary_large_image" />
<meta name="theme-color" content="#3776ab">

    <title>初始化，最终化和线程 &#8212; Python 3.14.0 文档</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=234b1a7c" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=8cd84f99" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=5349f25f" />
    
    <script src="../_static/documentation_options.js?v=a595ec0e"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=beaddf03"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.14.0 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于此文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权" href="../copyright.html" />
    <link rel="next" title="Python 初始化配置" href="init_config.html" />
    <link rel="prev" title="DateTime 对象" href="datetime.html" />
    
      
      <script defer file-types="bz2,epub,zip" data-domain="docs.python.org" src="https://analytics.python.org/js/script.file-downloads.outbound-links.js"></script>
      
      <link rel="canonical" href="https://docs.python.org/3/c-api/init.html">
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg">
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="菜单">
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo">
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q">
                <input type="submit" value="转到">
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    主题
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>自动</option>
        <option value="light">明亮</option>
        <option value="dark">黑暗</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#">初始化，最终化和线程</a><ul>
<li><a class="reference internal" href="#before-python-initialization">在Python初始化之前</a></li>
<li><a class="reference internal" href="#global-configuration-variables">全局配置变量</a></li>
<li><a class="reference internal" href="#initializing-and-finalizing-the-interpreter">初始化和最终化解释器</a></li>
<li><a class="reference internal" href="#process-wide-parameters">进程级参数</a></li>
<li><a class="reference internal" href="#thread-state-and-the-global-interpreter-lock">线程状态和全局解释器锁</a><ul>
<li><a class="reference internal" href="#detaching-the-thread-state-from-extension-code">从扩展代码分离线程状态</a></li>
<li><a class="reference internal" href="#non-python-created-threads">非Python创建的线程</a></li>
<li><a class="reference internal" href="#supporting-subinterpreters-in-non-python-threads">在非Python线程中支持子解释器</a></li>
<li><a class="reference internal" href="#cautions-about-fork">有关 fork() 的注意事项</a></li>
<li><a class="reference internal" href="#cautions-regarding-runtime-finalization">有关运行时最终化的注意事项</a></li>
<li><a class="reference internal" href="#high-level-api">高阶 API</a></li>
<li><a class="reference internal" href="#low-level-api">底层级 API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sub-interpreter-support">子解释器支持</a><ul>
<li><a class="reference internal" href="#a-per-interpreter-gil">解释器级 GIL</a></li>
<li><a class="reference internal" href="#bugs-and-caveats">错误和警告</a></li>
</ul>
</li>
<li><a class="reference internal" href="#asynchronous-notifications">异步通知</a></li>
<li><a class="reference internal" href="#profiling-and-tracing">分析和跟踪</a></li>
<li><a class="reference internal" href="#reference-tracing">引用追踪</a></li>
<li><a class="reference internal" href="#advanced-debugger-support">高级调试器支持</a></li>
<li><a class="reference internal" href="#thread-local-storage-support">线程本地存储支持</a><ul>
<li><a class="reference internal" href="#thread-specific-storage-tss-api">线程专属存储 (TSS) API</a><ul>
<li><a class="reference internal" href="#dynamic-allocation">动态分配</a></li>
<li><a class="reference internal" href="#methods">方法</a></li>
</ul>
</li>
<li><a class="reference internal" href="#thread-local-storage-tls-api">线程本地存储 (TLS) API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#synchronization-primitives">同步原语</a><ul>
<li><a class="reference internal" href="#python-critical-section-api">Python 关键节 API</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一主题</h4>
    <p class="topless"><a href="datetime.html"
                          title="上一章">DateTime 对象</a></p>
  </div>
  <div>
    <h4>下一主题</h4>
    <p class="topless"><a href="init_config.html"
                          title="下一章">Python 初始化配置</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">报告代码错误</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/c-api/init.rst?plain=1"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="init_config.html" title="Python 初始化配置"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="datetime.html" title="DateTime 对象"
             accesskey="P">上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.14.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python/C API 参考手册</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">初始化，最终化和线程</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q" id="search-box">
          <input type="submit" value="转到">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    主题
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>自动</option>
        <option value="light">明亮</option>
        <option value="dark">黑暗</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="initialization-finalization-and-threads">
<span id="initialization"></span><h1 class="translated">初始化，最终化和线程<a class="headerlink" href="#initialization-finalization-and-threads" title="Link to this heading">¶</a></h1>
<p class="translated">请参阅 <a class="reference internal" href="init_config.html#init-config"><span class="std std-ref">Python 初始化配置</span></a> 了解如何在初始化之前配置解释器的详情。</p>
<section id="before-python-initialization">
<span id="pre-init-safe"></span><h2 class="translated">在Python初始化之前<a class="headerlink" href="#before-python-initialization" title="Link to this heading">¶</a></h2>
<p class="translated">在一个植入了 Python 的应用程序中，<a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 函数必须在任何其他 Python/C API 函数之前被调用；例外的只有个别函数和 <a class="reference internal" href="#global-conf-vars"><span class="std std-ref">全局配置变量</span></a>。</p>
<p class="translated">在初始化Python之前，可以安全地调用以下函数：</p>
<ul class="simple">
<li><p class="translated">初始化解释器的函数：</p>
<ul>
<li><p class="translated"><a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="#c.Py_InitializeEx" title="Py_InitializeEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_InitializeEx()</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="#c.Py_InitializeFromConfig" title="Py_InitializeFromConfig"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_InitializeFromConfig()</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="#c.Py_BytesMain" title="Py_BytesMain"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_BytesMain()</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="#c.Py_Main" title="Py_Main"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Main()</span></code></a></p></li>
<li><p class="translated">运行时预初始化相关函数在 <a class="reference internal" href="init_config.html#init-config"><span class="std std-ref">Python 初始化配置</span></a> 中介绍</p></li>
</ul>
</li>
<li><p class="translated">配置函数：</p>
<ul>
<li><p class="translated"><a class="reference internal" href="import.html#c.PyImport_AppendInittab" title="PyImport_AppendInittab"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_AppendInittab()</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="import.html#c.PyImport_ExtendInittab" title="PyImport_ExtendInittab"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_ExtendInittab()</span></code></a></p></li>
<li><p class="translated"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInitFrozenExtensions()</span></code></p></li>
<li><p class="translated"><a class="reference internal" href="memory.html#c.PyMem_SetAllocator" title="PyMem_SetAllocator"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_SetAllocator()</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="memory.html#c.PyMem_SetupDebugHooks" title="PyMem_SetupDebugHooks"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_SetupDebugHooks()</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="memory.html#c.PyObject_SetArenaAllocator" title="PyObject_SetArenaAllocator"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_SetArenaAllocator()</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="#c.Py_SetProgramName" title="Py_SetProgramName"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetProgramName()</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="#c.Py_SetPythonHome" title="Py_SetPythonHome"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetPythonHome()</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="sys.html#c.PySys_ResetWarnOptions" title="PySys_ResetWarnOptions"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_ResetWarnOptions()</span></code></a></p></li>
<li><p class="translated">配置相关函数在 <a class="reference internal" href="init_config.html#init-config"><span class="std std-ref">Python 初始化配置</span></a> 中介绍</p></li>
</ul>
</li>
<li><p class="translated">信息函数：</p>
<ul>
<li><p class="translated"><a class="reference internal" href="#c.Py_IsInitialized" title="Py_IsInitialized"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_IsInitialized()</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="memory.html#c.PyMem_GetAllocator" title="PyMem_GetAllocator"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_GetAllocator()</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="memory.html#c.PyObject_GetArenaAllocator" title="PyObject_GetArenaAllocator"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetArenaAllocator()</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="#c.Py_GetBuildInfo" title="Py_GetBuildInfo"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetBuildInfo()</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="#c.Py_GetCompiler" title="Py_GetCompiler"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetCompiler()</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="#c.Py_GetCopyright" title="Py_GetCopyright"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetCopyright()</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="#c.Py_GetPlatform" title="Py_GetPlatform"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetPlatform()</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="#c.Py_GetVersion" title="Py_GetVersion"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetVersion()</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="#c.Py_IsInitialized" title="Py_IsInitialized"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_IsInitialized()</span></code></a></p></li>
</ul>
</li>
<li><p class="translated">工具</p>
<ul>
<li><p class="translated"><a class="reference internal" href="sys.html#c.Py_DecodeLocale" title="Py_DecodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DecodeLocale()</span></code></a></p></li>
<li><p class="translated">状态报告和工具相关函数在 <a class="reference internal" href="init_config.html#init-config"><span class="std std-ref">Python 初始化配置</span></a> 中介绍</p></li>
</ul>
</li>
<li><p class="translated">内存分配器：</p>
<ul>
<li><p class="translated"><a class="reference internal" href="memory.html#c.PyMem_RawMalloc" title="PyMem_RawMalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawMalloc()</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="memory.html#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawRealloc()</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="memory.html#c.PyMem_RawCalloc" title="PyMem_RawCalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawCalloc()</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="memory.html#c.PyMem_RawFree" title="PyMem_RawFree"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawFree()</span></code></a></p></li>
</ul>
</li>
<li><p class="translated">同步：</p>
<ul>
<li><p class="translated"><a class="reference internal" href="#c.PyMutex_Lock" title="PyMutex_Lock"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMutex_Lock()</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="#c.PyMutex_Unlock" title="PyMutex_Unlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMutex_Unlock()</span></code></a></p></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p class="translated">虽然它们看起来与上面列出的某些函数类似，但以下函数 <strong>不应</strong> 在解释器被初始化之前调用: <a class="reference internal" href="sys.html#c.Py_EncodeLocale" title="Py_EncodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_EncodeLocale()</span></code></a>, <a class="reference internal" href="#c.Py_GetPath" title="Py_GetPath"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetPath()</span></code></a>, <a class="reference internal" href="#c.Py_GetPrefix" title="Py_GetPrefix"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetPrefix()</span></code></a>, <a class="reference internal" href="#c.Py_GetExecPrefix" title="Py_GetExecPrefix"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetExecPrefix()</span></code></a>, <a class="reference internal" href="#c.Py_GetProgramFullPath" title="Py_GetProgramFullPath"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetProgramFullPath()</span></code></a>, <a class="reference internal" href="#c.Py_GetPythonHome" title="Py_GetPythonHome"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetPythonHome()</span></code></a>, <a class="reference internal" href="#c.Py_GetProgramName" title="Py_GetProgramName"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetProgramName()</span></code></a>, <a class="reference internal" href="#c.PyEval_InitThreads" title="PyEval_InitThreads"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_InitThreads()</span></code></a> 和 <a class="reference internal" href="#c.Py_RunMain" title="Py_RunMain"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_RunMain()</span></code></a>。</p>
</div>
</section>
<section id="global-configuration-variables">
<span id="global-conf-vars"></span><h2 class="translated">全局配置变量<a class="headerlink" href="#global-configuration-variables" title="Link to this heading">¶</a></h2>
<p class="translated">Python 有负责控制全局配置中不同特性和选项的变量。这些标志默认被 <a class="reference internal" href="../using/cmdline.html#using-on-interface-options"><span class="std std-ref">命令行选项</span></a>。</p>
<p class="translated">当一个选项设置一个旗标时，该旗标的值将是设置选项的次数。 例如，<code class="docutils literal notranslate"><span class="pre">-b</span></code> 会将 <a class="reference internal" href="#c.Py_BytesWarningFlag" title="Py_BytesWarningFlag"><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_BytesWarningFlag</span></code></a> 设为 1 而 <code class="docutils literal notranslate"><span class="pre">-bb</span></code> 会将 <a class="reference internal" href="#c.Py_BytesWarningFlag" title="Py_BytesWarningFlag"><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_BytesWarningFlag</span></code></a> 设为 2.</p>
<dl class="c var">
<dt class="sig sig-object c" id="c.Py_BytesWarningFlag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_BytesWarningFlag</span></span></span><a class="headerlink" href="#c.Py_BytesWarningFlag" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">此 API 仅为向下兼容而保留：应当改为设置 <a class="reference internal" href="init_config.html#c.PyConfig.bytes_warning" title="PyConfig.bytes_warning"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.bytes_warning</span></code></a>，参见 <a class="reference internal" href="init_config.html#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p class="translated">当将 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 或 <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 与 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 比较或者将 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 与 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 比较时发出警告。 如果大于等于 <code class="docutils literal notranslate"><span class="pre">2</span></code> 则报错。</p>
<p class="translated">由 <a class="reference internal" href="../using/cmdline.html#cmdoption-b"><code class="xref std std-option docutils literal notranslate"><span class="pre">-b</span></code></a> 选项设置。</p>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.12, will be removed in version 3.15.</span></p>
</div>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.Py_DebugFlag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_DebugFlag</span></span></span><a class="headerlink" href="#c.Py_DebugFlag" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">此 API 仅为向下兼容而保留：应当改为设置 <a class="reference internal" href="init_config.html#c.PyConfig.parser_debug" title="PyConfig.parser_debug"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.parser_debug</span></code></a>，参见 <a class="reference internal" href="init_config.html#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p class="translated">开启解析器调试输出（限专家使用，依赖于编译选项）。</p>
<p class="translated">由 <a class="reference internal" href="../using/cmdline.html#cmdoption-d"><code class="xref std std-option docutils literal notranslate"><span class="pre">-d</span></code></a> 选项和 <span class="target" id="index-73"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONDEBUG"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONDEBUG</span></code></a> 环境变量设置。</p>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.12, will be removed in version 3.15.</span></p>
</div>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.Py_DontWriteBytecodeFlag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_DontWriteBytecodeFlag</span></span></span><a class="headerlink" href="#c.Py_DontWriteBytecodeFlag" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">此 API 仅为向下兼容而保留：应当改为设置 <a class="reference internal" href="init_config.html#c.PyConfig.write_bytecode" title="PyConfig.write_bytecode"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.write_bytecode</span></code></a>，参见 <a class="reference internal" href="init_config.html#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p class="translated">如果设置为非零, Python 不会在导入源代码时尝试写入 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> 文件</p>
<p class="translated">由 <a class="reference internal" href="../using/cmdline.html#cmdoption-B"><code class="xref std std-option docutils literal notranslate"><span class="pre">-B</span></code></a> 选项和 <span class="target" id="index-74"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONDONTWRITEBYTECODE"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONDONTWRITEBYTECODE</span></code></a> 环境变量设置。</p>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.12, will be removed in version 3.15.</span></p>
</div>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.Py_FrozenFlag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_FrozenFlag</span></span></span><a class="headerlink" href="#c.Py_FrozenFlag" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">此 API 仅为向下兼容而保留：应当改为设置 <a class="reference internal" href="init_config.html#c.PyConfig.pathconfig_warnings" title="PyConfig.pathconfig_warnings"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.pathconfig_warnings</span></code></a>，参见 <a class="reference internal" href="init_config.html#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p class="translated">当在 <a class="reference internal" href="#c.Py_GetPath" title="Py_GetPath"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetPath()</span></code></a> 中计算模块搜索路径时屏蔽错误消息。</p>
<p class="translated">由 <code class="docutils literal notranslate"><span class="pre">_freeze_importlib</span></code> 和 <code class="docutils literal notranslate"><span class="pre">frozenmain</span></code> 程序使用的私有旗标。</p>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.12, will be removed in version 3.15.</span></p>
</div>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.Py_HashRandomizationFlag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_HashRandomizationFlag</span></span></span><a class="headerlink" href="#c.Py_HashRandomizationFlag" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">此 API 仅为向下兼容而保留：应当改为设置 <a class="reference internal" href="init_config.html#c.PyConfig.hash_seed" title="PyConfig.hash_seed"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.hash_seed</span></code></a> 和 <a class="reference internal" href="init_config.html#c.PyConfig.use_hash_seed" title="PyConfig.use_hash_seed"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.use_hash_seed</span></code></a>，参见 <a class="reference internal" href="init_config.html#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p class="translated">如果 <span class="target" id="index-75"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHASHSEED"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONHASHSEED</span></code></a> 环境变量被设为非空字符串则设为 <code class="docutils literal notranslate"><span class="pre">1</span></code>。</p>
<p class="translated">如果该旗标为非零值，则读取 <span class="target" id="index-76"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHASHSEED"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONHASHSEED</span></code></a> 环境变量来初始化加密哈希种子。</p>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.12, will be removed in version 3.15.</span></p>
</div>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.Py_IgnoreEnvironmentFlag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_IgnoreEnvironmentFlag</span></span></span><a class="headerlink" href="#c.Py_IgnoreEnvironmentFlag" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">此 API 仅为向下兼容而保留：应当改为设置 <a class="reference internal" href="init_config.html#c.PyConfig.use_environment" title="PyConfig.use_environment"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.use_environment</span></code></a>，参见 <a class="reference internal" href="init_config.html#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p class="translated">忽略所有 <code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHON*</span></code> 环境变量，例如可能设置的 <span class="target" id="index-77"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONPATH"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONPATH</span></code></a> 和 <span class="target" id="index-78"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHOME"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONHOME</span></code></a>。</p>
<p class="translated">由 <a class="reference internal" href="../using/cmdline.html#cmdoption-E"><code class="xref std std-option docutils literal notranslate"><span class="pre">-E</span></code></a>  和 <a class="reference internal" href="../using/cmdline.html#cmdoption-I"><code class="xref std std-option docutils literal notranslate"><span class="pre">-I</span></code></a> 选项设置。</p>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.12, will be removed in version 3.15.</span></p>
</div>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.Py_InspectFlag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_InspectFlag</span></span></span><a class="headerlink" href="#c.Py_InspectFlag" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">此 API 被保留用于向下兼容：应当改为采用设置 <a class="reference internal" href="init_config.html#c.PyConfig.inspect" title="PyConfig.inspect"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.inspect</span></code></a>，参见 <a class="reference internal" href="init_config.html#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p class="translated">当将脚本作为第一个参数传入或是使用了 <a class="reference internal" href="../using/cmdline.html#cmdoption-c"><code class="xref std std-option docutils literal notranslate"><span class="pre">-c</span></code></a> 选项时，则会在执行该脚本或命令后进入交互模式，即使在 <a class="reference internal" href="../library/sys.html#sys.stdin" title="sys.stdin"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdin</span></code></a> 并非一个终端时也是如此。</p>
<p class="translated">由 <a class="reference internal" href="../using/cmdline.html#cmdoption-i"><code class="xref std std-option docutils literal notranslate"><span class="pre">-i</span></code></a> 选项和 <span class="target" id="index-79"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONINSPECT"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONINSPECT</span></code></a> 环境变量设置。</p>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.12, will be removed in version 3.15.</span></p>
</div>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.Py_InteractiveFlag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_InteractiveFlag</span></span></span><a class="headerlink" href="#c.Py_InteractiveFlag" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">此 API 被保留用于向下兼容：应当改为采用设置 <a class="reference internal" href="init_config.html#c.PyConfig.interactive" title="PyConfig.interactive"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.interactive</span></code></a>，参见 <a class="reference internal" href="init_config.html#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p class="translated">由 <a class="reference internal" href="../using/cmdline.html#cmdoption-i"><code class="xref std std-option docutils literal notranslate"><span class="pre">-i</span></code></a> 选项设置。</p>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.12, will be removed in version 3.15.</span></p>
</div>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.Py_IsolatedFlag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_IsolatedFlag</span></span></span><a class="headerlink" href="#c.Py_IsolatedFlag" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">此 API 被保留用于向下兼容：应当改为设置 <a class="reference internal" href="init_config.html#c.PyConfig.isolated" title="PyConfig.isolated"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.isolated</span></code></a>，参见 <a class="reference internal" href="init_config.html#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p class="translated">以隔离模式运行 Python. 在隔离模式下 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 将不包含脚本的目录或用户的 site-packages 目录。</p>
<p class="translated">由 <a class="reference internal" href="../using/cmdline.html#cmdoption-I"><code class="xref std std-option docutils literal notranslate"><span class="pre">-I</span></code></a> 选项设置。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.12, will be removed in version 3.15.</span></p>
</div>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.Py_LegacyWindowsFSEncodingFlag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_LegacyWindowsFSEncodingFlag</span></span></span><a class="headerlink" href="#c.Py_LegacyWindowsFSEncodingFlag" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">此 API 被保留用于向下兼容：应当改为设置 <a class="reference internal" href="init_config.html#c.PyPreConfig.legacy_windows_fs_encoding" title="PyPreConfig.legacy_windows_fs_encoding"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyPreConfig.legacy_windows_fs_encoding</span></code></a>，参见 <a class="reference internal" href="init_config.html#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p class="translated">如果该旗标为非零值，则使用 <code class="docutils literal notranslate"><span class="pre">mbcs</span></code> 编码和 <code class="docutils literal notranslate"><span class="pre">replace</span></code> 错误处理器，而不是 UTF-8 编码和 <code class="docutils literal notranslate"><span class="pre">surrogatepass</span></code> 错误处理器作用 <a class="reference internal" href="../glossary.html#term-filesystem-encoding-and-error-handler"><span class="xref std std-term">filesystem encoding and error handler</span></a>。</p>
<p class="translated">如果 <span class="target" id="index-80"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONLEGACYWINDOWSFSENCODING"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONLEGACYWINDOWSFSENCODING</span></code></a> 环境变量被设为非空字符串则设为 <code class="docutils literal notranslate"><span class="pre">1</span></code>。</p>
<p class="translated">更多详情请参阅 <span class="target" id="index-81"></span><a class="pep reference external" href="https://peps.python.org/pep-0529/"><strong>PEP 529</strong></a>。</p>
<div class="availability docutils container">
<p class="translated"><a class="reference internal" href="../library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows.</p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.12, will be removed in version 3.15.</span></p>
</div>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.Py_LegacyWindowsStdioFlag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_LegacyWindowsStdioFlag</span></span></span><a class="headerlink" href="#c.Py_LegacyWindowsStdioFlag" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">此 API 被保留用于向下兼容：应当改为设置 <a class="reference internal" href="init_config.html#c.PyConfig.legacy_windows_stdio" title="PyConfig.legacy_windows_stdio"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.legacy_windows_stdio</span></code></a>，参见 <a class="reference internal" href="init_config.html#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p class="translated">如果该旗标为非零值，则会使用 <a class="reference internal" href="../library/io.html#io.FileIO" title="io.FileIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.FileIO</span></code></a> 而不是 <code class="xref py py-class docutils literal notranslate"><span class="pre">io._WindowsConsoleIO</span></code> 作为 <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a> 标准流。</p>
<p class="translated">如果 <span class="target" id="index-82"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONLEGACYWINDOWSSTDIO"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONLEGACYWINDOWSSTDIO</span></code></a> 环境变量被设为非空字符串则设为 <code class="docutils literal notranslate"><span class="pre">1</span></code>。</p>
<p class="translated">有关更多详细信息，请参阅 <span class="target" id="index-83"></span><a class="pep reference external" href="https://peps.python.org/pep-0528/"><strong>PEP 528</strong></a>。</p>
<div class="availability docutils container">
<p class="translated"><a class="reference internal" href="../library/intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows.</p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.12, will be removed in version 3.15.</span></p>
</div>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.Py_NoSiteFlag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_NoSiteFlag</span></span></span><a class="headerlink" href="#c.Py_NoSiteFlag" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">此 API 被保留用于向下兼容：应当改为设置 <a class="reference internal" href="init_config.html#c.PyConfig.site_import" title="PyConfig.site_import"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.site_import</span></code></a>，参见 <a class="reference internal" href="init_config.html#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p class="translated">禁用 <a class="reference internal" href="../library/site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code></a> 的导入及其所附带的基于站点对 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 的操作。 如果 <a class="reference internal" href="../library/site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code></a> 会在稍后被显式地导入也会禁用这些操作 (如果你希望触发它们则应调用 <a class="reference internal" href="../library/site.html#site.main" title="site.main"><code class="xref py py-func docutils literal notranslate"><span class="pre">site.main()</span></code></a>)。</p>
<p class="translated">由 <a class="reference internal" href="../using/cmdline.html#cmdoption-S"><code class="xref std std-option docutils literal notranslate"><span class="pre">-S</span></code></a> 选项设置。</p>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.12, will be removed in version 3.15.</span></p>
</div>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.Py_NoUserSiteDirectory">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_NoUserSiteDirectory</span></span></span><a class="headerlink" href="#c.Py_NoUserSiteDirectory" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">此 API 被保留用于向下兼容：应当改为设置 <a class="reference internal" href="init_config.html#c.PyConfig.user_site_directory" title="PyConfig.user_site_directory"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.user_site_directory</span></code></a>，参见 <a class="reference internal" href="init_config.html#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p class="translated">不要将 <a class="reference internal" href="../library/site.html#site.USER_SITE" title="site.USER_SITE"><code class="xref py py-data docutils literal notranslate"><span class="pre">用户</span> <span class="pre">site-packages</span> <span class="pre">目录</span></code></a> 添加到 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>。</p>
<p class="translated">由 <a class="reference internal" href="../using/cmdline.html#cmdoption-s"><code class="xref std std-option docutils literal notranslate"><span class="pre">-s</span></code></a> 和 <a class="reference internal" href="../using/cmdline.html#cmdoption-I"><code class="xref std std-option docutils literal notranslate"><span class="pre">-I</span></code></a> 选项以及 <span class="target" id="index-84"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONNOUSERSITE"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONNOUSERSITE</span></code></a> 环境变量设置。</p>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.12, will be removed in version 3.15.</span></p>
</div>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.Py_OptimizeFlag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_OptimizeFlag</span></span></span><a class="headerlink" href="#c.Py_OptimizeFlag" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">此 API 被保留用于向下兼容：应当改为 <a class="reference internal" href="init_config.html#c.PyConfig.optimization_level" title="PyConfig.optimization_level"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.optimization_level</span></code></a>，参见 <a class="reference internal" href="init_config.html#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p class="translated">由 <a class="reference internal" href="../using/cmdline.html#cmdoption-O"><code class="xref std std-option docutils literal notranslate"><span class="pre">-O</span></code></a> 选项和 <span class="target" id="index-85"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONOPTIMIZE"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONOPTIMIZE</span></code></a> 环境变量设置。</p>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.12, will be removed in version 3.15.</span></p>
</div>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.Py_QuietFlag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_QuietFlag</span></span></span><a class="headerlink" href="#c.Py_QuietFlag" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">此 API 被保留用于向下兼容：应当改为设置 <a class="reference internal" href="init_config.html#c.PyConfig.quiet" title="PyConfig.quiet"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.quiet</span></code></a>，参见 <a class="reference internal" href="init_config.html#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p class="translated">即使在交互模式下也不显示版权和版本信息。</p>
<p class="translated">由 <a class="reference internal" href="../using/cmdline.html#cmdoption-q"><code class="xref std std-option docutils literal notranslate"><span class="pre">-q</span></code></a> 选项设置。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.12, will be removed in version 3.15.</span></p>
</div>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.Py_UnbufferedStdioFlag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_UnbufferedStdioFlag</span></span></span><a class="headerlink" href="#c.Py_UnbufferedStdioFlag" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">此 API 被保留用于向下兼容：应当改为设置 <a class="reference internal" href="init_config.html#c.PyConfig.buffered_stdio" title="PyConfig.buffered_stdio"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.buffered_stdio</span></code></a>，参见 <a class="reference internal" href="init_config.html#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p class="translated">强制 stdout 和 stderr 流不带缓冲。</p>
<p class="translated">由 <a class="reference internal" href="../using/cmdline.html#cmdoption-u"><code class="xref std std-option docutils literal notranslate"><span class="pre">-u</span></code></a> 选项和 <span class="target" id="index-86"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONUNBUFFERED"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONUNBUFFERED</span></code></a> 环境变量设置。</p>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.12, will be removed in version 3.15.</span></p>
</div>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.Py_VerboseFlag">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_VerboseFlag</span></span></span><a class="headerlink" href="#c.Py_VerboseFlag" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">此 API 被保留用于向下兼容：应当改为设置 <a class="reference internal" href="init_config.html#c.PyConfig.verbose" title="PyConfig.verbose"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.verbose</span></code></a>，参见 <a class="reference internal" href="init_config.html#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p class="translated">每次初始化模块时打印一条消息，显示加载模块的位置（文件名或内置模块）。 如果大于或等于 <code class="docutils literal notranslate"><span class="pre">2</span></code>，则为搜索模块时检查的每个文件打印一条消息。 此外还会在退出时提供模块清理信息。</p>
<p class="translated">由 <a class="reference internal" href="../using/cmdline.html#cmdoption-v"><code class="xref std std-option docutils literal notranslate"><span class="pre">-v</span></code></a> 选项和 <span class="target" id="index-87"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONVERBOSE"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONVERBOSE</span></code></a> 环境变量设置。</p>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.12, will be removed in version 3.15.</span></p>
</div>
</dd></dl>

</section>
<section id="initializing-and-finalizing-the-interpreter">
<h2 class="translated">初始化和最终化解释器<a class="headerlink" href="#initializing-and-finalizing-the-interpreter" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.Py_Initialize">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_Initialize</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_Initialize" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated" id="index-15">初始化 Python 解释器。 在嵌入 Python 的应用程序中，它应当在使用任何其他 Python/C API 函数之前被调用；请参阅 <a class="reference internal" href="#pre-init-safe"><span class="std std-ref">在 Python 初始化之前</span></a> 了解少数的例外情况。</p>
<p class="translated">这将初始化已加载的模块表 (<code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>)，并创建基础模块 <a class="reference internal" href="../library/builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a>, <a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where top-level code is run. Covers command-line interfaces, import-time behavior, and ``__name__ == '__main__'``."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a> 和 <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a>。 它还会初始化模块搜索路径 (<code class="docutils literal notranslate"><span class="pre">sys.path</span></code>)。 它不会设置 <code class="docutils literal notranslate"><span class="pre">sys.argv</span></code>；对于此设置请使用 <a class="reference internal" href="init_config.html#init-config"><span class="std std-ref">Python 初始化配置</span></a> API。 当第二次被调用时（在未先调用 <a class="reference internal" href="#c.Py_FinalizeEx" title="Py_FinalizeEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FinalizeEx()</span></code></a> 的情况下）将不会执行任何操作。 它没有返回值；如果初始化失败则会发生致命错误。</p>
<p class="translated">使用 <a class="reference internal" href="#c.Py_InitializeFromConfig" title="Py_InitializeFromConfig"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_InitializeFromConfig()</span></code></a> 来自定义 <a class="reference internal" href="init_config.html#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p class="translated">在 Windows 上，将控制台模式从 <code class="docutils literal notranslate"><span class="pre">O_TEXT</span></code> 改为 <code class="docutils literal notranslate"><span class="pre">O_BINARY</span></code>，这还将影响使用 C 运行时的非 Python 的控制台使用。</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_InitializeEx">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_InitializeEx</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">initsigs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_InitializeEx" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">如果 <em>initsigs</em> 为 <code class="docutils literal notranslate"><span class="pre">1</span></code> 则此函数的工作方式与 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 类似。 如果 <em>initsigs</em> 为 <code class="docutils literal notranslate"><span class="pre">0</span></code>，它将跳过信号处理器的初始化注册，这在将 CPython 作为更大应用程序的一部分嵌入时会很有用处。</p>
<p class="translated">使用 <a class="reference internal" href="#c.Py_InitializeFromConfig" title="Py_InitializeFromConfig"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_InitializeFromConfig()</span></code></a> 来自定义 <a class="reference internal" href="init_config.html#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_InitializeFromConfig">
<a class="reference internal" href="init_config.html#c.PyStatus" title="PyStatus"><span class="n"><span class="pre">PyStatus</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_InitializeFromConfig</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="init_config.html#c.PyConfig" title="PyConfig"><span class="n"><span class="pre">PyConfig</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">config</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_InitializeFromConfig" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">根据 <em>config</em> 配置来初始化 Python，如 <a class="reference internal" href="init_config.html#init-from-config"><span class="std std-ref">使用 PyConfig 初始化</span></a> 中所描述的。.</p>
<p class="translated">请参阅 <a class="reference internal" href="init_config.html#init-config"><span class="std std-ref">Python 初始化配置</span></a> 一节了解有关预初始化解释器，填充运行时配置结构体，以及查询所返回的状态结构体的详情。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_IsInitialized">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_IsInitialized</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_IsInitialized" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">如果 Python 解释器已初始化，则返回真值（非零）；否则返回假值（零）。 在调用 <a class="reference internal" href="#c.Py_FinalizeEx" title="Py_FinalizeEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FinalizeEx()</span></code></a> 之后，此函数将返回假值直到 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 再次被调用。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_IsFinalizing">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_IsFinalizing</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_IsFinalizing" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.13 版起.</em><p class="translated">如果主 Python 解释器 <a class="reference internal" href="../glossary.html#term-interpreter-shutdown"><span class="xref std std-term">正在关闭</span></a> 则返回真（非零）值。 在其他情况下返回假（零）值。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_FinalizeEx">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_FinalizeEx</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_FinalizeEx" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.6 版起.</em><p class="translated">撤销由 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 完成的所有初始化操作及后续Python/C API函数调用，并销毁自上次调用 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 以来创建但尚未销毁的所有子解释器（参见下文 <a class="reference internal" href="#c.Py_NewInterpreter" title="Py_NewInterpreter"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewInterpreter()</span></code></a>）。若在未再次调用 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 的情况下重复执行，该操作将无效。</p>
<p class="translated">由于这是 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 的逆向操作，因而它应当在激活同一解释器的同一线程中被调用。 这意味着主线程和主解释器。 当 <a class="reference internal" href="#c.Py_RunMain" title="Py_RunMain"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_RunMain()</span></code></a> 仍然运行时则绝不应调用此函数。</p>
<p class="translated">通常返回值为 <code class="docutils literal notranslate"><span class="pre">0</span></code>。 如果在最终化（刷新缓冲的数据）期间发生错误，则返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code>。</p>
<p class="translated">请注意，Python会尽最大努力释放解释器分配的所有内存。因此，任何C扩展模块都应确保在后续调用 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 前，正确清理之前分配的所有PyObject对象。否则可能导致安全漏洞和异常行为。</p>
<p class="translated">提供此函数的原因有很多。嵌入应用程序可能希望重新启动Python，而不必重新启动应用程序本身。从动态可加载库（或DLL）加载Python解释器的应用程序可能希望在卸载DLL之前释放Python分配的所有内存。在搜索应用程序内存泄漏的过程中，开发人员可能希望在退出应用程序之前释放Python分配的所有内存。</p>
<p class="translated"><strong>已知问题与注意事项：</strong>
模块及模块内对象的销毁顺序是随机的，这可能导致析构函数（<a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 方法）在依赖其他对象（甚至函数）或模块时执行失败；
由Python动态加载的扩展模块不会被卸载；
Python解释器分配的少量内存可能无法释放（如发现内存泄漏请提交报告）；
对象间循环引用占用的内存不会被释放；
无论引用计数如何，所有驻留字符串（interned strings）都将被释放；
扩展模块分配的部分内存可能无法释放；
某些扩展在初始化例程被多次调用时可能出现异常行为（当应用程序多次调用 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 和 <a class="reference internal" href="#c.Py_FinalizeEx" title="Py_FinalizeEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FinalizeEx()</span></code></a> 时会发生这种情况）；
<a class="reference internal" href="#c.Py_FinalizeEx" title="Py_FinalizeEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FinalizeEx()</span></code></a> 不可被自身递归调用，因此任何可能作为解释器关闭流程一部分的代码（如 <a class="reference internal" href="../library/atexit.html#module-atexit" title="atexit: Register and execute cleanup functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">atexit</span></code></a> 处理器、对象终结器、或在刷新stdout/stderr文件时运行的代码）都不得调用该函数。</p>
<p class="audit-hook translated">引发一个不带参数的 <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">cpython._PySys_ClearAuditHooks</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.6.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_Finalize">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_Finalize</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_Finalize" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">这是一个不考虑返回值的 <a class="reference internal" href="#c.Py_FinalizeEx" title="Py_FinalizeEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FinalizeEx()</span></code></a> 的向下兼容版本。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_BytesMain">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_BytesMain</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">argc</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">argv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_BytesMain" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.8 版起.</em><p class="translated">类似于 <a class="reference internal" href="#c.Py_Main" title="Py_Main"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Main()</span></code></a> 但 <em>argv</em> 是一个字节串数组，允许调用方应用程序将文本编码步骤委托给 CPython 运行时。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_Main">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_Main</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">argc</span></span>, <span class="n"><span class="pre">wchar_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">argv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_Main" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">标准解释器的主程序，封装了完整的初始化/最终化循环，以及一些附加行为以实现从环境和命令行读取配置设置，然后按照 <a class="reference internal" href="../using/cmdline.html#using-on-cmdline"><span class="std std-ref">命令行</span></a> 的规则执行 <code class="docutils literal notranslate"><span class="pre">__main__</span></code>。</p>
<p class="translated">这适用于希望支持完整 CPython 命令行界面的程序，而不仅是在更大应用程序中嵌入 Python 运行时。</p>
<p class="translated"><em>argc</em> 和 <em>argv</em> 形参与传给 C 程序的 <code class="xref c c-func docutils literal notranslate"><span class="pre">main()</span></code> 函数的形参类似，不同之处在于 <em>argv</em> 的条目会先使用 <a class="reference internal" href="sys.html#c.Py_DecodeLocale" title="Py_DecodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DecodeLocale()</span></code></a> 转换为 <code class="docutils literal notranslate"><span class="pre">wchar_t</span></code>。 还有一个重要的注意事项是参数列表条目可能会被修改为指向并非被传入的字符串（不过，参数列表所指向的字符串内容不会被修改）。</p>
<p class="translated">如果参数列表不是表示一个有效的 Python 命令行则返回值为 <code class="docutils literal notranslate"><span class="pre">2</span></code>，否则将与 <a class="reference internal" href="#c.Py_RunMain" title="Py_RunMain"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_RunMain()</span></code></a> 相同。</p>
<p class="translated">在记录于 <a class="reference internal" href="init_config.html#init-config"><span class="std std-ref">运行时配置</span></a> 一节的 CPython 运行时配置 API 文档中（不考虑错误处理），<code class="docutils literal notranslate"><span class="pre">Py_Main</span></code> 大致相当于:</p>
<div class="translated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyConfig</span><span class="w"> </span><span class="n">config</span><span class="p">;</span>
<span class="n">PyConfig_InitPythonConfig</span><span class="p">(</span><span class="o">&amp;</span><span class="n">config</span><span class="p">);</span>
<span class="n">PyConfig_SetArgv</span><span class="p">(</span><span class="o">&amp;</span><span class="n">config</span><span class="p">,</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">);</span>
<span class="n">Py_InitializeFromConfig</span><span class="p">(</span><span class="o">&amp;</span><span class="n">config</span><span class="p">);</span>
<span class="n">PyConfig_Clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">config</span><span class="p">);</span>

<span class="n">Py_RunMain</span><span class="p">();</span>
</pre></div>
</div>
<p class="translated">在正常使用中，嵌入式应用程序将调用此函数 <em>而不是</em> 直接调用 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a>, <a class="reference internal" href="#c.Py_InitializeEx" title="Py_InitializeEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_InitializeEx()</span></code></a> 或 <a class="reference internal" href="#c.Py_InitializeFromConfig" title="Py_InitializeFromConfig"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_InitializeFromConfig()</span></code></a>，并且所有设置都将如本文档的其他部分所描述的那样被应用。 如果此函数改在某个先前的运行时初始化 API 调用 <em>之后</em> 被调用，那么到底那个环境和命令行配置会被更新将取决于具体的版本（因为它要依赖当运行时被初始化时究竟有哪些设置在它们已被设置一次之后是正确地支持被修改的）。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_RunMain">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_RunMain</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_RunMain" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">在完整配置的 CPython 运行时中执行主模块。</p>
<p class="translated">执行在命令行或配置中指定的命令 (<a class="reference internal" href="init_config.html#c.PyConfig.run_command" title="PyConfig.run_command"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.run_command</span></code></a>)、脚本 (<a class="reference internal" href="init_config.html#c.PyConfig.run_filename" title="PyConfig.run_filename"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.run_filename</span></code></a>) 或模块 (<a class="reference internal" href="init_config.html#c.PyConfig.run_module" title="PyConfig.run_module"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.run_module</span></code></a>)。 如果这些值均未设置，则使用 <code class="docutils literal notranslate"><span class="pre">__main__</span></code> 模块的全局命令空间来运行交互式 Python 提示符 (REPL)。</p>
<p class="translated">如果 <a class="reference internal" href="init_config.html#c.PyConfig.inspect" title="PyConfig.inspect"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.inspect</span></code></a> 未设置（默认），则当解释器正常退出（也就是说未引发异常）时返回值将为 <code class="docutils literal notranslate"><span class="pre">0</span></code>，未处理的 <a class="reference internal" href="../library/exceptions.html#SystemExit" title="SystemExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SystemExit</span></code></a> 的退出状态，或者对于任何其他未处理异常则为 <code class="docutils literal notranslate"><span class="pre">1</span></code>。</p>
<p class="translated">如果 <a class="reference internal" href="init_config.html#c.PyConfig.inspect" title="PyConfig.inspect"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.inspect</span></code></a> 已设置（例如当使用了 <a class="reference internal" href="../using/cmdline.html#cmdoption-i"><code class="xref std std-option docutils literal notranslate"><span class="pre">-i</span></code></a> 选项时），则当解释器退出时执行将不会返回，而是会使用 <code class="docutils literal notranslate"><span class="pre">__main__</span></code> 模块的全局命名空间在交互式 Python 提示符 (REPL) 中恢复。 如果解释器附带异常退出，该异常将在 REPL 会话中被立即引发。 随后函数的返回值将由 <em>REPL 会话</em> 的终结方式来决定: <code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">1</span></code> 或者 <a class="reference internal" href="../library/exceptions.html#SystemExit" title="SystemExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SystemExit</span></code></a> 的状态，如上文所指明的。</p>
<p class="translated">此函数总是会在它返回之前最终化 Python 解释器。</p>
<p class="translated">请参阅 <a class="reference internal" href="init_config.html#init-python-config"><span class="std std-ref">Python 配置</span></a> 查看一个使用 <a class="reference internal" href="#c.Py_RunMain" title="Py_RunMain"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_RunMain()</span></code></a> 在隔离模式下始终运行定制的 Python 的示例。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyUnstable_AtExit">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyUnstable_AtExit</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">interp</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">func</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyUnstable_AtExit" title="Link to this definition">¶</a><br /></dt>
<dd><div class="unstable-c-api warning admonition">
<em>这是 <a class="reference internal" href="stable.html#unstable-c-api"><span class="std std-ref">不稳定 API</span></a>。它可在次发布版中不经警告地改变。</em></div>
<p class="translated">为目标解释器 <em>interp</em> 注册一个 <a class="reference internal" href="../library/atexit.html#module-atexit" title="atexit: Register and execute cleanup functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">atexit</span></code></a> 回调。 这与 <a class="reference internal" href="sys.html#c.Py_AtExit" title="Py_AtExit"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_AtExit()</span></code></a> 类似，但它接受一个显式的解释器和用于回调的数据指针。</p>
<p class="translated">必须有一个对应 <em>interp</em> 的 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

</section>
<section id="process-wide-parameters">
<h2 class="translated">进程级参数<a class="headerlink" href="#process-wide-parameters" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.Py_SetProgramName">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_SetProgramName</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">wchar_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">name</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_SetProgramName" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated" id="index-16">此 API 被保留用于向下兼容：应当改为设置 <a class="reference internal" href="init_config.html#c.PyConfig.program_name" title="PyConfig.program_name"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.program_name</span></code></a>，参见 <a class="reference internal" href="init_config.html#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p class="translated">如果要调用该函数，应当在首次调用 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 之前调用它。 它将告诉解释器程序的 <code class="xref c c-func docutils literal notranslate"><span class="pre">main()</span></code> 函数的 <code class="docutils literal notranslate"><span class="pre">argv[0]</span></code> 参数的值（转换为宽字符）。 <a class="reference internal" href="#c.Py_GetPath" title="Py_GetPath"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetPath()</span></code></a> 和下面的某些其他函数会使用它在相对于解释器的位置上查找可执行文件的 Python 运行时库。 默认值是 <code class="docutils literal notranslate"><span class="pre">'python'</span></code>。 参数应当指向静态存储中的一个以零值结束的宽字符串，其内容在程序执行期间不会发生改变。 Python 解释器中的任何代码都不会改变该存储的内容。</p>
<p class="translated">使用 <a class="reference internal" href="sys.html#c.Py_DecodeLocale" title="Py_DecodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DecodeLocale()</span></code></a> 解码字节串以得到一个 <span class="c-expr sig sig-inline c"><span class="n">wchar_t</span><span class="p">*</span></span> 字符串。</p>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.11, will be removed in version 3.15.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_GetProgramName">
<span class="n"><span class="pre">wchar_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">Py_GetProgramName</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_GetProgramName" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">返回用 <a class="reference internal" href="#c.Py_SetProgramName" title="Py_SetProgramName"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetProgramName()</span></code></a> 设置的程序名称，或默认的名称。 返回的字符串指向静态存储；调用者不应修改其值。</p>
<p class="translated">此函数不应在 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 之前被调用，否则将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>现在如果它在 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 之前被调用将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.13, will be removed in version 3.15: </span>改用 <a class="reference internal" href="init_config.html#c.PyConfig_Get" title="PyConfig_Get"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyConfig_Get(&quot;executable&quot;)</span></code></a> (<a class="reference internal" href="../library/sys.html#sys.executable" title="sys.executable"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.executable</span></code></a>)。</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_GetPrefix">
<span class="n"><span class="pre">wchar_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">Py_GetPrefix</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_GetPrefix" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">返回针对已安装的独立于平台文件的 <em>prefix</em>。 这是通过基于使用 <a class="reference internal" href="init_config.html#c.PyConfig.program_name" title="PyConfig.program_name"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.program_name</span></code></a> 设置的程序名称和某些环境变量所派生的一系列复杂规则来获取的；举例来说，如果程序名称为 <code class="docutils literal notranslate"><span class="pre">'/usr/local/bin/python'</span></code>，则 prefix 为 <code class="docutils literal notranslate"><span class="pre">'/usr/local'</span></code>。 返回的字符串将指向静态存储；调用方不应修改其值。 这对应于最高层级 <code class="file docutils literal notranslate"><span class="pre">Makefile</span></code> 中的 <strong class="makevar">prefix</strong> 变量以及在编译时传给 <strong class="program">configure</strong> 脚本的 <a class="reference internal" href="../using/configure.html#cmdoption-prefix"><code class="xref std std-option docutils literal notranslate"><span class="pre">--prefix</span></code></a> 参数。 该值将作为 <code class="docutils literal notranslate"><span class="pre">sys.base_prefix</span></code> 供 Python 代码使用。 它仅适用于 Unix。 另请参见下一个函数。</p>
<p class="translated">此函数不应在 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 之前被调用，否则将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>现在如果它在 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 之前被调用将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.13, will be removed in version 3.15: </span>改用 <a class="reference internal" href="init_config.html#c.PyConfig_Get" title="PyConfig_Get"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyConfig_Get(&quot;base_prefix&quot;)</span></code></a> (<a class="reference internal" href="../library/sys.html#sys.base_prefix" title="sys.base_prefix"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.base_prefix</span></code></a>)。 如果需要处理 <a class="reference internal" href="../library/venv.html#venv-def"><span class="std std-ref">虚拟环境</span></a> 则使用 <a class="reference internal" href="init_config.html#c.PyConfig_Get" title="PyConfig_Get"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyConfig_Get(&quot;prefix&quot;)</span></code></a> (<a class="reference internal" href="../library/sys.html#sys.prefix" title="sys.prefix"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.prefix</span></code></a>)。</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_GetExecPrefix">
<span class="n"><span class="pre">wchar_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">Py_GetExecPrefix</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_GetExecPrefix" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">返回针对已安装的 <em>依赖于</em> 平台文件的 <em>exec-prefix</em>。 这是通过基于使用 <a class="reference internal" href="init_config.html#c.PyConfig.program_name" title="PyConfig.program_name"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.program_name</span></code></a> 设置的程序名称和某些环境变量所派生的一系列复杂规则来获取的；举例来说，如果程序名称为 <code class="docutils literal notranslate"><span class="pre">'/usr/local/bin/python'</span></code>，则 exec-prefix 为 <code class="docutils literal notranslate"><span class="pre">'/usr/local'</span></code>。 返回的字符串将指向静态存储；调用方不应修改其值。 这对应于最高层级 <code class="file docutils literal notranslate"><span class="pre">Makefile</span></code> 中的 <strong class="makevar">exec_prefix</strong> 变量以及在编译时传给 <strong class="program">configure</strong> 脚本的 <code class="docutils literal notranslate"><span class="pre">--exec-prefix</span></code> 参数。 该值将作为 <code class="docutils literal notranslate"><span class="pre">sys.base_exec_prefix</span></code> 供 Python 代码使用。 它仅适用于 Unix。</p>
<p class="translated">背景：当依赖于平台的文件（如可执行文件和共享库）是安装于不同的目录树中的时候 exec-prefix 将会不同于 prefix。 在典型的安装中，依赖于平台的文件可能安装于 the <code class="file docutils literal notranslate"><span class="pre">/usr/local/plat</span></code> 子目录树而独立于平台的文件可能安装于 <code class="file docutils literal notranslate"><span class="pre">/usr/local</span></code>。</p>
<p class="translated">总而言之，平台是一组硬件和软件资源的组合，例如所有运行 Solaris 2.x 操作系统的 Sparc 机器会被视为相同平台，但运行 Solaris 2.x 的 Intel 机器是另一种平台，而运行 Linux 的 Intel 机器又是另一种平台。 相同操作系统的不同主要发布版通常也会构成不同的平台。 非 Unix 操作系统的情况又有所不同；这类系统上的安装策略差别巨大因此 prefix 和 exec-prefix 是没有意义的，并将被设为空字符串。 请注意已编译的 Python 字节码是独立于平台的（但并不独立于它们编译时所使用的 Python 版本！）</p>
<p class="translated">系统管理员知道如何配置 <strong class="program">mount</strong> 或 <strong class="program">automount</strong> 程序以在平台间共享 <code class="file docutils literal notranslate"><span class="pre">/usr/local</span></code> 而让 <code class="file docutils literal notranslate"><span class="pre">/usr/local/plat</span></code> 成为针对不同平台的不同文件系统。</p>
<p class="translated">此函数不应在 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 之前被调用，否则将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>现在如果它在 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 之前被调用将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.13, will be removed in version 3.15: </span>改用 <a class="reference internal" href="init_config.html#c.PyConfig_Get" title="PyConfig_Get"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyConfig_Get(&quot;base_exec_prefix&quot;)</span></code></a> (<a class="reference internal" href="../library/sys.html#sys.base_exec_prefix" title="sys.base_exec_prefix"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.base_exec_prefix</span></code></a>)。 如果需要处理 <a class="reference internal" href="../library/venv.html#venv-def"><span class="std std-ref">虚拟环境</span></a> 则使用 <a class="reference internal" href="init_config.html#c.PyConfig_Get" title="PyConfig_Get"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyConfig_Get(&quot;exec_prefix&quot;)</span></code></a> (<a class="reference internal" href="../library/sys.html#sys.exec_prefix" title="sys.exec_prefix"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.exec_prefix</span></code></a>)。</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_GetProgramFullPath">
<span class="n"><span class="pre">wchar_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">Py_GetProgramFullPath</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_GetProgramFullPath" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated" id="index-17">返回 Python 可执行文件的完整程序名称；这是作为基于程序名称（由 <a class="reference internal" href="init_config.html#c.PyConfig.program_name" title="PyConfig.program_name"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.program_name</span></code></a> 设置）派生默认模块搜索路径的附带影响计算得出的。 返回的字符串将指向静态存储；调用方不应修改其值。 该值将以 <code class="docutils literal notranslate"><span class="pre">sys.executable</span></code> 的名称供 Python 代码访问。</p>
<p class="translated">此函数不应在 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 之前被调用，否则将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>现在如果它在 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 之前被调用将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.13, will be removed in version 3.15: </span>改用 <a class="reference internal" href="init_config.html#c.PyConfig_Get" title="PyConfig_Get"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyConfig_Get(&quot;executable&quot;)</span></code></a> (<a class="reference internal" href="../library/sys.html#sys.executable" title="sys.executable"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.executable</span></code></a>)。</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_GetPath">
<span class="n"><span class="pre">wchar_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">Py_GetPath</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_GetPath" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated" id="index-18">返回默认模块搜索路径；这是基于程序名称（由 <a class="reference internal" href="init_config.html#c.PyConfig.program_name" title="PyConfig.program_name"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.program_name</span></code></a> 设置）和某些环境变量计算得出的。 返回的字符串由一系列以依赖于平台的分隔符分开的目录名称组成。 此分隔符在 Unix 和 macOS 上为 <code class="docutils literal notranslate"><span class="pre">':'</span></code>，在 Windows 上为 <code class="docutils literal notranslate"><span class="pre">';'</span></code>。 返回的字符串将指向静态存储；调用方不应修改其值。 列表 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 将在解释器启动时使用该值来初始化；它可以在随后被修改（并且通常都会被修改）以变更用于加载模块的搜索路径。</p>
<p class="translated">此函数不应在 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 之前被调用，否则将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>现在如果它在 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 之前被调用将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.13, will be removed in version 3.15: </span>改用 <a class="reference internal" href="init_config.html#c.PyConfig_Get" title="PyConfig_Get"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyConfig_Get(&quot;module_search_paths&quot;)</span></code></a> (<a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>)。</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_GetVersion">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">Py_GetVersion</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_GetVersion" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">返回 Python 解释器的版本。 这将为如下形式的字符串</p>
<div class="translated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="s">&quot;3.0a5+ (py3k:63103M, May 12 2008, 00:53:55) </span><span class="se">\n</span><span class="s">[GCC 4.2.3]&quot;</span>
</pre></div>
</div>
<p class="translated" id="index-19">第一个单词（到第一个空格符为止）是当前的 Python 版本；前面的字符是以点号分隔的主要和次要版本号。 返回的字符串将指向静态存储；调用方不应修改其值。 该值将以 <a class="reference internal" href="../library/sys.html#sys.version" title="sys.version"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.version</span></code></a> 的名称供 Python 代码使用。</p>
<p class="translated">另请参阅 <a class="reference internal" href="apiabiversion.html#c.Py_Version" title="Py_Version"><code class="xref c c-var docutils literal notranslate"><span class="pre">Py_Version</span></code></a> 常量。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_GetPlatform">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">Py_GetPlatform</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_GetPlatform" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated" id="index-20">返回当前平台的平台标识符。 在 Unix 上，这将以操作系统的“官方”名称为基础，转换为小写形式，再加上主版本号；例如，对于 Solaris 2.x，或称 SunOS 5.x，该值将为 <code class="docutils literal notranslate"><span class="pre">'sunos5'</span></code>。 在 macOS 上，它将为 <code class="docutils literal notranslate"><span class="pre">'darwin'</span></code>。 在 Windows 上它将为 <code class="docutils literal notranslate"><span class="pre">'win'</span></code>。 返回的字符串指向静态存储；调用方不应修改其值。 Python 代码可通过 <code class="docutils literal notranslate"><span class="pre">sys.platform</span></code> 获取该值。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_GetCopyright">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">Py_GetCopyright</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_GetCopyright" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">返回当前 Python 版本的官方版权字符串，例如</p>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">'Copyright</span> <span class="pre">1991-1995</span> <span class="pre">Stichting</span> <span class="pre">Mathematisch</span> <span class="pre">Centrum,</span> <span class="pre">Amsterdam'</span></code></p>
<p class="translated" id="index-21">返回的字符串指向静态存储；调用者不应修改其值。 Python 代码可通过 <code class="docutils literal notranslate"><span class="pre">sys.copyright</span></code> 获取该值。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_GetCompiler">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">Py_GetCompiler</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_GetCompiler" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">返回用于编译当前 Python 版本的编译器指令，为带方括号的形式，例如:</p>
<div class="translated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="s">&quot;[GCC 2.7.2.2]&quot;</span>
</pre></div>
</div>
<p class="translated" id="index-22">返回的字符串指向静态存储；调用者不应修改其值。 Python 代码可以从变量 <code class="docutils literal notranslate"><span class="pre">sys.version</span></code> 中获取该值。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_GetBuildInfo">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">Py_GetBuildInfo</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_GetBuildInfo" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">返回有关当前Python解释器实例的序列号和构建日期和时间的信息，例如：</p>
<div class="translated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="s">&quot;#67, Aug  1 1997, 22:34:28&quot;</span>
</pre></div>
</div>
<p class="translated" id="index-23">返回的字符串指向静态存储；调用者不应修改其值。 Python 代码可以从变量 <code class="docutils literal notranslate"><span class="pre">sys.version</span></code> 中获取该值。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PySys_SetArgvEx">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PySys_SetArgvEx</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">argc</span></span>, <span class="n"><span class="pre">wchar_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">argv</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">updatepath</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PySys_SetArgvEx" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated" id="index-24">此 API 被保留用于向下兼容：应当改为设置 <a class="reference internal" href="init_config.html#c.PyConfig.argv" title="PyConfig.argv"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.argv</span></code></a>, <a class="reference internal" href="init_config.html#c.PyConfig.parse_argv" title="PyConfig.parse_argv"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.parse_argv</span></code></a> 和 <a class="reference internal" href="init_config.html#c.PyConfig.safe_path" title="PyConfig.safe_path"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.safe_path</span></code></a>，参见 <a class="reference internal" href="init_config.html#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p class="translated">根据 <em>argc</em> 和 <em>argv</em> 设置 <a class="reference internal" href="../library/sys.html#sys.argv" title="sys.argv"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.argv</span></code></a>。 这些形参与传给程序的 <code class="xref c c-func docutils literal notranslate"><span class="pre">main()</span></code> 函数的类似，区别在于第一项应当指向要执行的脚本文件而不是 Python 解释器对应的可执行文件。 如果没有要运行的脚本，则 <em>argv</em> 中的第一项可以为空字符串。 如果此函数无法初始化 <a class="reference internal" href="../library/sys.html#sys.argv" title="sys.argv"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.argv</span></code></a>，则将使用 <a class="reference internal" href="sys.html#c.Py_FatalError" title="Py_FatalError"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FatalError()</span></code></a> 发出严重情况信号。</p>
<p class="translated">如果 <em>updatepath</em> 为零，此函数将完成操作。 如果 <em>updatepath</em> 为非零值，则此函数还将根据以下算法修改 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a>:</p>
<ul class="simple">
<li><p class="translated">如果在 <code class="docutils literal notranslate"><span class="pre">argv[0]</span></code> 中传入一个现有脚本，则脚本所在目录的绝对路径将被添加到 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 的开头。</p></li>
<li><p class="translated">在其他情况下 (也就是说，如果 <em>argc</em> 为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 或 <code class="docutils literal notranslate"><span class="pre">argv[0]</span></code> 未指向现有文件名)，则将在 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 的开头添加一个空字符串，这等价于添加当前工作目录 (<code class="docutils literal notranslate"><span class="pre">&quot;.&quot;</span></code>)。</p></li>
</ul>
<p class="translated">使用 <a class="reference internal" href="sys.html#c.Py_DecodeLocale" title="Py_DecodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DecodeLocale()</span></code></a> 解码字节串以得到一个 <span class="c-expr sig sig-inline c"><span class="n">wchar_t</span><span class="p">*</span></span> 字符串。</p>
<p class="translated">另请参阅 <a class="reference internal" href="init_config.html#init-config"><span class="std std-ref">Python 初始化配置</span></a> 的 <a class="reference internal" href="init_config.html#c.PyConfig.orig_argv" title="PyConfig.orig_argv"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.orig_argv</span></code></a> 和 <a class="reference internal" href="init_config.html#c.PyConfig.argv" title="PyConfig.argv"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.argv</span></code></a> 成员。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p class="translated">建议在出于执行单个脚本以外的目的嵌入 Python 解释器的应用传入 <code class="docutils literal notranslate"><span class="pre">0</span></code> 作为 <em>updatepath</em>，并在需要时更新 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 本身。 参见 <span class="target" id="index-88"></span><a class="cve reference external" href="https://www.cve.org/CVERecord?id=CVE-2008-5983"><strong>CVE 2008-5983</strong></a>。</p>
<p class="translated">在 3.1.3 之前的版本中，你可以通过在调用 <a class="reference internal" href="#c.PySys_SetArgv" title="PySys_SetArgv"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_SetArgv()</span></code></a> 之后手动弹出第一个 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 元素，例如使用:</p>
<div class="translated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyRun_SimpleString</span><span class="p">(</span><span class="s">&quot;import sys; sys.path.pop(0)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.1.3.</span></p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.11, will be removed in version 3.15.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PySys_SetArgv">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PySys_SetArgv</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">argc</span></span>, <span class="n"><span class="pre">wchar_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">argv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PySys_SetArgv" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">此 API 仅为向下兼容而保留：应当改为设置 <a class="reference internal" href="init_config.html#c.PyConfig.argv" title="PyConfig.argv"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.argv</span></code></a> 并改用 <a class="reference internal" href="init_config.html#c.PyConfig.parse_argv" title="PyConfig.parse_argv"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.parse_argv</span></code></a>，参见 <a class="reference internal" href="init_config.html#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p class="translated">此函数相当于 <a class="reference internal" href="#c.PySys_SetArgvEx" title="PySys_SetArgvEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_SetArgvEx()</span></code></a> 设置了 <em>updatepath</em> 为 <code class="docutils literal notranslate"><span class="pre">1</span></code> 除非 <strong class="program">python</strong> 解释器启动时附带了 <a class="reference internal" href="../using/cmdline.html#cmdoption-I"><code class="xref std std-option docutils literal notranslate"><span class="pre">-I</span></code></a>。</p>
<p class="translated">使用 <a class="reference internal" href="sys.html#c.Py_DecodeLocale" title="Py_DecodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DecodeLocale()</span></code></a> 解码字节串以得到一个 <span class="c-expr sig sig-inline c"><span class="n">wchar_t</span><span class="p">*</span></span> 字符串。</p>
<p class="translated">另请参阅 <a class="reference internal" href="init_config.html#init-config"><span class="std std-ref">Python 初始化配置</span></a> 的 <a class="reference internal" href="init_config.html#c.PyConfig.orig_argv" title="PyConfig.orig_argv"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.orig_argv</span></code></a> 和 <a class="reference internal" href="init_config.html#c.PyConfig.argv" title="PyConfig.argv"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.argv</span></code></a> 成员。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.4 版本发生变更: </span><em>updatepath</em> 值依赖于 <a class="reference internal" href="../using/cmdline.html#cmdoption-I"><code class="xref std std-option docutils literal notranslate"><span class="pre">-I</span></code></a>。</p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.11, will be removed in version 3.15.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_SetPythonHome">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_SetPythonHome</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">wchar_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">home</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_SetPythonHome" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">此 API 被保留用于向下兼容：应当改为设置 <a class="reference internal" href="init_config.html#c.PyConfig.home" title="PyConfig.home"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.home</span></code></a>，参见 <a class="reference internal" href="init_config.html#init-config"><span class="std std-ref">Python 初始化配置</span></a>。</p>
<p class="translated">设置默认的 &quot;home&quot; 目录，也就是标准 Python 库所在的位置。 请参阅 <span class="target" id="index-89"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHOME"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONHOME</span></code></a> 了解该参数字符串的含义。</p>
<p class="translated">此参数应当指向静态存储中一个以零值结束的字符串，其内容在程序执行期间将保持不变。 Python 解释器中的代码绝不会修改此存储中的内容。</p>
<p class="translated">使用 <a class="reference internal" href="sys.html#c.Py_DecodeLocale" title="Py_DecodeLocale"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_DecodeLocale()</span></code></a> 解码字节串以得到一个 <span class="c-expr sig sig-inline c"><span class="n">wchar_t</span><span class="p">*</span></span> 字符串。</p>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.11, will be removed in version 3.15.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_GetPythonHome">
<span class="n"><span class="pre">wchar_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">Py_GetPythonHome</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_GetPythonHome" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">返回默认的 &quot;home&quot;，就是由 <a class="reference internal" href="init_config.html#c.PyConfig.home" title="PyConfig.home"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyConfig.home</span></code></a> 所设置的值，或者在设置了 <span class="target" id="index-90"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHOME"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONHOME</span></code></a> 环境变量的情况下则为该变量的值。</p>
<p class="translated">此函数不应在 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 之前被调用，否则将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.10 版本发生变更: </span>现在如果它在 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 之前被调用将返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</div>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.13, will be removed in version 3.15: </span>改用 <a class="reference internal" href="init_config.html#c.PyConfig_Get" title="PyConfig_Get"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyConfig_Get(&quot;home&quot;)</span></code></a> 或 <span class="target" id="index-91"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONHOME"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONHOME</span></code></a> 环境变量。</p>
</div>
</dd></dl>

</section>
<section id="thread-state-and-the-global-interpreter-lock">
<span id="threads"></span><h2 class="translated">线程状态和全局解释器锁<a class="headerlink" href="#thread-state-and-the-global-interpreter-lock" title="Link to this heading">¶</a></h2>
<p class="translated" id="index-29">除非使用 <a class="reference internal" href="../glossary.html#term-free-threading"><span class="xref std std-term">自由线程</span></a> 构建的 <a class="reference internal" href="../glossary.html#term-CPython"><span class="xref std std-term">CPython</span></a> 版本，否则 Python 解释器并非完全线程安全。 为支持多线程 Python 程序，系统设置了名为 <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">global interpreter lock</span></a> 或 <a class="reference internal" href="../glossary.html#term-GIL"><span class="xref std std-term">GIL</span></a> 的全局锁 —— 当前线程必须获取该锁后才能安全操作Python对象。 若未持有此锁，即便是最简单的操作也可能引发多线程程序问题：例如当两个线程同时递增同一对象的引用计数时，最终引用计数可能只增加一次而非两次。</p>
<p class="translated" id="index-30">因此，规则要求只有获得 <a class="reference internal" href="../glossary.html#term-GIL"><span class="xref std std-term">GIL</span></a> 的线程才能在 Python对象上执行操作或调用 Python/C API 函数。 为了模拟并发执行，解释器会定期尝试切换线程 (参见 <a class="reference internal" href="../library/sys.html#sys.setswitchinterval" title="sys.setswitchinterval"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.setswitchinterval()</span></code></a>)。 锁也会在读写文件等可能造成阻塞的 I/O 操作时释放，以便其他 Python 线程可以同时运行。</p>
<p class="translated" id="index-31">Python解释器将线程特定的簿记信息存储在名为 <a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyThreadState</span></code></a> 的数据结构中，该结构被称为 <a class="reference internal" href="../glossary.html#term-thread-state"><span class="xref std std-term">thread state</span></a>。 每个操作系统线程都拥有一个线程本地指针指向 <a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyThreadState</span></code></a>，被该指针引用的线程状态被视为 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">已附加</span></a>。</p>
<p class="translated">一个线程同一时间只能拥有一个 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a>。 已附加线程状态通常等同于持有 <a class="reference internal" href="../glossary.html#term-GIL"><span class="xref std std-term">GIL</span></a>，但在 <a class="reference internal" href="../glossary.html#term-free-threading"><span class="xref std std-term">自由线程</span></a> 构建中例外。 在启用 <a class="reference internal" href="../glossary.html#term-GIL"><span class="xref std std-term">GIL</span></a> 的构建版本中，<a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">附加</span></a> 线程状态会阻塞直至获取到 <a class="reference internal" href="../glossary.html#term-GIL"><span class="xref std std-term">GIL</span></a>。 但需注意，即使在禁用 <a class="reference internal" href="../glossary.html#term-GIL"><span class="xref std std-term">GIL</span></a> 的构建版本中，调用大多数 C API 仍需要已附加线程状态。</p>
<p class="translated">通常情况下，使用 Python C API 时总会存在一个 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a>。 仅在某些特定情况下（例如处于 <a class="reference internal" href="#c.Py_BEGIN_ALLOW_THREADS" title="Py_BEGIN_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></code></a> 代码块中），线程才不会有已附加线程状态。 如不确定，可通过检查 <a class="reference internal" href="#c.PyThreadState_GetUnchecked" title="PyThreadState_GetUnchecked"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_GetUnchecked()</span></code></a> 是否返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 来确认。</p>
<section id="detaching-the-thread-state-from-extension-code">
<h3 class="translated">从扩展代码分离线程状态<a class="headerlink" href="#detaching-the-thread-state-from-extension-code" title="Link to this heading">¶</a></h3>
<p class="translated">大多数操作 <a class="reference internal" href="../glossary.html#term-thread-state"><span class="xref std std-term">thread state</span></a> 的扩展代码具有以下简单结构:</p>
<div class="translated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">Save</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="kr">thread</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">local</span><span class="w"> </span><span class="n">variable</span><span class="p">.</span>
<span class="p">...</span><span class="w"> </span><span class="n">Do</span><span class="w"> </span><span class="n">some</span><span class="w"> </span><span class="n">blocking</span><span class="w"> </span><span class="n">I</span><span class="o">/</span><span class="n">O</span><span class="w"> </span><span class="n">operation</span><span class="w"> </span><span class="p">...</span>
<span class="n">Restore</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="kr">thread</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">local</span><span class="w"> </span><span class="n">variable</span><span class="p">.</span>
</pre></div>
</div>
<p class="translated">这是如此常用因此增加了一对宏来简化它:</p>
<div class="translated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">Py_BEGIN_ALLOW_THREADS</span>
<span class="p">...</span><span class="w"> </span><span class="n">执行某些阻塞式的</span><span class="w"> </span><span class="n">I</span><span class="o">/</span><span class="n">O</span><span class="w"> </span><span class="n">操作</span><span class="w"> </span><span class="p">...</span>
<span class="n">Py_END_ALLOW_THREADS</span>
</pre></div>
</div>
<p class="translated" id="index-32"><a class="reference internal" href="#c.Py_BEGIN_ALLOW_THREADS" title="Py_BEGIN_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></code></a> 宏将打开一个新块并声明一个隐藏的局部变量；<a class="reference internal" href="#c.Py_END_ALLOW_THREADS" title="Py_END_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_END_ALLOW_THREADS</span></code></a> 宏将关闭这个块。</p>
<p class="translated">上面的代码块可扩展为下面的代码:</p>
<div class="translated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyThreadState</span><span class="w"> </span><span class="o">*</span><span class="n">_save</span><span class="p">;</span>

<span class="n">_save</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyEval_SaveThread</span><span class="p">();</span>
<span class="p">...</span><span class="w"> </span><span class="n">执行某些阻塞式的</span><span class="w"> </span><span class="n">I</span><span class="o">/</span><span class="n">O</span><span class="w"> </span><span class="n">操作</span><span class="w"> </span><span class="p">...</span>
<span class="n">PyEval_RestoreThread</span><span class="p">(</span><span class="n">_save</span><span class="p">);</span>
</pre></div>
</div>
<p class="translated" id="index-33">下面介绍这些函数是如何运作的：</p>
<p class="translated"><a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a> 持有整个解释器的 <a class="reference internal" href="../glossary.html#term-GIL"><span class="xref std std-term">GIL</span></a>。当分离 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a> 时，<a class="reference internal" href="../glossary.html#term-GIL"><span class="xref std std-term">GIL</span></a> 会被释放，允许其他线程将线程状态附加到自己的线程上，从而获取 <a class="reference internal" href="../glossary.html#term-GIL"><span class="xref std std-term">GIL</span></a> 并开始执行。先前 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a> 的指针会被存储为局部变量。当执行到 <a class="reference internal" href="#c.Py_END_ALLOW_THREADS" title="Py_END_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_END_ALLOW_THREADS</span></code></a> 时，先前 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">已附加</span></a> 的线程状态会被传递给 <a class="reference internal" href="#c.PyEval_RestoreThread" title="PyEval_RestoreThread"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_RestoreThread()</span></code></a>。 该函数将阻塞直到其他线程释放其 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">线程状态</span></a>，从而使旧的 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">线程状态</span></a> 能够重新附加，并再次调用 C API。</p>
<p class="translated">对于 <a class="reference internal" href="../glossary.html#term-free-threading"><span class="xref std std-term">自由线程</span></a> 构建版本，通常无需考虑 <a class="reference internal" href="../glossary.html#term-GIL"><span class="xref std std-term">GIL</span></a>，但在阻塞I/O和长时操作中仍需分离 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">线程状态</span></a>。不同之处在于，线程无需等待 <a class="reference internal" href="../glossary.html#term-GIL"><span class="xref std std-term">GIL</span></a> 释放即可附加其线程状态，从而实现真正的多核并行。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p class="translated">调用系统I/O函数是分离 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">线程状态</span></a> 的最常见场景，但在执行无需访问Python对象的长时计算（如针对内存缓冲区的压缩或加密运算）前，分离线程状态同样有益。例如标准库中的 <a class="reference internal" href="../library/zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zlib</span></code></a> 和 <a class="reference internal" href="../library/hashlib.html#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code class="xref py py-mod docutils literal notranslate"><span class="pre">hashlib</span></code></a> 模块在压缩或哈希数据时就会分离 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">线程状态</span></a>。</p>
</div>
</section>
<section id="non-python-created-threads">
<span id="gilstate"></span><h3 class="translated">非Python创建的线程<a class="headerlink" href="#non-python-created-threads" title="Link to this heading">¶</a></h3>
<p class="translated">当线程通过 Python 专用 API（如 <a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> 模块）创建时，系统会自动为其关联线程状态，因此上述代码是正确的。 然而，当线程直接从 C 创建时（例如通过自带线程管理的第三方库），这些线程不会持有 <a class="reference internal" href="../glossary.html#term-GIL"><span class="xref std std-term">GIL</span></a>，因为它们没有 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a>。</p>
<p class="translated">若需从这些线程调用 Python 代码（常见于前述第三方库提供的回调 API 中），必须首先创建 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a> 向解释器注册线程，然后才能使用 Python/C API。 操作完成后，应当分离 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">线程状态</span></a> 并最终释放该线程。</p>
<p class="translated"><a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> 和 <a class="reference internal" href="#c.PyGILState_Release" title="PyGILState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a> 函数会自动完成上述的所有操作。 从 C 线程调用到 Python 的典型方式如下:</p>
<div class="translated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyGILState_STATE</span><span class="w"> </span><span class="n">gstate</span><span class="p">;</span>
<span class="n">gstate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyGILState_Ensure</span><span class="p">();</span>

<span class="cm">/* 在此执行 Python 动作。 */</span>
<span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CallSomeFunction</span><span class="p">();</span>
<span class="cm">/* 评估结果或处理异常 */</span>

<span class="cm">/* 释放线程。 在此之后不再允许 Python API。 */</span>
<span class="n">PyGILState_Release</span><span class="p">(</span><span class="n">gstate</span><span class="p">);</span>
</pre></div>
</div>
<p class="translated">请注意 <code class="docutils literal notranslate"><span class="pre">PyGILState_*</span></code> 系列函数基于单全局解释器假设（由 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 自动创建）。 Python虽支持创建附加解释器（通过 <a class="reference internal" href="#c.Py_NewInterpreter" title="Py_NewInterpreter"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewInterpreter()</span></code></a>），但混合使用多解释器与 <code class="docutils literal notranslate"><span class="pre">PyGILState_*</span></code> API 不受支持。这是因为 <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> 及类似函数默认将 <a class="reference internal" href="../glossary.html#term-thread-state"><span class="xref std std-term">thread state</span></a> <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">附加</span></a> 到主解释器，导致线程无法安全地与调用方的子解释器交互。</p>
</section>
<section id="supporting-subinterpreters-in-non-python-threads">
<h3 class="translated">在非Python线程中支持子解释器<a class="headerlink" href="#supporting-subinterpreters-in-non-python-threads" title="Link to this heading">¶</a></h3>
<p class="translated">如需在非Python创建的线程中支持子解释器，必须改用 <code class="docutils literal notranslate"><span class="pre">PyThreadState_*</span></code> API 替代传统的 <code class="docutils literal notranslate"><span class="pre">PyGILState_*</span></code> API。</p>
<p class="translated">特别需要注意的是，必须从调用函数中保存解释器状态，并将其传递给 <a class="reference internal" href="#c.PyThreadState_New" title="PyThreadState_New"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_New()</span></code></a>，该函数会确保新建的 <a class="reference internal" href="../glossary.html#term-thread-state"><span class="xref std std-term">thread state</span></a> 正确关联目标解释器:</p>
<div class="translated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* 创建该线程的函数中 PyInterpreterState_Get() 的返回值*/</span>
<span class="n">PyInterpreterState</span><span class="w"> </span><span class="o">*</span><span class="n">interp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ThreadData</span><span class="o">-&gt;</span><span class="n">interp</span><span class="p">;</span>
<span class="n">PyThreadState</span><span class="w"> </span><span class="o">*</span><span class="n">tstate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyThreadState_New</span><span class="p">(</span><span class="n">interp</span><span class="p">);</span>
<span class="n">PyThreadState_Swap</span><span class="p">(</span><span class="n">tstate</span><span class="p">);</span>

<span class="cm">/* 此时已持有子解释器的GIL，</span>
<span class="cm">可在此执行Python操作。 */</span>
<span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CallSomeFunction</span><span class="p">();</span>
<span class="cm">/* 评估结果或处理异常 */</span>

<span class="cm">/* 销毁线程状态。此后禁止调用任何 Python API。*/</span>
<span class="n">PyThreadState_Clear</span><span class="p">(</span><span class="n">tstate</span><span class="p">);</span>
<span class="n">PyThreadState_DeleteCurrent</span><span class="p">();</span>
</pre></div>
</div>
</section>
<section id="cautions-about-fork">
<span id="fork-and-threads"></span><h3 class="translated">有关 fork() 的注意事项<a class="headerlink" href="#cautions-about-fork" title="Link to this heading">¶</a></h3>
<p class="translated">有关线程的另一个需要注意的重要问题是它们在面对 C <code class="xref c c-func docutils literal notranslate"><span class="pre">fork()</span></code> 调用时的行为。 在大多数支持 <code class="xref c c-func docutils literal notranslate"><span class="pre">fork()</span></code> 的系统中，当一个进程执行 fork 之后将只有发出 fork 的线程存在。 这对需要如何处理锁以及CPython 的运行时内所有的存储状态都会有实质性的影响。</p>
<p class="translated">只保留“当前”线程这一事实意味着任何由其他线程所持有的锁永远不会被释放。 Python 通过在 fork 之前获取内部使用的锁，并随后释放它们的方式为 <a class="reference internal" href="../library/os.html#os.fork" title="os.fork"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fork()</span></code></a> 解决了这个问题。 此外，它还会重置子进程中的任何 <a class="reference internal" href="../library/threading.html#lock-objects"><span class="std std-ref">Lock 对象</span></a>。 在扩展或嵌入 Python 时，没有办法通知 Python 在 fork 之前或之后需要获取或重置的附加（非 Python）锁。 需要使用 OS 工具例如 <code class="xref c c-func docutils literal notranslate"><span class="pre">pthread_atfork()</span></code> 来完成同样的事情。 此外，在扩展或嵌入 Python 时，直接调用 <code class="xref c c-func docutils literal notranslate"><span class="pre">fork()</span></code> 而不是通过 <a class="reference internal" href="../library/os.html#os.fork" title="os.fork"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fork()</span></code></a> (并返回到或调用至 Python 中) 调用可能会导致某个被  fork 之后失效的线程所持有的 Python 内部锁发生死锁。 <a class="reference internal" href="sys.html#c.PyOS_AfterFork_Child" title="PyOS_AfterFork_Child"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyOS_AfterFork_Child()</span></code></a> 会尝试重置必要的锁，但并不总是能够做到。</p>
<p class="translated">所有其他线程都将结束这一事实也意味着 CPython 的运行时状态必须妥善清理，<a class="reference internal" href="../library/os.html#os.fork" title="os.fork"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fork()</span></code></a> 就是这样做的。 这意味着最终化归属于当前解释器的所有其他 <a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyThreadState</span></code></a> 对象以及所有其他 <a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyInterpreterState</span></code></a> 对象。 由于这一点以及 <a class="reference internal" href="#sub-interpreter-support"><span class="std std-ref">&quot;main&quot; 解释器</span></a> 的特殊性质，<code class="xref c c-func docutils literal notranslate"><span class="pre">fork()</span></code> 应当只在该解释器 的 &quot;main&quot; 线程中被调用，而 CPython 全局运行时最初就是在该线程中初始化的。 只有当 <code class="xref c c-func docutils literal notranslate"><span class="pre">exec()</span></code> 将随后立即被调用的情况是唯一的例外。</p>
</section>
<section id="cautions-regarding-runtime-finalization">
<span id="id1"></span><h3 class="translated">有关运行时最终化的注意事项<a class="headerlink" href="#cautions-regarding-runtime-finalization" title="Link to this heading">¶</a></h3>
<p class="translated">在 <a class="reference internal" href="../glossary.html#term-interpreter-shutdown"><span class="xref std std-term">interpreter shutdown</span></a> 的后期阶段，系统会先尝试等待非守护线程退出（此过程可能被 <a class="reference internal" href="../library/exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-class docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> 中断），并执行 <a class="reference internal" href="../library/atexit.html#module-atexit" title="atexit: Register and execute cleanup functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">atexit</span></code></a> 注册的函数。 此时运行时状态会被标记为 <em>正在终结</em>: <a class="reference internal" href="#c.Py_IsFinalizing" title="Py_IsFinalizing"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_IsFinalizing()</span></code></a> 和 <a class="reference internal" href="../library/sys.html#sys.is_finalizing" title="sys.is_finalizing"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.is_finalizing()</span></code></a> 均返回真值。 在此状态下，仅允许发起终结流程的 <em>终结线程</em> （通常为主线程）获取 <a class="reference internal" href="../glossary.html#term-GIL"><span class="xref std std-term">GIL</span></a>。</p>
<p class="translated">如果非终结线程的其他线程在终结阶段尝试显式或隐式附加 <a class="reference internal" href="../glossary.html#term-thread-state"><span class="xref std std-term">thread state</span></a>，该线程将进入 <strong>永久阻塞状态</strong> ——直至程序退出前都无法恢复。 多数情况下这不会造成危害，但如果终结过程的后续阶段试图获取被阻塞线程持有的锁，或以其他方式等待该线程响应，则可能引发死锁。</p>
<p class="translated">粗暴？确实如此。 但这样做能避免随机崩溃，以及当这些线程在 CPython 3.13 及更早版本中被强制退出时，调用栈上游可能出现的 C++ 资源未释放问题。 CPython 运行时的 <a class="reference internal" href="../glossary.html#term-thread-state"><span class="xref std std-term">thread state</span></a> C API在设计之初就未考虑在 <a class="reference internal" href="../glossary.html#term-thread-state"><span class="xref std std-term">thread state</span></a> 附加阶段提供错误报告或处理机制，因此无法优雅处理这种情况。 若要改变现状，就需要新增稳定的 C API，并重写 CPython 生态中绝大多数 C 代码来适配这些带错误处理的新 API。</p>
</section>
<section id="high-level-api">
<h3 class="translated">高阶 API<a class="headerlink" href="#high-level-api" title="Link to this heading">¶</a></h3>
<p class="translated">这些是在编写 C 扩展代码或在嵌入 Python 解释器时最常用的类型和函数：</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.PyInterpreterState">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterState</span></span></span><a class="headerlink" href="#c.PyInterpreterState" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">受限 API</span></a> （作为不透明的结构体）.</em><p class="translated">该数据结构代表多个合作线程所共享的状态。 属于同一解释器的线程将共享其模块管理以及其他一些内部条目。 该结构体中不包含公有成员。</p>
<p class="translated">最初归属于不同解释器的线程不会共享任何东西，但进程状态如可用内存、打开的文件描述符等等除外。 全局解释器锁也会被所有线程共享，无论它们归属于哪个解释器。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span><span class="target" id="index-92"></span><a class="pep reference external" href="https://peps.python.org/pep-0684/"><strong>PEP 684</strong></a> 引入了 <a class="reference internal" href="#per-interpreter-gil"><span class="std std-ref">单解释器 GIL</span></a> 的可能性。请参阅 <a class="reference internal" href="#c.Py_NewInterpreterFromConfig" title="Py_NewInterpreterFromConfig"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewInterpreterFromConfig()</span></code></a>。</p>
</div>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.PyThreadState">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState</span></span></span><a class="headerlink" href="#c.PyThreadState" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">受限 API</span></a> （作为不透明的结构体）.</em><p class="translated">该数据结构代表单个线程的状态。 唯一的公有数据成员为：</p>
<dl class="c member">
<dt class="sig sig-object c" id="c.PyThreadState.interp">
<a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">interp</span></span></span><a class="headerlink" href="#c.PyThreadState.interp" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">该线程的解释器状态。</p>
</dd></dl>

</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyEval_InitThreads">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyEval_InitThreads</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyEval_InitThreads" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated" id="index-35">不执行任何操作的已弃用函数。</p>
<p class="translated">在 Python 3.6 及更老的版本中，此函数会在 GIL 不存在时创建它。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版本发生变更: </span>此函数现在不执行任何操作。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span>该函数现在由 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 调用，因此你无需再自行调用它。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.2 版本发生变更: </span>此函数已不再被允许在 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 之前调用。</p>
</div>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.9 版本弃用.</span></p>
</div>
<span class="target" id="index-36"></span></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyEval_SaveThread">
<a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyEval_SaveThread</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyEval_SaveThread" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">分离当前线程的 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a> 并返回该状态对象。调 用此函数返回后，当前线程将不再关联任何 <a class="reference internal" href="../glossary.html#term-thread-state"><span class="xref std std-term">thread state</span></a>。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyEval_RestoreThread">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyEval_RestoreThread</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tstate</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyEval_RestoreThread" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">将 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a> 设置为 <em>tstate</em>。传入的 <a class="reference internal" href="../glossary.html#term-thread-state"><span class="xref std std-term">thread state</span></a> <strong>不应</strong> 处于 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">已附加</span></a> 状态，否则会导致死锁。 调用此函数返回后，<em>tstate</em> 将被附加到当前线程。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p class="translated">当运行时处于终结阶段时，若从某个线程调用此函数，该线程将被挂起直至程序退出，即便是由非 Python 创建的线程也不例外。更多详情请参考 <a class="reference internal" href="#cautions-regarding-runtime-finalization"><span class="std std-ref">有关运行时最终化的注意事项</span></a>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.14 版本发生变更: </span>如果在解释器处于终结阶段时调用此函数，当前线程将被挂起而非终止。</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThreadState_Get">
<a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState_Get</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_Get" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">返回当前线程的 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a>。 如果线程没有已附加的线程状态（例如，当处于 <a class="reference internal" href="#c.Py_BEGIN_ALLOW_THREADS" title="Py_BEGIN_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></code></a> 代码块内部时），则会触发致命错误 (因此调用者无需检查返回值是否为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>)。</p>
<p class="translated">另请参阅 <a class="reference internal" href="#c.PyThreadState_GetUnchecked" title="PyThreadState_GetUnchecked"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_GetUnchecked()</span></code></a>。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThreadState_GetUnchecked">
<a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState_GetUnchecked</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_GetUnchecked" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">与 <a class="reference internal" href="#c.PyThreadState_Get" title="PyThreadState_Get"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Get()</span></code></a> 类似，但如果其为 NULL 则不会杀死进程并设置致命错误。 调用方要负责检查结果是否为 NULL。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13: </span>在 Python 3.5 到 3.12 中，此函数是私有的并且命名为 <code class="docutils literal notranslate"><span class="pre">_PyThreadState_UncheckedGet()</span></code>。</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThreadState_Swap">
<a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState_Swap</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tstate</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_Swap" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">将 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a> 设置为 <em>tstate</em>，并返回调用此函数前已附加的 <a class="reference internal" href="../glossary.html#term-thread-state"><span class="xref std std-term">thread state</span></a>。</p>
<p class="translated">此函数在没有 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a> 的情况下调用也是安全的；此时它会直接返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，表示之前不存在线程状态。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p class="translated"><a class="reference internal" href="#c.PyEval_ReleaseThread" title="PyEval_ReleaseThread"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_ReleaseThread()</span></code></a></p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p class="translated">与 <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> 类似，当运行时处于终结阶段时，调用此函数会导致线程挂起。</p>
</div>
</dd></dl>

<p class="translated">下列函数使用线程级本地存储，并且不能兼容子解释器：</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.PyGILState_STATE">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyGILState_STATE</span></span></span><a class="headerlink" href="#c.PyGILState_STATE" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">由 <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> 返回并传递给 <a class="reference internal" href="#c.PyGILState_Release" title="PyGILState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a> 的值的类型。</p>
<dl class="c enumerator">
<dt class="sig sig-object c" id="c.PyGILState_STATE.PyGILState_LOCKED">
<span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyGILState_LOCKED</span></span></span><a class="headerlink" href="#c.PyGILState_STATE.PyGILState_LOCKED" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">当调用 <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> 时 GIL 已经被持有。</p>
</dd></dl>

<dl class="c enumerator">
<dt class="sig sig-object c" id="c.PyGILState_STATE.PyGILState_UNLOCKED">
<span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyGILState_UNLOCKED</span></span></span><a class="headerlink" href="#c.PyGILState_STATE.PyGILState_UNLOCKED" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">当调用 <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> 时 GIL 尚未被持有。</p>
</dd></dl>

</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyGILState_Ensure">
<a class="reference internal" href="#c.PyGILState_STATE" title="PyGILState_STATE"><span class="n"><span class="pre">PyGILState_STATE</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyGILState_Ensure</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyGILState_Ensure" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">确保当前线程可以调用 Python C API，无论 Python 的当前状态或 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a> 如何。只要每个调用都与对 <a class="reference internal" href="#c.PyGILState_Release" title="PyGILState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a> 的调用相匹配，线程就可以根据需要多次调用此函数。通常，只要线程状态在调用 Release() 之前恢复到其先前状态，就可以在 <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> 和 <a class="reference internal" href="#c.PyGILState_Release" title="PyGILState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a> 调用之间使用其他与线程相关的 API。例如，可以正常使用 <a class="reference internal" href="#c.Py_BEGIN_ALLOW_THREADS" title="Py_BEGIN_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></code></a> 和 <a class="reference internal" href="#c.Py_END_ALLOW_THREADS" title="Py_END_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_END_ALLOW_THREADS</span></code></a> 宏。</p>
<p class="translated">返回值是一个不透明的&quot;句柄&quot;，指向调用 <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> 时的 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a>，必须将其传递给 <a class="reference internal" href="#c.PyGILState_Release" title="PyGILState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a> 以确保 Python 恢复到相同状态。尽管允许递归调用，但这些句柄 <em>不能</em> 共享 — 每次对 <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> 的独立调用都必须保存其对应的句柄，用于后续调用 <a class="reference internal" href="#c.PyGILState_Release" title="PyGILState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a>。</p>
<p class="translated">当此函数返回时，将存在一个 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a>，并且线程将能够调用任意 Python 代码。若操作失败则会引发致命错误。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p class="translated">当运行时处于终结阶段时调用此函数是不安全的。这样做要么会使线程挂起直至程序结束，在极少数情况下还可能导致解释器完全崩溃。更多详情请参考 <a class="reference internal" href="#cautions-regarding-runtime-finalization"><span class="std std-ref">有关运行时最终化的注意事项</span></a>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.14 版本发生变更: </span>如果在解释器处于终结阶段时调用此函数，当前线程将被挂起而非终止。</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyGILState_Release">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyGILState_Release</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyGILState_STATE" title="PyGILState_STATE"><span class="n"><span class="pre">PyGILState_STATE</span></span></a><span class="sig-paren">)</span><a class="headerlink" href="#c.PyGILState_Release" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">释放之前获取的任何资源。 在此调用之后，Python 的状态将与其在对相应 <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> 调用之前的一样（但是通常此状态对调用方来说将是未知的，对 GILState API 的使用也是如此）。</p>
<p class="translated">对 <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> 的每次调用都必须与在同一线程上对 <a class="reference internal" href="#c.PyGILState_Release" title="PyGILState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a> 的调用相匹配。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyGILState_GetThisThreadState">
<a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyGILState_GetThisThreadState</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyGILState_GetThisThreadState" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">获取当前线程的 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a>。如果当前线程尚未使用任何 GILState API，则可能返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。 请注意，主线程始终拥有这样的线程状态，即使尚未在主线程上进行任何自动线程状态调用。此函数主要用作辅助/诊断工具。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p class="translated">即使在 <a class="reference internal" href="../glossary.html#term-thread-state"><span class="xref std std-term">thread state</span></a> 已被分离时此函数也可能返回非 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。 大多数情况下建议使用 <a class="reference internal" href="#c.PyThreadState_Get" title="PyThreadState_Get"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Get()</span></code></a> 或 <a class="reference internal" href="#c.PyThreadState_GetUnchecked" title="PyThreadState_GetUnchecked"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_GetUnchecked()</span></code></a>。</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p class="translated"><a class="reference internal" href="#c.PyThreadState_Get" title="PyThreadState_Get"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Get()</span></code></a></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyGILState_Check">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyGILState_Check</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyGILState_Check" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">如果当前线程持有 <a class="reference internal" href="../glossary.html#term-GIL"><span class="xref std std-term">GIL</span></a> 则返回 <code class="docutils literal notranslate"><span class="pre">1</span></code>，否则返回 <code class="docutils literal notranslate"><span class="pre">0</span></code>。此函数可随时从任何线程调用。只有当线程的 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">线程状态</span></a> 通过 <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> 初始化后，它才会返回 <code class="docutils literal notranslate"><span class="pre">1</span></code>。此函数主要用作辅助/诊断工具。例如，在回调函数上下文或内存分配函数中，了解 <a class="reference internal" href="../glossary.html#term-GIL"><span class="xref std std-term">GIL</span></a> 是否被锁定可以让调用者执行敏感操作或以不同方式运行时，这个函数就会很有用。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p class="translated">如果当前 Python 进程曾经创建过子解释器，则此函数 <em>始终</em> 返回 <code class="docutils literal notranslate"><span class="pre">1</span></code>。在大多数情况下，建议使用 <a class="reference internal" href="#c.PyThreadState_GetUnchecked" title="PyThreadState_GetUnchecked"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_GetUnchecked()</span></code></a>。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.4.</span></p>
</div>
</dd></dl>

<p class="translated">以下的宏被使用时通常不带末尾分号；请在 Python 源代码发布包中查看示例用法。</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_BEGIN_ALLOW_THREADS">
<span class="sig-name descname"><span class="n"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></span></span><a class="headerlink" href="#c.Py_BEGIN_ALLOW_THREADS" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">此宏会扩展为 <code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">PyThreadState</span> <span class="pre">*_save;</span> <span class="pre">_save</span> <span class="pre">=</span> <span class="pre">PyEval_SaveThread();</span></code>。 请注意它包含一个开头花括号；它必须与后面的 <a class="reference internal" href="#c.Py_END_ALLOW_THREADS" title="Py_END_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_END_ALLOW_THREADS</span></code></a> 宏匹配。 有关此宏的进一步讨论请参阅上文。</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_END_ALLOW_THREADS">
<span class="sig-name descname"><span class="n"><span class="pre">Py_END_ALLOW_THREADS</span></span></span><a class="headerlink" href="#c.Py_END_ALLOW_THREADS" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">此宏扩展为 <code class="docutils literal notranslate"><span class="pre">PyEval_RestoreThread(_save);</span> <span class="pre">}</span></code>。 注意它包含一个右花括号；它必须与之前的 <a class="reference internal" href="#c.Py_BEGIN_ALLOW_THREADS" title="Py_BEGIN_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></code></a> 宏匹配。 请参阅上文以进一步讨论此宏。</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_BLOCK_THREADS">
<span class="sig-name descname"><span class="n"><span class="pre">Py_BLOCK_THREADS</span></span></span><a class="headerlink" href="#c.Py_BLOCK_THREADS" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">这个宏扩展为 <code class="docutils literal notranslate"><span class="pre">PyEval_RestoreThread(_save);</span></code>: 它等价于没有关闭花括号的 <a class="reference internal" href="#c.Py_END_ALLOW_THREADS" title="Py_END_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_END_ALLOW_THREADS</span></code></a>。</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_UNBLOCK_THREADS">
<span class="sig-name descname"><span class="n"><span class="pre">Py_UNBLOCK_THREADS</span></span></span><a class="headerlink" href="#c.Py_UNBLOCK_THREADS" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">这个宏扩展为 <code class="docutils literal notranslate"><span class="pre">_save</span> <span class="pre">=</span> <span class="pre">PyEval_SaveThread();</span></code>: 它等价于没有开始花括号和变量声明的 <a class="reference internal" href="#c.Py_BEGIN_ALLOW_THREADS" title="Py_BEGIN_ALLOW_THREADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></code></a>。</p>
</dd></dl>

</section>
<section id="low-level-api">
<h3 class="translated">底层级 API<a class="headerlink" href="#low-level-api" title="Link to this heading">¶</a></h3>
<p class="translated">下列所有函数都必须在 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 之后被调用。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span>现在 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 会初始化 <a class="reference internal" href="../glossary.html#term-GIL"><span class="xref std std-term">GIL</span></a> 并设置一个 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a>。</p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.PyInterpreterState_New">
<a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterState_New</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyInterpreterState_New" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">新建一个解释器状态对象。 不需要有 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a>，但如果有必要序列化对此函数的调用则可能选择有。</p>
<p class="audit-hook translated">引发一个不带参数的 <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">cpython.PyInterpreterState_New</span></code>。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyInterpreterState_Clear">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterState_Clear</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">interp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyInterpreterState_Clear" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">重置解释器状态对象中的所有信息。解释器必须存在一个 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a>。</p>
<p class="audit-hook translated">引发一个不带参数的 <a class="reference internal" href="../library/sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">cpython.PyInterpreterState_Clear</span></code>。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyInterpreterState_Delete">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterState_Delete</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">interp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyInterpreterState_Delete" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">销毁一个解释器状态对象。目标解释器 <strong>不应</strong> 存在 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a>。 在调用此函数之前，必须先调用 <a class="reference internal" href="#c.PyInterpreterState_Clear" title="PyInterpreterState_Clear"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_Clear()</span></code></a> 重置解释器状态。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThreadState_New">
<a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState_New</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">interp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_New" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">创建一个属于指定解释器对象的新线程状态对象。此操作不需要存在 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a>。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThreadState_Clear">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState_Clear</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tstate</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_Clear" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">重置 <a class="reference internal" href="../glossary.html#term-thread-state"><span class="xref std std-term">thread state</span></a> 对象中的所有信息。 <em>tstate</em> 必须处于 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">已附加</span></a> 状态。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版本发生变更: </span>此函数现在会调用 <code class="xref c c-member docutils literal notranslate"><span class="pre">PyThreadState.on_delete</span></code> 回调。 在之前版本中，此操作是发生在 <a class="reference internal" href="#c.PyThreadState_Delete" title="PyThreadState_Delete"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Delete()</span></code></a> 中的。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.13 版本发生变更: </span><code class="xref c c-member docutils literal notranslate"><span class="pre">PyThreadState.on_delete</span></code> 回调已被移除。</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThreadState_Delete">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState_Delete</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tstate</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_Delete" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">销毁一个 <a class="reference internal" href="../glossary.html#term-thread-state"><span class="xref std std-term">thread state</span></a> 对象。<em>tstate</em> 不应被 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">已附加</span></a> 到任何线程。<em>tstate</em> 必须在之前通过调用 <a class="reference internal" href="#c.PyThreadState_Clear" title="PyThreadState_Clear"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Clear()</span></code></a> 进行过重置。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThreadState_DeleteCurrent">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState_DeleteCurrent</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_DeleteCurrent" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">分离 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a> (该状态必须已通过先前调用 <a class="reference internal" href="#c.PyThreadState_Clear" title="PyThreadState_Clear"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Clear()</span></code></a> 进行重置)，然后销毁它。</p>
<p class="translated">返回时将不会有任何 <a class="reference internal" href="../glossary.html#term-thread-state"><span class="xref std std-term">thread state</span></a> 处于 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">已附加</span></a> 状态。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThreadState_GetFrame">
<a class="reference internal" href="frame.html#c.PyFrameObject" title="PyFrameObject"><span class="n"><span class="pre">PyFrameObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState_GetFrame</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tstate</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_GetFrame" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.10 版起.</em><p class="translated">获取 Python 线程状态 <em>tstate</em> 的当前帧。</p>
<p class="translated">返回一个 <a class="reference internal" href="../glossary.html#term-strong-reference"><span class="xref std std-term">strong reference</span></a>。 如果没有当前执行的帧则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
<p class="translated">另请参阅 <a class="reference internal" href="reflection.html#c.PyEval_GetFrame" title="PyEval_GetFrame"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_GetFrame()</span></code></a>。</p>
<p class="translated"><em>tstate</em> 不得为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，并且必须处于 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">已附加</span></a> 状态。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThreadState_GetID">
<span class="n"><span class="pre">uint64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState_GetID</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tstate</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_GetID" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.10 版起.</em><p class="translated">获取 Python 线程状态 <em>tstate</em> 的唯一 <a class="reference internal" href="../glossary.html#term-thread-state"><span class="xref std std-term">thread state</span></a> 标识符。</p>
<p class="translated"><em>tstate</em> 不得为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，并且必须处于 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">已附加</span></a> 状态。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThreadState_GetInterpreter">
<a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState_GetInterpreter</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tstate</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_GetInterpreter" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.10 版起.</em><p class="translated">获取 Python 线程状态 <em>tstate</em> 对应的解释器。</p>
<p class="translated"><em>tstate</em> 不得为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，并且必须处于 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">已附加</span></a> 状态。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThreadState_EnterTracing">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState_EnterTracing</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tstate</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_EnterTracing" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">暂停 Python 线程状态 <em>tstate</em> 中的追踪和性能分析。</p>
<p class="translated">使用 <a class="reference internal" href="#c.PyThreadState_LeaveTracing" title="PyThreadState_LeaveTracing"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_LeaveTracing()</span></code></a> 函数来恢复它们。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThreadState_LeaveTracing">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState_LeaveTracing</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tstate</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_LeaveTracing" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">恢复 Python 线程状态 <em>tstate</em> 中被 <a class="reference internal" href="#c.PyThreadState_EnterTracing" title="PyThreadState_EnterTracing"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_EnterTracing()</span></code></a> 函数暂停的追踪和性能分析。</p>
<p class="translated">另请参阅 <a class="reference internal" href="#c.PyEval_SetTrace" title="PyEval_SetTrace"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetTrace()</span></code></a> 和 <a class="reference internal" href="#c.PyEval_SetProfile" title="PyEval_SetProfile"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetProfile()</span></code></a> 函数。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyInterpreterState_Get">
<a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterState_Get</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyInterpreterState_Get" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.9 版起.</em><p class="translated">获取当前解释器。</p>
<p class="translated">如果不存在 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a>，则触发致命错误。此函数不会返回 NULL。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyInterpreterState_GetID">
<span class="n"><span class="pre">int64_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterState_GetID</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">interp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyInterpreterState_GetID" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.7 版起.</em><p class="translated">返回解释器的唯一 ID。 如果执行过程中发生任何错误则将返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 并设置错误。</p>
<p class="translated">调用方必须有已附加的线程状态 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyInterpreterState_GetDict">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterState_GetDict</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">interp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyInterpreterState_GetDict" title="Link to this definition">¶</a><br /></dt>
<dd><em class="refcount return_borrowed_ref">返回值：借入的引用。</em><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.8 版起.</em><p class="translated">返回一个存储解释器专属数据的字典。 如果此函数返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 则没有任何异常被引发并且调用方应当将解释器专属字典视为不可用。</p>
<p class="translated">这不是 <a class="reference internal" href="module.html#c.PyModule_GetState" title="PyModule_GetState"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyModule_GetState()</span></code></a> 的替代，扩展仍应使用它来存储解释器专属的状态信息。</p>
<p class="translated">返回的字典是从解释器借入的并将保持可用直到解释器关闭。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.8.</span></p>
</div>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c._PyFrameEvalFunction">
<span class="k"><span class="pre">typedef</span></span><span class="w"> </span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">_PyFrameEvalFunction</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tstate</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="frame.html#c._PyInterpreterFrame" title="_PyInterpreterFrame"><span class="n"><span class="pre">_PyInterpreterFrame</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">frame</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">throwflag</span></span><span class="p"><span class="pre">)</span></span><a class="headerlink" href="#c._PyFrameEvalFunction" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">帧评估函数的类型</p>
<p class="translated"><em>throwflag</em> 形参将由生成器的 <code class="docutils literal notranslate"><span class="pre">throw()</span></code> 方法来使用：如为非零值，则处理当前异常。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版本发生变更: </span>此函数现在可接受一个 <em>tstate</em> 形参。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版本发生变更: </span><em>frame</em> 形参由 <code class="docutils literal notranslate"><span class="pre">PyFrameObject*</span></code> 改为 <code class="docutils literal notranslate"><span class="pre">_PyInterpreterFrame*</span></code>。</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._PyInterpreterState_GetEvalFrameFunc">
<a class="reference internal" href="#c._PyFrameEvalFunction" title="_PyFrameEvalFunction"><span class="n"><span class="pre">_PyFrameEvalFunction</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_PyInterpreterState_GetEvalFrameFunc</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">interp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._PyInterpreterState_GetEvalFrameFunc" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">获取帧评估函数。</p>
<p class="translated">请参阅 <span class="target" id="index-93"></span><a class="pep reference external" href="https://peps.python.org/pep-0523/"><strong>PEP 523</strong></a> &quot;Adding a frame evaluation API to CPython&quot;。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._PyInterpreterState_SetEvalFrameFunc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_PyInterpreterState_SetEvalFrameFunc</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">interp</span></span>, <a class="reference internal" href="#c._PyFrameEvalFunction" title="_PyFrameEvalFunction"><span class="n"><span class="pre">_PyFrameEvalFunction</span></span></a><span class="w"> </span><span class="n"><span class="pre">eval_frame</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._PyInterpreterState_SetEvalFrameFunc" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">设置帧评估函数。</p>
<p class="translated">请参阅 <span class="target" id="index-94"></span><a class="pep reference external" href="https://peps.python.org/pep-0523/"><strong>PEP 523</strong></a> &quot;Adding a frame evaluation API to CPython&quot;。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.9.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThreadState_GetDict">
<a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState_GetDict</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_GetDict" title="Link to this definition">¶</a><br /></dt>
<dd><em class="refcount return_borrowed_ref">返回值：借入的引用。</em><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">返回一个字典，扩展模块可在其中存储线程特定的状态信息。 每个扩展模块应使用唯一的键来在此字典中存储状态。当没有 <a class="reference internal" href="../glossary.html#term-thread-state"><span class="xref std std-term">thread state</span></a> 处于 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">已附加</span></a> 状态时，调用此函数是安全的。 如果此函数返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，则表示没有引发异常，调用者应假定没有线程状态被附加。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThreadState_SetAsyncExc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState_SetAsyncExc</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n"><span class="pre">id</span></span>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_SetAsyncExc" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">在一个线程中异步引发异常。<em>id</em> 参数是目标线程的线程 ID；<em>exc</em> 是要引发的异常对象。此函数不会窃取对 <em>exc</em> 的引用。 为防止误用，必须编写自己的 C 扩展来调用此函数。必须在 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a> 下调用此函数。 返回被修改的线程状态数量；通常为 1，如果找不到线程 ID 则返回 0。如果 <em>exc</em> 为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，则清除该线程的待处理异常（如果有）。 此函数不会引发任何异常。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.7 版本发生变更: </span><em>id</em> 形参的类型已从 <span class="c-expr sig sig-inline c"><span class="kt">long</span></span> 变为 <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span></span>。</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyEval_AcquireThread">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyEval_AcquireThread</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tstate</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyEval_AcquireThread" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">将 <em>tstate</em> <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">附加</span></a> 到当前线程，当前线程不能为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 或者已经 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">附加线程状态</span></a>。</p>
<p class="translated">调用方线程不能已经具有 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a>。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p class="translated">当运行时处于终结阶段时，若从某个线程调用此函数，该线程将被挂起直至程序退出，即便是由非 Python 创建的线程也不例外。更多详情请参考 <a class="reference internal" href="#cautions-regarding-runtime-finalization"><span class="std std-ref">有关运行时最终化的注意事项</span></a>。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>已被更新为与 <a class="reference internal" href="#c.PyEval_RestoreThread" title="PyEval_RestoreThread"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_RestoreThread()</span></code></a>, <a class="reference internal" href="#c.Py_END_ALLOW_THREADS" title="Py_END_ALLOW_THREADS"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_END_ALLOW_THREADS()</span></code></a> 和 <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> 保持一致，如果在解释器正在最终化时被调用则会终结当前线程。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.14 版本发生变更: </span>如果在解释器处于终结阶段时调用此函数，当前线程将被挂起而非终止。</p>
</div>
<p class="translated"><a class="reference internal" href="#c.PyEval_RestoreThread" title="PyEval_RestoreThread"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_RestoreThread()</span></code></a> 是一个始终可用的（即使线程尚未初始化）更高层级函数。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyEval_ReleaseThread">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyEval_ReleaseThread</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tstate</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyEval_ReleaseThread" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">分离 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a>。 <em>tstate</em> 参数必须不为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，该参数仅被用于检查它是否代表 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a> --- 如果不是，则会报告一个致命级错误。</p>
<p class="translated"><a class="reference internal" href="#c.PyEval_SaveThread" title="PyEval_SaveThread"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SaveThread()</span></code></a> 是一个始终可用的（即使线程尚未初始化）更高层级函数。</p>
</dd></dl>

</section>
</section>
<section id="sub-interpreter-support">
<span id="id2"></span><h2 class="translated">子解释器支持<a class="headerlink" href="#sub-interpreter-support" title="Link to this heading">¶</a></h2>
<p class="translated">虽然在大多数用例中，你都只会嵌入一个单独的 Python 解释器，但某些场景需要你在同一个进程甚至同一个线程中创建多个独立的解释器。 子解释器让你能够做到这一点。</p>
<p class="translated">“主”解释器是在运行时初始化时创建的第一个解释器。 它通常是一个进程中唯一的 Python 解释器。 与子解释器不同，主解释器具有唯一的进程全局责任比如信号处理等。 它还负责在运行时初始化期间的执行并且通常还是运行时最终化期间的活动解释器。 <a class="reference internal" href="#c.PyInterpreterState_Main" title="PyInterpreterState_Main"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyInterpreterState_Main()</span></code></a> 函数将返回一个指向其状态的指针。</p>
<p class="translated">你可以使用 <a class="reference internal" href="#c.PyThreadState_Swap" title="PyThreadState_Swap"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThreadState_Swap()</span></code></a> 函数在子解释器之间进行切换。 你可以使用下列函数来创建和销毁它们：</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.PyInterpreterConfig">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterConfig</span></span></span><a class="headerlink" href="#c.PyInterpreterConfig" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">包含用于配置子解释器的大部分形参的结构体。 其值仅在 <a class="reference internal" href="#c.Py_NewInterpreterFromConfig" title="Py_NewInterpreterFromConfig"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewInterpreterFromConfig()</span></code></a> 中被使用而绝不会被运行时所修改。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
<p class="translated">结构体字段:</p>
<dl class="c member">
<dt class="sig sig-object c" id="c.PyInterpreterConfig.use_main_obmalloc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">use_main_obmalloc</span></span></span><a class="headerlink" href="#c.PyInterpreterConfig.use_main_obmalloc" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">如果该值为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 则子解释器将使用自己的“对象”分配器状态。 否则它将使用（共享）主解释器的状态。</p>
<p class="translated">如果该值为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 则 <a class="reference internal" href="#c.PyInterpreterConfig.check_multi_interp_extensions" title="PyInterpreterConfig.check_multi_interp_extensions"><code class="xref c c-member docutils literal notranslate"><span class="pre">check_multi_interp_extensions</span></code></a> 必须为 <code class="docutils literal notranslate"><span class="pre">1</span></code> (非零值)。 如果该值为 <code class="docutils literal notranslate"><span class="pre">1</span></code> 则 <a class="reference internal" href="#c.PyInterpreterConfig.gil" title="PyInterpreterConfig.gil"><code class="xref c c-member docutils literal notranslate"><span class="pre">gil</span></code></a> 不可为 <a class="reference internal" href="#c.PyInterpreterConfig_OWN_GIL" title="PyInterpreterConfig_OWN_GIL"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyInterpreterConfig_OWN_GIL</span></code></a>。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyInterpreterConfig.allow_fork">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">allow_fork</span></span></span><a class="headerlink" href="#c.PyInterpreterConfig.allow_fork" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">如果该值为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 则运行时将不支持在当前激活了子解释器的任何线程中 fork 进程。 否则 fork 将不受限制。</p>
<p class="translated">请注意当 fork 被禁止时 <a class="reference internal" href="../library/subprocess.html#module-subprocess" title="subprocess: Subprocess management."><code class="xref py py-mod docutils literal notranslate"><span class="pre">subprocess</span></code></a> 模块将仍然可用。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyInterpreterConfig.allow_exec">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">allow_exec</span></span></span><a class="headerlink" href="#c.PyInterpreterConfig.allow_exec" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">如果该值为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 则运行时将不支持在当前激活了子解释器的任何线程中通过 exec (例如 <a class="reference internal" href="../library/os.html#os.execv" title="os.execv"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.execv()</span></code></a>) 替换当前进程。 否则 exec 将不受限制。</p>
<p class="translated">请注意当 exec 被禁止时 <a class="reference internal" href="../library/subprocess.html#module-subprocess" title="subprocess: Subprocess management."><code class="xref py py-mod docutils literal notranslate"><span class="pre">subprocess</span></code></a> 模块将仍然可用。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyInterpreterConfig.allow_threads">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">allow_threads</span></span></span><a class="headerlink" href="#c.PyInterpreterConfig.allow_threads" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">如果该值为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 则子解释器的 <a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> 模块将不会创建线程。 否则线程将被允许。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyInterpreterConfig.allow_daemon_threads">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">allow_daemon_threads</span></span></span><a class="headerlink" href="#c.PyInterpreterConfig.allow_daemon_threads" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">如果该值为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 则子解释器的 <a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> 模块将不会创建守护线程。 否则将允许守护线程（只要 <a class="reference internal" href="#c.PyInterpreterConfig.allow_threads" title="PyInterpreterConfig.allow_threads"><code class="xref c c-member docutils literal notranslate"><span class="pre">allow_threads</span></code></a> 是非零值）。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyInterpreterConfig.check_multi_interp_extensions">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">check_multi_interp_extensions</span></span></span><a class="headerlink" href="#c.PyInterpreterConfig.check_multi_interp_extensions" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">如果该值为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 则所有扩展模块均可在当前子解释器被激活的任何线程中被导入，包括旧式的 (单阶段初始化) 模块。 否则将只有多阶段初始化扩展模块 (参见 <span class="target" id="index-95"></span><a class="pep reference external" href="https://peps.python.org/pep-0489/"><strong>PEP 489</strong></a>) 可以被导入。 (另请参阅 <a class="reference internal" href="module.html#c.Py_mod_multiple_interpreters" title="Py_mod_multiple_interpreters"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_mod_multiple_interpreters</span></code></a>。)</p>
<p class="translated">如果 <a class="reference internal" href="#c.PyInterpreterConfig.use_main_obmalloc" title="PyInterpreterConfig.use_main_obmalloc"><code class="xref c c-member docutils literal notranslate"><span class="pre">use_main_obmalloc</span></code></a> 为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 则该值必须为 <code class="docutils literal notranslate"><span class="pre">1</span></code> (非零值)。</p>
</dd></dl>

<dl class="c member">
<dt class="sig sig-object c" id="c.PyInterpreterConfig.gil">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">gil</span></span></span><a class="headerlink" href="#c.PyInterpreterConfig.gil" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">这将确定针对子解释器的 GIL 操作方式。 它可以是以下的几种之一：</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.PyInterpreterConfig_DEFAULT_GIL">
<span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterConfig_DEFAULT_GIL</span></span></span><a class="headerlink" href="#c.PyInterpreterConfig_DEFAULT_GIL" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">使用默认选择 (<a class="reference internal" href="#c.PyInterpreterConfig_SHARED_GIL" title="PyInterpreterConfig_SHARED_GIL"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyInterpreterConfig_SHARED_GIL</span></code></a>)。</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.PyInterpreterConfig_SHARED_GIL">
<span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterConfig_SHARED_GIL</span></span></span><a class="headerlink" href="#c.PyInterpreterConfig_SHARED_GIL" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">使用（共享）主解释器的 GIL。</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.PyInterpreterConfig_OWN_GIL">
<span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterConfig_OWN_GIL</span></span></span><a class="headerlink" href="#c.PyInterpreterConfig_OWN_GIL" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">使用子解释器自己的 GIL。</p>
</dd></dl>

<p class="translated">如果该值为 <a class="reference internal" href="#c.PyInterpreterConfig_OWN_GIL" title="PyInterpreterConfig_OWN_GIL"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyInterpreterConfig_OWN_GIL</span></code></a> 则 <a class="reference internal" href="#c.PyInterpreterConfig.use_main_obmalloc" title="PyInterpreterConfig.use_main_obmalloc"><code class="xref c c-member docutils literal notranslate"><span class="pre">PyInterpreterConfig.use_main_obmalloc</span></code></a> 必须为 <code class="docutils literal notranslate"><span class="pre">0</span></code>。</p>
</dd></dl>

</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_NewInterpreterFromConfig">
<a class="reference internal" href="init_config.html#c.PyStatus" title="PyStatus"><span class="n"><span class="pre">PyStatus</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_NewInterpreterFromConfig</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tstate_p</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.PyInterpreterConfig" title="PyInterpreterConfig"><span class="n"><span class="pre">PyInterpreterConfig</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">config</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_NewInterpreterFromConfig" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated" id="index-40">新建一个子解释器。 这是一个 (几乎) 完全隔离的 Python 代码执行环境。 特别需要注意，新的子解释器具有全部已导入模块的隔离的、独立的版本，包括基本模块 <a class="reference internal" href="../library/builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a>, <a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where top-level code is run. Covers command-line interfaces, import-time behavior, and ``__name__ == '__main__'``."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a> 和 <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a> 等。 已加载模块表 (<code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>) 和模块搜索路径 (<code class="docutils literal notranslate"><span class="pre">sys.path</span></code>) 也是隔离的。 新环境没有 <code class="docutils literal notranslate"><span class="pre">sys.argv</span></code> 变量。 它具有新的标准 I/O 流文件对象 <code class="docutils literal notranslate"><span class="pre">sys.stdin</span></code>, <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code> 和 <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code> (不过这些对象都指向相同的底层文件描述符)。</p>
<p class="translated">给定的 <em>config</em> 控制着初始化解释器所使用的选项。</p>
<p class="translated">成功后，<em>tstate_p</em> 将被设为新的子解释器中创建的第一个 <a class="reference internal" href="../glossary.html#term-thread-state"><span class="xref std std-term">thread state</span></a>。 该线程状态是 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">已附加的</span></a>。 请注意并没有真实的线程被创建；请参阅下文有关线程状态的讨论。 如果新解释器的创建没有成功，则 <em>tstate_p</em> 将被设为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>；不会设置任何异常因为异常状态是存储在 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a> 中的，而它并不一定存在。</p>
<p class="translated">与所有其他 Python/C API 函数一样，调用此函数前必须存在 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a>，但返回时该状态可能会被分离。 成功时，返回的线程状态将处于 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">已附加</span></a> 状态。 如果子解释器使用自己的 <a class="reference internal" href="../glossary.html#term-GIL"><span class="xref std std-term">GIL</span></a> 创建，则调用解释器的 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a> 将被分离。 当函数返回时，新解释器的 <a class="reference internal" href="../glossary.html#term-thread-state"><span class="xref std std-term">thread state</span></a> 将 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">已附加</span></a> 到当前线程，而先前解释器的 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a> 将保持分离状态。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
<p class="translated">子解释器在彼此相互隔离，并让特定功能受限的情况下是最有效率的:</p>
<div class="translated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyInterpreterConfig</span><span class="w"> </span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">use_main_obmalloc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">allow_fork</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">allow_exec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">allow_threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">allow_daemon_threads</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">check_multi_interp_extensions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">gil</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyInterpreterConfig_OWN_GIL</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">PyThreadState</span><span class="w"> </span><span class="o">*</span><span class="n">tstate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="n">PyStatus</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Py_NewInterpreterFromConfig</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tstate</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">config</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">PyStatus_Exception</span><span class="p">(</span><span class="n">status</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Py_ExitStatusException</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="translated">请注意该配置只会被短暂使用而不会被修改。 在初始化期间配置的值会被转换成各种 <a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyInterpreterState</span></code></a> 值。 配置的只读副本可以被内部存储于 <a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyInterpreterState</span></code></a> 中。</p>
<p class="translated" id="index-41">扩展模块将以如下方式在（子）解释器之间共享：</p>
<ul>
<li><p class="translated">对于使用多阶段初始化的模块 ，例如 <a class="reference internal" href="module.html#c.PyModule_FromDefAndSpec" title="PyModule_FromDefAndSpec"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyModule_FromDefAndSpec()</span></code></a>，将为每个解释器创建并初始化一个单独的模块对象。 只有 C 层级的静态和全局变量能在这些模块 对象之间共享。</p></li>
<li><p class="translated">对于使用单阶段初始化的模块，例如 <a class="reference internal" href="module.html#c.PyModule_Create" title="PyModule_Create"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyModule_Create()</span></code></a>，当特定扩展被首次导入时，它将被正常初始化，并会保存其模块字典的一个 (浅) 拷贝。 当同一扩展被另一个 (子) 解释器导入时，将初始化一个新模块并填充该拷贝的内容；扩展的 <code class="docutils literal notranslate"><span class="pre">init</span></code> 函数不会被调用。 因此模块字典中的对象最终会被 (子) 解释器所共享，这可能会导致预期之外的行为  (参见下文的 <a class="reference internal" href="#bugs-and-caveats">Bugs and caveats</a>)。</p>
<p class="translated">请注意这不同于在调用 <a class="reference internal" href="#c.Py_FinalizeEx" title="Py_FinalizeEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FinalizeEx()</span></code></a> 和 <a class="reference internal" href="#c.Py_Initialize" title="Py_Initialize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Initialize()</span></code></a> 完全重新初始化解释器之后导入扩展时所发生的情况；对于那种情况，扩展的 <code class="docutils literal notranslate"><span class="pre">initmodule</span></code> 函数 <em>会被</em> 再次调用。 与多阶段初始化一样，这意味着只有 C 层级的静态和全局变量能在这些模块之间共享。</p>
</li>
</ul>
<span class="target" id="index-42"></span></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_NewInterpreter">
<a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">Py_NewInterpreter</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_NewInterpreter" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated" id="index-43">新建一个子解释器。 这在本质上只是针对 <a class="reference internal" href="#c.Py_NewInterpreterFromConfig" title="Py_NewInterpreterFromConfig"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewInterpreterFromConfig()</span></code></a> 的包装器，其配置保留了现有的行为。 结果是一个未隔离的子解释器，它会共享主解释器的 GIL，允许 fork/exec，允许守护线程，也允许单阶段初始化模块。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_EndInterpreter">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_EndInterpreter</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tstate</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_EndInterpreter" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated" id="index-44">销毁由给定 <a class="reference internal" href="../glossary.html#term-thread-state"><span class="xref std std-term">thread state</span></a> 表示的（子）解释器。给定的线程状态必须处于 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">已附加</span></a> 状态。调用返回时，将不存在任何 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a>。 与此解释器关联的所有线程状态都会被销毁。</p>
<p class="translated"><a class="reference internal" href="#c.Py_FinalizeEx" title="Py_FinalizeEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_FinalizeEx()</span></code></a> 将销毁所有在当前时间点上尚未被明确销毁的子解释器。</p>
</dd></dl>

<section id="a-per-interpreter-gil">
<span id="per-interpreter-gil"></span><h3 class="translated">解释器级 GIL<a class="headerlink" href="#a-per-interpreter-gil" title="Link to this heading">¶</a></h3>
<p class="translated">使用 <a class="reference internal" href="#c.Py_NewInterpreterFromConfig" title="Py_NewInterpreterFromConfig"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_NewInterpreterFromConfig()</span></code></a> 你将可以创建一个与其他解释器完全隔离的子解释器，包括具有自己的 GIL。 这种隔离带来的最大好处在于这样的解释器执行 Python 代码时不会被其他解释器所阻塞或者阻塞任何其他解释器。 因此在运行 Python 代码时单个 Python 进程可以真正地利用多个 CPU 核心。 这种隔离还能鼓励开发者采取不同于仅使用线程的并发方式。 (参见 <span class="target" id="index-96"></span><a class="pep reference external" href="https://peps.python.org/pep-0554/"><strong>PEP 554</strong></a> 和 <span class="target" id="index-97"></span><a class="pep reference external" href="https://peps.python.org/pep-0684/"><strong>PEP 684</strong></a> )。</p>
<p class="translated">使用隔离的解释器要求谨慎地保持隔离状态。 尤其是意味着不要在未确保线程安全的情况下共享任何对象或可变的状态。  由于引用计数的存在即使是在其他情况下不可变的对象 (例如 <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">5)</span></code>) 通常也不可被共享。 针对此问题的一种简单但效率较低的解决方式是在使用某些状态 (或对象) 时总是使用一个全局锁。 或者，对象实际上不可变的对象 (如整数或字符串) 可以通过将其设为 <a class="reference internal" href="../glossary.html#term-immortal"><span class="xref std std-term">immortal</span></a> 对象而无视其引用计数来确保其安全性。 事实上，对于内置单例、小整数和其他一些内置对象都是这样做的。</p>
<p class="translated">如果你能保持隔离状态那么你将能获得真正的多核计算能力而不会遇到自由线程所带来的复杂性。 如果未能保持隔离状态那么你将面对自由线程所带来的全部后果，包括线程竞争和难以调试的崩溃。</p>
<p class="translated">除此之外，使用多个相互隔离的解释器的一个主要挑战是如何在它们之间安全 (不破坏隔离状态)、高效地进行通信。 运行时和标准库还没有为此提供任何标准方式。 未来的标准库模块将会帮助减少保持隔离状态所需的工作量并为解释器之间的数据通信（和共享）公开有效的工具。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</section>
<section id="bugs-and-caveats">
<h3 class="translated">错误和警告<a class="headerlink" href="#bugs-and-caveats" title="Link to this heading">¶</a></h3>
<p class="translated">由于子解释器 (以及主解释器) 都是同一个进程的组成部分，它们之间的隔离状态并非完美 --- 举例来说，使用低层级的文件操作如 <a class="reference internal" href="../library/os.html#os.close" title="os.close"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.close()</span></code></a> 时它们可能 (无意或恶意地) 影响它们各自打开的文件。 由于 (子) 解释器之间共享扩展的方式，某些扩展可能无法正常工作；在使用单阶段初始化或者 (静态) 全局变量时尤其如此。 在一个子解释器中创建的对象有可能被插入到另一个 (子) 解释器的命名空间中；这种情况应当尽可能地避免。</p>
<p class="translated">应当特别注意避免在子解释器之间共享用户自定义的函数、方法、实例或类，因为由这些对象执行的导入 操作可能会影响错误的已加载模块的 (子) 解释器的字典。 同样重要的一点是应当避免共享可被上述对象访问的对象 。</p>
<p class="translated">还要注意的一点是将此功能与 <code class="docutils literal notranslate"><span class="pre">PyGILState_*</span></code> API 结合使用是很微妙的，因为这些 API 会假定 Python线程状态与操作系统级线程之间存在双向投影关系，而子解释器的存在打破了这一假定。 强烈建议你不要在一对互相匹配的 <a class="reference internal" href="#c.PyGILState_Ensure" title="PyGILState_Ensure"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Ensure()</span></code></a> 和 <a class="reference internal" href="#c.PyGILState_Release" title="PyGILState_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyGILState_Release()</span></code></a> 调用之间切换子解释器。 此外，使用这些 API 以允许从非 Python 创建的线程调用 Python 代码的扩展 (如 <a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a>) 在使用子解释器时很可能会出现问题。</p>
</section>
</section>
<section id="asynchronous-notifications">
<h2 class="translated">异步通知<a class="headerlink" href="#asynchronous-notifications" title="Link to this heading">¶</a></h2>
<p class="translated">提供了一种向主解释器线程发送异步通知的机制。 这些通知将采用函数指针和空指针参数的形式。</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.Py_AddPendingCall">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_AddPendingCall</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">func</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="kt"><span class="pre">void</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">)</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">arg</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_AddPendingCall" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">将一个函数加入从主解释器线程调用的计划任务。 成功时，将返回 <code class="docutils literal notranslate"><span class="pre">0</span></code> 并将 <em>func</em> 加入要被主线程调用的等待队列。 失败时，将返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 但不会设置任何异常。</p>
<p class="translated">当成功加入队列后，<em>func</em> 将 <em>最终</em> 附带参数 <em>arg</em> 被主解释器线程调用。 对于正常运行的 Python 代码来说它将被异步地调用，但要同时满足以下两个条件：</p>
<ul class="simple">
<li><p class="translated">位于 <a class="reference internal" href="../glossary.html#term-bytecode"><span class="xref std std-term">bytecode</span></a> 的边界上；</p></li>
<li><p class="translated">主线程持有一个 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a> (因此 <em>func</em> 可以使用完整的 C API)。</p></li>
</ul>
<p class="translated"><em>func</em> 必须在成功时返回 <code class="docutils literal notranslate"><span class="pre">0</span></code>，或在失败时返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 并设置一个异常集合。 <em>func</em> 不会被中断来递归地执行另一个异步通知，但如果 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">thread state</span></a> 已被分离则它仍可被中断以切换线程。</p>
<p class="translated">此函数不需要 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a>。 不过，要在子解释器中调用此函数，调用方必须具有 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a>。 否则，函数 <em>func</em> 可能会被安排给错误的解释器来调用。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p class="translated">这是一个低层级函数，只在非常特殊的情况下有用。 不能保证 <em>func</em> 会尽快被调用。 如果主线程忙于执行某个系统调用，<em>func</em> 将不会在系统调用返回之前被调用。 此函数 通常 <strong>不适合</strong> 从任意 C 线程调用 Python 代码。 作为替代，请使用 <a class="reference internal" href="#gilstate"><span class="std std-ref">PyGILStateAPI</span></a>。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.1.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.9 版本发生变更: </span>如果此函数在子解释器中被调用，则函数 <em>func</em> 将被安排在子解释器中调用，而不是在主解释器中调用。现在每个子解释器都有自己的计划调用列表。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>此函数现在总是会安排 <em>func</em> 在主解释器中运行。to be run in the main interpreter.</p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.Py_MakePendingCalls">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_MakePendingCalls</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_MakePendingCalls" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em><p class="translated">执行所有待命的调用。 这通常会由解释器自动执行。</p>
<p class="translated">此函数成功时返回 <code class="docutils literal notranslate"><span class="pre">0</span></code>，失败时返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 并设置一个异常。</p>
<p class="translated">如果此函数不是在主解释器的主线程中被调用，它将不会任何事并返回 <code class="docutils literal notranslate"><span class="pre">0</span></code>。 调用方必须持有 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.1.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>此函数将只在主解释器中运行待命的调用。</p>
</div>
</dd></dl>

</section>
<section id="profiling-and-tracing">
<span id="profiling"></span><h2 class="translated">分析和跟踪<a class="headerlink" href="#profiling-and-tracing" title="Link to this heading">¶</a></h2>
<p class="translated">Python 解释器为附加的性能分析和执行跟踪工具提供了一些低层级的支持。 它们可被用于性能分析、调试和覆盖分析工具。</p>
<p class="translated">这个 C 接口允许性能分析或跟踪代码避免调用 Python 层级的可调用对象带来的开销，它能直接执行 C 函数调用。 此工具的基本属性没有变化；这个接口允许针对每个线程安装跟踪函数，并且向跟踪函数报告的基本事件与之前版本中向 Python 层级跟踪函数报告的事件相同。</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.Py_tracefunc">
<span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">Py_tracefunc</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="frame.html#c.PyFrameObject" title="PyFrameObject"><span class="n"><span class="pre">PyFrameObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">frame</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">what</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">arg</span></span><span class="p"><span class="pre">)</span></span><a class="headerlink" href="#c.Py_tracefunc" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">使用 <a class="reference internal" href="#c.PyEval_SetProfile" title="PyEval_SetProfile"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetProfile()</span></code></a> 和 <a class="reference internal" href="#c.PyEval_SetTrace" title="PyEval_SetTrace"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetTrace()</span></code></a> 注册的跟踪函数的类型。 第一个形参是作为 <em>obj</em> 传递给注册函数的对象，<em>frame</em> 是与事件相关的帧对象，<em>what</em> 是常量 <a class="reference internal" href="#c.PyTrace_CALL" title="PyTrace_CALL"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_CALL</span></code></a>, <a class="reference internal" href="#c.PyTrace_EXCEPTION" title="PyTrace_EXCEPTION"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_EXCEPTION</span></code></a>, <a class="reference internal" href="#c.PyTrace_LINE" title="PyTrace_LINE"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_LINE</span></code></a>, <a class="reference internal" href="#c.PyTrace_RETURN" title="PyTrace_RETURN"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_RETURN</span></code></a>, <a class="reference internal" href="#c.PyTrace_C_CALL" title="PyTrace_C_CALL"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_C_CALL</span></code></a>, <a class="reference internal" href="#c.PyTrace_C_EXCEPTION" title="PyTrace_C_EXCEPTION"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_C_EXCEPTION</span></code></a>, <a class="reference internal" href="#c.PyTrace_C_RETURN" title="PyTrace_C_RETURN"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_C_RETURN</span></code></a> 或 <a class="reference internal" href="#c.PyTrace_OPCODE" title="PyTrace_OPCODE"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_OPCODE</span></code></a> 中的一个，而 <em>arg</em> 将依赖于 <em>what</em> 的值：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p class="translated"><em>what</em> 的值</p></th>
<th class="head"><p class="translated"><em>arg</em> 的含义</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#c.PyTrace_CALL" title="PyTrace_CALL"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_CALL</span></code></a></p></td>
<td><p class="translated">总是 <a class="reference internal" href="none.html#c.Py_None" title="Py_None"><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_None</span></code></a>.</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#c.PyTrace_EXCEPTION" title="PyTrace_EXCEPTION"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_EXCEPTION</span></code></a></p></td>
<td><p class="translated"><a class="reference internal" href="../library/sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> 返回的异常信息。</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#c.PyTrace_LINE" title="PyTrace_LINE"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_LINE</span></code></a></p></td>
<td><p class="translated">总是 <a class="reference internal" href="none.html#c.Py_None" title="Py_None"><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_None</span></code></a>.</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#c.PyTrace_RETURN" title="PyTrace_RETURN"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_RETURN</span></code></a></p></td>
<td><p class="translated">返回给调用方的值，或者如果是由异常导致的则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#c.PyTrace_C_CALL" title="PyTrace_C_CALL"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_C_CALL</span></code></a></p></td>
<td><p class="translated">正在调用函数对象。</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#c.PyTrace_C_EXCEPTION" title="PyTrace_C_EXCEPTION"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_C_EXCEPTION</span></code></a></p></td>
<td><p class="translated">正在调用函数对象。</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#c.PyTrace_C_RETURN" title="PyTrace_C_RETURN"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_C_RETURN</span></code></a></p></td>
<td><p class="translated">正在调用函数对象。</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#c.PyTrace_OPCODE" title="PyTrace_OPCODE"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_OPCODE</span></code></a></p></td>
<td><p class="translated">总是 <a class="reference internal" href="none.html#c.Py_None" title="Py_None"><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_None</span></code></a>.</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.PyTrace_CALL">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyTrace_CALL</span></span></span><a class="headerlink" href="#c.PyTrace_CALL" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">当对一个函数或方法的新调用被报告，或是向一个生成器增加新条目时传给 <a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tracefunc</span></code></a> 函数的 <em>what</em> 形参的值。 请注意针对生成器函数的迭代器的创建情况不会被报告因为在相应的帧中没有向 Python字节码转移控制权。</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.PyTrace_EXCEPTION">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyTrace_EXCEPTION</span></span></span><a class="headerlink" href="#c.PyTrace_EXCEPTION" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">当一个异常被引发时传给 <a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tracefunc</span></code></a> 函数的 <em>what</em> 形参的值。 在处理完任何字节码之后将附带 <em>what</em> 的值调用回调函数，在此之后该异常将会被设置在正在执行的帧中。 这样做的效果是当异常传播导致 Python 栈展开时，被调用的回调函数将随异常传播返回到每个帧。 只有跟踪函数才会接收到这些事件；性能分析器并不需要它们。</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.PyTrace_LINE">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyTrace_LINE</span></span></span><a class="headerlink" href="#c.PyTrace_LINE" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">当一个行编号事件被报告时传给 <a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tracefunc</span></code></a> 函数 (但不会传给性能分析函数) 的 <em>what</em> 形参的值。 它可以通过将 <a class="reference internal" href="../reference/datamodel.html#frame.f_trace_lines" title="frame.f_trace_lines"><code class="xref py py-attr docutils literal notranslate"><span class="pre">f_trace_lines</span></code></a> 设为 <em>0</em> 在某个帧中被禁用。</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.PyTrace_RETURN">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyTrace_RETURN</span></span></span><a class="headerlink" href="#c.PyTrace_RETURN" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">当一个调用即将返回时传给 <a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tracefunc</span></code></a> 函数的 <em>what</em> 形参的值。</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.PyTrace_C_CALL">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyTrace_C_CALL</span></span></span><a class="headerlink" href="#c.PyTrace_C_CALL" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">当一个 C 函数即将被调用时传给 <a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tracefunc</span></code></a> 函数的 <em>what</em> 形参的值。</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.PyTrace_C_EXCEPTION">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyTrace_C_EXCEPTION</span></span></span><a class="headerlink" href="#c.PyTrace_C_EXCEPTION" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">当一个 C 函数引发异常时传给 <a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tracefunc</span></code></a> 函数的 <em>what</em> 形参的值。</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.PyTrace_C_RETURN">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyTrace_C_RETURN</span></span></span><a class="headerlink" href="#c.PyTrace_C_RETURN" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">当一个 C 函数返回时传给 <a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tracefunc</span></code></a> 函数的 <em>what</em> 形参的值。</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.PyTrace_OPCODE">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyTrace_OPCODE</span></span></span><a class="headerlink" href="#c.PyTrace_OPCODE" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">当一个新操作码即将被执行时传给 <a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tracefunc</span></code></a> 函数 (但不会传给性能分析函数) 的 <em>what</em> 形参的值。 在默认情况下此事件不会被发送：它必须通过在某个帧上将 <a class="reference internal" href="../reference/datamodel.html#frame.f_trace_opcodes" title="frame.f_trace_opcodes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">f_trace_opcodes</span></code></a> 设为 <em>1</em> 来显式地请求。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyEval_SetProfile">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyEval_SetProfile</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><span class="n"><span class="pre">Py_tracefunc</span></span></a><span class="w"> </span><span class="n"><span class="pre">func</span></span>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyEval_SetProfile" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">将性能分析器函数设为 <em>func</em>。 <em>obj</em> 形参将作为第一个形参传给该函数，它可以是任意 Python 对象或为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。 如果性能分析函数需要维护状态，则为每个线程的 <em>obj</em> 使用不同的值将提供一个方便而线程安全的存储位置。 这个性能分析函数将针对除 <a class="reference internal" href="#c.PyTrace_LINE" title="PyTrace_LINE"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_LINE</span></code></a> <a class="reference internal" href="#c.PyTrace_OPCODE" title="PyTrace_OPCODE"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_OPCODE</span></code></a> 和 <a class="reference internal" href="#c.PyTrace_EXCEPTION" title="PyTrace_EXCEPTION"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_EXCEPTION</span></code></a> 以外的所有被监控事件进行调用。</p>
<p class="translated">另请参阅 <a class="reference internal" href="../library/sys.html#sys.setprofile" title="sys.setprofile"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.setprofile()</span></code></a> 函数。</p>
<p class="translated">调用方必须有已附加的线程状态 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a>。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyEval_SetProfileAllThreads">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyEval_SetProfileAllThreads</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><span class="n"><span class="pre">Py_tracefunc</span></span></a><span class="w"> </span><span class="n"><span class="pre">func</span></span>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyEval_SetProfileAllThreads" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">类似于 <a class="reference internal" href="#c.PyEval_SetProfile" title="PyEval_SetProfile"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetProfile()</span></code></a> 但会在属于当前解释器的所有在运行线程中设置性能分析函数而不是仅在当前线程上设置。</p>
<p class="translated">调用方必须有已附加的线程状态 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a>。</p>
<p class="translated">与 <a class="reference internal" href="#c.PyEval_SetProfile" title="PyEval_SetProfile"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetProfile()</span></code></a> 一样，该函数会忽略任何被引发的异常同时在所有线程中设置性能分析函数。</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.PyEval_SetTrace">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyEval_SetTrace</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><span class="n"><span class="pre">Py_tracefunc</span></span></a><span class="w"> </span><span class="n"><span class="pre">func</span></span>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyEval_SetTrace" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">将跟踪函数设为 <em>func</em>。 这类似于 <a class="reference internal" href="#c.PyEval_SetProfile" title="PyEval_SetProfile"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetProfile()</span></code></a>，区别在于跟踪函数会接收行编号事件和操作码级事件，但不会接收与被调用的 C 函数对象相关的任何事件。 使用 <a class="reference internal" href="#c.PyEval_SetTrace" title="PyEval_SetTrace"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetTrace()</span></code></a> 注册的任何跟踪函数将不会接收 <a class="reference internal" href="#c.PyTrace_C_CALL" title="PyTrace_C_CALL"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_C_CALL</span></code></a>、<a class="reference internal" href="#c.PyTrace_C_EXCEPTION" title="PyTrace_C_EXCEPTION"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_C_EXCEPTION</span></code></a> 或 <a class="reference internal" href="#c.PyTrace_C_RETURN" title="PyTrace_C_RETURN"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyTrace_C_RETURN</span></code></a> 作为 <em>what</em> 形参的值。</p>
<p class="translated">另请参阅 <a class="reference internal" href="../library/sys.html#sys.settrace" title="sys.settrace"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.settrace()</span></code></a> 函数。</p>
<p class="translated">调用方必须有已附加的线程状态 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a>。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyEval_SetTraceAllThreads">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyEval_SetTraceAllThreads</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tracefunc" title="Py_tracefunc"><span class="n"><span class="pre">Py_tracefunc</span></span></a><span class="w"> </span><span class="n"><span class="pre">func</span></span>, <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">obj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyEval_SetTraceAllThreads" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">类似于 <a class="reference internal" href="#c.PyEval_SetTrace" title="PyEval_SetTrace"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetTrace()</span></code></a> 但会在属于当前解释器的所有在运行线程中设置跟踪函数而不是仅在当前线程上设置。</p>
<p class="translated">调用方必须有已附加的线程状态 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a>。</p>
<p class="translated">与 <a class="reference internal" href="#c.PyEval_SetTrace" title="PyEval_SetTrace"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SetTrace()</span></code></a> 一样，该函数会忽略任何被引发的异常同时在所有线程中设置跟踪函数。</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</section>
<section id="reference-tracing">
<h2 class="translated">引用追踪<a class="headerlink" href="#reference-tracing" title="Link to this heading">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
<dl class="c type">
<dt class="sig sig-object c" id="c.PyRefTracer">
<span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyRefTracer</span></span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n"><span class="pre">PyObject</span></span></a><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">event</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">)</span></span><a class="headerlink" href="#c.PyRefTracer" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">使用 <a class="reference internal" href="#c.PyRefTracer_SetTracer" title="PyRefTracer_SetTracer"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyRefTracer_SetTracer()</span></code></a> 注册的追踪函数的类型。 第一个形参是刚创建（当 <strong>event</strong> 被设为 <a class="reference internal" href="#c.PyRefTracer_CREATE" title="PyRefTracer_CREATE"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyRefTracer_CREATE</span></code></a> 时）或将销毁（当 <strong>event</strong> 被设为 <a class="reference internal" href="#c.PyRefTracer_DESTROY" title="PyRefTracer_DESTROY"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyRefTracer_DESTROY</span></code></a> 时）的 Python 对象。 <strong>data</strong> 参数是当 <a class="reference internal" href="#c.PyRefTracer_SetTracer" title="PyRefTracer_SetTracer"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyRefTracer_SetTracer()</span></code></a> 被调用时所提供的不透明指针。</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
<dl class="c var">
<dt class="sig sig-object c" id="c.PyRefTracer_CREATE">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyRefTracer_CREATE</span></span></span><a class="headerlink" href="#c.PyRefTracer_CREATE" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">当一个 Python 对象被创建时传给 <a class="reference internal" href="#c.PyRefTracer" title="PyRefTracer"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyRefTracer</span></code></a> 函数的 <em>event</em> 形参。</p>
</dd></dl>

<dl class="c var">
<dt class="sig sig-object c" id="c.PyRefTracer_DESTROY">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyRefTracer_DESTROY</span></span></span><a class="headerlink" href="#c.PyRefTracer_DESTROY" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">当一个 Python 对象被销毁时传给 <a class="reference internal" href="#c.PyRefTracer" title="PyRefTracer"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyRefTracer</span></code></a> 函数的 <em>event</em> 形参。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyRefTracer_SetTracer">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyRefTracer_SetTracer</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyRefTracer" title="PyRefTracer"><span class="n"><span class="pre">PyRefTracer</span></span></a><span class="w"> </span><span class="n"><span class="pre">tracer</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyRefTracer_SetTracer" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">注册一个引用追踪函数。 该函数将在新的 Python 对象被创建或对象被销毁时被调用。 如果提供了 <strong>data</strong> 则它必须是一个当追踪函数被调用时所提供的不透明指针。 成功时返回 <code class="docutils literal notranslate"><span class="pre">0</span></code>。 发生错误时将设置一个异常并返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code>。</p>
<p class="translated">追踪函数 <strong>不可</strong> 在内部创建 Python 对象否则调用将被重入。 追踪器也 <strong>不可</strong> 清除任何现有异常或设置异常。 每次当追踪器被调用时都将激活一个 <a class="reference internal" href="../glossary.html#term-thread-state"><span class="xref std std-term">thread state</span></a>。</p>
<p class="translated">当调用此函数时必须有一个 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a>。</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c.PyRefTracer_GetTracer">
<a class="reference internal" href="#c.PyRefTracer" title="PyRefTracer"><span class="n"><span class="pre">PyRefTracer</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyRefTracer_GetTracer</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">data</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyRefTracer_GetTracer" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">获取已注册的引用追踪函数以及当 <a class="reference internal" href="#c.PyRefTracer_SetTracer" title="PyRefTracer_SetTracer"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyRefTracer_SetTracer()</span></code></a> 被调用时所注册的不透明数据指针的值。 如果未注册任何追踪器则此函数将返回 NULL 并将 <strong>data</strong> 指针设为 NULL。</p>
<p class="translated">当调用此函数时必须有一个 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">attached thread state</span></a>。</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</section>
<section id="advanced-debugger-support">
<span id="advanced-debugging"></span><h2 class="translated">高级调试器支持<a class="headerlink" href="#advanced-debugger-support" title="Link to this heading">¶</a></h2>
<p class="translated">这些函数仅供高级调试工具使用。</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.PyInterpreterState_Head">
<a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterState_Head</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyInterpreterState_Head" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">将解释器状态对象返回到由所有此类对象组成的列表的开头。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyInterpreterState_Main">
<a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterState_Main</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyInterpreterState_Main" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">返回主解释器状态对象。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyInterpreterState_Next">
<a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterState_Next</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">interp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyInterpreterState_Next" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">从由解释器状态对象组成的列表中返回 <em>interp</em> 之后的下一项。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyInterpreterState_ThreadHead">
<a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyInterpreterState_ThreadHead</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><span class="n"><span class="pre">PyInterpreterState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">interp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyInterpreterState_ThreadHead" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">在由与解释器 <em>interp</em> 相关联的线程组成的列表中返回指向第一个 <a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyThreadState</span></code></a> 对象的指针。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThreadState_Next">
<a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyThreadState_Next</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyThreadState" title="PyThreadState"><span class="n"><span class="pre">PyThreadState</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">tstate</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThreadState_Next" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">从由属于同一个 <a class="reference internal" href="#c.PyInterpreterState" title="PyInterpreterState"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyInterpreterState</span></code></a> 对象的线程状态对象组成的列表中返回 <em>tstate</em> 之后的下一项。</p>
</dd></dl>

</section>
<section id="thread-local-storage-support">
<span id="thread-local-storage"></span><h2 class="translated">线程本地存储支持<a class="headerlink" href="#thread-local-storage-support" title="Link to this heading">¶</a></h2>
<p class="translated">Python 解释器提供也对线程本地存储 (TLS) 的低层级支持，它对下层的原生 TLS 实现进行了包装以支持 Python 层级的线程本地存储 API (<a class="reference internal" href="../library/threading.html#threading.local" title="threading.local"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.local</span></code></a>)。 CPython 的 C 层级 API 与 pthreads 和 Windows 所提供的类似：使用一个线程键和函数来为每个线程关联一个 <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> 值。</p>
<p class="translated">当调用这些函数时 <em>不需要</em> <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">附加</span></a> 一个 <a class="reference internal" href="../glossary.html#term-thread-state"><span class="xref std std-term">thread state</span></a>；它们会提供自己的锁机制。</p>
<p class="translated">请注意 <code class="file docutils literal notranslate"><span class="pre">Python.h</span></code> 并不包括 TLS API 的声明，你需要包括 <code class="file docutils literal notranslate"><span class="pre">pythread.h</span></code> 来使用线程本地存储。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p class="translated">这些 API 函数都不会为 <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> 的值处理内存管理问题。 你需要自己分配和释放它们。 如果 <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> 值碰巧为 <span class="c-expr sig sig-inline c"><a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span>，这些函数也不会对它们执行引用计数操作。</p>
</div>
<section id="thread-specific-storage-tss-api">
<span id="thread-specific-storage-api"></span><h3 class="translated">线程专属存储 (TSS) API<a class="headerlink" href="#thread-specific-storage-tss-api" title="Link to this heading">¶</a></h3>
<p class="translated">引入 TSSAPI 是为了取代 CPython 解释器中现有 TLS API 的使用。 该 API 使用一个新类型 <a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tss_t</span></code></a> 而不是 <span class="c-expr sig sig-inline c"><span class="kt">int</span></span> 来表示线程键。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.7.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p class="translated">&quot;A New C-API for Thread-Local Storage in CPython&quot; (<span class="target" id="index-47"></span><a class="pep reference external" href="https://peps.python.org/pep-0539/"><strong>PEP 539</strong></a>)</p>
</div>
<dl class="c type">
<dt class="sig sig-object c" id="c.Py_tss_t">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Py_tss_t</span></span></span><a class="headerlink" href="#c.Py_tss_t" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">该数据结构表示线程键的状态，其定义可能依赖于下层的 TLS 实现，并且它有一个表示键初始化状态的内部字段。 该结构体中不存在公有成员。</p>
<p class="translated">当未定义 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Py_LIMITED_API</span></a> 时，允许由 <a class="reference internal" href="#c.Py_tss_NEEDS_INIT" title="Py_tss_NEEDS_INIT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_tss_NEEDS_INIT</span></code></a> 执行此类型的静态分配。</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_tss_NEEDS_INIT">
<span class="sig-name descname"><span class="n"><span class="pre">Py_tss_NEEDS_INIT</span></span></span><a class="headerlink" href="#c.Py_tss_NEEDS_INIT" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">这个宏将扩展为 <a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tss_t</span></code></a> 变量的初始化器。 请注意这个宏不会用 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Py_LIMITED_API</span></a> 来定义。</p>
</dd></dl>

<section id="dynamic-allocation">
<h4 class="translated">动态分配<a class="headerlink" href="#dynamic-allocation" title="Link to this heading">¶</a></h4>
<p class="translated"><a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tss_t</span></code></a> 的动态分配，在使用 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">Py_LIMITED_API</span></a> 编译的扩展模块中是必须的，在这些模块由于此类型的实现在编译时是不透明的因此它不可能静态分配。</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.PyThread_tss_alloc">
<a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t"><span class="n"><span class="pre">Py_tss_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyThread_tss_alloc</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_tss_alloc" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.7 版起.</em><p class="translated">返回一个与使用 <a class="reference internal" href="#c.Py_tss_NEEDS_INIT" title="Py_tss_NEEDS_INIT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_tss_NEEDS_INIT</span></code></a> 初始化的值的状态相同的值，或者当动态分配失败时则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThread_tss_free">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThread_tss_free</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t"><span class="n"><span class="pre">Py_tss_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">key</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_tss_free" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.7 版起.</em><p class="translated">在首次调用 <a class="reference internal" href="#c.PyThread_tss_delete" title="PyThread_tss_delete"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThread_tss_delete()</span></code></a> 以确保任何相关联的线程局部变量已被撤销赋值之后释放由 <a class="reference internal" href="#c.PyThread_tss_alloc" title="PyThread_tss_alloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThread_tss_alloc()</span></code></a> 所分配的给定的 <em>key</em>。 如果 <em>key</em> 参数为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 则这将无任何操作。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p class="translated">被释放的 key 将变成一个悬空指针。 你应当将 key 重置为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</div>
</dd></dl>

</section>
<section id="methods">
<h4 class="translated">方法<a class="headerlink" href="#methods" title="Link to this heading">¶</a></h4>
<p class="translated">这些函数的形参 <em>key</em> 不可为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。 并且，如果给定的 <a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tss_t</span></code></a> 还未被 <a class="reference internal" href="#c.PyThread_tss_create" title="PyThread_tss_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThread_tss_create()</span></code></a> 初始化则 <a class="reference internal" href="#c.PyThread_tss_set" title="PyThread_tss_set"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThread_tss_set()</span></code></a> 和 <a class="reference internal" href="#c.PyThread_tss_get" title="PyThread_tss_get"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThread_tss_get()</span></code></a> 的行为将是未定义的。</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.PyThread_tss_is_created">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThread_tss_is_created</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t"><span class="n"><span class="pre">Py_tss_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">key</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_tss_is_created" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.7 版起.</em><p class="translated">如果给定的 <a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_tss_t</span></code></a> 已通过has been initialized by <a class="reference internal" href="#c.PyThread_tss_create" title="PyThread_tss_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThread_tss_create()</span></code></a> 被初始化则返回一个非零值。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThread_tss_create">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThread_tss_create</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t"><span class="n"><span class="pre">Py_tss_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">key</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_tss_create" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.7 版起.</em><p class="translated">当成功初始化一个 TSS 键时将返回零值。 如果 <em>key</em> 参数所指向的值未被 <a class="reference internal" href="#c.Py_tss_NEEDS_INIT" title="Py_tss_NEEDS_INIT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_tss_NEEDS_INIT</span></code></a> 初始化则其行为是未定义的。 此函数可在相同的键上重复调用 -- 在已初始化的键上调用它将不执行任何操作并立即成功返回。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThread_tss_delete">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThread_tss_delete</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t"><span class="n"><span class="pre">Py_tss_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">key</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_tss_delete" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.7 版起.</em><p class="translated">销毁一个 TSS 键以便在所有线程中遗忘与该键相关联的值，并将该键的初始化状态改为未初始化的。 已销毁的键可以通过 <a class="reference internal" href="#c.PyThread_tss_create" title="PyThread_tss_create"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThread_tss_create()</span></code></a> 再次被初始化。 此函数可以在同一个键上重复调用 -- 但在一个已被销毁的键上调用将是无效的。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThread_tss_set">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThread_tss_set</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t"><span class="n"><span class="pre">Py_tss_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">key</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_tss_set" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.7 版起.</em><p class="translated">返回零值来表示成功将一个 <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> 值与当前线程中的 TSS 键相关联。 每个线程都有一个从键到 <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> 值的独立映射。</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThread_tss_get">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyThread_tss_get</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.Py_tss_t" title="Py_tss_t"><span class="n"><span class="pre">Py_tss_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">key</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_tss_get" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a> 自 3.7 版起.</em><p class="translated">返回当前线程中与一个 TSS 键相关联的 <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> 值。 如果当前线程中没有与该键相关联的值则返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>。</p>
</dd></dl>

</section>
</section>
<section id="thread-local-storage-tls-api">
<span id="thread-local-storage-api"></span><h3 class="translated">线程本地存储 (TLS) API<a class="headerlink" href="#thread-local-storage-tls-api" title="Link to this heading">¶</a></h3>
<div class="deprecated">
<p><span class="versionmodified deprecated">自 3.7 版本弃用: </span>此 API 已被 <a class="reference internal" href="#thread-specific-storage-api"><span class="std std-ref">线程专属存储 (TSS) API</span></a> 所取代。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p class="translated">这个 API 版本不支持原生 TLS 键采用无法被安全转换为 <code class="docutils literal notranslate"><span class="pre">int</span></code> 的的定义方式的平台。 在这样的平台上，<a class="reference internal" href="#c.PyThread_create_key" title="PyThread_create_key"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThread_create_key()</span></code></a> 将立即返回一个失败状态，并且其他 TLS 函数在这样的平台上也都无效。</p>
</div>
<p class="translated">由于上面提到的兼容性问题，不应在新代码中使用此版本的API。</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.PyThread_create_key">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThread_create_key</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_create_key" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThread_delete_key">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThread_delete_key</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">key</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_delete_key" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThread_set_key_value">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThread_set_key_value</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">key</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">value</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_set_key_value" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThread_get_key_value">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">PyThread_get_key_value</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">key</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_get_key_value" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThread_delete_key_value">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThread_delete_key_value</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">key</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_delete_key_value" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyThread_ReInitTLS">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyThread_ReInitTLS</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyThread_ReInitTLS" title="Link to this definition">¶</a><br /></dt>
<dd><em class="stableabi"> 属于 <a class="reference internal" href="stable.html#stable"><span class="std std-ref">稳定 ABI</span></a>.</em></dd></dl>

</section>
</section>
<section id="synchronization-primitives">
<h2 class="translated">同步原语<a class="headerlink" href="#synchronization-primitives" title="Link to this heading">¶</a></h2>
<p class="translated">C-API 提供了一个基本的互斥锁。</p>
<dl class="c type">
<dt class="sig sig-object c" id="c.PyMutex">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyMutex</span></span></span><a class="headerlink" href="#c.PyMutex" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">一个互斥锁。 <code class="xref c c-type docutils literal notranslate"><span class="pre">PyMutex</span></code> 应当被初始化为零以代表未加锁状态。 例如:</p>
<div class="translated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyMutex</span><span class="w"> </span><span class="n">mutex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</pre></div>
</div>
<p class="translated"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMutex</span></code> 的实例不应被拷贝或移动。 <code class="xref c c-type docutils literal notranslate"><span class="pre">PyMutex</span></code> 的内容和地址都是有意义的，它必须在内存中保持一个固定的、可写的位置。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p class="translated"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMutex</span></code> 目前占用一个字节，但这个大小应当被视为是不稳定的。 这个大小可能在未来的 Python 发布版中发生改变而不会设置弃用期。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyMutex_Lock">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyMutex_Lock</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyMutex" title="PyMutex"><span class="n"><span class="pre">PyMutex</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">m</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMutex_Lock" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">锁定互斥锁 <em>m</em>。 如果另一个线程已经锁定了它，调用方线程将会阻塞直到互斥锁被解锁。 在阻塞期间，如果线程存在 <a class="reference internal" href="../glossary.html#term-attached-thread-state"><span class="xref std std-term">线程状态</span></a> 则会临时释放它。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyMutex_Unlock">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyMutex_Unlock</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyMutex" title="PyMutex"><span class="n"><span class="pre">PyMutex</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">m</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMutex_Unlock" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">解锁互斥锁 <em>m</em>。 该互斥锁必须已被锁定 --- 否则，此函数将发生致命错误。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PyMutex_IsLocked">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PyMutex_IsLocked</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.PyMutex" title="PyMutex"><span class="n"><span class="pre">PyMutex</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">m</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PyMutex_IsLocked" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">若互斥锁 <em>m</em> 当前处于锁定状态，则返回非零值；否则返回零。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p class="translated">此函数仅适用于断言和调试场景，请勿将其用于并发控制决策，因为锁状态可能在检查后立即发生变化。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

<section id="python-critical-section-api">
<span id="id3"></span><h3 class="translated">Python 关键节 API<a class="headerlink" href="#python-critical-section-api" title="Link to this heading">¶</a></h3>
<p class="translated">此关键节 API 为 <a class="reference internal" href="../glossary.html#term-free-threading"><span class="xref std std-term">自由线程</span></a> CPython 的每对象锁之上提供了一个死锁避免层。 它们旨在替代对 <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">global interpreter lock</span></a> 的依赖，而在具有全局解释器锁的 Python 版本上将不做任何操作。</p>
<p class="translated">关键节被设计用于在 C-API 扩展中实现的自定义类型。 它们通常不应当被用于内置类型如 <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> 和 <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 因为它们的公有 C-API 已经在内部使用了关键节，一个显著的例外是 <a class="reference internal" href="dict.html#c.PyDict_Next" title="PyDict_Next"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyDict_Next()</span></code></a>，它需要在外部获取关键节。</p>
<p class="translated">关键节是通过隐式地挂起活动关键节来避免死锁的，因此，它们并不提供传统锁如 <a class="reference internal" href="#c.PyMutex" title="PyMutex"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMutex</span></code></a> 所提供的那种独占访问。 当一个关键节启动时，将会获取对象的每对象锁。 如果关键节内部执行的代码调用了 C-API 函数那么它可以挂起关键节从而释放这个每对象锁，这样其他线程就可以获取同一个对象的每对象锁。</p>
<p class="translated">此外，还提供了接受 <a class="reference internal" href="#c.PyMutex" title="PyMutex"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMutex</span></code></a> 指针（而非 Python 对象）的函数变体。当你处于没有 <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> 的场景中时（例如，处理一个既未继承也未封装 <a class="reference internal" href="structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> 的 C 类型，但仍需以可能导致死锁的方式调用 C API），请使用这些变体来启动临界区。</p>
<p class="translated">宏所使用的函数和结构体是针对 C 宏不可用的场景而公开的。 它们应当仅被用于给定的宏扩展中。 请注意这些结构体的大小和内容在未来的 Python 版本中可能发生改变。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p class="translated">需要同时锁定两个对象的操作必须使用 <a class="reference internal" href="#c.Py_BEGIN_CRITICAL_SECTION2" title="Py_BEGIN_CRITICAL_SECTION2"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_BEGIN_CRITICAL_SECTION2</span></code></a>。 你 <em>不可</em> 使用嵌套的关键节来同时锁定一个以上的对象，因为内层的关键节可能会挂起外层的关键节。  这个 API 没有提供同时锁定两个以上对象的办法。</p>
</div>
<p class="translated">用法示例:</p>
<div class="translated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span>
<span class="nf">set_field</span><span class="p">(</span><span class="n">MyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">Py_BEGIN_CRITICAL_SECTION</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
<span class="w">   </span><span class="n">Py_SETREF</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">field</span><span class="p">,</span><span class="w"> </span><span class="n">Py_XNewRef</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
<span class="w">   </span><span class="n">Py_END_CRITICAL_SECTION</span><span class="p">();</span>
<span class="w">   </span><span class="n">Py_RETURN_NONE</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="translated">在上面的例子中，<a class="reference internal" href="refcounting.html#c.Py_SETREF" title="Py_SETREF"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_SETREF</span></code></a> 调用了 <a class="reference internal" href="refcounting.html#c.Py_DECREF" title="Py_DECREF"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_DECREF</span></code></a>，它可以通过一个对象的取消分配函数来调用任意代码。 当由最终化器触发的代码发生阻塞并调用 <a class="reference internal" href="#c.PyEval_SaveThread" title="PyEval_SaveThread"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_SaveThread()</span></code></a> 时关键节 API 将通过允许运行临时挂起关键节来避免由于重入和锁顺序导致的潜在死锁。</p>
<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_BEGIN_CRITICAL_SECTION">
<span class="sig-name descname"><span class="n"><span class="pre">Py_BEGIN_CRITICAL_SECTION</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">op</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_BEGIN_CRITICAL_SECTION" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">为对象 <em>op</em> 获取每对象锁并开始一个关键节。</p>
<p class="translated">在自由线程构建版中，该宏将扩展为:</p>
<div class="translated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">    </span><span class="n">PyCriticalSection</span><span class="w"> </span><span class="n">_py_cs</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyCriticalSection_Begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_py_cs</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">PyObject</span><span class="o">*</span><span class="p">)(</span><span class="n">op</span><span class="p">))</span>
</pre></div>
</div>
<p class="translated">在默认构建版中，该宏将扩展为 <code class="docutils literal notranslate"><span class="pre">{</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_BEGIN_CRITICAL_SECTION_MUTEX">
<span class="sig-name descname"><span class="n"><span class="pre">Py_BEGIN_CRITICAL_SECTION_MUTEX</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">m</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_BEGIN_CRITICAL_SECTION_MUTEX" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">锁定互斥锁 <em>m</em> 并开始一个临界区。</p>
<p class="translated">在自由线程构建版中，该宏将扩展为:</p>
<div class="translated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">     </span><span class="n">PyCriticalSection</span><span class="w"> </span><span class="n">_py_cs</span><span class="p">;</span>
<span class="w">     </span><span class="n">PyCriticalSection_BeginMutex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_py_cs</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">需要注意的是，与 <a class="reference internal" href="#c.Py_BEGIN_CRITICAL_SECTION" title="Py_BEGIN_CRITICAL_SECTION"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_BEGIN_CRITICAL_SECTION</span></code></a> 不同，此宏的参数无需类型转换——它必须是一个 <a class="reference internal" href="#c.PyMutex" title="PyMutex"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMutex</span></code></a> 指针。</p>
<p class="translated">在默认构建版中，该宏将扩展为 <code class="docutils literal notranslate"><span class="pre">{</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_END_CRITICAL_SECTION">
<span class="sig-name descname"><span class="n"><span class="pre">Py_END_CRITICAL_SECTION</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_END_CRITICAL_SECTION" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">结束关键节并释放每对象锁。</p>
<p class="translated">在自由线程构建版中，该宏将扩展为:</p>
<div class="translated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="n">PyCriticalSection_End</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_py_cs</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="translated">在默认构建版中，该宏将扩展为 <code class="docutils literal notranslate"><span class="pre">}</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_BEGIN_CRITICAL_SECTION2">
<span class="sig-name descname"><span class="n"><span class="pre">Py_BEGIN_CRITICAL_SECTION2</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_BEGIN_CRITICAL_SECTION2" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">为对象 <em>a</em> 和 <em>b</em> 获取每对象锁并开始一个关键节。 这些锁是按连续顺序获取的（最低的地址在最前）以避免锁顺序列死锁。</p>
<p class="translated">在自由线程构建版中，该宏将扩展为:</p>
<div class="translated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">    </span><span class="n">PyCriticalSection2</span><span class="w"> </span><span class="n">_py_cs2</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyCriticalSection2_Begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_py_cs2</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">PyObject</span><span class="o">*</span><span class="p">)(</span><span class="n">a</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="n">PyObject</span><span class="o">*</span><span class="p">)(</span><span class="n">b</span><span class="p">))</span>
</pre></div>
</div>
<p class="translated">在默认构建版中，该宏将扩展为 <code class="docutils literal notranslate"><span class="pre">{</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_BEGIN_CRITICAL_SECTION2_MUTEX">
<span class="sig-name descname"><span class="n"><span class="pre">Py_BEGIN_CRITICAL_SECTION2_MUTEX</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">m1</span></span>, <span class="n"><span class="pre">m2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_BEGIN_CRITICAL_SECTION2_MUTEX" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">锁定互斥锁 <em>m1</em> 和 <em>m2</em> 并开始一个临界区。</p>
<p class="translated">在自由线程构建版中，该宏将扩展为:</p>
<div class="translated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">     </span><span class="n">PyCriticalSection2</span><span class="w"> </span><span class="n">_py_cs2</span><span class="p">;</span>
<span class="w">     </span><span class="n">PyCriticalSection2_BeginMutex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_py_cs2</span><span class="p">,</span><span class="w"> </span><span class="n">m1</span><span class="p">,</span><span class="w"> </span><span class="n">m2</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">需要注意的是，与 <a class="reference internal" href="#c.Py_BEGIN_CRITICAL_SECTION2" title="Py_BEGIN_CRITICAL_SECTION2"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_BEGIN_CRITICAL_SECTION2</span></code></a> 不同，此宏的参数无需类型转换——它们必须是 <a class="reference internal" href="#c.PyMutex" title="PyMutex"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMutex</span></code></a> 指针。</p>
<p class="translated">在默认构建版中，该宏将扩展为 <code class="docutils literal notranslate"><span class="pre">{</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.Py_END_CRITICAL_SECTION2">
<span class="sig-name descname"><span class="n"><span class="pre">Py_END_CRITICAL_SECTION2</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.Py_END_CRITICAL_SECTION2" title="Link to this definition">¶</a><br /></dt>
<dd><p class="translated">结束关键节并释放每对象锁。</p>
<p class="translated">在自由线程构建版中，该宏将扩展为:</p>
<div class="translated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="n">PyCriticalSection2_End</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_py_cs2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="translated">在默认构建版中，该宏将扩展为 <code class="docutils literal notranslate"><span class="pre">}</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#">初始化，最终化和线程</a><ul>
<li><a class="reference internal" href="#before-python-initialization">在Python初始化之前</a></li>
<li><a class="reference internal" href="#global-configuration-variables">全局配置变量</a></li>
<li><a class="reference internal" href="#initializing-and-finalizing-the-interpreter">初始化和最终化解释器</a></li>
<li><a class="reference internal" href="#process-wide-parameters">进程级参数</a></li>
<li><a class="reference internal" href="#thread-state-and-the-global-interpreter-lock">线程状态和全局解释器锁</a><ul>
<li><a class="reference internal" href="#detaching-the-thread-state-from-extension-code">从扩展代码分离线程状态</a></li>
<li><a class="reference internal" href="#non-python-created-threads">非Python创建的线程</a></li>
<li><a class="reference internal" href="#supporting-subinterpreters-in-non-python-threads">在非Python线程中支持子解释器</a></li>
<li><a class="reference internal" href="#cautions-about-fork">有关 fork() 的注意事项</a></li>
<li><a class="reference internal" href="#cautions-regarding-runtime-finalization">有关运行时最终化的注意事项</a></li>
<li><a class="reference internal" href="#high-level-api">高阶 API</a></li>
<li><a class="reference internal" href="#low-level-api">底层级 API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sub-interpreter-support">子解释器支持</a><ul>
<li><a class="reference internal" href="#a-per-interpreter-gil">解释器级 GIL</a></li>
<li><a class="reference internal" href="#bugs-and-caveats">错误和警告</a></li>
</ul>
</li>
<li><a class="reference internal" href="#asynchronous-notifications">异步通知</a></li>
<li><a class="reference internal" href="#profiling-and-tracing">分析和跟踪</a></li>
<li><a class="reference internal" href="#reference-tracing">引用追踪</a></li>
<li><a class="reference internal" href="#advanced-debugger-support">高级调试器支持</a></li>
<li><a class="reference internal" href="#thread-local-storage-support">线程本地存储支持</a><ul>
<li><a class="reference internal" href="#thread-specific-storage-tss-api">线程专属存储 (TSS) API</a><ul>
<li><a class="reference internal" href="#dynamic-allocation">动态分配</a></li>
<li><a class="reference internal" href="#methods">方法</a></li>
</ul>
</li>
<li><a class="reference internal" href="#thread-local-storage-tls-api">线程本地存储 (TLS) API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#synchronization-primitives">同步原语</a><ul>
<li><a class="reference internal" href="#python-critical-section-api">Python 关键节 API</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一主题</h4>
    <p class="topless"><a href="datetime.html"
                          title="上一章">DateTime 对象</a></p>
  </div>
  <div>
    <h4>下一主题</h4>
    <p class="topless"><a href="init_config.html"
                          title="下一章">Python 初始化配置</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">报告代码错误</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/c-api/init.rst?plain=1"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="折叠边栏">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="init_config.html" title="Python 初始化配置"
             >下一页</a> |</li>
        <li class="right" >
          <a href="datetime.html" title="DateTime 对象"
             >上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.14.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python/C API 参考手册</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">初始化，最终化和线程</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q" id="search-box">
          <input type="submit" value="转到">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    主题
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>自动</option>
        <option value="light">明亮</option>
        <option value="dark">黑暗</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版权</a> 2001 Python Software Foundation.
    <br>
    本页面采用 Python 软件基金会许可证第 2 版授权。
    <br>
    文档中的示例、代码片段及其他代码内容额外采用零条款 BSD 许可证授权。
    <br>
    
      更多信息请参阅《<a href="/license.html"> 历史与许可 </a>》。<br>
    
    
    <br>

    Python 软件基金会是一家非营利性公司。
<a href="https://www.python.org/psf/donations/">请进行捐赠。</a>
<br>
    <br>
      最后更新于11月 25, 2025 (07:24 UTC) 。
    
      <a href="/bugs.html">发现了错误</a>？
    
    <br>

    使用<a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3 创建。
    </div>

  </body>
</html>
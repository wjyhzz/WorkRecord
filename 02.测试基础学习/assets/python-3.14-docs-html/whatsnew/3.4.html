<!DOCTYPE html>

<html lang="zh-CN" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="Python 3.4 有什么新变化" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/whatsnew/3.4.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="作者, R. David Murray &lt; rdmurray@bitdance.com&gt; (Editor),. 这篇文章介绍了 Python 3.4 相比 3.3 增加的新特性。 Python 3.4 发布于 2014 年 3 月 16 日。 对于完整的细节，请参见 更新日志 。 摘要 - 发布重点: 新的语法特性： Python 3.4 中没有增加新的语法特性。. 其他的新特性..." />
<meta property="og:image:width" content="1146" />
<meta property="og:image:height" content="600" />
<meta property="og:image" content="https://docs.python.org/3.14/zh-cn/_images/social_previews/summary_whatsnew_3.4_10688bab.png" />
<meta property="og:image:alt" content="作者, R. David Murray &lt; rdmurray@bitdance.com&gt; (Editor),. 这篇文章介绍了 Python 3.4 相比 3.3 增加的新特性。 Python 3.4 发布于 2014 年 3 月 16 日。 对于完整的细节，请参见 更新日志 。 摘要 - 发布重点: 新的语法特性： Python 3.4 中没有增加新的语法特性。. 其他的新特性..." />
<meta name="description" content="作者, R. David Murray &lt; rdmurray@bitdance.com&gt; (Editor),. 这篇文章介绍了 Python 3.4 相比 3.3 增加的新特性。 Python 3.4 发布于 2014 年 3 月 16 日。 对于完整的细节，请参见 更新日志 。 摘要 - 发布重点: 新的语法特性： Python 3.4 中没有增加新的语法特性。. 其他的新特性..." />
<meta name="twitter:card" content="summary_large_image" />
<meta name="theme-color" content="#3776ab">

    <title>Python 3.4 有什么新变化 &#8212; Python 3.14.0 文档</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=234b1a7c" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=8cd84f99" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=5349f25f" />
    
    <script src="../_static/documentation_options.js?v=a595ec0e"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=beaddf03"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.14.0 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于此文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权" href="../copyright.html" />
    <link rel="next" title="Python 3.3 有什么新变化" href="3.3.html" />
    <link rel="prev" title="Python 3.5 有什么新变化" href="3.5.html" />
    
      
      <script defer file-types="bz2,epub,zip" data-domain="docs.python.org" src="https://analytics.python.org/js/script.file-downloads.outbound-links.js"></script>
      
      <link rel="canonical" href="https://docs.python.org/3/whatsnew/3.4.html">
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg">
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="菜单">
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo">
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q">
                <input type="submit" value="转到">
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    主题
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>自动</option>
        <option value="light">明亮</option>
        <option value="dark">黑暗</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#">Python 3.4 有什么新变化</a><ul>
<li><a class="reference internal" href="#summary-release-highlights">摘要 - 发布重点</a></li>
<li><a class="reference internal" href="#new-features">新的特性</a><ul>
<li><a class="reference internal" href="#pep-453-explicit-bootstrapping-of-pip-in-python-installations">PEP 453: 在 Python 安装版中对 PIP 的显式初始设置</a><ul>
<li><a class="reference internal" href="#bootstrapping-pip-by-default">默认对 pip 进行初始设置</a></li>
<li><a class="reference internal" href="#documentation-changes">文档更改</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pep-446-newly-created-file-descriptors-are-non-inheritable">PEP 446: 新创建的文件描述符将设为不可继承</a></li>
<li><a class="reference internal" href="#improvements-to-codec-handling">编解码器处理方式的改进</a></li>
<li><a class="reference internal" href="#pep-451-a-modulespec-type-for-the-import-system">PEP 451: 针对导入系统的 ModuleSpec 类型</a></li>
<li><a class="reference internal" href="#other-language-changes">其他语言特性修改</a></li>
</ul>
</li>
<li><a class="reference internal" href="#new-modules">新增模块</a><ul>
<li><a class="reference internal" href="#asyncio">asyncio</a></li>
<li><a class="reference internal" href="#ensurepip">ensurepip</a></li>
<li><a class="reference internal" href="#enum">enum</a></li>
<li><a class="reference internal" href="#pathlib">pathlib</a></li>
<li><a class="reference internal" href="#selectors">selectors</a></li>
<li><a class="reference internal" href="#statistics">statistics</a></li>
<li><a class="reference internal" href="#tracemalloc">tracemalloc</a></li>
</ul>
</li>
<li><a class="reference internal" href="#improved-modules">改进的模块</a><ul>
<li><a class="reference internal" href="#abc">abc</a></li>
<li><a class="reference internal" href="#aifc">aifc</a></li>
<li><a class="reference internal" href="#argparse">argparse</a></li>
<li><a class="reference internal" href="#audioop">audioop</a></li>
<li><a class="reference internal" href="#base64">base64</a></li>
<li><a class="reference internal" href="#collections">collections</a></li>
<li><a class="reference internal" href="#colorsys">colorsys</a></li>
<li><a class="reference internal" href="#contextlib">contextlib</a></li>
<li><a class="reference internal" href="#dbm">dbm</a></li>
<li><a class="reference internal" href="#dis">dis</a></li>
<li><a class="reference internal" href="#doctest">doctest</a></li>
<li><a class="reference internal" href="#email">email</a></li>
<li><a class="reference internal" href="#filecmp">filecmp</a></li>
<li><a class="reference internal" href="#functools">functools</a></li>
<li><a class="reference internal" href="#gc">gc</a></li>
<li><a class="reference internal" href="#glob">glob</a></li>
<li><a class="reference internal" href="#hashlib">hashlib</a></li>
<li><a class="reference internal" href="#hmac">hmac</a></li>
<li><a class="reference internal" href="#html">html</a></li>
<li><a class="reference internal" href="#http">http</a></li>
<li><a class="reference internal" href="#idlelib-and-idle">idlelib 与 IDLE</a></li>
<li><a class="reference internal" href="#importlib">importlib</a></li>
<li><a class="reference internal" href="#inspect">inspect</a></li>
<li><a class="reference internal" href="#ipaddress">ipaddress</a></li>
<li><a class="reference internal" href="#logging">logging</a></li>
<li><a class="reference internal" href="#marshal">marshal</a></li>
<li><a class="reference internal" href="#mmap">mmap</a></li>
<li><a class="reference internal" href="#multiprocessing">multiprocessing</a></li>
<li><a class="reference internal" href="#operator">operator</a></li>
<li><a class="reference internal" href="#os">os</a></li>
<li><a class="reference internal" href="#pdb">pdb</a></li>
<li><a class="reference internal" href="#pickle">pickle</a></li>
<li><a class="reference internal" href="#plistlib">plistlib</a></li>
<li><a class="reference internal" href="#poplib">poplib</a></li>
<li><a class="reference internal" href="#pprint">pprint</a></li>
<li><a class="reference internal" href="#pty">pty</a></li>
<li><a class="reference internal" href="#pydoc">pydoc</a></li>
<li><a class="reference internal" href="#re">re</a></li>
<li><a class="reference internal" href="#resource">resource</a></li>
<li><a class="reference internal" href="#select">select</a></li>
<li><a class="reference internal" href="#shelve">shelve</a></li>
<li><a class="reference internal" href="#shutil">shutil</a></li>
<li><a class="reference internal" href="#smtpd">smtpd</a></li>
<li><a class="reference internal" href="#smtplib">smtplib</a></li>
<li><a class="reference internal" href="#socket">socket</a></li>
<li><a class="reference internal" href="#sqlite3">sqlite3</a></li>
<li><a class="reference internal" href="#ssl">ssl</a></li>
<li><a class="reference internal" href="#stat">stat</a></li>
<li><a class="reference internal" href="#struct">struct</a></li>
<li><a class="reference internal" href="#subprocess">subprocess</a></li>
<li><a class="reference internal" href="#sunau">sunau</a></li>
<li><a class="reference internal" href="#sys">sys</a></li>
<li><a class="reference internal" href="#tarfile">tarfile</a></li>
<li><a class="reference internal" href="#textwrap">textwrap</a></li>
<li><a class="reference internal" href="#threading">threading</a></li>
<li><a class="reference internal" href="#traceback">回溯</a></li>
<li><a class="reference internal" href="#types">types</a></li>
<li><a class="reference internal" href="#urllib">urllib</a></li>
<li><a class="reference internal" href="#unittest">unittest</a></li>
<li><a class="reference internal" href="#venv">venv</a></li>
<li><a class="reference internal" href="#wave">wave</a></li>
<li><a class="reference internal" href="#weakref">weakref</a></li>
<li><a class="reference internal" href="#xml-etree">xml.etree</a></li>
<li><a class="reference internal" href="#zipfile">zipfile</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cpython-implementation-changes">CPython 实现的变化</a><ul>
<li><a class="reference internal" href="#pep-445-customization-of-cpython-memory-allocators">PEP 445: 自定义 CPython 内存分配器</a></li>
<li><a class="reference internal" href="#pep-442-safe-object-finalization">PEP 442: 安全的对象最终化</a></li>
<li><a class="reference internal" href="#pep-456-secure-and-interchangeable-hash-algorithm">PEP 456: 安全且可互换的哈希算法</a></li>
<li><a class="reference internal" href="#pep-436-argument-clinic">PEP 436: Argument Clinic</a></li>
<li><a class="reference internal" href="#other-build-and-c-api-changes">其他的构建和 C API 的改变</a></li>
<li><a class="reference internal" href="#other-improvements">其他改进</a></li>
<li><a class="reference internal" href="#significant-optimizations">显著的优化</a></li>
</ul>
</li>
<li><a class="reference internal" href="#deprecated">弃用</a><ul>
<li><a class="reference internal" href="#deprecations-in-the-python-api">Python API 中的弃用</a></li>
<li><a class="reference internal" href="#deprecated-features">弃用的特性</a></li>
</ul>
</li>
<li><a class="reference internal" href="#removed">移除</a><ul>
<li><a class="reference internal" href="#operating-systems-no-longer-supported">不再支持的操作系统</a></li>
<li><a class="reference internal" href="#api-and-feature-removals">API 与特性的移除</a></li>
<li><a class="reference internal" href="#code-cleanups">代码清理</a></li>
</ul>
</li>
<li><a class="reference internal" href="#porting-to-python-3-4">移植到 Python 3.4</a><ul>
<li><a class="reference internal" href="#changes-in-python-command-behavior"> 'python' 命令行为的变化</a></li>
<li><a class="reference internal" href="#changes-in-the-python-api">Python API 的变化</a></li>
<li><a class="reference internal" href="#changes-in-the-c-api">C API 的变化</a></li>
</ul>
</li>
<li><a class="reference internal" href="#changed-in-3-4-3">3.4.3 的变化</a><ul>
<li><a class="reference internal" href="#pep-476-enabling-certificate-verification-by-default-for-stdlib-http-clients">PEP 476: 默认为 stdlib http 客户端启用证书验证</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一主题</h4>
    <p class="topless"><a href="3.5.html"
                          title="上一章">Python 3.5 有什么新变化</a></p>
  </div>
  <div>
    <h4>下一主题</h4>
    <p class="topless"><a href="3.3.html"
                          title="下一章">Python 3.3 有什么新变化</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">报告代码错误</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/whatsnew/3.4.rst?plain=1"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="3.3.html" title="Python 3.3 有什么新变化"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="3.5.html" title="Python 3.5 有什么新变化"
             accesskey="P">上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.14.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python的新变化</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Python 3.4 有什么新变化</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q" id="search-box">
          <input type="submit" value="转到">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    主题
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>自动</option>
        <option value="light">明亮</option>
        <option value="dark">黑暗</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="what-s-new-in-python-3-4">
<h1 class="translated">Python 3.4 有什么新变化<a class="headerlink" href="#what-s-new-in-python-3-4" title="Link to this heading">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd translated">作者<span class="colon">:</span></dt>
<dd class="field-odd translated"><p class="translated">R. David Murray &lt;<a class="reference external" href="mailto:rdmurray&#37;&#52;&#48;bitdance&#46;com">rdmurray<span>&#64;</span>bitdance<span>&#46;</span>com</a>&gt; (Editor)</p>
</dd>
</dl>
<p class="translated">这篇文章介绍了 Python 3.4 相比 3.3 增加的新特性。 Python 3.4 发布于 2014 年 3 月 16 日。 对于完整的细节，请参见 <a class="reference external" href="https://docs.python.org/3.4/whatsnew/changelog.html">更新日志</a>。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p class="translated"><span class="target" id="index-119"></span><a class="pep reference external" href="https://peps.python.org/pep-0429/"><strong>PEP 429</strong></a> -- Python 3.4 发布计划</p>
</div>
<section id="summary-release-highlights">
<h2 class="translated">摘要 - 发布重点<a class="headerlink" href="#summary-release-highlights" title="Link to this heading">¶</a></h2>
<p class="translated">新的语法特性：</p>
<ul class="simple">
<li><p class="translated">Python 3.4 中没有增加新的语法特性。</p></li>
</ul>
<p class="translated">其他的新特性</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="#whatsnew-pep-453"><span class="std std-ref">pip 能够随时可用</span></a> (<span class="target" id="index-120"></span><a class="pep reference external" href="https://peps.python.org/pep-0453/"><strong>PEP 453</strong></a>).</p></li>
<li><p class="translated"><a class="reference internal" href="#whatsnew-pep-446"><span class="std std-ref">新创建的文件描述符是不可继承的</span></a> (<span class="target" id="index-121"></span><a class="pep reference external" href="https://peps.python.org/pep-0446/"><strong>PEP 446</strong></a>)。</p></li>
<li><p class="translated">对应 <a class="reference internal" href="#whatsnew-isolated-mode"><span class="std std-ref">隔离模式</span></a> 的命令行选项 (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16499">bpo-16499</a>)。</p></li>
<li><p class="translated">针对非文本编码格式的 <a class="reference internal" href="#codec-handling-improvements"><span class="std std-ref">编解码器处理方式的改进</span></a> (多个相关问题)。</p></li>
<li><p class="translated">针对导入系统的 <a class="reference internal" href="#whatsnew-pep-451"><span class="std std-ref">ModuleSpec 类型</span></a> (<span class="target" id="index-122"></span><a class="pep reference external" href="https://peps.python.org/pep-0451/"><strong>PEP 451</strong></a>)。 （将影响导入器的作者。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">marshal</span></code></a> 格式已被改进为 <a class="reference internal" href="#whatsnew-marshal-3"><span class="std std-ref">更为紧凑与高效</span></a> (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16475">bpo-16475</a>)。</p></li>
</ul>
<p class="translated">新的库模块：</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="../library/asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a>: <a class="reference internal" href="#whatsnew-asyncio"><span class="std std-ref">针对异步 IO 的新版暂定 API</span></a> (<span class="target" id="index-123"></span><a class="pep reference external" href="https://peps.python.org/pep-3156/"><strong>PEP 3156</strong></a>)。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/ensurepip.html#module-ensurepip" title="ensurepip: Bootstrapping the &quot;pip&quot; installer into an existing Python installation or virtual environment."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ensurepip</span></code></a>: <a class="reference internal" href="#whatsnew-ensurepip"><span class="std std-ref">引导设置 pip 安装器</span></a> (<span class="target" id="index-124"></span><a class="pep reference external" href="https://peps.python.org/pep-0453/"><strong>PEP 453</strong></a>)。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/enum.html#module-enum" title="enum: Implementation of an enumeration class."><code class="xref py py-mod docutils literal notranslate"><span class="pre">enum</span></code></a>: <a class="reference internal" href="#whatsnew-enum"><span class="std std-ref">对枚举类型的支持</span></a> (<span class="target" id="index-125"></span><a class="pep reference external" href="https://peps.python.org/pep-0435/"><strong>PEP 435</strong></a>)。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/pathlib.html#module-pathlib" title="pathlib: Object-oriented filesystem paths"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pathlib</span></code></a>: <a class="reference internal" href="#whatsnew-pathlib"><span class="std std-ref">面向对象的文件系统路径</span></a> (<span class="target" id="index-126"></span><a class="pep reference external" href="https://peps.python.org/pep-0428/"><strong>PEP 428</strong></a>)。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/selectors.html#module-selectors" title="selectors: High-level I/O multiplexing."><code class="xref py py-mod docutils literal notranslate"><span class="pre">selectors</span></code></a>: <a class="reference internal" href="#whatsnew-selectors"><span class="std std-ref">高层级且高效率的 I/O 复用</span></a>，在 <a class="reference internal" href="../library/select.html#module-select" title="select: Wait for I/O completion on multiple streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">select</span></code></a> 模块的基础之上建立（为 <span class="target" id="index-127"></span><a class="pep reference external" href="https://peps.python.org/pep-3156/"><strong>PEP 3156</strong></a> 的组成部分）。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/statistics.html#module-statistics" title="statistics: Mathematical statistics functions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">statistics</span></code></a>: 基础 <a class="reference internal" href="#whatsnew-statistics"><span class="std std-ref">数字领域稳定统计库</span></a> (<span class="target" id="index-128"></span><a class="pep reference external" href="https://peps.python.org/pep-0450/"><strong>PEP 450</strong></a>)。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/tracemalloc.html#module-tracemalloc" title="tracemalloc: Trace memory allocations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tracemalloc</span></code></a>: <a class="reference internal" href="#whatsnew-tracemalloc"><span class="std std-ref">追踪 Python 内存分配</span></a> (<span class="target" id="index-129"></span><a class="pep reference external" href="https://peps.python.org/pep-0454/"><strong>PEP 454</strong></a>)。</p></li>
</ul>
<p class="translated">显著改进的库模块:</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="../library/functools.html#module-functools" title="functools: Higher-order functions and operations on callable objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">functools</span></code></a> 中的 <a class="reference internal" href="#whatsnew-singledispatch"><span class="std std-ref">单一调度泛型函数</span></a> (<span class="target" id="index-130"></span><a class="pep reference external" href="https://peps.python.org/pep-0443/"><strong>PEP 443</strong></a>)。</p></li>
<li><p class="translated">新的 <a class="reference internal" href="../library/pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> <a class="reference internal" href="#whatsnew-protocol-4"><span class="std std-ref">协议 4</span></a> (<span class="target" id="index-131"></span><a class="pep reference external" href="https://peps.python.org/pep-3154/"><strong>PEP 3154</strong></a>)。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> 现在包含 <a class="reference internal" href="#whatsnew-multiprocessing-no-fork"><span class="std std-ref">一个避免在 Unix 上使用 os.fork 的选项</span></a> (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=8713">bpo-8713</a>)。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code></a> 增加新的子模块 <a class="reference internal" href="../library/email.contentmanager.html#module-email.contentmanager" title="email.contentmanager: Storing and Retrieving Content from MIME Parts"><code class="xref py py-mod docutils literal notranslate"><span class="pre">contentmanager</span></code></a> 和新的子类 <a class="reference internal" href="../library/email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Message</span></code></a> (<a class="reference internal" href="../library/email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a>) 用以 <a class="reference internal" href="#whatsnew-email-contentmanager"><span class="std std-ref">简化 MIME 处理</span></a> (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18891">bpo-18891</a>)。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/inspect.html#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect</span></code></a> 和 <a class="reference internal" href="../library/pydoc.html#module-pydoc" title="pydoc: Documentation generator and online help system."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code></a> 模块现在能够自省更多种类的可调用对象，这改进了 Python <a class="reference internal" href="../library/functions.html#help" title="help"><code class="xref py py-func docutils literal notranslate"><span class="pre">help()</span></code></a> 系统的输出。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/ipaddress.html#module-ipaddress" title="ipaddress: IPv4/IPv6 manipulation library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ipaddress</span></code></a> 模块 API 已被声明为稳定状态</p></li>
</ul>
<p class="translated">安全改进：</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="#whatsnew-pep-456"><span class="std std-ref">安全且可互换的哈希算法</span></a> (<span class="target" id="index-132"></span><a class="pep reference external" href="https://peps.python.org/pep-0456/"><strong>PEP 456</strong></a>)。</p></li>
<li><p class="translated"><a class="reference internal" href="#whatsnew-pep-446"><span class="std std-ref">将新创建的文件描述符设为不可继承</span></a> (<span class="target" id="index-133"></span><a class="pep reference external" href="https://peps.python.org/pep-0446/"><strong>PEP 446</strong></a>) 以避免将文件描述符泄露给子进程。</p></li>
<li><p class="translated">新增对应 <a class="reference internal" href="#whatsnew-isolated-mode"><span class="std std-ref">隔离模式</span></a> 的命令行选项。 (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16499">bpo-16499</a>)。</p></li>
<li><p class="translated">现在 <a class="reference internal" href="../library/multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> 具有 <a class="reference internal" href="#whatsnew-multiprocessing-no-fork"><span class="std std-ref">一个在 Unix 上避免使用 os.fork 的选项</span></a>。 <em>spawn</em> 和 <em>forkserver</em> 更为安全因为它们会避免与子进程共享数据。</p></li>
<li><p class="translated">在 Windows 上 <a class="reference internal" href="../library/multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> 子进程将不再继承父进程的所有可继承句柄，而仅继承必需的几个。</p></li>
<li><p class="translated">新增的 <a class="reference internal" href="../library/hashlib.html#hashlib.pbkdf2_hmac" title="hashlib.pbkdf2_hmac"><code class="xref py py-func docutils literal notranslate"><span class="pre">hashlib.pbkdf2_hmac()</span></code></a> 函数可提供 <a class="reference external" href="https://en.wikipedia.org/wiki/PBKDF2">PKCS#5 基于口令的密钥派生函数 2</a>。</p></li>
<li><p class="translated">在 <a class="reference internal" href="../library/ssl.html#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> 中对于 <a class="reference internal" href="#whatsnew-tls-11-12"><span class="std std-ref">TLSv1.1 和 TLSv1.2 的支持</span></a>。</p></li>
<li><p class="translated">在 <a class="reference internal" href="../library/ssl.html#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> 中对于 <a class="reference internal" href="#whatsnew34-win-cert-store"><span class="std std-ref">从 Windows 系统证书库获取证书的支持</span></a>。</p></li>
<li><p class="translated">在 <a class="reference internal" href="../library/ssl.html#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> 中对于 <a class="reference internal" href="#whatsnew34-sni"><span class="std std-ref">服务端 SNI (Server Name Indication) 的支持</span></a>。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a> 类具有 <a class="reference internal" href="#whatsnew34-sslcontext"><span class="std std-ref">大量改进</span></a>。</p></li>
<li><p class="translated">标准库中所有支持 SSL 的模块现在都支持服务器证书验证，包括主机名匹配 (<code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.match_hostname()</span></code>) 和 CRL (Certificate Revocation Lists，参见 <a class="reference internal" href="../library/ssl.html#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.SSLContext.load_verify_locations()</span></code></a>)。</p></li>
</ul>
<p class="translated">CPython 实现的改进：</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="#whatsnew-pep-442"><span class="std std-ref">安全的对象最终化</span></a> (<span class="target" id="index-134"></span><a class="pep reference external" href="https://peps.python.org/pep-0442/"><strong>PEP 442</strong></a>)。</p></li>
<li><p class="translated">通过应用 <span class="target" id="index-135"></span><a class="pep reference external" href="https://peps.python.org/pep-0442/"><strong>PEP 442</strong></a>，在大多数情况下 <a class="reference internal" href="#whatsnew-pep-442"><span class="std std-ref">模块的 globals 在最终化期间将不再被设为 None</span></a> (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18214">bpo-18214</a>)。</p></li>
<li><p class="translated"><a class="reference internal" href="#whatsnew-pep-445"><span class="std std-ref">可配置的内存分配器</span></a> (<span class="target" id="index-136"></span><a class="pep reference external" href="https://peps.python.org/pep-0445/"><strong>PEP 445</strong></a>)。</p></li>
<li><p class="translated"><a class="reference internal" href="#whatsnew-pep-436"><span class="std std-ref">Argument Clinic</span></a> (<span class="target" id="index-137"></span><a class="pep reference external" href="https://peps.python.org/pep-0436/"><strong>PEP 436</strong></a>)。</p></li>
</ul>
<p class="translated">请继续阅读有关针对用户的改变的完整清单，包括许多其他较小的改进、CPython 优化、弃用以及潜在的移植问题。</p>
</section>
<section id="new-features">
<h2 class="translated">新的特性<a class="headerlink" href="#new-features" title="Link to this heading">¶</a></h2>
<section id="pep-453-explicit-bootstrapping-of-pip-in-python-installations">
<span id="whatsnew-pep-453"></span><h3 class="translated">PEP 453: 在 Python 安装版中对 PIP 的显式初始设置<a class="headerlink" href="#pep-453-explicit-bootstrapping-of-pip-in-python-installations" title="Link to this heading">¶</a></h3>
<section id="bootstrapping-pip-by-default">
<h4 class="translated">默认对 pip 进行初始设置<a class="headerlink" href="#bootstrapping-pip-by-default" title="Link to this heading">¶</a></h4>
<p class="translated">新增的 <a class="reference internal" href="../library/ensurepip.html#module-ensurepip" title="ensurepip: Bootstrapping the &quot;pip&quot; installer into an existing Python installation or virtual environment."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ensurepip</span></code></a> 模块（在 <span class="target" id="index-138"></span><a class="pep reference external" href="https://peps.python.org/pep-0453/"><strong>PEP 453</strong></a> 中定义）提供了一个在 Python 安装版和虚拟环境中初始设置 pip 安装器的标准跨平台机制。 包括在 Python 3.4.0 中的 <code class="docutils literal notranslate"><span class="pre">pip</span></code> 版本是 <code class="docutils literal notranslate"><span class="pre">pip</span></code> 1.5.4，未来的 3.4.x 维护发布版会将附带版本升级为创建候选发布版时的 <code class="docutils literal notranslate"><span class="pre">pip</span></code> 最新版本。</p>
<p class="translated">在默认情况下，将在所有平台上安装 <code class="docutils literal notranslate"><span class="pre">pipX</span></code> 和 <code class="docutils literal notranslate"><span class="pre">pipX.Y</span></code> 等命令（其中 X.Y 表示 Python 安装包的版本），并包括 <code class="docutils literal notranslate"><span class="pre">pip</span></code> Python 包及其依赖。 在 Windows 中以及所有平台的虚拟环境中，还将安装不带版本号的 <code class="docutils literal notranslate"><span class="pre">pip</span></code> 命令。 在其他平台中，系统层级上不带版本号的 <code class="docutils literal notranslate"><span class="pre">pip</span></code> 命令通常是指向单独安装的 Python 2 版本。</p>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">pyvenv</span></code> 命令行工具和 <a class="reference internal" href="../library/venv.html#module-venv" title="venv: Creation of virtual environments."><code class="xref py py-mod docutils literal notranslate"><span class="pre">venv</span></code></a> 模块可利用 <a class="reference internal" href="../library/ensurepip.html#module-ensurepip" title="ensurepip: Bootstrapping the &quot;pip&quot; installer into an existing Python installation or virtual environment."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ensurepip</span></code></a> 模块在虚拟环境中准备好 <code class="docutils literal notranslate"><span class="pre">pip</span></code>。 当使用命令行工具时，会默认安装 <code class="docutils literal notranslate"><span class="pre">pip</span></code>，而当使用 <a class="reference internal" href="../library/venv.html#module-venv" title="venv: Creation of virtual environments."><code class="xref py py-mod docutils literal notranslate"><span class="pre">venv</span></code></a> 模块的 <a class="reference internal" href="../library/venv.html#venv-api"><span class="std std-ref">API</span></a> 安装版时必须显式地安装 <code class="docutils literal notranslate"><span class="pre">pip</span></code>。</p>
<p class="translated">对于 CPython <a class="reference internal" href="../using/unix.html#building-python-on-unix"><span class="std std-ref">在 POSIX 系统上的源代码编译版</span></a>，<code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">install</span></code> 和 <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">altinstall</span></code> 命令默认会初始设置 <code class="docutils literal notranslate"><span class="pre">pip</span></code>。 此行为可通过配置选项来控制，并通过 Makefile 选项来重写。</p>
<p class="translated">在 Windows 和 Mac OS X 上，现在 CPython 安装程序默认会将 <code class="docutils literal notranslate"><span class="pre">pip</span></code> 与 CPython 本身一同安装（用户可以在安装过程中选择不安装它）。 Window 用户需要选择执行 <code class="docutils literal notranslate"><span class="pre">PATH</span></code> 修改以使 <code class="docutils literal notranslate"><span class="pre">pip</span></code> 在命令行中默认可用，在其他情况下它仍然可以通过 Windows 版 Python 启动器以 <code class="docutils literal notranslate"><span class="pre">py</span> <span class="pre">-m</span> <span class="pre">pip</span></code> 的方式使用。</p>
<p class="translated">正如 <span class="target" id="index-139"></span><a class="pep reference external" href="https://peps.python.org/pep-0453/#recommendations-for-downstream-distributors"><strong>在 PEP 中已讨论的</strong></a> 那样平台打包者可以选择不默认安装这些命令，只需在它们被唤起时，能够提供有关如何在该平台上安装它们的简单清晰的指引（通常是使用系统的包管理器）。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p class="translated">为了避免同时存在的 Python 2 和 Python 3 安装版之前的冲突，当 <code class="docutils literal notranslate"><span class="pre">ensurepip</span></code> 被直接唤起时默认只会初始设置带版本号的 <code class="docutils literal notranslate"><span class="pre">pip3</span></code> 和 <code class="docutils literal notranslate"><span class="pre">pip3.4</span></code> 命令 —— 需要添加 <code class="docutils literal notranslate"><span class="pre">--default-pip</span></code> 选项来请求设置不带版本号的 <code class="docutils literal notranslate"><span class="pre">pip</span></code> 命令。 <code class="docutils literal notranslate"><span class="pre">pyvenv</span></code> 和 Windows 安装程序会确保未限定版本的 <code class="docutils literal notranslate"><span class="pre">pip</span></code> 命令在环境中可用，并且 <code class="docutils literal notranslate"><span class="pre">pip</span></code> 始终可以通过 <code class="docutils literal notranslate"><span class="pre">-m</span></code> 选项开关而不是直接唤起以避免在具有多个 Python 安装版的系统中造成歧义。</p>
</div>
</section>
<section id="documentation-changes">
<h4 class="translated">文档更改<a class="headerlink" href="#documentation-changes" title="Link to this heading">¶</a></h4>
<p class="translated">作为此项更改的一部分，文档的 <a class="reference internal" href="../installing/index.html#installing-index"><span class="std std-ref">安装 Python 模块</span></a> 和 <a class="reference internal" href="../distributing/index.html#distributing-index"><span class="std std-ref">分发 Python 模块</span></a> 章节已经完全重新设计，快速入门和 FAQ 文档也是如此。 大部分打包指南文档现在都已被移至由 Python Packaging Authority 维护的 <a class="reference external" href="https://packaging.python.org">Python Packaging User Guide</a> 以及相应的独立项目文档。</p>
<p class="translated">不过，由于目前迁移过程尚未完成，这些指南的旧版本仍然可通过 <a class="reference internal" href="../extending/building.html#install-index"><span class="std std-ref">使用 setuptools 构建 C 和 C++ 扩展</span></a> 和 <a class="reference internal" href="../extending/building.html#setuptools-index"><span class="std std-ref">使用 setuptools 构建 C 和 C++ 扩展</span></a> 来访问。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-140"></span><a class="pep reference external" href="https://peps.python.org/pep-0453/"><strong>PEP 453</strong></a> -- Python 安装版中对 pip 的显式初始设置</dt><dd><p class="translated">PEP 由Donald Stufft 和 Nick Coghlan 撰写，由 Donald Stufft，Nick Coghlan，Martin von Löwis 和 Ned Deily 实现。</p>
</dd>
</dl>
</div>
</section>
</section>
<section id="pep-446-newly-created-file-descriptors-are-non-inheritable">
<span id="whatsnew-pep-446"></span><h3 class="translated">PEP 446: 新创建的文件描述符将设为不可继承<a class="headerlink" href="#pep-446-newly-created-file-descriptors-are-non-inheritable" title="Link to this heading">¶</a></h3>
<p class="translated"><span class="target" id="index-141"></span><a class="pep reference external" href="https://peps.python.org/pep-0446/"><strong>PEP 446</strong></a> 将新创建的文件描述符设为 <a class="reference internal" href="../library/os.html#fd-inheritance"><span class="std std-ref">不可继承的</span></a>。 通常，这就是应用程序所需要的行为：当启动一个新进程时，让当前打开的文件也在新进程里打开可能导致各种难以查找的程序错误以及潜在的安全问题。</p>
<p class="translated">不过，也存在一些需要继承行为的情况。 为了支持这些情况，可以使用以下的新增函数和方法：</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="../library/os.html#os.get_inheritable" title="os.get_inheritable"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.get_inheritable()</span></code></a>, <a class="reference internal" href="../library/os.html#os.set_inheritable" title="os.set_inheritable"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.set_inheritable()</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="../library/os.html#os.get_handle_inheritable" title="os.get_handle_inheritable"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.get_handle_inheritable()</span></code></a>, <a class="reference internal" href="../library/os.html#os.set_handle_inheritable" title="os.set_handle_inheritable"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.set_handle_inheritable()</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="../library/socket.html#socket.socket.get_inheritable" title="socket.socket.get_inheritable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.socket.get_inheritable()</span></code></a>, <a class="reference internal" href="../library/socket.html#socket.socket.set_inheritable" title="socket.socket.set_inheritable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.socket.set_inheritable()</span></code></a></p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-142"></span><a class="pep reference external" href="https://peps.python.org/pep-0446/"><strong>PEP 446</strong></a> -- 将新创建的文件描述符设为不可继承</dt><dd><p class="translated">PEP 由 Victor Stinner 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="improvements-to-codec-handling">
<span id="codec-handling-improvements"></span><h3 class="translated">编解码器处理方式的改进<a class="headerlink" href="#improvements-to-codec-handling" title="Link to this heading">¶</a></h3>
<p class="translated">自首次被引入以来，<a class="reference internal" href="../library/codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code></a> 模块始终是作为一个类型中立的动态编码和解码系统来运作的。 然而，它与 Python 文本模型，尤其是内置 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>、<a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 和 <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 类型上的限定类型的便捷方法的紧密耦合，在历史上掩盖了这一事实。</p>
<p class="translated">作为明晰情况的关键一步，现在 <a class="reference internal" href="../library/codecs.html#codecs.encode" title="codecs.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">codecs.encode()</span></code></a> 和 <a class="reference internal" href="../library/codecs.html#codecs.decode" title="codecs.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">codecs.decode()</span></code></a> 便捷函数在 Python 2.7、3.3 和 3.4 中都正确地写入了文档。 自 Python 2.4 以来这些函数即已存在于 <a class="reference internal" href="../library/codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code></a> 模块中（并已被回归测试套件所覆盖），但在此前只能通过运行时自省才能发现。</p>
<p class="translated">不同于 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 和 <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 上的便捷方法，<a class="reference internal" href="../library/codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code></a> 的便捷函数同时支持 Python 2 和 Python 3 中的任意编解码器，而非仅限于 Unicode 文本编码格式（在 Python 3 中) 或 <code class="docutils literal notranslate"><span class="pre">basestring</span></code> &lt;-&gt; <code class="docutils literal notranslate"><span class="pre">basestring</span></code> 转换（在 Python 2 中）。</p>
<p class="translated">在 Python 3.4 中，解释器能够识别标准库中提供的已知非文本编码格式并会在适当的时候引导用户找到这些通用型便捷函数:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;hex&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">LookupError</span>: <span class="n">&#39;hex&#39; is not a text encoding; use codecs.decode() to handle arbitrary codecs</span>

<span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;hello&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;rot13&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">LookupError</span>: <span class="n">&#39;rot13&#39; is not a text encoding; use codecs.encode() to handle arbitrary codecs</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">open</span><span class="p">(</span><span class="s2">&quot;foo.txt&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;hex&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">LookupError</span>: <span class="n">&#39;hex&#39; is not a text encoding; use codecs.open() to handle arbitrary codecs</span>
</pre></div>
</div>
<p class="translated">在相关的改变中，只要在不破坏向下兼容性 的情况下是可行的，则在编码和解码操作期间引发的异常都会被包装在一个特定类型的链式异常中，该类型的名称与产生错误的相应编解码器一致:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">codecs</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">codecs</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdefgh&quot;</span><span class="p">,</span> <span class="s2">&quot;hex&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;/usr/lib/python3.4/encodings/hex_codec.py&quot;</span>, line <span class="m">20</span>, in <span class="n">hex_decode</span>
<span class="w">    </span><span class="k">return</span> <span class="p">(</span><span class="n">binascii</span><span class="o">.</span><span class="n">a2b_hex</span><span class="p">(</span><span class="nb">input</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="p">))</span>
<span class="gr">binascii.Error</span>: <span class="n">Non-hexadecimal digit found</span>

<span class="gt">The above exception was the direct cause of the following exception:</span>

<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">binascii.Error</span>: <span class="n">decoding with &#39;hex&#39; codec failed (Error: Non-hexadecimal digit found)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">codecs</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">,</span> <span class="s2">&quot;bz2&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;/usr/lib/python3.4/encodings/bz2_codec.py&quot;</span>, line <span class="m">17</span>, in <span class="n">bz2_encode</span>
<span class="w">    </span><span class="k">return</span> <span class="p">(</span><span class="n">bz2</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="nb">input</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="p">))</span>
  File <span class="nb">&quot;/usr/lib/python3.4/bz2.py&quot;</span>, line <span class="m">498</span>, in <span class="n">compress</span>
<span class="w">    </span><span class="k">return</span> <span class="n">comp</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">+</span> <span class="n">comp</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
<span class="gr">TypeError</span>: <span class="n">&#39;str&#39; does not support the buffer interface</span>

<span class="gt">The above exception was the direct cause of the following exception:</span>

<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">encoding with &#39;bz2&#39; codec failed (TypeError: &#39;str&#39; does not support the buffer interface)</span>
</pre></div>
</div>
<p class="translated">最后，正如上面的例子所示，这些改进允许恢复非 Unicode 编解码器的便捷别名，这些别名在 Python 3.2 中已被恢复。 这意味着（举例来说）二进制数据到其十六进制表示形式的编码转换现在可以写成:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">codecs</span><span class="w"> </span><span class="kn">import</span> <span class="n">encode</span><span class="p">,</span> <span class="n">decode</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encode</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;hello&quot;</span><span class="p">,</span> <span class="s2">&quot;hex&quot;</span><span class="p">)</span>
<span class="go">b&#39;68656c6c6f&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decode</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;68656c6c6f&quot;</span><span class="p">,</span> <span class="s2">&quot;hex&quot;</span><span class="p">)</span>
<span class="go">b&#39;hello&#39;</span>
</pre></div>
</div>
<p class="translated">在标准库中提供的二进制和文本转换操作详见 <a class="reference internal" href="../library/codecs.html#binary-transforms"><span class="std std-ref">二进制转换</span></a> 和 <a class="reference internal" href="../library/codecs.html#text-transforms"><span class="std std-ref">文字转换</span></a>。</p>
<p class="translated">（由 Nick Coghlan 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7475">bpo-7475</a>, <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=17827">bpo-17827</a>, <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=17828">bpo-17828</a> 和 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19619">bpo-19619</a> 中贡献。）</p>
</section>
<section id="pep-451-a-modulespec-type-for-the-import-system">
<span id="whatsnew-pep-451"></span><h3 class="translated">PEP 451: 针对导入系统的 ModuleSpec 类型<a class="headerlink" href="#pep-451-a-modulespec-type-for-the-import-system" title="Link to this heading">¶</a></h3>
<p class="translated"><span class="target" id="index-143"></span><a class="pep reference external" href="https://peps.python.org/pep-0451/"><strong>PEP 451</strong></a> 提供了对模块相关信息的封装，导入机制将使用这些信息来加载它（即模块规范说明）。 这有助于简化导入的实现和几个导入相关的 API。 这一改动也是 <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2013-November/130111.html">某些未来导入相关改进</a> 的基石。</p>
<p class="translated">PEP 中面向公众的修改是完全向下兼容的。 并且，它们应当对除导入器开发者之外的其他所有人都可见。 主要查找器和加载器方法已被弃用，但它们将继续工作。 新的导入器应当使用 PEP 中描述的新方法。  现有的导入器应当被更新以实现这些新方法。 请参阅 <a class="reference internal" href="#deprecated-3-4"><span class="std std-ref">弃用</span></a> 一节获取应当被替代的方法及其替代物的列表。</p>
</section>
<section id="other-language-changes">
<h3 class="translated">其他语言特性修改<a class="headerlink" href="#other-language-changes" title="Link to this heading">¶</a></h3>
<p class="translated">对Python 语言核心进行的小改动：</p>
<ul class="simple">
<li><p class="translated">Unicode 数据库更新至 UCD 版本 6.3。</p></li>
<li><p class="translated">现在 <a class="reference internal" href="../library/functions.html#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a> 和 <a class="reference internal" href="../library/functions.html#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a> 均接受一个 <em>default</em> 仅限关键字参数可被用来指定当它们要求值的可迭代对象中没有任何元素时要返回的值。 （由 Julian Berman 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18111">bpo-18111</a> 中贡献。）</p></li>
<li><p class="translated">模块对象现在是 <a class="reference internal" href="../library/weakref.html#mod-weakref"><span class="std std-ref">可弱引用的</span></a>。</p></li>
<li><p class="translated">模块的 <code class="docutils literal notranslate"><span class="pre">__file__</span></code> 属性（以及相关的值）现在应当总是默认包含绝对路径，唯一的例外是当使用相对路径直接执行一个脚本时的 <code class="docutils literal notranslate"><span class="pre">__main__.__file__</span></code>。 （由 Brett Cannon 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18416">bpo-18416</a> 中贡献。）</p></li>
<li><p class="translated">现在所有 UTF-* 编解码器（UTF-7 除外）在编码和解码期间都将拒绝替代符除非使用 <code class="docutils literal notranslate"><span class="pre">surrogatepass</span></code> 错误处理器，例外情况有 UTF-16 解码器（接受有效的替代符对）和 UTF-16 编码器（在编码非 BMP 字符时会产生替代符）。 （由 Victor Stinner, Kang-Hao (Kenny) Lu 和 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=12892">bpo-12892</a> 中贡献。）</p></li>
<li><p class="translated">新增 German EBCDIC <a class="reference internal" href="../library/codecs.html#standard-encodings"><span class="std std-ref">编解码器</span></a> <code class="docutils literal notranslate"><span class="pre">cp273</span></code>。 （由 Michael Bierenfeld 和 Andrew Kuchling 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1097797">bpo-1097797</a> 中贡献。）</p></li>
<li><p class="translated">新增 Ukrainian <a class="reference internal" href="../library/codecs.html#standard-encodings"><span class="std std-ref">编解码器</span></a> <code class="docutils literal notranslate"><span class="pre">cp1125</span></code>。 （由 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19668">bpo-19668</a> 中贡献。）</p></li>
<li><p class="translated">现在 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>.join() 和 <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a>.join() 接受任意缓冲区对象作为参数。 （由 Antoine Pitrou 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=15958">bpo-15958</a> 中贡献。）</p></li>
<li><p class="translated">现在 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 构造器接受任何具有 <code class="docutils literal notranslate"><span class="pre">__index__</span></code> 方法的对象作为其 <em>base</em> 参数。 （由 Mark Dickinson 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16772">bpo-16772</a> 中贡献。）</p></li>
<li><p class="translated">帧对象现在具有 <a class="reference internal" href="../reference/datamodel.html#frame.clear" title="frame.clear"><code class="xref py py-func docutils literal notranslate"><span class="pre">clear()</span></code></a> 方法用来从帧中清除所有对局部变量的引用。 （由 Antoine Pitrou 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=17934">bpo-17934</a> 中贡献。）</p></li>
<li><p class="translated">现在 <a class="reference internal" href="../library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> 被注册为 <a class="reference internal" href="../library/collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-class docutils literal notranslate"><span class="pre">序列</span></code></a>，并支持 <a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a> 内置函数。 （由 Nick Coghlan 和 Claudiu Popa 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18690">bpo-18690</a> 和 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19078">bpo-19078</a> 中贡献。）</p></li>
<li><p class="translated">作为对引入 Argument Clinic 以及对 <a class="reference internal" href="../library/inspect.html#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect</span></code></a> 和 <a class="reference internal" href="../library/pydoc.html#module-pydoc" title="pydoc: Documentation generator and online help system."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code></a> 模块的其他修改的结果，在各种场合下由 <a class="reference internal" href="../library/functions.html#help" title="help"><code class="xref py py-func docutils literal notranslate"><span class="pre">help()</span></code></a> 所报告的签名信息已获得修改和提升。</p></li>
<li><p class="translated">现在 <a class="reference internal" href="../reference/datamodel.html#object.__length_hint__" title="object.__length_hint__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__length_hint__()</span></code></a> 已成为正式语言规范的一部分 (参见 <span class="target" id="index-144"></span><a class="pep reference external" href="https://peps.python.org/pep-0424/"><strong>PEP 424</strong></a>)。 （由 Armin Ronacher 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16148">bpo-16148</a> 中贡献。）</p></li>
</ul>
</section>
</section>
<section id="new-modules">
<h2 class="translated">新增模块<a class="headerlink" href="#new-modules" title="Link to this heading">¶</a></h2>
<section id="asyncio">
<span id="whatsnew-asyncio"></span><h3 class="translated">asyncio<a class="headerlink" href="#asyncio" title="Link to this heading">¶</a></h3>
<p class="translated">新增的 <a class="reference internal" href="../library/asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a> 模块（在 <span class="target" id="index-145"></span><a class="pep reference external" href="https://peps.python.org/pep-3156/"><strong>PEP 3156</strong></a> 中定义）为 Python 提供了一个标准的可插入事件循环模型，在标准库中提供了坚实的异步 IO 支持，并使得其他事件循环的实现与标准库和其他库的相互操作更为容易。</p>
<p class="translated">对于 Python 3.4，此模块被视为属于 <a class="reference internal" href="../glossary.html#term-provisional-API"><span class="xref std std-term">provisional API</span></a>。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-146"></span><a class="pep reference external" href="https://peps.python.org/pep-3156/"><strong>PEP 3156</strong></a> -- 异步 IO 支持的重启: &quot;asyncio&quot; 模块</dt><dd><p class="translated">PEP 由 Guido van Rossum 领导编写和实现。</p>
</dd>
</dl>
</div>
</section>
<section id="ensurepip">
<span id="whatsnew-ensurepip"></span><h3 class="translated">ensurepip<a class="headerlink" href="#ensurepip" title="Link to this heading">¶</a></h3>
<p class="translated">新增的 <a class="reference internal" href="../library/ensurepip.html#module-ensurepip" title="ensurepip: Bootstrapping the &quot;pip&quot; installer into an existing Python installation or virtual environment."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ensurepip</span></code></a> 模块是用于 <span class="target" id="index-147"></span><a class="pep reference external" href="https://peps.python.org/pep-0453/"><strong>PEP 453</strong></a> 实现的主要基础设施。   在正常情况下最终用户不需要与此模块进行交互，但如果对安装版或虚拟环境的自动初始设置遭到拒绝则可使用它来手动初始设置 <code class="docutils literal notranslate"><span class="pre">pip</span></code>。</p>
<p class="translated"><a class="reference internal" href="../library/ensurepip.html#module-ensurepip" title="ensurepip: Bootstrapping the &quot;pip&quot; installer into an existing Python installation or virtual environment."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ensurepip</span></code></a> 包括了一个捆绑的 <code class="docutils literal notranslate"><span class="pre">pip</span></code> 副本，其版本更新时间即 CPython 发布包的第一个候选发布版的发布时间（此规则同样适用于维护发布版和新特性发布版）。 <code class="docutils literal notranslate"><span class="pre">ensurepip</span></code> 不会访问因特网。 如果安装版可以访问因特网，则在运行 <code class="docutils literal notranslate"><span class="pre">ensurepip</span></code> 之后可以使用所捆绑的 <code class="docutils literal notranslate"><span class="pre">pip</span></code> 来将 <code class="docutils literal notranslate"><span class="pre">pip</span></code> 升级为比所捆绑版本更高的版本。 （请注意这样得到的 <code class="docutils literal notranslate"><span class="pre">pip</span></code> 升级版本将被视为一个单独安装的软件包并且在 Python 被卸载时将不会被移除。）</p>
<p class="translated">该模块被命名为 <em>ensure</em>pip 是因为如果在已安装 <code class="docutils literal notranslate"><span class="pre">pip</span></code> 的情况下被调用，它将不做任何操作。 它还有一个 <code class="docutils literal notranslate"><span class="pre">--upgrade</span></code> 选项可以在当前已安装的 <code class="docutils literal notranslate"><span class="pre">pip</span></code> 版本比所捆绑的副本更旧的情况下安装所捆绑的 <code class="docutils literal notranslate"><span class="pre">pip</span></code> 副本。</p>
</section>
<section id="enum">
<span id="whatsnew-enum"></span><h3 class="translated">enum<a class="headerlink" href="#enum" title="Link to this heading">¶</a></h3>
<p class="translated">新增的 <a class="reference internal" href="../library/enum.html#module-enum" title="enum: Implementation of an enumeration class."><code class="xref py py-mod docutils literal notranslate"><span class="pre">enum</span></code></a> 模块（在 <span class="target" id="index-148"></span><a class="pep reference external" href="https://peps.python.org/pep-0435/"><strong>PEP 435</strong></a> 中定义）提供了枚举类型的标准实现，允许其他模块（如 <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> 等）通过将含义不清晰的整数常量替换为可向下兼容的枚举值来提供更具信息量的错误消息和更好的调试支持。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-149"></span><a class="pep reference external" href="https://peps.python.org/pep-0435/"><strong>PEP 435</strong></a> -- 为 Python 标准库增加了 Enum 类型</dt><dd><p class="translated">PEP 由 Barry Warsaw，Eli Bendersky 和 Ethan Furman 撰写 ，由 Ethan Furman 实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pathlib">
<span id="whatsnew-pathlib"></span><h3 class="translated">pathlib<a class="headerlink" href="#pathlib" title="Link to this heading">¶</a></h3>
<p class="translated">新增的 <a class="reference internal" href="../library/pathlib.html#module-pathlib" title="pathlib: Object-oriented filesystem paths"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pathlib</span></code></a> 模块提供了代表文件系统路径的类，其语义适用于不同的操作系统。 路径类被划分为提供不带 I/O 的纯计算操作的 <em>纯路径</em>，以及继承自纯路径但提供 I/O 操作的 <em>实体路径</em>。</p>
<p class="translated">对于 Python 3.4，此模块被视为属于 <a class="reference internal" href="../glossary.html#term-provisional-API"><span class="xref std std-term">provisional API</span></a>。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-150"></span><a class="pep reference external" href="https://peps.python.org/pep-0428/"><strong>PEP 428</strong></a> -- pathlib 模块 -- 面向对象的文件系统路径</dt><dd><p class="translated">PEP 由 Antoine Pitrou 撰写并实现</p>
</dd>
</dl>
</div>
</section>
<section id="selectors">
<span id="whatsnew-selectors"></span><h3 class="translated">selectors<a class="headerlink" href="#selectors" title="Link to this heading">¶</a></h3>
<p class="translated">新增的 <a class="reference internal" href="../library/selectors.html#module-selectors" title="selectors: High-level I/O multiplexing."><code class="xref py py-mod docutils literal notranslate"><span class="pre">selectors</span></code></a> 模块（作为 <span class="target" id="index-151"></span><a class="pep reference external" href="https://peps.python.org/pep-3156/"><strong>PEP 3156</strong></a> 实现的一部分被创建）允许高层级且高效的 I/O 多路复用，它是在 <a class="reference internal" href="../library/select.html#module-select" title="select: Wait for I/O completion on multiple streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">select</span></code></a> 模块的基础上构建的。</p>
</section>
<section id="statistics">
<span id="whatsnew-statistics"></span><h3 class="translated">statistics<a class="headerlink" href="#statistics" title="Link to this heading">¶</a></h3>
<p class="translated">新增的 <a class="reference internal" href="../library/statistics.html#module-statistics" title="statistics: Mathematical statistics functions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">statistics</span></code></a> 模块（在 <span class="target" id="index-152"></span><a class="pep reference external" href="https://peps.python.org/pep-0450/"><strong>PEP 450</strong></a> 中定义）直接在标准库中提供了一些核心统计功能。 该模块支持计算数据系列的平均值、中位数、模式、方差和标准差等。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-153"></span><a class="pep reference external" href="https://peps.python.org/pep-0450/"><strong>PEP 450</strong></a> -- 为标准库增加 statistics 模块</dt><dd><p class="translated">PEP 由 Steven D'Aprano 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="tracemalloc">
<span id="whatsnew-tracemalloc"></span><h3 class="translated">tracemalloc<a class="headerlink" href="#tracemalloc" title="Link to this heading">¶</a></h3>
<p class="translated">新增的 <a class="reference internal" href="../library/tracemalloc.html#module-tracemalloc" title="tracemalloc: Trace memory allocations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tracemalloc</span></code></a> 模块（在 <span class="target" id="index-154"></span><a class="pep reference external" href="https://peps.python.org/pep-0454/"><strong>PEP 454</strong></a> 中定义）是用于追踪由 Python 所分配的内存块的调试工具。 它提供了以下信息：</p>
<ul class="simple">
<li><p class="translated">追踪对象被分配所在的位置</p></li>
<li><p class="translated">按文件、按行统计python的内存块分配情况: 总大小、块的数量以及块平均大小。</p></li>
<li><p class="translated">对比两个内存快照的差异，以便排查内存泄漏</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-155"></span><a class="pep reference external" href="https://peps.python.org/pep-0454/"><strong>PEP 454</strong></a> -- 新增 tracemalloc 模块用于追踪 Python 内存分配</dt><dd><p class="translated">PEP 由 Victor Stinner 撰写并实现</p>
</dd>
</dl>
</div>
</section>
</section>
<section id="improved-modules">
<h2 class="translated">改进的模块<a class="headerlink" href="#improved-modules" title="Link to this heading">¶</a></h2>
<section id="abc">
<h3 class="translated">abc<a class="headerlink" href="#abc" title="Link to this heading">¶</a></h3>
<p class="translated">新增的函数 <a class="reference internal" href="../library/abc.html#abc.get_cache_token" title="abc.get_cache_token"><code class="xref py py-func docutils literal notranslate"><span class="pre">abc.get_cache_token()</span></code></a> 可被用来获知何时使得受到对象图改变影响的缓存失效。 （由 Łukasz Langa 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16832">bpo-16832</a> 中贡献。）</p>
<p class="translated">新增的类型 <a class="reference internal" href="../library/abc.html#abc.ABC" title="abc.ABC"><code class="xref py py-class docutils literal notranslate"><span class="pre">ABC</span></code></a> 以 <a class="reference internal" href="../library/abc.html#abc.ABCMeta" title="abc.ABCMeta"><code class="xref py py-class docutils literal notranslate"><span class="pre">ABCMeta</span></code></a> 作为其元类。 使用 <code class="docutils literal notranslate"><span class="pre">ABC</span></code> 作为基类的效果实际上相当于指定 <code class="docutils literal notranslate"><span class="pre">metaclass=abc.ABCMeta</span></code>，但其写法更简单也更易读。 （由 Bruno Dupuis 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16049">bpo-16049</a> 中贡献。）</p>
</section>
<section id="aifc">
<h3 class="translated">aifc<a class="headerlink" href="#aifc" title="Link to this heading">¶</a></h3>
<p class="translated">现在 <code class="xref py py-meth docutils literal notranslate"><span class="pre">getparams()</span></code> 方法将返回一个具名元组而不是普通元组。 （由 Claudiu Popa 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=17818">bpo-17818</a> 中贡献。）</p>
<p class="translated">现在 <code class="xref py py-func docutils literal notranslate"><span class="pre">aifc.open()</span></code> 已支持上下文管理协议：当在 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 代码块中使用时，所返回对象的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code> 方法将在代码块结束时被自动调用。 （由 Serhiy Storchacha 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16486">bpo-16486</a> 中贡献。）</p>
<p class="translated">现在 <code class="xref py py-meth docutils literal notranslate"><span class="pre">writeframesraw()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">writeframes()</span></code> 方法将接受任意 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>。 （由 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=8311">bpo-8311</a> 中贡献。）</p>
</section>
<section id="argparse">
<h3 class="translated">argparse<a class="headerlink" href="#argparse" title="Link to this heading">¶</a></h3>
<p class="translated">现在 <a class="reference internal" href="../library/argparse.html#argparse.FileType" title="argparse.FileType"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileType</span></code></a> 类可接受 <em>encoding</em> 和 <em>errors</em> 参数，它们将被传递给 <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>。 （由 Lucas Maystre 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=11175">bpo-11175</a> 中贡献。）</p>
</section>
<section id="audioop">
<h3 class="translated">audioop<a class="headerlink" href="#audioop" title="Link to this heading">¶</a></h3>
<p class="translated">现在 <code class="xref py py-mod docutils literal notranslate"><span class="pre">audioop</span></code> 可支持 24 位采样。 （由 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=12866">bpo-12866</a> 中贡献。）</p>
<p class="translated">新增的 <code class="xref py py-func docutils literal notranslate"><span class="pre">byteswap()</span></code> 函数可将大端序样本转换为小端序，并可反向转换。 （由 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19641">bpo-19641</a> 中贡献。）.)</p>
<p class="translated">所有 <code class="xref py py-mod docutils literal notranslate"><span class="pre">audioop</span></code> 函数现在可接受任意 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>。 字符串将不被接受：它们在之前也不可用，现在它们将立即引发错误。 （由 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16685">bpo-16685</a> 中贡献。）</p>
</section>
<section id="base64">
<h3 class="translated">base64<a class="headerlink" href="#base64" title="Link to this heading">¶</a></h3>
<p class="translated">现在 <a class="reference internal" href="../library/base64.html#module-base64" title="base64: RFC 4648: Base16, Base32, Base64 Data Encodings; Base85 and Ascii85"><code class="xref py py-mod docutils literal notranslate"><span class="pre">base64</span></code></a> 中的编码和解码函数在之前需要 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 或 <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 实例的场合下均接受任意 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>。 （由 Nick Coghlan 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=17839">bpo-17839</a> 中贡献。）</p>
<p class="translated">新增的函数 <a class="reference internal" href="../library/base64.html#base64.a85encode" title="base64.a85encode"><code class="xref py py-func docutils literal notranslate"><span class="pre">a85encode()</span></code></a>, <a class="reference internal" href="../library/base64.html#base64.a85decode" title="base64.a85decode"><code class="xref py py-func docutils literal notranslate"><span class="pre">a85decode()</span></code></a>, <a class="reference internal" href="../library/base64.html#base64.b85encode" title="base64.b85encode"><code class="xref py py-func docutils literal notranslate"><span class="pre">b85encode()</span></code></a> 以及 <a class="reference internal" href="../library/base64.html#base64.b85decode" title="base64.b85decode"><code class="xref py py-func docutils literal notranslate"><span class="pre">b85decode()</span></code></a> 分别提供针对 <code class="docutils literal notranslate"><span class="pre">Ascii85</span></code> 以及 git/mercurial <code class="docutils literal notranslate"><span class="pre">Base85</span></code> 格式的二进制数据进行编码和解码的能力。 <code class="docutils literal notranslate"><span class="pre">a85</span></code> 函数具有可被用于使其与 <code class="docutils literal notranslate"><span class="pre">Ascii85</span></code> 编码格式的变种，包括 Adobe 变种相互兼容的选项。 （由 Martin Morrison, Mercurial 项目, Serhiy Storchaka 和 Antoine Pitrou 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=17618">bpo-17618</a> 中贡献。）</p>
</section>
<section id="collections">
<h3 class="translated">collections<a class="headerlink" href="#collections" title="Link to this heading">¶</a></h3>
<p class="translated">现在 <a class="reference internal" href="../library/collections.html#collections.ChainMap.new_child" title="collections.ChainMap.new_child"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ChainMap.new_child()</span></code></a> 方法接受一个 <em>m</em> 参数用于指定要向链结构中添加的子映射表。 这允许将现有的映射和/或自定义映射类型用于子映射表。 （由 Vinay Sajip 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16613">bpo-16613</a> 中贡献。）</p>
</section>
<section id="colorsys">
<h3 class="translated">colorsys<a class="headerlink" href="#colorsys" title="Link to this heading">¶</a></h3>
<p class="translated">用于 RGB --- YIQ 转换系数的数码位数已被扩展以使其与 FCC NTSC 版本匹配。 结果中的变化应当少于 1% 并可与在其他地方找到的结果更好地匹配。 （由 Brian Landers 和 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=14323">bpo-14323</a> 中贡献。）</p>
</section>
<section id="contextlib">
<h3 class="translated">contextlib<a class="headerlink" href="#contextlib" title="Link to this heading">¶</a></h3>
<p class="translated">新增的 <a class="reference internal" href="../library/contextlib.html#contextlib.suppress" title="contextlib.suppress"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextlib.suppress</span></code></a> 上下文管理器可以帮助澄清故意抑制来自单条语句的异常的代码的意图。 （由 Raymond Hettinger 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=15806">bpo-15806</a> 和 Zero Piraeus 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19266">bpo-19266</a> 中贡献。）</p>
<p class="translated">新增的 <a class="reference internal" href="../library/contextlib.html#contextlib.redirect_stdout" title="contextlib.redirect_stdout"><code class="xref py py-func docutils literal notranslate"><span class="pre">contextlib.redirect_stdout()</span></code></a> 上下文管理器使得工具脚本能更容易地处理将输出写入 <a class="reference internal" href="../library/sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout</span></code></a> 并且不提供任何重定向选项的不灵活 API。  使用该上下文管理器，可以将 <a class="reference internal" href="../library/sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout</span></code></a> 的输出重定向到任何其他流，或者配合使用 <a class="reference internal" href="../library/io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.StringIO</span></code></a> 来重定向到字符串。 后一种方式有时会特别有用，例如写入函数的输出来实现 命令行接口。 由于它会影响 <a class="reference internal" href="../library/sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout</span></code></a> 的全局状态因此只推荐用于工具脚本。 （由 Raymond Hettinger 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=15805">bpo-15805</a> 中贡献。）</p>
<p class="translated"><a class="reference internal" href="../library/contextlib.html#module-contextlib" title="contextlib: Utilities for with-statement contexts."><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextlib</span></code></a> 文档也已获得更新以包括有关仅单用、可重用与可重入上下文管理器之间的区别的 <a class="reference internal" href="../library/contextlib.html#single-use-reusable-and-reentrant-cms"><span class="std std-ref">讨论</span></a>。</p>
</section>
<section id="dbm">
<h3 class="translated">dbm<a class="headerlink" href="#dbm" title="Link to this heading">¶</a></h3>
<p class="translated">现在 <a class="reference internal" href="../library/dbm.html#dbm.open" title="dbm.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">dbm.open()</span></code></a> 对象已支持上下文管理器协议。 当在 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 语句中使用时，数据库对象的 <code class="docutils literal notranslate"><span class="pre">close</span></code> 方法将在代码块结束时被自动调用。 （由 Claudiu Popa 和 Nick Coghlan 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19282">bpo-19282</a> 中贡献。）</p>
</section>
<section id="dis">
<h3 class="translated">dis<a class="headerlink" href="#dis" title="Link to this heading">¶</a></h3>
<p class="translated">现在 <a class="reference internal" href="../library/dis.html#dis.show_code" title="dis.show_code"><code class="xref py py-func docutils literal notranslate"><span class="pre">show_code()</span></code></a>, <a class="reference internal" href="../library/dis.html#dis.dis" title="dis.dis"><code class="xref py py-func docutils literal notranslate"><span class="pre">dis()</span></code></a>, <a class="reference internal" href="../library/dis.html#dis.distb" title="dis.distb"><code class="xref py py-func docutils literal notranslate"><span class="pre">distb()</span></code></a> 和 <a class="reference internal" href="../library/dis.html#dis.disassemble" title="dis.disassemble"><code class="xref py py-func docutils literal notranslate"><span class="pre">disassemble()</span></code></a> 等函数可接受仅限关键字参数 <em>file</em> 来控制其输出的写入目标。</p>
<p class="translated">现在 <a class="reference internal" href="../library/dis.html#module-dis" title="dis: Disassembler for Python bytecode."><code class="xref py py-mod docutils literal notranslate"><span class="pre">dis</span></code></a> 模块是围绕 <a class="reference internal" href="../library/dis.html#dis.Instruction" title="dis.Instruction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Instruction</span></code></a> 类来构建的，该类以面向对象的访问方式提供对于每个单独字节码操作的细节。</p>
<p class="translated">新增的方法 <a class="reference internal" href="../library/dis.html#dis.get_instructions" title="dis.get_instructions"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_instructions()</span></code></a> 提供了一个为给定 Python 代码段产生 Instruction 流的迭代器。 这使得现在可以编写以不同于由 <a class="reference internal" href="../library/dis.html#module-dis" title="dis: Disassembler for Python bytecode."><code class="xref py py-mod docutils literal notranslate"><span class="pre">dis</span></code></a> 模块本身所提供的方式检查和操纵字节码对象的程序。 例如:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">dis</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">instr</span> <span class="ow">in</span> <span class="n">dis</span><span class="o">.</span><span class="n">get_instructions</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">opname</span><span class="p">)</span>
<span class="go">LOAD_FAST</span>
<span class="go">LOAD_CONST</span>
<span class="go">BINARY_ADD</span>
<span class="go">RETURN_VALUE</span>
</pre></div>
</div>
<p class="translated"><a class="reference internal" href="../library/dis.html#module-dis" title="dis: Disassembler for Python bytecode."><code class="xref py py-mod docutils literal notranslate"><span class="pre">dis</span></code></a> 模块中的各种显示工具已被重新编写以使用这些新组件。</p>
<p class="translated">此外，新增的对应用程序友好的类 <a class="reference internal" href="../library/dis.html#dis.Bytecode" title="dis.Bytecode"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bytecode</span></code></a> 提供了一个面向对象的 API 用于以人类可读的形式检查字节码并对指令进行迭代。 <a class="reference internal" href="../library/dis.html#dis.Bytecode" title="dis.Bytecode"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bytecode</span></code></a> 构造器接受与 <a class="reference internal" href="../library/dis.html#dis.get_instructions" title="dis.get_instructions"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_instructions()</span></code></a> 相同的参数（外加一个可选的 <em>current_offset</em> 参数），其结果对象可被迭代以产生 <a class="reference internal" href="../library/dis.html#dis.Instruction" title="dis.Instruction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Instruction</span></code></a> 对象。 但它还有一个 <a class="reference internal" href="../library/dis.html#dis.Bytecode.dis" title="dis.Bytecode.dis"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dis</span></code></a> 方法，相当于在构造器参数上调用 <a class="reference internal" href="../library/dis.html#dis.dis" title="dis.dis"><code class="xref py py-mod docutils literal notranslate"><span class="pre">dis</span></code></a>，但是返回一个多行字符串:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bytecode</span> <span class="o">=</span> <span class="n">dis</span><span class="o">.</span><span class="n">Bytecode</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">current_offset</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">instr</span> <span class="ow">in</span> <span class="n">bytecode</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> (</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">opname</span><span class="p">,</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span><span class="p">))</span>
<span class="go">LOAD_FAST (124)</span>
<span class="go">LOAD_CONST (100)</span>
<span class="go">BINARY_ADD (23)</span>
<span class="go">RETURN_VALUE (83)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bytecode</span><span class="o">.</span><span class="n">dis</span><span class="p">()</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
<span class="go">[&#39;  1           0 LOAD_FAST                0 (x)&#39;,</span>
<span class="go"> &#39;      --&gt;     3 LOAD_CONST               1 (1)&#39;,</span>
<span class="go"> &#39;              6 BINARY_ADD&#39;,</span>
<span class="go"> &#39;              7 RETURN_VALUE&#39;]</span>
</pre></div>
</div>
<p class="translated"><a class="reference internal" href="../library/dis.html#dis.Bytecode" title="dis.Bytecode"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bytecode</span></code></a> 还有一个类方法 <a class="reference internal" href="../library/dis.html#dis.Bytecode.from_traceback" title="dis.Bytecode.from_traceback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_traceback()</span></code></a>，它提供了操纵回溯对象的能力（也就是说，<code class="docutils literal notranslate"><span class="pre">print(Bytecode.from_traceback(tb).dis())</span></code> 等价于 <code class="docutils literal notranslate"><span class="pre">distb(tb)</span></code>。）</p>
<p class="translated">（由 Nick Coghlan, Ryan Kelly 和 Thomas Kluyver 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=11816">bpo-11816</a> 并由 Claudiu Popa 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=17916">bpo-17916</a> 中贡献。）</p>
<p class="translated">新增的函数 <a class="reference internal" href="../library/dis.html#dis.stack_effect" title="dis.stack_effect"><code class="xref py py-func docutils literal notranslate"><span class="pre">stack_effect()</span></code></a> 可在给定操作码和参数的 Python 栈上计算其效果，相关信息是无法以其他方式获得的。 （由 Larry Hastings 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19722">bpo-19722</a> 中贡献。）</p>
</section>
<section id="doctest">
<h3 class="translated">doctest<a class="headerlink" href="#doctest" title="Link to this heading">¶</a></h3>
<p class="translated">新增的 <a class="reference internal" href="../library/doctest.html#doctest-options"><span class="std std-ref">选项旗标</span></a> <a class="reference internal" href="../library/doctest.html#doctest.FAIL_FAST" title="doctest.FAIL_FAST"><code class="xref py py-const docutils literal notranslate"><span class="pre">FAIL_FAST</span></code></a> 将在检测到首次失败时暂停测试运行。 （由 R. David Murray 和 Daniel Urban 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16522">bpo-16522</a> 中贡献。）</p>
<p class="translated">现在 <a class="reference internal" href="../library/doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> 的命令行接口使用 <a class="reference internal" href="../library/argparse.html#module-argparse" title="argparse: Command-line option and argument parsing library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">argparse</span></code></a>，并新增了两个选项 <code class="docutils literal notranslate"><span class="pre">-o</span></code> 和 <code class="docutils literal notranslate"><span class="pre">-f</span></code>。 <code class="docutils literal notranslate"><span class="pre">-o</span></code> 允许在命令行中指定 <a class="reference internal" href="../library/doctest.html#doctest-options"><span class="std std-ref">doctest 选项</span></a>，而 <code class="docutils literal notranslate"><span class="pre">-f</span></code> 是 <code class="docutils literal notranslate"><span class="pre">-o</span> <span class="pre">FAIL_FAST</span></code> 的简写形式（与 <a class="reference internal" href="../library/unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> CLI 所支持的类似选项相对应）。 （由 R. David Murray 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=11390">bpo-11390</a> 中贡献。）</p>
<p class="translated">现在 <a class="reference internal" href="../library/doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> 会在扩展模块的 <code class="docutils literal notranslate"><span class="pre">__doc__</span></code> 字符串中查找文档测试。 （由 Zachary Ware 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=3158">bpo-3158</a> 中贡献。）</p>
</section>
<section id="email">
<h3 class="translated">email<a class="headerlink" href="#email" title="Link to this heading">¶</a></h3>
<p class="translated">现在 <a class="reference internal" href="../library/email.compat32-message.html#email.message.Message.as_string" title="email.message.Message.as_string"><code class="xref py py-meth docutils literal notranslate"><span class="pre">as_string()</span></code></a> 接受一个 <em>policy</em> 参数用于在生成其字符串表示形式时重写默认的消息策略。 这意味着 <code class="docutils literal notranslate"><span class="pre">as_string</span></code> 现在可以在更多情况下被使用，而不必创建和使用 <a class="reference internal" href="../library/email.generator.html#module-email.generator" title="email.generator: Generate flat text email messages from a message structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">generator</span></code></a> 来将已格式化的形参传递给其 <code class="docutils literal notranslate"><span class="pre">flatten</span></code> 方法。 （由 R. David Murray 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18600">bpo-18600</a> 中贡献。）</p>
<p class="translated">新增方法 <a class="reference internal" href="../library/email.compat32-message.html#email.message.Message.as_bytes" title="email.message.Message.as_bytes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">as_bytes()</span></code></a> 用于产生消息的与 <code class="docutils literal notranslate"><span class="pre">as_string</span></code> 所产生的字符串表示形式类似的字节串表示形式。 它不接受 <em>maxheaderlen</em> 参数，但接受 <em>unixfrom</em> 和 <em>policy</em> 参数。 <a class="reference internal" href="../library/email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 的 <a class="reference internal" href="../library/email.compat32-message.html#email.message.Message.__bytes__" title="email.message.Message.__bytes__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__bytes__()</span></code></a> 方法将调用它，这意味着现在 <code class="docutils literal notranslate"><span class="pre">bytes(mymsg)</span></code> 将产生直观的结果：一个包含完整已格式化消息的字节串对象。 （由 R. David Murray 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18600">bpo-18600</a> 中贡献。）</p>
<p class="translated">现在 <a class="reference internal" href="../library/email.compat32-message.html#email.message.Message.set_param" title="email.message.Message.set_param"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Message.set_param()</span></code></a> 消息接受一个 <em>replace</em> 关键字参数。 当指定该参数时，关联的标头将被更新而不会修改其在标头列表中的位置。 为了保持向下兼容，该参数默认值为 <code class="docutils literal notranslate"><span class="pre">False</span></code>。 （由 R. David Murray 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18891">bpo-18891</a> 中贡献。）</p>
<p class="translated" id="whatsnew-email-contentmanager">新增了一对 <a class="reference internal" href="../library/email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 的子类 (<a class="reference internal" href="../library/email.message.html#email.message.EmailMessage" title="email.message.EmailMessage"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailMessage</span></code></a> 和 <a class="reference internal" href="../library/email.message.html#email.message.MIMEPart" title="email.message.MIMEPart"><code class="xref py py-class docutils literal notranslate"><span class="pre">MIMEPart</span></code></a>)，以及新的子模块 <a class="reference internal" href="../library/email.contentmanager.html#module-email.contentmanager" title="email.contentmanager: Storing and Retrieving Content from MIME Parts"><code class="xref py py-mod docutils literal notranslate"><span class="pre">contentmanager</span></code></a> 和新的 <a class="reference internal" href="../library/email.policy.html#module-email.policy" title="email.policy: Controlling the parsing and generating of messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">policy</span></code></a> 属性 <a class="reference internal" href="../library/email.policy.html#email.policy.EmailPolicy.content_manager" title="email.policy.EmailPolicy.content_manager"><code class="xref py py-attr docutils literal notranslate"><span class="pre">content_manager</span></code></a>。 所有文档目前都在新模块中，它是作为 email 的新 <a class="reference internal" href="../glossary.html#term-provisional-API"><span class="xref std std-term">provisional API</span></a> 的一部分添加的。 这些类提供了多个使从内容提取邮件消息和插入内容到消息更容易的新方法。 相关细节，请参阅 <a class="reference internal" href="../library/email.contentmanager.html#module-email.contentmanager" title="email.contentmanager: Storing and Retrieving Content from MIME Parts"><code class="xref py py-mod docutils literal notranslate"><span class="pre">contentmanager</span></code></a> 文档和 <a class="reference internal" href="../library/email.examples.html#email-examples"><span class="std std-ref">email: 示例</span></a>。 这些 API 的加入完成了作为 email6 项目计划组成部分的大部分工作。 目前的暂定 API 计划在 Python 3.5 最终确定 (可能在错误处理方面再增加少量内容)。 （由 R. David Murray 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18891">bpo-18891</a> 中贡献。）</p>
</section>
<section id="filecmp">
<h3 class="translated">filecmp<a class="headerlink" href="#filecmp" title="Link to this heading">¶</a></h3>
<p class="translated">新增的 <a class="reference internal" href="../library/filecmp.html#filecmp.clear_cache" title="filecmp.clear_cache"><code class="xref py py-func docutils literal notranslate"><span class="pre">clear_cache()</span></code></a> 函数提供了清除 <a class="reference internal" href="../library/filecmp.html#module-filecmp" title="filecmp: Compare files efficiently."><code class="xref py py-mod docutils literal notranslate"><span class="pre">filecmp</span></code></a> 比较缓存的功能，它使用 <a class="reference internal" href="../library/os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.stat()</span></code></a> 信息来确定文件自上次比较后是否发生了更改。 例如，如果文件被修改和重新检查的时间短于特定文件系统文件修改时间的精度就可使用这一功能。 （由 Mark Levitt 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18149">bpo-18149</a> 中贡献。）</p>
<p class="translated">新增的模块属性 <a class="reference internal" href="../library/filecmp.html#filecmp.DEFAULT_IGNORES" title="filecmp.DEFAULT_IGNORES"><code class="xref py py-const docutils literal notranslate"><span class="pre">DEFAULT_IGNORES</span></code></a> 提供了作为 <a class="reference internal" href="../library/filecmp.html#filecmp.dircmp" title="filecmp.dircmp"><code class="xref py py-func docutils literal notranslate"><span class="pre">dircmp()</span></code></a> 函数的 <em>ignore</em> 形参默认值的目录列表。 （由 Eli Bendersky 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=15442">bpo-15442</a> 中贡献。）</p>
</section>
<section id="functools">
<h3 class="translated">functools<a class="headerlink" href="#functools" title="Link to this heading">¶</a></h3>
<p class="translated">新增的 <a class="reference internal" href="../library/functools.html#functools.partialmethod" title="functools.partialmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">partialmethod()</span></code></a> 描述器提供了对描述器的部分参数应用，就像 <a class="reference internal" href="../library/functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">partial()</span></code></a> 为普通可调用对象提供的一样。 新的描述器还可以让任意可调用对象 （包括 <a class="reference internal" href="../library/functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">partial()</span></code></a> 实例）在包括在类定义中时表现得像普通的实例方法一样。 （由 Alon Horev 和 Nick Coghlan 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4331">bpo-4331</a> 中贡献。）</p>
<p class="translated" id="whatsnew-singledispatch">新增的 <a class="reference internal" href="../library/functools.html#functools.singledispatch" title="functools.singledispatch"><code class="xref py py-func docutils literal notranslate"><span class="pre">singledispatch()</span></code></a> 装饰器为 Python 标准库带来了对单分派泛型函数的支持。 面向对象编程侧重于将对一组共同数据的多种操作组合到一个类中，而泛型函数则侧重于将一种操作的多个实现组合在一起使其能够处理 <em>不同</em> 种类的数据。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-156"></span><a class="pep reference external" href="https://peps.python.org/pep-0443/"><strong>PEP 443</strong></a> -- 单分派泛型函数</dt><dd><p class="translated">PEP 由 Łukasz Langa 撰写并实现。</p>
</dd>
</dl>
</div>
<p class="translated">现在 <a class="reference internal" href="../library/functools.html#functools.total_ordering" title="functools.total_ordering"><code class="xref py py-func docutils literal notranslate"><span class="pre">total_ordering()</span></code></a> 支持从下层的比较函数返回 <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a> 作为返回值。 （由 Katie Miller 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=10042">bpo-10042</a> 中贡献。）</p>
<p class="translated">现在标准库中增加了 <a class="reference internal" href="../library/functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">partial()</span></code></a> 函数的纯 Python 版本；在 CPython 中它会被 C 加速版本覆盖，但它以供其他实现来使用。 （由 Brian Thorne 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=12428">bpo-12428</a> 中贡献。）</p>
</section>
<section id="gc">
<h3 class="translated">gc<a class="headerlink" href="#gc" title="Link to this heading">¶</a></h3>
<p class="translated">新增的函数 <a class="reference internal" href="../library/gc.html#gc.get_stats" title="gc.get_stats"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_stats()</span></code></a> 可返回由三个单独生成字典组成的列表，每个字典均包含自解释器启动以来收集的统计信息。 （由 Antoine Pitrou 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16351">bpo-16351</a> 中贡献。）</p>
</section>
<section id="glob">
<h3 class="translated">glob<a class="headerlink" href="#glob" title="Link to this heading">¶</a></h3>
<p class="translated">新增函数 <a class="reference internal" href="../library/glob.html#glob.escape" title="glob.escape"><code class="xref py py-func docutils literal notranslate"><span class="pre">escape()</span></code></a> 提供了为文件名中的特殊字符进行转义的方式以使它们不会成为 glob 扩展的组成部分而是按字面值来匹配。 （由 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=8402">bpo-8402</a> 中贡献。）</p>
</section>
<section id="hashlib">
<h3 class="translated">hashlib<a class="headerlink" href="#hashlib" title="Link to this heading">¶</a></h3>
<p class="translated">新增的 <a class="reference internal" href="../library/hashlib.html#hashlib.pbkdf2_hmac" title="hashlib.pbkdf2_hmac"><code class="xref py py-func docutils literal notranslate"><span class="pre">hashlib.pbkdf2_hmac()</span></code></a> 函数提供了 <a class="reference external" href="https://en.wikipedia.org/wiki/PBKDF2">PKCS#5 基于口令的密钥派生函数 2</a>。 （由 Christian Heimes 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18582">bpo-18582</a> 中贡献。）</p>
<p class="translated">现在 <a class="reference internal" href="../library/hashlib.html#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code class="xref py py-mod docutils literal notranslate"><span class="pre">hashlib</span></code></a> 哈希对象的 <a class="reference internal" href="../library/hashlib.html#hashlib.hash.name" title="hashlib.hash.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code></a> 属性已成为受正式支持的接口。 它一直存在于 CPython 的 <a class="reference internal" href="../library/hashlib.html#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code class="xref py py-mod docutils literal notranslate"><span class="pre">hashlib</span></code></a> 中（尽管它没有返回所有受支持的哈希算法的小写名称），但它不是一个公开的接口因此其他一些 Python 实现以前并不支持它。 （由 Jason R. Coombs 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18532">bpo-18532</a> 中提供。）</p>
</section>
<section id="hmac">
<h3 class="translated">hmac<a class="headerlink" href="#hmac" title="Link to this heading">¶</a></h3>
<p class="translated">现在 <a class="reference internal" href="../library/hmac.html#module-hmac" title="hmac: Keyed-Hashing for Message Authentication (HMAC) implementation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">hmac</span></code></a> 可接受 <code class="docutils literal notranslate"><span class="pre">bytearray</span></code> 和 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 作为传给 <a class="reference internal" href="../library/hmac.html#hmac.new" title="hmac.new"><code class="xref py py-func docutils literal notranslate"><span class="pre">new()</span></code></a> 函数的 <em>key</em> 参数，而传给 <a class="reference internal" href="../library/hmac.html#hmac.new" title="hmac.new"><code class="xref py py-func docutils literal notranslate"><span class="pre">new()</span></code></a> 函数和 <a class="reference internal" href="../library/hmac.html#hmac.HMAC.update" title="hmac.HMAC.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code></a> 方法的 <em>msg</em> 形参现在可接受 <a class="reference internal" href="../library/hashlib.html#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code class="xref py py-mod docutils literal notranslate"><span class="pre">hashlib</span></code></a> 模块所支持的任何类型。 （由 Jonas Borgström 的 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18240">bpo-18240</a> 中贡献。）</p>
<p class="translated">传给 <a class="reference internal" href="../library/hmac.html#hmac.new" title="hmac.new"><code class="xref py py-func docutils literal notranslate"><span class="pre">hmac.new()</span></code></a> 函数的 <em>digestmod</em> 参数现在可以是 <a class="reference internal" href="../library/hashlib.html#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code class="xref py py-mod docutils literal notranslate"><span class="pre">hashlib</span></code></a> 能识别的任何哈希摘要名称。 此外，当前将 <em>digestmod</em> 默认值设为 <code class="docutils literal notranslate"><span class="pre">MD5</span></code> 的行为已被弃用：在未来的 Python 版本中将没有默认值。 （由 Christian Heimes 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=17276">bpo-17276</a> 中贡献。）</p>
<p class="translated">由于增加了 <a class="reference internal" href="../library/hmac.html#hmac.HMAC.block_size" title="hmac.HMAC.block_size"><code class="xref py py-attr docutils literal notranslate"><span class="pre">block_size</span></code></a> 和 <a class="reference internal" href="../library/hmac.html#hmac.HMAC.name" title="hmac.HMAC.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code></a> 属性 （以及 <a class="reference internal" href="../library/hmac.html#hmac.HMAC.digest_size" title="hmac.HMAC.digest_size"><code class="xref py py-attr docutils literal notranslate"><span class="pre">digest_size</span></code></a> 属性的正式文档），<a class="reference internal" href="../library/hmac.html#module-hmac" title="hmac: Keyed-Hashing for Message Authentication (HMAC) implementation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">hmac</span></code></a> 模块现在已完全符合 <span class="target" id="index-157"></span><a class="pep reference external" href="https://peps.python.org/pep-0247/"><strong>PEP 247</strong></a> API。 （由 Christian Heimes 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18775">bpo-18775</a> 中贡献。）</p>
</section>
<section id="html">
<h3 class="translated">html<a class="headerlink" href="#html" title="Link to this heading">¶</a></h3>
<p class="translated">新增的函数 <a class="reference internal" href="../library/html.html#html.unescape" title="html.unescape"><code class="xref py py-func docutils literal notranslate"><span class="pre">unescape()</span></code></a> 用于将 HTML5 字符引用转换为相应的 Unicode 字符。 （由 Ezio Melotti 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2927">bpo-2927</a> 中贡献。）.)</p>
<p class="translated"><a class="reference internal" href="../library/html.parser.html#html.parser.HTMLParser" title="html.parser.HTMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTMLParser</span></code></a> 接受新的关键字参数 <em>convert_charrefs</em>，当其为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 时，会自动转换所有字符引用。 为了保持向下兼容，其值默认为 <code class="docutils literal notranslate"><span class="pre">False</span></code>，但在未来的 Python 版本中将改为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，因此建议你显式地设置它并更新代码以使用这个新特性。 （由 Ezio Melotti 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=13633">bpo-13633</a> 中贡献。）</p>
<p class="translated">现在 <a class="reference internal" href="../library/html.parser.html#html.parser.HTMLParser" title="html.parser.HTMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTMLParser</span></code></a> 的 <em>strict</em> 参数已被弃用。 （由 Ezio Melotti 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=15114">bpo-15114</a> 中贡献。）</p>
</section>
<section id="http">
<h3 class="translated">http<a class="headerlink" href="#http" title="Link to this heading">¶</a></h3>
<p class="translated">现在 <a class="reference internal" href="../library/http.server.html#http.server.BaseHTTPRequestHandler.send_error" title="http.server.BaseHTTPRequestHandler.send_error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_error()</span></code></a> 接受可选的附加形参 <em>explain</em> 用于提供扩展的错误描述，覆盖可能存在的硬编码的默认值。 这个扩展的错误描述将使用 <a class="reference internal" href="../library/http.server.html#http.server.BaseHTTPRequestHandler.error_message_format" title="http.server.BaseHTTPRequestHandler.error_message_format"><code class="xref py py-attr docutils literal notranslate"><span class="pre">error_message_format</span></code></a> 属性进行格式化并作为错误响应体发送。 （由 Karl Cow 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=12921">bpo-12921</a> 中贡献。）</p>
<p class="translated">现在 <a class="reference internal" href="../library/http.server.html#module-http.server" title="http.server: HTTP server and request handlers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">http.server</span></code></a> <a class="reference internal" href="../library/http.server.html#http-server-cli"><span class="std std-ref">命令行界面</span></a> 增加了一个 <code class="docutils literal notranslate"><span class="pre">-b/--bind</span></code> 选项用于让服务器在指定的地址上进行监听。 （由 Malte Swart 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=17764">bpo-17764</a> 中贡献。）</p>
</section>
<section id="idlelib-and-idle">
<h3 class="translated">idlelib 与 IDLE<a class="headerlink" href="#idlelib-and-idle" title="Link to this heading">¶</a></h3>
<p class="translated">由于 idlelib 实现了 IDLE 命令行界面和编辑器且不应被其他程序导入，它将随每个发布版获得改进。 请参阅 <code class="file docutils literal notranslate"><span class="pre">Lib/idlelib/NEWS.txt</span></code> 查看 3.3.0 以来的累积变化列表，以及未来 3.4.x 发布版即将发生的变化。 此文件也可通过 IDLE <span class="menuselection">Help ‣ About IDLE</span> 对话框来查看。</p>
</section>
<section id="importlib">
<h3 class="translated">importlib<a class="headerlink" href="#importlib" title="Link to this heading">¶</a></h3>
<p class="translated"><a class="reference internal" href="../library/importlib.html#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">InspectLoader</span></code></a> ABC 定义了一个新方法 <a class="reference internal" href="../library/importlib.html#importlib.abc.InspectLoader.source_to_code" title="importlib.abc.InspectLoader.source_to_code"><code class="xref py py-meth docutils literal notranslate"><span class="pre">source_to_code()</span></code></a>，它接受源数据和一个路径并返回一个代码对象。 其默认实现等价于 <code class="docutils literal notranslate"><span class="pre">compile(data,</span> <span class="pre">path,</span> <span class="pre">'exec',</span> <span class="pre">dont_inherit=True)</span></code>。 （由 Eric Snow 和 Brett Cannon 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=15627">bpo-15627</a> 中贡献。）</p>
<p class="translated">现在 <a class="reference internal" href="../library/importlib.html#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">InspectLoader</span></code></a> 也具有 <a class="reference internal" href="../library/importlib.html#importlib.abc.InspectLoader.get_code" title="importlib.abc.InspectLoader.get_code"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_code()</span></code></a> 方法的默认实现。 不过，出于性能原因通常需要重写默认实现。 （由 Brett Cannon 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18072">bpo-18072</a> 中贡献。）</p>
<p class="translated">由于 <code class="xref py py-mod docutils literal notranslate"><span class="pre">imp</span></code> 模块被弃用 <a class="reference internal" href="../library/importlib.html#importlib.reload" title="importlib.reload"><code class="xref py py-func docutils literal notranslate"><span class="pre">reload()</span></code></a> 函数已从 <code class="xref py py-mod docutils literal notranslate"><span class="pre">imp</span></code> 移至 <a class="reference internal" href="../library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a>。 （由 Berker Peksag 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18193">bpo-18193</a> 中贡献。）</p>
<p class="translated">现在 <a class="reference internal" href="../library/importlib.html#module-importlib.util" title="importlib.util: Utility code for importers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.util</span></code></a> 有一个 <a class="reference internal" href="../library/importlib.html#importlib.util.MAGIC_NUMBER" title="importlib.util.MAGIC_NUMBER"><code class="xref py py-const docutils literal notranslate"><span class="pre">MAGIC_NUMBER</span></code></a> 属性提供对字节码版本号的访问。 该属性将取代已弃用的 <code class="xref py py-mod docutils literal notranslate"><span class="pre">imp</span></code> 模块中的 <code class="xref py py-func docutils literal notranslate"><span class="pre">get_magic()</span></code> 函数。 （由 Brett Cannon 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18192">bpo-18192</a> 中贡献。）</p>
<p class="translated">新增的 <a class="reference internal" href="../library/importlib.html#module-importlib.util" title="importlib.util: Utility code for importers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.util</span></code></a> 函数 <a class="reference internal" href="../library/importlib.html#importlib.util.cache_from_source" title="importlib.util.cache_from_source"><code class="xref py py-func docutils literal notranslate"><span class="pre">cache_from_source()</span></code></a> 和 <a class="reference internal" href="../library/importlib.html#importlib.util.source_from_cache" title="importlib.util.source_from_cache"><code class="xref py py-func docutils literal notranslate"><span class="pre">source_from_cache()</span></code></a> 替换了已弃用的 <code class="xref py py-mod docutils literal notranslate"><span class="pre">imp</span></code> 模块中的同名函数。 （由 Brett Cannon 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18194">bpo-18194</a> 中贡献。）</p>
<p class="translated">现在 <a class="reference internal" href="../library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a> 将以符合 <a class="reference internal" href="../library/importlib.html#importlib.abc.InspectLoader" title="importlib.abc.InspectLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">InspectLoader</span></code></a> ABC 的方式初始设置 <a class="reference internal" href="../library/importlib.html#importlib.machinery.NamespaceLoader" title="importlib.machinery.NamespaceLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">NamespaceLoader</span></code></a>，这意味着 <code class="docutils literal notranslate"><span class="pre">runpy</span> <span class="pre">``</span> <span class="pre">和</span> <span class="pre">``python</span> <span class="pre">-m</span></code> 现在可以与命名空间包一起使用。 （由 Brett Cannon 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18058">bpo-18058</a> 中贡献。）</p>
<p class="translated"><a class="reference internal" href="../library/importlib.html#module-importlib.util" title="importlib.util: Utility code for importers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.util</span></code></a> 中新增的函数 <a class="reference internal" href="../library/importlib.html#importlib.util.decode_source" title="importlib.util.decode_source"><code class="xref py py-func docutils literal notranslate"><span class="pre">decode_source()</span></code></a> 可使用通用换行处理方式从字节数据中解码源代码。 这适用于实现 <a class="reference internal" href="../library/importlib.html#importlib.abc.InspectLoader.get_source" title="importlib.abc.InspectLoader.get_source"><code class="xref py py-meth docutils literal notranslate"><span class="pre">InspectLoader.get_source()</span></code></a> 方法。</p>
<p class="translated">现在 <a class="reference internal" href="../library/importlib.html#importlib.machinery.ExtensionFileLoader" title="importlib.machinery.ExtensionFileLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.ExtensionFileLoader</span></code></a> 增加了 <a class="reference internal" href="../library/importlib.html#importlib.machinery.ExtensionFileLoader.get_filename" title="importlib.machinery.ExtensionFileLoader.get_filename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_filename()</span></code></a> 方法。 此方法在最初的实现中意外缺失。 （由 Eric Snow 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19152">bpo-19152</a> 中贡献。）</p>
</section>
<section id="inspect">
<h3 class="translated">inspect<a class="headerlink" href="#inspect" title="Link to this heading">¶</a></h3>
<p class="translated">现在 <a class="reference internal" href="../library/inspect.html#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect</span></code></a> 模块提供了一个基本的 <a class="reference internal" href="../library/inspect.html#inspect-module-cli"><span class="std std-ref">命令行界面</span></a> 用于快速显示模块、类和函数的源代码以及其他信息。 （由 Claudiu Popa 和 Nick Coghlan 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18626">bpo-18626</a> 中贡献。）</p>
<p class="translated"><a class="reference internal" href="../library/inspect.html#inspect.unwrap" title="inspect.unwrap"><code class="xref py py-func docutils literal notranslate"><span class="pre">unwrap()</span></code></a> 用于方便地解开由 <a class="reference internal" href="../library/functools.html#functools.wraps" title="functools.wraps"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.wraps()</span></code></a> (以及任何在包装器函数上设置 <code class="docutils literal notranslate"><span class="pre">__wrapped__</span></code> 属性的 API) 创建的包装器函数链。 （由 Daniel Urban, Aaron Iles 和 Nick Coghlan 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=13266">bpo-13266</a> 中贡献。）</p>
<p class="translated">作为新的 <a class="reference internal" href="../library/enum.html#module-enum" title="enum: Implementation of an enumeration class."><code class="xref py py-mod docutils literal notranslate"><span class="pre">enum</span></code></a> 模块实现的一部分，现在 <a class="reference internal" href="../library/inspect.html#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect</span></code></a> 模块通过元类为自定义 <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> 方法和动态类属性提供了更好的支持。 （由 Ethan Furman 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18929">bpo-18929</a> 和 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19030">bpo-19030</a> 中贡献。）</p>
<p class="translated">现在 <a class="reference internal" href="../library/inspect.html#inspect.getfullargspec" title="inspect.getfullargspec"><code class="xref py py-func docutils literal notranslate"><span class="pre">getfullargspec()</span></code></a> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">getargspec()</span></code> 将使用 <a class="reference internal" href="../library/inspect.html#inspect.signature" title="inspect.signature"><code class="xref py py-func docutils literal notranslate"><span class="pre">signature()</span></code></a> API。 这允许它们支持更多种类的可调用对象，包括具有 <code class="docutils literal notranslate"><span class="pre">__signature__</span></code> 属性的、具有通过 argument clinic 提供元数据的、<a class="reference internal" href="../library/functools.html#functools.partial" title="functools.partial"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a> 对象等等。 请注意，不同于 <a class="reference internal" href="../library/inspect.html#inspect.signature" title="inspect.signature"><code class="xref py py-func docutils literal notranslate"><span class="pre">signature()</span></code></a>，这些函数仍然会忽略 <code class="docutils literal notranslate"><span class="pre">__wrapped__</span></code> 属性，并会报告绑定方法已绑定的第一个参数，所以如果想要这些特性的话你仍然需要更新你的代码以直接使用 <a class="reference internal" href="../library/inspect.html#inspect.signature" title="inspect.signature"><code class="xref py py-func docutils literal notranslate"><span class="pre">signature()</span></code></a>。 （由 Yury Selivanov 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=17481">bpo-17481</a> 中贡献。）</p>
<p class="translated">现在 <a class="reference internal" href="../library/inspect.html#inspect.signature" title="inspect.signature"><code class="xref py py-func docutils literal notranslate"><span class="pre">signature()</span></code></a> 支持 CPython 函数的鸭子类型，它增加了对使用 Cython 编译的函数的支持。 （由 Stefan Behnel 和 Yury Selivanov 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=17159">bpo-17159</a> 中贡献。）</p>
</section>
<section id="ipaddress">
<h3 class="translated">ipaddress<a class="headerlink" href="#ipaddress" title="Link to this heading">¶</a></h3>
<p class="translated"><a class="reference internal" href="../library/ipaddress.html#module-ipaddress" title="ipaddress: IPv4/IPv6 manipulation library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ipaddress</span></code></a> 已在 Python 3.3 中作为 <a class="reference internal" href="../glossary.html#term-provisional-API"><span class="xref std std-term">provisional API</span></a> 被添加到标准库。 随着 Python 3.4 的发布，此限定已被移除：现在 <a class="reference internal" href="../library/ipaddress.html#module-ipaddress" title="ipaddress: IPv4/IPv6 manipulation library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ipaddress</span></code></a> 属于稳定 API，由常规的标准库需求所覆盖以维护向下兼容性。</p>
<p class="translated">如果一个地址是全局可路由的则新增的 <a class="reference internal" href="../library/ipaddress.html#ipaddress.IPv4Address.is_global" title="ipaddress.IPv4Address.is_global"><code class="xref py py-attr docutils literal notranslate"><span class="pre">is_global</span></code></a> 属性将为 <code class="docutils literal notranslate"><span class="pre">True</span></code>。 （由 Peter Moody 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=17400">bpo-17400</a> 中贡献。）</p>
</section>
<section id="logging">
<h3 class="translated">logging<a class="headerlink" href="#logging" title="Link to this heading">¶</a></h3>
<p class="translated"><a class="reference internal" href="../library/logging.handlers.html#logging.handlers.TimedRotatingFileHandler" title="logging.handlers.TimedRotatingFileHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimedRotatingFileHandler</span></code></a> 新增的 <em>atTime</em> 形参可被用于指定每日要执行日志文件轮转的时间。 （由 Ronald Oussoren 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=9556">bpo-9556</a> 中贡献。）</p>
<p class="translated">现在 <a class="reference internal" href="../library/logging.handlers.html#logging.handlers.SocketHandler" title="logging.handlers.SocketHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketHandler</span></code></a> 和 <a class="reference internal" href="../library/logging.handlers.html#logging.handlers.DatagramHandler" title="logging.handlers.DatagramHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">DatagramHandler</span></code></a> 已支持 Unix 域套接字 (通过将 <em>port</em> 设为 <code class="docutils literal notranslate"><span class="pre">None</span></code>)。 （由 Vinay Sajip 在 commit ce46195b56a9 中贡献。）</p>
<p class="translated">现在 <a class="reference internal" href="../library/logging.config.html#logging.config.fileConfig" title="logging.config.fileConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">fileConfig()</span></code></a> 接受一个 <a class="reference internal" href="../library/configparser.html#configparser.RawConfigParser" title="configparser.RawConfigParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">configparser.RawConfigParser</span></code></a> 子类实例作为 <em>fname</em> 形参。 这有助于在日志配置只是整体应用程序配置的一部分，或者在将配置传递给 <a class="reference internal" href="../library/logging.config.html#logging.config.fileConfig" title="logging.config.fileConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">fileConfig()</span></code></a> 之前对其进行了修改时使用配置文件。 （由 Vinay Sajip 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16110">bpo-16110</a> 中贡献。）</p>
<p class="translated">现在通过 <a class="reference internal" href="../library/logging.config.html#logging.config.listen" title="logging.config.listen"><code class="xref py py-func docutils literal notranslate"><span class="pre">logging.config.listen()</span></code></a> 函数从套接字接收的日志配置数据可以在处理前以将验证函数作为参数提供给新的 <em>verify</em> 关键字参数 的方式执行验证。 （由 Vinay Sajip 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=15452">bpo-15452</a> 中贡献。）</p>
</section>
<section id="marshal">
<span id="whatsnew-marshal-3"></span><h3 class="translated">marshal<a class="headerlink" href="#marshal" title="Link to this heading">¶</a></h3>
<p class="translated">默认的 <a class="reference internal" href="../library/marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">marshal</span></code></a> 版本已被提升至 3。 新版本的代码实现恢复了 Python2 行为即只记录内联字符串的一份副本并在反序列化时保留内联状态，并将此“一份副本”功能扩展到任何对象类型（包括处理递归引用）。 这既减少了 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> 文件的大小也减少了模块从 <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> (或 <code class="docutils literal notranslate"><span class="pre">.pyo</span></code>) 文件加载时占用的内存量。 （由 Kristján Valur Jónsson 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16475">bpo-16475</a> 中贡献，并由 Antoine Pitrou 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19219">bpo-19219</a> 中提供进一步的加速。）</p>
</section>
<section id="mmap">
<h3 class="translated">mmap<a class="headerlink" href="#mmap" title="Link to this heading">¶</a></h3>
<p class="translated">现在 mmap 对象将是 <a class="reference internal" href="../library/weakref.html#mod-weakref"><span class="std std-ref">可弱引用的</span></a>。 （由 Valerie Lambert 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4885">bpo-4885</a> 中贡献。）</p>
</section>
<section id="multiprocessing">
<h3 class="translated">multiprocessing<a class="headerlink" href="#multiprocessing" title="Link to this heading">¶</a></h3>
<p class="translated" id="whatsnew-multiprocessing-no-fork">在 Unix 上新增了两个 <a class="reference internal" href="../library/multiprocessing.html#multiprocessing-start-methods"><span class="std std-ref">启动方法</span></a> <code class="docutils literal notranslate"><span class="pre">spawn</span></code> 和 <code class="docutils literal notranslate"><span class="pre">forkserver</span></code> 可使用 <a class="reference internal" href="../library/multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> 来启动进程。 这两个方法使得进程和线程的混合更为健壮，并且 <code class="docutils literal notranslate"><span class="pre">spawn</span></code> 方法可以匹配 multiprocessing 在 Windows 上一直使用的语法。 新增的函数 <a class="reference internal" href="../library/multiprocessing.html#multiprocessing.get_all_start_methods" title="multiprocessing.get_all_start_methods"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_all_start_methods()</span></code></a> 可报告平台上可用的所有启动方法，<a class="reference internal" href="../library/multiprocessing.html#multiprocessing.get_start_method" title="multiprocessing.get_start_method"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_start_method()</span></code></a> 可报告当前的启动方法，而 <a class="reference internal" href="../library/multiprocessing.html#multiprocessing.set_start_method" title="multiprocessing.set_start_method"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_start_method()</span></code></a> 可设置启动方法。 （由 Richard Oudkerk 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=8713">bpo-8713</a> 中贡献。）</p>
<p class="translated">现在 <a class="reference internal" href="../library/multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> 还具有 <code class="docutils literal notranslate"><span class="pre">上下文</span></code> 的概念，它决定了子进程的创建方式。 新增的函数 <a class="reference internal" href="../library/multiprocessing.html#multiprocessing.get_context" title="multiprocessing.get_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_context()</span></code></a> 可返回一个使用指定启动方法的上下文。 它具有与 <a class="reference internal" href="../library/multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> 模块本身一致的 API，因此你可以使用它来创建 <a class="reference internal" href="../library/multiprocessing.html#multiprocessing.pool.Pool" title="multiprocessing.pool.Pool"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pool</span></code></a> 和其他在上下文中执行操作的对象。 这允许一个框架和某个应用程序或相同应用程序的不同部分使用多进程而不会彼此干扰。 （由 Richard Oudkerk 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18999">bpo-18999</a> 中贡献。）</p>
<p class="translated">除非是在使用旧的 <em>fork</em> 启动方法，子进程将不再从其父进程继承不需要的句柄/文件描述符 (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=8713">bpo-8713</a> 的一部分)。</p>
<p class="translated">现在当使用 <code class="docutils literal notranslate"><span class="pre">spawn</span></code> 或 <code class="docutils literal notranslate"><span class="pre">forkserver</span></code> 启动方法时 <a class="reference internal" href="../library/multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> 依赖于 <a class="reference internal" href="../library/runpy.html#module-runpy" title="runpy: Locate and run Python modules without importing them first."><code class="xref py py-mod docutils literal notranslate"><span class="pre">runpy</span></code></a> (它实现了 <code class="docutils literal notranslate"><span class="pre">-m</span></code> 开关) 在子进程中正确地初始化 <code class="docutils literal notranslate"><span class="pre">__main__</span></code>。 这解决了一些合并多进程操作中，<code class="docutils literal notranslate"><span class="pre">-m</span></code> 命令行开关和显式相对导入可能在子进程中导致失败的边缘场景问题。 （由 Nick Coghlan 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19946">bpo-19946</a> 中贡献。）</p>
</section>
<section id="operator">
<h3 class="translated">operator<a class="headerlink" href="#operator" title="Link to this heading">¶</a></h3>
<p class="translated">新增的函数 <a class="reference internal" href="../library/operator.html#operator.length_hint" title="operator.length_hint"><code class="xref py py-func docutils literal notranslate"><span class="pre">length_hint()</span></code></a> 提供了应当如何使用 <a class="reference internal" href="../reference/datamodel.html#object.__length_hint__" title="object.__length_hint__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__length_hint__()</span></code></a> 特殊方法的规范实现，作为该语言特性的 <span class="target" id="index-158"></span><a class="pep reference external" href="https://peps.python.org/pep-0424/"><strong>PEP 424</strong></a> 正式规范说明的一部分。 （由 Armin Ronacher 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16148">bpo-16148</a> 中贡献。）</p>
<p class="translated">现在提供了一个纯 Python 版本的 <a class="reference internal" href="../library/operator.html#module-operator" title="operator: Functions corresponding to the standard operators."><code class="xref py py-mod docutils literal notranslate"><span class="pre">operator</span></code></a> 模块，可用于参考并由 Python 的其他实现使用。 （由 Zachary Ware 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16694">bpo-16694</a> 中贡献。）</p>
</section>
<section id="os">
<h3 class="translated">os<a class="headerlink" href="#os" title="Link to this heading">¶</a></h3>
<p class="translated">新增一些函数用于获取和设置文件描述符或 Windows 句柄的 <a class="reference internal" href="../library/os.html#fd-inheritance"><span class="std std-ref">可继承旗标</span></a> (<a class="reference internal" href="../library/os.html#os.get_inheritable" title="os.get_inheritable"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.get_inheritable()</span></code></a>, <a class="reference internal" href="../library/os.html#os.set_inheritable" title="os.set_inheritable"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.set_inheritable()</span></code></a>) 或 (<a class="reference internal" href="../library/os.html#os.get_handle_inheritable" title="os.get_handle_inheritable"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.get_handle_inheritable()</span></code></a>, <a class="reference internal" href="../library/os.html#os.set_handle_inheritable" title="os.set_handle_inheritable"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.set_handle_inheritable()</span></code></a>)。</p>
<p class="translated">新增函数 <a class="reference internal" href="../library/os.html#os.cpu_count" title="os.cpu_count"><code class="xref py py-func docutils literal notranslate"><span class="pre">cpu_count()</span></code></a> 可报告 Python 运行所在平台上可用 CPU 的数量 (如果无法确定数量则为 <code class="docutils literal notranslate"><span class="pre">None</span></code>)。 现在 <a class="reference internal" href="../library/multiprocessing.html#multiprocessing.cpu_count" title="multiprocessing.cpu_count"><code class="xref py py-func docutils literal notranslate"><span class="pre">multiprocessing.cpu_count()</span></code></a> 函数是根据此函数实现的。 （由 Trent Nelson, Yogesh Chaudhari, Victor Stinner 和 Charles-François Natali 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=17914">bpo-17914</a> 中贡献。）</p>
<p class="translated">现在 <a class="reference internal" href="../library/os.path.html#os.path.samestat" title="os.path.samestat"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.path.samestat()</span></code></a> 将在 Windows 平台上可用（并且现在 <a class="reference internal" href="../library/os.path.html#os.path.samefile" title="os.path.samefile"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.path.samefile()</span></code></a> 实现可在 Unix 和 Windows 间共享）。 （由 Brian Curtin 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=11939">bpo-11939</a> 中贡献。）</p>
<p class="translated">现在 <a class="reference internal" href="../library/os.path.html#os.path.ismount" title="os.path.ismount"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.path.ismount()</span></code></a> 可识别 Windows 中在驱动器根目录下加载的卷。 （由 Tim Golden 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=9035">bpo-9035</a> 中贡献。）</p>
<p class="translated"><a class="reference internal" href="../library/os.html#os.open" title="os.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.open()</span></code></a> 在受支持的平台上提供了两个新旗标 <a class="reference internal" href="../library/os.html#os.O_PATH" title="os.O_PATH"><code class="xref py py-const docutils literal notranslate"><span class="pre">O_PATH</span></code></a> (未打开的文件描述符) 和 <a class="reference internal" href="../library/os.html#os.O_TMPFILE" title="os.O_TMPFILE"><code class="xref py py-const docutils literal notranslate"><span class="pre">O_TMPFILE</span></code></a> (未命名的临时文件；因为 3.4.0 发布版仅在具有 uapi 标头的内核版本 3.11 或更新的 Linux 系统上可用)。 （分别由 Christian Heimes 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18673">bpo-18673</a> 中以及 Benjamin Peterson 贡献。）</p>
</section>
<section id="pdb">
<h3 class="translated">pdb<a class="headerlink" href="#pdb" title="Link to this heading">¶</a></h3>
<p class="translated"><a class="reference internal" href="../library/pdb.html#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pdb</span></code></a> 已被增强以通过更有用的方式来处理生成器, <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 和 <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code>。 这在调试基于 <a class="reference internal" href="../library/asyncio.html#module-asyncio" title="asyncio: Asynchronous I/O."><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a> 的程序时特别有帮助。 （由 Andrew Svetlov 和 Xavier de Gaye 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16596">bpo-16596</a> 中贡献。）</p>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">print</span></code> 命令已从 <a class="reference internal" href="../library/pdb.html#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pdb</span></code></a> 中移除，恢复了从 pdb 命令行对 Python <a class="reference internal" href="../library/functions.html#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a> 函数的访问。 Python2 的 <code class="docutils literal notranslate"><span class="pre">pdb</span></code> 没有 <code class="docutils literal notranslate"><span class="pre">print</span></code> 命令；而是会在输入 <code class="docutils literal notranslate"><span class="pre">print</span></code> 时执行 <code class="docutils literal notranslate"><span class="pre">print</span></code> 语句。 在 Python3 中 <code class="docutils literal notranslate"><span class="pre">print</span></code> 被错误地设为 pdb <a class="reference internal" href="../library/pdb.html#pdbcommand-p"><code class="xref std std-pdbcmd docutils literal notranslate"><span class="pre">p</span></code></a> 命令的别名。 然而，<code class="docutils literal notranslate"><span class="pre">p</span></code> 会打印其参数的 <code class="docutils literal notranslate"><span class="pre">repr</span></code>，而不是像 Python2 <code class="docutils literal notranslate"><span class="pre">print</span></code> 命令那样打印其参数的 <code class="docutils literal notranslate"><span class="pre">str</span></code>。 更糟糕的是，Python3 <code class="docutils literal notranslate"><span class="pre">pdb</span> <span class="pre">print</span></code> 命令会覆盖 Python3 <code class="docutils literal notranslate"><span class="pre">print</span></code> 函数，导致其在 <code class="docutils literal notranslate"><span class="pre">pdb</span></code> 提示符下无法被访问。 （由 Connor Osborn 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18764">bpo-18764</a> 中贡献。）</p>
</section>
<section id="pickle">
<span id="whatsnew-protocol-4"></span><h3 class="translated">pickle<a class="headerlink" href="#pickle" title="Link to this heading">¶</a></h3>
<p class="translated">现在 <a class="reference internal" href="../library/pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 支持（但默认不使用）新的 pickle 协议即协议 4。 这个新协议解决了在之前版本中存在的多个问题，例如嵌套类、超长字符串和容器，以及 <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 方法接受仅限关键字参数的类的序列化。 它还提供了一些效率上的改进。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-159"></span><a class="pep reference external" href="https://peps.python.org/pep-3154/"><strong>PEP 3154</strong></a> -- pickle 协议 4</dt><dd><p class="translated">PEP 由 Antoine Pitrou 撰写，并由 Alexandre Vassalotti 实现</p>
</dd>
</dl>
</div>
</section>
<section id="plistlib">
<h3 class="translated">plistlib<a class="headerlink" href="#plistlib" title="Link to this heading">¶</a></h3>
<p class="translated">现在 <a class="reference internal" href="../library/plistlib.html#module-plistlib" title="plistlib: Generate and parse Apple plist files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">plistlib</span></code></a> 个具有与 stdlib 序列化协议标准模式类似的 API，使用新的 <a class="reference internal" href="../library/plistlib.html#plistlib.load" title="plistlib.load"><code class="xref py py-func docutils literal notranslate"><span class="pre">load()</span></code></a>, <a class="reference internal" href="../library/plistlib.html#plistlib.dump" title="plistlib.dump"><code class="xref py py-func docutils literal notranslate"><span class="pre">dump()</span></code></a>, <a class="reference internal" href="../library/plistlib.html#plistlib.loads" title="plistlib.loads"><code class="xref py py-func docutils literal notranslate"><span class="pre">loads()</span></code></a> 和 <a class="reference internal" href="../library/plistlib.html#plistlib.dumps" title="plistlib.dumps"><code class="xref py py-func docutils literal notranslate"><span class="pre">dumps()</span></code></a> 函数。 (旧 API 现已被弃用。) 除了已受支持的 XML plist 格式 (<a class="reference internal" href="../library/plistlib.html#plistlib.FMT_XML" title="plistlib.FMT_XML"><code class="xref py py-const docutils literal notranslate"><span class="pre">FMT_XML</span></code></a>)，现在它还支持二进制 plist 格式 (<a class="reference internal" href="../library/plistlib.html#plistlib.FMT_BINARY" title="plistlib.FMT_BINARY"><code class="xref py py-const docutils literal notranslate"><span class="pre">FMT_BINARY</span></code></a>)。 （由 Ronald Oussoren 等人在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=14455">bpo-14455</a> 中贡献。）</p>
</section>
<section id="poplib">
<h3 class="translated">poplib<a class="headerlink" href="#poplib" title="Link to this heading">¶</a></h3>
<p class="translated">在 <a class="reference internal" href="../library/poplib.html#module-poplib" title="poplib: POP3 protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">poplib</span></code></a> 中新增了两个方法: <a class="reference internal" href="../library/poplib.html#poplib.POP3.capa" title="poplib.POP3.capa"><code class="xref py py-meth docutils literal notranslate"><span class="pre">capa()</span></code></a>，它将返回 POP 服务器公开的功能列表，以及 <a class="reference internal" href="../library/poplib.html#poplib.POP3.stls" title="poplib.POP3.stls"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stls()</span></code></a>，它将在 POP 支持的情况下将明文 POP3 会话切换为加密 POP3 会话。 （由 Lorenzo Catucci 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4473">bpo-4473</a> 中贡献。）</p>
</section>
<section id="pprint">
<h3 class="translated">pprint<a class="headerlink" href="#pprint" title="Link to this heading">¶</a></h3>
<p class="translated"><a class="reference internal" href="../library/pprint.html#module-pprint" title="pprint: Data pretty printer."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pprint</span></code></a> 模块的 <a class="reference internal" href="../library/pprint.html#pprint.PrettyPrinter" title="pprint.PrettyPrinter"><code class="xref py py-class docutils literal notranslate"><span class="pre">PrettyPrinter</span></code></a> 类以及 <a class="reference internal" href="../library/pprint.html#pprint.pformat" title="pprint.pformat"><code class="xref py py-func docutils literal notranslate"><span class="pre">pformat()</span></code></a> 和 <a class="reference internal" href="../library/pprint.html#pprint.pprint" title="pprint.pprint"><code class="xref py py-func docutils literal notranslate"><span class="pre">pprint()</span></code></a> 函数新增了一个选项 <em>compact</em>，它可控制输出所使用的格式。 目前将 <em>compact</em> 设为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 表示打印序列时将在每个（缩进的）行中放入 <em>width</em> 所允许的尽可能多的元素。 （由 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19132">bpo-19132</a> 中贡献。）</p>
<p class="translated">长字符串现在将使用 Python 的常规续行语法进行包装。 （由 Antoine Pitrou 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=17150">bpo-17150</a> 中贡献。）</p>
</section>
<section id="pty">
<h3 class="translated">pty<a class="headerlink" href="#pty" title="Link to this heading">¶</a></h3>
<p class="translated">现在 <a class="reference internal" href="../library/pty.html#pty.spawn" title="pty.spawn"><code class="xref py py-func docutils literal notranslate"><span class="pre">pty.spawn()</span></code></a> 将返回来自子进程上 <a class="reference internal" href="../library/os.html#os.waitpid" title="os.waitpid"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.waitpid()</span></code></a> 的状态值，而不是 <code class="docutils literal notranslate"><span class="pre">None</span></code>。 （由 Gregory P. Smith 贡献。）</p>
</section>
<section id="pydoc">
<h3 class="translated">pydoc<a class="headerlink" href="#pydoc" title="Link to this heading">¶</a></h3>
<p class="translated">现在 <a class="reference internal" href="../library/pydoc.html#module-pydoc" title="pydoc: Documentation generator and online help system."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code></a> 模块是直接基于 <a class="reference internal" href="../library/inspect.html#inspect.signature" title="inspect.signature"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.signature()</span></code></a> 内省 API，这允许它提供更多可调用对象的签名信息。 这一改变也意味着现在当显示帮助信息时 <code class="docutils literal notranslate"><span class="pre">__wrapped__</span></code> 属性也会被纳入考虑。 （由 Larry Hastings 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19674">bpo-19674</a> 中贡献。）</p>
<p class="translated"><a class="reference internal" href="../library/pydoc.html#module-pydoc" title="pydoc: Documentation generator and online help system."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code></a> 模块将不再显示已绑定方法的 <code class="docutils literal notranslate"><span class="pre">self</span></code> 形参。 现在，它总是会显示所提供可调用对象实际的当前签名。 （由 Larry Hastings 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=20710">bpo-20710</a> 中贡献。）</p>
<p class="translated">除了 <a class="reference internal" href="../library/pydoc.html#module-pydoc" title="pydoc: Documentation generator and online help system."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code></a> 已有的直接修改，它对自定义 <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> 方法和各种描述器行为的处理也通过对下层 <a class="reference internal" href="../library/inspect.html#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect</span></code></a> 模块的修改获得了显著的改进。</p>
<p class="translated">由于 <a class="reference internal" href="../library/functions.html#help" title="help"><code class="xref py py-func docutils literal notranslate"><span class="pre">help()</span></code></a> 内置函数是基于 <a class="reference internal" href="../library/pydoc.html#module-pydoc" title="pydoc: Documentation generator and online help system."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code></a> 的，上述的变化也会影响 <a class="reference internal" href="../library/functions.html#help" title="help"><code class="xref py py-func docutils literal notranslate"><span class="pre">help()</span></code></a> 的行为。</p>
</section>
<section id="re">
<h3 class="translated">re<a class="headerlink" href="#re" title="Link to this heading">¶</a></h3>
<p class="translated">新增的 <a class="reference internal" href="../library/re.html#re.fullmatch" title="re.fullmatch"><code class="xref py py-func docutils literal notranslate"><span class="pre">fullmatch()</span></code></a> 函数和 <a class="reference internal" href="../library/re.html#re.Pattern.fullmatch" title="re.Pattern.fullmatch"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Pattern.fullmatch()</span></code></a> 方法可将模式锚定到要匹配的字符串的两端。 这提供了一种显式匹配目标的方式，从而避免了一类微妙的错误错误，即在代码更改或为现有正则表达式添加替代项时丢失 <code class="docutils literal notranslate"><span class="pre">$</span></code> 字符。 （由 Matthew Barnett 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16203">bpo-16203</a> 中贡献。）</p>
<p class="translated"><a class="reference internal" href="../library/re.html#re-objects"><span class="std std-ref">正则表达式对象</span></a> 的 repr 现在将包括模式和旗标；<a class="reference internal" href="../library/re.html#match-objects"><span class="std std-ref">匹配对象</span></a> 的 repr 现在将包括已匹配字符串的开头、末尾和组成。 （由 Hugo Lopes Tavares 和 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=13592">bpo-13592</a> 和 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=17087">bpo-17087</a> 中贡献。）</p>
</section>
<section id="resource">
<h3 class="translated">resource<a class="headerlink" href="#resource" title="Link to this heading">¶</a></h3>
<p class="translated">新增的 <a class="reference internal" href="../library/resource.html#resource.prlimit" title="resource.prlimit"><code class="xref py py-func docutils literal notranslate"><span class="pre">prlimit()</span></code></a> 函数，在内核版本 2.6.36 以上的 Linux 平台及 glibc 版本 2.13 以上可用，提供了查询或设置执行调用的进程以外的进程的资源限制的功能。 （由 Christian Heimes 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16595">bpo-16595</a> 中贡献。）</p>
<p class="translated">在内核版本 2.6.36 以上的 Linux 上，新增了一些 Linux 专属的常量: <a class="reference internal" href="../library/resource.html#resource.RLIMIT_MSGQUEUE" title="resource.RLIMIT_MSGQUEUE"><code class="xref py py-const docutils literal notranslate"><span class="pre">RLIMIT_MSGQUEUE</span></code></a>, <a class="reference internal" href="../library/resource.html#resource.RLIMIT_NICE" title="resource.RLIMIT_NICE"><code class="xref py py-const docutils literal notranslate"><span class="pre">RLIMIT_NICE</span></code></a>, <a class="reference internal" href="../library/resource.html#resource.RLIMIT_RTPRIO" title="resource.RLIMIT_RTPRIO"><code class="xref py py-const docutils literal notranslate"><span class="pre">RLIMIT_RTPRIO</span></code></a>, <a class="reference internal" href="../library/resource.html#resource.RLIMIT_RTTIME" title="resource.RLIMIT_RTTIME"><code class="xref py py-const docutils literal notranslate"><span class="pre">RLIMIT_RTTIME</span></code></a> 和 <a class="reference internal" href="../library/resource.html#resource.RLIMIT_SIGPENDING" title="resource.RLIMIT_SIGPENDING"><code class="xref py py-const docutils literal notranslate"><span class="pre">RLIMIT_SIGPENDING</span></code></a>。 （由 Christian Heimes 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19324">bpo-19324</a> 中贡献。）</p>
<p class="translated">在版本 9 以上的 FreeBSD 上，新增了一些 FreeBSD 专属的常量: <a class="reference internal" href="../library/resource.html#resource.RLIMIT_SBSIZE" title="resource.RLIMIT_SBSIZE"><code class="xref py py-const docutils literal notranslate"><span class="pre">RLIMIT_SBSIZE</span></code></a>, <a class="reference internal" href="../library/resource.html#resource.RLIMIT_SWAP" title="resource.RLIMIT_SWAP"><code class="xref py py-const docutils literal notranslate"><span class="pre">RLIMIT_SWAP</span></code></a> 和 <a class="reference internal" href="../library/resource.html#resource.RLIMIT_NPTS" title="resource.RLIMIT_NPTS"><code class="xref py py-const docutils literal notranslate"><span class="pre">RLIMIT_NPTS</span></code></a>。 （由 Claudiu Popa 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19343">bpo-19343</a> 中贡献。）</p>
</section>
<section id="select">
<h3 class="translated">select<a class="headerlink" href="#select" title="Link to this heading">¶</a></h3>
<p class="translated">现在 <a class="reference internal" href="../library/select.html#select.epoll" title="select.epoll"><code class="xref py py-class docutils literal notranslate"><span class="pre">epoll</span></code></a> 对象可支持上下文管理协议。 当在 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 语句中使用时，<a class="reference internal" href="../library/select.html#select.epoll.close" title="select.epoll.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> 方法将在代码块结束时被自动调用。 （由 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16488">bpo-16488</a> 中贡献。）</p>
<p class="translated">现在 <a class="reference internal" href="../library/select.html#select.devpoll" title="select.devpoll"><code class="xref py py-class docutils literal notranslate"><span class="pre">devpoll</span></code></a> 对象具有 <a class="reference internal" href="../library/select.html#select.devpoll.fileno" title="select.devpoll.fileno"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fileno()</span></code></a> 和 <a class="reference internal" href="../library/select.html#select.devpoll.close" title="select.devpoll.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> 方法，以及新的属性 <a class="reference internal" href="../library/select.html#select.devpoll.closed" title="select.devpoll.closed"><code class="xref py py-attr docutils literal notranslate"><span class="pre">closed</span></code></a>。 （由 Victor Stinner 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18794">bpo-18794</a> 中贡献。）</p>
</section>
<section id="shelve">
<h3 class="translated">shelve<a class="headerlink" href="#shelve" title="Link to this heading">¶</a></h3>
<p class="translated">现在 <a class="reference internal" href="../library/shelve.html#shelve.Shelf" title="shelve.Shelf"><code class="xref py py-class docutils literal notranslate"><span class="pre">Shelf</span></code></a> 实例可以在 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 语句中使用，并将在 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code> 代码块结束时自动关闭。 （由 Filip Gruszczyński 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=13896">bpo-13896</a> 中贡献。）</p>
</section>
<section id="shutil">
<h3 class="translated">shutil<a class="headerlink" href="#shutil" title="Link to this heading">¶</a></h3>
<p class="translated">现在当源和目标为相同文件时 <a class="reference internal" href="../library/shutil.html#shutil.copyfile" title="shutil.copyfile"><code class="xref py py-func docutils literal notranslate"><span class="pre">copyfile()</span></code></a> 会引发专门的 <a class="reference internal" href="../library/shutil.html#shutil.Error" title="shutil.Error"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Error</span></code></a> 子类 <a class="reference internal" href="../library/shutil.html#shutil.SameFileError" title="shutil.SameFileError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SameFileError</span></code></a>，这允许应用程序针对这个特定错误采取适当的动作。 （由 Atsuo Ishimoto 和 Hynek Schlawack 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1492704">bpo-1492704</a> 中贡献。）</p>
</section>
<section id="smtpd">
<h3 class="translated">smtpd<a class="headerlink" href="#smtpd" title="Link to this heading">¶</a></h3>
<p class="translated">现在 <code class="xref py py-class docutils literal notranslate"><span class="pre">SMTPServer</span></code> 和 <code class="xref py py-class docutils literal notranslate"><span class="pre">SMTPChannel</span></code> 类接受一个 <em>map</em> 关键字参数，如果指定了该参数，它将被传给 <code class="xref py py-class docutils literal notranslate"><span class="pre">asynchat.async_chat</span></code> 作为其 <em>map</em> 参数。 这允许应用程序避免影响全局套接字映射表。 （由 Vinay Sajip 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=11959">bpo-11959</a> 中贡献。）</p>
</section>
<section id="smtplib">
<h3 class="translated">smtplib<a class="headerlink" href="#smtplib" title="Link to this heading">¶</a></h3>
<p class="translated">现在 <a class="reference internal" href="../library/smtplib.html#smtplib.SMTPException" title="smtplib.SMTPException"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SMTPException</span></code></a> 是 <a class="reference internal" href="../library/exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 的子类，它允许仅需关注是否有错误发生的代码在一个 try/except 语句中同时捕获套接字级错误和 SMTP 协议级错误。 （由 Ned Jackson Lovely 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2118">bpo-2118</a> 中贡献。）</p>
</section>
<section id="socket">
<h3 class="translated">socket<a class="headerlink" href="#socket" title="Link to this heading">¶</a></h3>
<p class="translated">现在 socket 模块会在受支持的平台上支持 <a class="reference internal" href="../library/socket.html#socket.CAN_BCM" title="socket.CAN_BCM"><code class="xref py py-const docutils literal notranslate"><span class="pre">CAN_BCM</span></code></a> 协议。 （由 Brian Thorne 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=15359">bpo-15359</a> 中贡献。）</p>
<p class="translated">Socket 对象新增了用于获取或设置其 <a class="reference internal" href="../library/os.html#fd-inheritance"><span class="std std-ref">可继承旗标</span></a> 的方法，<a class="reference internal" href="../library/socket.html#socket.socket.get_inheritable" title="socket.socket.get_inheritable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_inheritable()</span></code></a> 和 <a class="reference internal" href="../library/socket.html#socket.socket.set_inheritable" title="socket.socket.set_inheritable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_inheritable()</span></code></a>。</p>
<p class="translated">现在 <code class="docutils literal notranslate"><span class="pre">socket.AF_*</span></code> 和 <code class="docutils literal notranslate"><span class="pre">socket.SOCK_*</span></code> 常量是使用了新增的 <a class="reference internal" href="../library/enum.html#module-enum" title="enum: Implementation of an enumeration class."><code class="xref py py-mod docutils literal notranslate"><span class="pre">enum</span></code></a> 模块的枚举值。 这允许在调试期间打印有意义的名称，而不是整数形式的“魔法数字”。</p>
<p class="translated">现在 <a class="reference internal" href="../library/socket.html#socket.AF_LINK" title="socket.AF_LINK"><code class="xref py py-const docutils literal notranslate"><span class="pre">AF_LINK</span></code></a> 常量将在 BSD 和 OSX 上可用。</p>
<p class="translated">现在 <a class="reference internal" href="../library/socket.html#socket.inet_pton" title="socket.inet_pton"><code class="xref py py-func docutils literal notranslate"><span class="pre">inet_pton()</span></code></a> 和 <a class="reference internal" href="../library/socket.html#socket.inet_ntop" title="socket.inet_ntop"><code class="xref py py-func docutils literal notranslate"><span class="pre">inet_ntop()</span></code></a> 在 Windows 上已受到支持。 （由 Atsuo Ishimoto 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7171">bpo-7171</a> 中贡献。）</p>
</section>
<section id="sqlite3">
<h3 class="translated">sqlite3<a class="headerlink" href="#sqlite3" title="Link to this heading">¶</a></h3>
<p class="translated"><a class="reference internal" href="../library/sqlite3.html#sqlite3.connect" title="sqlite3.connect"><code class="xref py py-func docutils literal notranslate"><span class="pre">connect()</span></code></a> 函数新增布尔值形参 <em>uri</em>，它可被用来指明 <em>database</em> 形参是一个 <code class="docutils literal notranslate"><span class="pre">uri</span></code> (参见 <a class="reference external" href="https://www.sqlite.org/uri.html">SQLite URI 文档</a>)。 （由 poq 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=13773">bpo-13773</a> 中贡献。）</p>
</section>
<section id="ssl">
<h3 class="translated">ssl<a class="headerlink" href="#ssl" title="Link to this heading">¶</a></h3>
<p class="translated" id="whatsnew-tls-11-12">添加了 <a class="reference internal" href="../library/ssl.html#ssl.PROTOCOL_TLSv1_1" title="ssl.PROTOCOL_TLSv1_1"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLSv1_1</span></code></a> 和 <a class="reference internal" href="../library/ssl.html#ssl.PROTOCOL_TLSv1_2" title="ssl.PROTOCOL_TLSv1_2"><code class="xref py py-data docutils literal notranslate"><span class="pre">PROTOCOL_TLSv1_2</span></code></a> (TLSv1.1 和 TLSv1.2 支持)；对这些协议的支持仅在 Python 使用 OpenSSL 1.0.1 或更高版本链接时可用。 （由 Michele Orrù 和 Antoine Pitrou 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16692">bpo-16692</a> 中贡献。）</p>
<p class="translated" id="whatsnew34-sslcontext">新增的函数 <a class="reference internal" href="../library/ssl.html#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_default_context()</span></code></a> 提供了获取 <a class="reference internal" href="../library/ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> 的标准方式，其设置旨在合理兼顾兼容性和安全性。 这些设置比 <a class="reference internal" href="../library/ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> 构造器所提供的默认设置更为严格，如果最佳实践的安全要求发生变化，将来可能会对其进行调整，而不预先提示弃用。 对于使用支持 SSL 的 stdlib 库来新推荐的最佳实践是使用 <a class="reference internal" href="../library/ssl.html#ssl.create_default_context" title="ssl.create_default_context"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_default_context()</span></code></a> 来获取 <a class="reference internal" href="../library/ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> 对象，必要时对其进行修改，然后将其作为相应 stdlib API 的 <em>contex</em> 参数传入。 （由 Christian Heimes 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19689">bpo-19689</a> 中贡献。）</p>
<p class="translated"><a class="reference internal" href="../library/ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> 方法 <a class="reference internal" href="../library/ssl.html#ssl.SSLContext.load_verify_locations" title="ssl.SSLContext.load_verify_locations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">load_verify_locations()</span></code></a> 接受新增的可选参数 <em>cadata</em>，它可被来分别通过字符串或字节串来直接提供 PEM 或 DER 编码的证书。 （由 Christian Heimes 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18138">bpo-18138</a> 中贡献。）</p>
<p class="translated">新增的函数 <a class="reference internal" href="../library/ssl.html#ssl.get_default_verify_paths" title="ssl.get_default_verify_paths"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_default_verify_paths()</span></code></a> 可返回一个由路径和环境变量组成的具名元组， 供 <a class="reference internal" href="../library/ssl.html#ssl.SSLContext.set_default_verify_paths" title="ssl.SSLContext.set_default_verify_paths"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_default_verify_paths()</span></code></a> 方法用来设置 OpenSSL 的默认 <code class="docutils literal notranslate"><span class="pre">cafile</span></code> 和 <code class="docutils literal notranslate"><span class="pre">capath</span></code>。 这有助于对默认的验证问题进行调试。 （由 Christian Heimes 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18143">bpo-18143</a> 中贡献。）</p>
<p class="translated"><a class="reference internal" href="../library/ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> 增加了一个新方法 <a class="reference internal" href="../library/ssl.html#ssl.SSLContext.cert_store_stats" title="ssl.SSLContext.cert_store_stats"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cert_store_stats()</span></code></a>，用来报告已加载的 <code class="docutils literal notranslate"><span class="pre">X.509</span></code> 证书, <code class="docutils literal notranslate"><span class="pre">X.509</span> <span class="pre">CA</span></code> 证书数量和证书吊销列表 (<code class="docutils literal notranslate"><span class="pre">crl</span></code>s)，以及 <a class="reference internal" href="../library/ssl.html#ssl.SSLContext.get_ca_certs" title="ssl.SSLContext.get_ca_certs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_ca_certs()</span></code></a> 方法用来返回已加载的 <code class="docutils literal notranslate"><span class="pre">CA</span></code> 证书列表。 （由 Christian Heimes 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18147">bpo-18147</a> 中贡献。）</p>
<p class="translated">如果 OpenSSL 0.9.8 或更高版本可用，<a class="reference internal" href="../library/ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> 将具有一个新增属性 <a class="reference internal" href="../library/ssl.html#ssl.SSLContext.verify_flags" title="ssl.SSLContext.verify_flags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">verify_flags</span></code></a> 可被用于通过设置新增常量 <a class="reference internal" href="../library/ssl.html#ssl.VERIFY_DEFAULT" title="ssl.VERIFY_DEFAULT"><code class="xref py py-const docutils literal notranslate"><span class="pre">VERIFY_DEFAULT</span></code></a>, <a class="reference internal" href="../library/ssl.html#ssl.VERIFY_CRL_CHECK_LEAF" title="ssl.VERIFY_CRL_CHECK_LEAF"><code class="xref py py-const docutils literal notranslate"><span class="pre">VERIFY_CRL_CHECK_LEAF</span></code></a>, <a class="reference internal" href="../library/ssl.html#ssl.VERIFY_CRL_CHECK_CHAIN" title="ssl.VERIFY_CRL_CHECK_CHAIN"><code class="xref py py-const docutils literal notranslate"><span class="pre">VERIFY_CRL_CHECK_CHAIN</span></code></a> 或 <a class="reference internal" href="../library/ssl.html#ssl.VERIFY_X509_STRICT" title="ssl.VERIFY_X509_STRICT"><code class="xref py py-const docutils literal notranslate"><span class="pre">VERIFY_X509_STRICT</span></code></a> 的组合来控制证书验证过程。 在默认情况下 OpenSSL 不会执行任何 CRL 验证。 （由 Christien Heimes 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=8813">bpo-8813</a> 中贡献。）</p>
<p class="translated">新增的 <a class="reference internal" href="../library/ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> 方法 <a class="reference internal" href="../library/ssl.html#ssl.SSLContext.load_default_certs" title="ssl.SSLContext.load_default_certs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">load_default_certs()</span></code></a> 可从默认位置加载一组默认的“证书颁发机构”（CA）证书，此位置随平台而异。 它可被用于加载 TLS Web 服务器验证证书 (<code class="docutils literal notranslate"><span class="pre">purpose=</span></code><a class="reference internal" href="../library/ssl.html#ssl.Purpose.SERVER_AUTH" title="ssl.Purpose.SERVER_AUTH"><code class="xref py py-data docutils literal notranslate"><span class="pre">SERVER_AUTH</span></code></a> ) 供客户端用来验证服务器，或加载证书供服务器用来验证客户端证书 (<code class="docutils literal notranslate"><span class="pre">purpose=</span></code><a class="reference internal" href="../library/ssl.html#ssl.Purpose.CLIENT_AUTH" title="ssl.Purpose.CLIENT_AUTH"><code class="xref py py-data docutils literal notranslate"><span class="pre">CLIENT_AUTH</span></code></a> )。 （由 Christian Heimes 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19292">bpo-19292</a> 中贡献。）</p>
<p class="translated" id="whatsnew34-win-cert-store">新增的两个 Windows 专属函数 <a class="reference internal" href="../library/ssl.html#ssl.enum_certificates" title="ssl.enum_certificates"><code class="xref py py-func docutils literal notranslate"><span class="pre">enum_certificates()</span></code></a> 和 <a class="reference internal" href="../library/ssl.html#ssl.enum_crls" title="ssl.enum_crls"><code class="xref py py-func docutils literal notranslate"><span class="pre">enum_crls()</span></code></a> 提供了从 Windows 证书存储库提取证书、证书信息和 CRL 的功能。 （由 Christian Heimes 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=17134">bpo-17134</a> 中贡献。）</p>
<p class="translated" id="whatsnew34-sni">使用新增的 <a class="reference internal" href="../library/ssl.html#ssl.SSLContext.set_servername_callback" title="ssl.SSLContext.set_servername_callback"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLContext.set_servername_callback()</span></code></a> 方法来支持服务器端 SNI (Server Name Indication)。 （由 Daniel Black 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=8109">bpo-8109</a> 中贡献。）</p>
<p class="translated">由 <a class="reference internal" href="../library/ssl.html#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.getpeercert()</span></code></a> 返回的字典包含额外的 <code class="docutils literal notranslate"><span class="pre">X509v3</span></code> 扩展条目: <code class="docutils literal notranslate"><span class="pre">crlDistributionPoints</span></code>, <code class="docutils literal notranslate"><span class="pre">calIssuers</span></code> 和 <code class="docutils literal notranslate"><span class="pre">OCSP</span></code> URI。 （由 Christian Heimes 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18379">bpo-18379</a> 中贡献。）</p>
</section>
<section id="stat">
<h3 class="translated">stat<a class="headerlink" href="#stat" title="Link to this heading">¶</a></h3>
<p class="translated">现在 <a class="reference internal" href="../library/stat.html#module-stat" title="stat: Utilities for interpreting the results of os.stat(), os.lstat() and os.fstat()."><code class="xref py py-mod docutils literal notranslate"><span class="pre">stat</span></code></a> 模块以 <code class="xref py py-mod docutils literal notranslate"><span class="pre">_stat</span></code> 中的 C 实现作为后端。 C 实现是必需的因为大多数值都未被标准化并且依赖于平台。 （由 Christian Heimes 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=11016">bpo-11016</a> 中贡献。）</p>
<p class="translated">该模块支持新的 <a class="reference internal" href="../library/stat.html#stat.ST_MODE" title="stat.ST_MODE"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ST_MODE</span></code></a> 旗标, <a class="reference internal" href="../library/stat.html#stat.S_IFDOOR" title="stat.S_IFDOOR"><code class="xref py py-mod docutils literal notranslate"><span class="pre">S_IFDOOR</span></code></a>, <a class="reference internal" href="../library/stat.html#stat.S_IFPORT" title="stat.S_IFPORT"><code class="xref py py-const docutils literal notranslate"><span class="pre">S_IFPORT</span></code></a> 和 <a class="reference internal" href="../library/stat.html#stat.S_IFWHT" title="stat.S_IFWHT"><code class="xref py py-const docutils literal notranslate"><span class="pre">S_IFWHT</span></code></a>。 （由 Christian Hiemes 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=11016">bpo-11016</a> 中贡献。）</p>
</section>
<section id="struct">
<h3 class="translated">struct<a class="headerlink" href="#struct" title="Link to this heading">¶</a></h3>
<p class="translated">新增函数 <a class="reference internal" href="../library/struct.html#struct.iter_unpack" title="struct.iter_unpack"><code class="xref py py-mod docutils literal notranslate"><span class="pre">iter_unpack</span></code></a> 和在已编译格式上的新增方法 <a class="reference internal" href="../library/struct.html#struct.Struct.iter_unpack" title="struct.Struct.iter_unpack"><code class="xref py py-meth docutils literal notranslate"><span class="pre">struct.Struct.iter_unpack()</span></code></a> 提供了对包含给定格式数据的重复实例的缓冲区的流式解包功能。 （由 Antoine Pitrou 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=17804">bpo-17804</a> 中贡献。）</p>
</section>
<section id="subprocess">
<h3 class="translated">subprocess<a class="headerlink" href="#subprocess" title="Link to this heading">¶</a></h3>
<p class="translated">现在 <a class="reference internal" href="../library/subprocess.html#subprocess.check_output" title="subprocess.check_output"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_output()</span></code></a> 接受一个 <em>input</em> 参数用于为所运行的命令提供 <code class="docutils literal notranslate"><span class="pre">stdin</span></code> 的内容。 （由 Zack Weinberg 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16624">bpo-16624</a> 中贡献。）</p>
<p class="translated">现在 <a class="reference internal" href="../library/subprocess.html#subprocess.getoutput" title="subprocess.getoutput"><code class="xref py py-func docutils literal notranslate"><span class="pre">getoutput()</span></code></a> 和 <a class="reference internal" href="../library/subprocess.html#subprocess.getstatusoutput" title="subprocess.getstatusoutput"><code class="xref py py-func docutils literal notranslate"><span class="pre">getstatusoutput()</span></code></a> 已适用于 Windows。 这一修改是在 3.3.4 中意外实施的。 （由 Tim Golden 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=10197">bpo-10197</a> 中贡献。）</p>
</section>
<section id="sunau">
<h3 class="translated">sunau<a class="headerlink" href="#sunau" title="Link to this heading">¶</a></h3>
<p class="translated">现在 <code class="xref py py-meth docutils literal notranslate"><span class="pre">getparams()</span></code> 方法将返回一个具名元组而不是普通元组。 （由 Claudiu Popa 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18901">bpo-18901</a> 中贡献。）</p>
<p class="translated">现在 <code class="xref py py-meth docutils literal notranslate"><span class="pre">sunau.open()</span></code> 可支持上下文管理协议：当在 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 代码块中使用时，所返回对象的 <code class="docutils literal notranslate"><span class="pre">close</span></code> 方法将在代码块结束时被自动调用。 （由 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18878">bpo-18878</a> 中贡献。）</p>
<p class="translated">现在 <code class="xref py py-meth docutils literal notranslate"><span class="pre">AU_write.setsampwidth()</span></code> 已支持 24 位采样，因此增加了使用该模块写入 24 位采样的支持。 （由 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19261">bpo-19261</a> 中贡献。）</p>
<p class="translated">现在 <code class="xref py py-meth docutils literal notranslate"><span class="pre">writeframesraw()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">writeframes()</span></code> 方法将接受任意 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>。 （由 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=8311">bpo-8311</a> 中贡献。）</p>
</section>
<section id="sys">
<h3 class="translated">sys<a class="headerlink" href="#sys" title="Link to this heading">¶</a></h3>
<p class="translated">新增函数 <a class="reference internal" href="../library/sys.html#sys.getallocatedblocks" title="sys.getallocatedblocks"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getallocatedblocks()</span></code></a> 可返回当前由解释器所分配的内存块数量。 （在使用默认 <code class="docutils literal notranslate"><span class="pre">--with-pymalloc</span></code> 设置的 CPython 中，这将是通过 <a class="reference internal" href="../c-api/memory.html#c.PyObject_Malloc" title="PyObject_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Malloc()</span></code></a> API 执行的分配。） 这在追踪内存泄漏时会很有用处，特别是对于通过测试套件自动追踪的场景。 （由 Antoine Pitrou 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=13390">bpo-13390</a> 中贡献。）</p>
<p class="translated">当 Python 解释器以 <a class="reference internal" href="../tutorial/interpreter.html#tut-interactive"><span class="std std-ref">交互模式</span></a> 启动时，它会检查 <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a> 模块中的 <a class="reference internal" href="../library/sys.html#sys.__interactivehook__" title="sys.__interactivehook__"><code class="xref py py-data docutils literal notranslate"><span class="pre">__interactivehook__</span></code></a> 属性。 如果该属性存在，它的值将在交互模式启动之前不附带参数地被调用。 这个检查是在读取 <span class="target" id="index-160"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONSTARTUP"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONSTARTUP</span></code></a> 文件之后进行的，因此可以在那里设置它。 <a class="reference internal" href="../library/site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code></a> 模块会在平台支持 <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">readline</span></code></a> 的情况下 <a class="reference internal" href="../library/site.html#rlcompleter-config"><span class="std std-ref">把它设置为</span></a> 一个启用制表符补全和历史记录保存（在 <code class="file docutils literal notranslate"><span class="pre">~/.python-history</span></code> 中）的函数。 如果你不想要这个（新增的）行为，可以通过从 <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a> 中删除这个属性（或将其设为其他可调用对象）在 <span class="target" id="index-161"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONSTARTUP"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONSTARTUP</span></code></a>, <a class="reference internal" href="../library/site.html#module-sitecustomize" title="sitecustomize"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sitecustomize</span></code></a> 或 <a class="reference internal" href="../library/site.html#module-usercustomize" title="usercustomize"><code class="xref py py-mod docutils literal notranslate"><span class="pre">usercustomize</span></code></a> 中覆盖它。 （由 Éric Araujo 和 Antoine Pitrou 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5845">bpo-5845</a> 中贡献。）</p>
</section>
<section id="tarfile">
<h3 class="translated">tarfile<a class="headerlink" href="#tarfile" title="Link to this heading">¶</a></h3>
<p class="translated">现在 <a class="reference internal" href="../library/tarfile.html#module-tarfile" title="tarfile: Read and write tar-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tarfile</span></code></a> 模块当直接作为脚本或通过 <code class="docutils literal notranslate"><span class="pre">-m</span></code> 调用时将支持简单的 <a class="reference internal" href="../library/tarfile.html#tarfile-commandline"><span class="std std-ref">命令行接口</span></a>。 这可被用来创建和提取 tar 归档文件。 （由 Berker Peksag 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=13477">bpo-13477</a> 中贡献。）</p>
</section>
<section id="textwrap">
<h3 class="translated">textwrap<a class="headerlink" href="#textwrap" title="Link to this heading">¶</a></h3>
<p class="translated"><a class="reference internal" href="../library/textwrap.html#textwrap.TextWrapper" title="textwrap.TextWrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextWrapper</span></code></a> 类新增了两个属性/构造器参数: <a class="reference internal" href="../library/textwrap.html#textwrap.TextWrapper.max_lines" title="textwrap.TextWrapper.max_lines"><code class="xref py py-attr docutils literal notranslate"><span class="pre">max_lines</span></code></a>，用来限制输出的行数，以及 <a class="reference internal" href="../library/textwrap.html#textwrap.TextWrapper.placeholder" title="textwrap.TextWrapper.placeholder"><code class="xref py py-attr docutils literal notranslate"><span class="pre">placeholder</span></code></a>，它是一个当输出由于 <em>max_lines</em> 限制被截断时将出现在输出末尾处的字符串。 一个在此功能之上新增的便捷函数 <a class="reference internal" href="../library/textwrap.html#textwrap.shorten" title="textwrap.shorten"><code class="xref py py-func docutils literal notranslate"><span class="pre">shorten()</span></code></a> 可将输入中的所有空格压缩为单个空格并产生一个宽度为 <em>width</em> 并以 <em>placeholder</em> (默认为 <code class="docutils literal notranslate"><span class="pre">[...]</span></code>) 结束的单独行。 （由 Antoine Pitrou 和 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18585">bpo-18585</a> 和 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18725">bpo-18725</a> 中贡献。）</p>
</section>
<section id="threading">
<h3 class="translated">threading<a class="headerlink" href="#threading" title="Link to this heading">¶</a></h3>
<p class="translated">代表可通过新增的 <a class="reference internal" href="../library/threading.html#threading.main_thread" title="threading.main_thread"><code class="xref py py-func docutils literal notranslate"><span class="pre">main_thread()</span></code></a> 函数来获取的主线程的 <a class="reference internal" href="../library/threading.html#threading.Thread" title="threading.Thread"><code class="xref py py-class docutils literal notranslate"><span class="pre">Thread</span></code></a> 对象。 在通常条件下这将是启动 Python 解释器所在的线程。 （由 Andrew Svetlov 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18882">bpo-18882</a> 中贡献。）</p>
</section>
<section id="traceback">
<h3 class="translated">回溯<a class="headerlink" href="#traceback" title="Link to this heading">¶</a></h3>
<p class="translated">新增的 <a class="reference internal" href="../library/traceback.html#traceback.clear_frames" title="traceback.clear_frames"><code class="xref py py-func docutils literal notranslate"><span class="pre">traceback.clear_frames()</span></code></a> 函数可接受一个回溯对象清除它所引用的所有帧中的局部变量，以减少内存消耗量。 （由 Andrew Kuchling 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1565525">bpo-1565525</a> 中贡献。）</p>
</section>
<section id="types">
<h3 class="translated">types<a class="headerlink" href="#types" title="Link to this heading">¶</a></h3>
<p class="translated">新增的 <a class="reference internal" href="../library/types.html#types.DynamicClassAttribute" title="types.DynamicClassAttribute"><code class="xref py py-func docutils literal notranslate"><span class="pre">DynamicClassAttribute()</span></code></a> 描述器提供了一种定义属性的方式，这种属性可正常地在实例对象中查找，但在类中查找时会被导向 <em>类的</em> <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code>。 这将允许设置在类上激活的特征属性，并在相同名称的类上具有虚拟属性（参见 <a class="reference internal" href="../library/enum.html#module-enum" title="enum: Implementation of an enumeration class."><code class="xref py py-mod docutils literal notranslate"><span class="pre">enum</span></code></a> 的例子）。 （由 Ethan Furman 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19030">bpo-19030</a> 中贡献。）</p>
</section>
<section id="urllib">
<h3 class="translated">urllib<a class="headerlink" href="#urllib" title="Link to this heading">¶</a></h3>
<p class="translated">现在 <a class="reference internal" href="../library/urllib.request.html#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code></a> 支持 <code class="docutils literal notranslate"><span class="pre">data:</span></code> 使用 <a class="reference internal" href="../library/urllib.request.html#urllib.request.DataHandler" title="urllib.request.DataHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataHandler</span></code></a> 类的 URL。 （由 Mathias Panzenböck 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16423">bpo-16423</a> 中贡献。）</p>
<p class="translated">由 <a class="reference internal" href="../library/urllib.request.html#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 类使用的 http 方法现在可通过在子类上设置 <a class="reference internal" href="../library/urllib.request.html#urllib.request.Request.method" title="urllib.request.Request.method"><code class="xref py py-class docutils literal notranslate"><span class="pre">method</span></code></a> 类属性来指定。 （由 Jason R Coombs 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18978">bpo-18978</a> 中贡献。）</p>
<p class="translated">现在 <a class="reference internal" href="../library/urllib.request.html#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 对象是可重用的：如果 <a class="reference internal" href="../library/urllib.request.html#urllib.request.Request.full_url" title="urllib.request.Request.full_url"><code class="xref py py-attr docutils literal notranslate"><span class="pre">full_url</span></code></a> 或 <a class="reference internal" href="../library/urllib.request.html#urllib.request.Request.data" title="urllib.request.Request.data"><code class="xref py py-attr docutils literal notranslate"><span class="pre">data</span></code></a> 属性被修改，所有相关的内部特征属性都将被更新。 例如，这意味着现在可以在多个使用不同 <em>data</em> 参数的 <a class="reference internal" href="../library/urllib.request.html#urllib.request.OpenerDirector.open" title="urllib.request.OpenerDirector.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">OpenerDirector.open()</span></code></a> 调用中使用相同的 <a class="reference internal" href="../library/urllib.request.html#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 对象，或者修改 <a class="reference internal" href="../library/urllib.request.html#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 的 <code class="docutils literal notranslate"><span class="pre">url</span></code> 而不必从头重新计算它们。 此外还有新增的 <a class="reference internal" href="../library/urllib.request.html#urllib.request.Request.remove_header" title="urllib.request.Request.remove_header"><code class="xref py py-meth docutils literal notranslate"><span class="pre">remove_header()</span></code></a> 方法可被用来从 <a class="reference internal" href="../library/urllib.request.html#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 中移除标头。 （由 Alexey Kachayev 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16464">bpo-16464</a> 中，Daniel Wozniak 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=17485">bpo-17485</a> 中，以及 Damien Brecht 和 Senthil Kumaran 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=17272">bpo-17272</a> 中贡献。）</p>
<p class="translated">现在 <a class="reference internal" href="../library/urllib.error.html#urllib.error.HTTPError" title="urllib.error.HTTPError"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPError</span></code></a> 对象具有一个 <a class="reference internal" href="../library/urllib.error.html#urllib.error.HTTPError.headers" title="urllib.error.HTTPError.headers"><code class="xref py py-attr docutils literal notranslate"><span class="pre">headers</span></code></a> 属性可提供对与错误相关的 HTTP 响应的访问。 （由 Berker Peksag 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=15701">bpo-15701</a> 中贡献。）</p>
</section>
<section id="unittest">
<h3 class="translated">unittest<a class="headerlink" href="#unittest" title="Link to this heading">¶</a></h3>
<p class="translated"><a class="reference internal" href="../library/unittest.html#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 类有一个新方法 <a class="reference internal" href="../library/unittest.html#unittest.TestCase.subTest" title="unittest.TestCase.subTest"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subTest()</span></code></a>，它可产生一个以 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 代码块作为“子测试”的上下文管理器。 这个上下文管理器允许测试方法通过调用一个循环内的 <code class="docutils literal notranslate"><span class="pre">subTest</span></code> 上下文管理器这样的方式动态生成子测试。 这样单个测试方法就可以产生无限多个单独标识并单独计数的测试，这些测试即使在其中一个或多个测试失败的情况下仍然会全部运行。 例如:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">NumbersTest</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">test_even</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">subTest</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">将得到六个子测试，在单元测试详细输出中各自以变量名 <code class="docutils literal notranslate"><span class="pre">i</span></code> 加该变量专属的值来标识 (<code class="docutils literal notranslate"><span class="pre">i=0</span></code>, <code class="docutils literal notranslate"><span class="pre">i=1</span></code> 等等)。 该示例的完整版本见 <a class="reference internal" href="../library/unittest.html#subtests"><span class="std std-ref">使用子测试区分测试迭代</span></a>。 （由 Antoine Pitrou 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16997">bpo-16997</a> 中贡献。）</p>
<p class="translated">现在 <a class="reference internal" href="../library/unittest.html#unittest.main" title="unittest.main"><code class="xref py py-func docutils literal notranslate"><span class="pre">unittest.main()</span></code></a> 接受一个包含测试名称的可迭代对象作为 <em>defaultTest</em>，而在之前版本中它只接受单个字符串形式的测试名称。 （由 Jyrki Pulliainen 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=15132">bpo-15132</a> 中贡献。）</p>
<p class="translated">如果在测试发现期间（即在测试文件中的模块层级）引发了 <a class="reference internal" href="../library/unittest.html#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-class docutils literal notranslate"><span class="pre">SkipTest</span></code></a>，现在它将被报告为跳过而不是错误。 （由 Zach Ware 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16935">bpo-16935</a> 中贡献。）</p>
<p class="translated">现在 <a class="reference internal" href="../library/unittest.html#unittest.TestLoader.discover" title="unittest.TestLoader.discover"><code class="xref py py-meth docutils literal notranslate"><span class="pre">discover()</span></code></a> 会对所发现的文件进行排序以提供一致的测试顺序。 （由 Martin Melin 和 Jeff Ramnani 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16709">bpo-16709</a> 中贡献。）</p>
<p class="translated">如果测试成功，现在 <a class="reference internal" href="../library/unittest.html#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> 会在测试完成运行时立即丢弃对测试的引用。 在支持垃圾回收的 Python 解释器上，这允许当没有其他对象持有对测试的引用时将该测试作为垃圾回收。 可以通过创建一个定义了自定义 <code class="docutils literal notranslate"><span class="pre">_removeTestAtIndex</span></code> 方法的 <a class="reference internal" href="../library/unittest.html#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> 子类来覆盖此行为。 （由 Tom Wardill, Matt McClure 和 Andrew Svetlov 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=11798">bpo-11798</a> 中贡献。）</p>
<p class="translated">新增的测试断言上下文管理器 <a class="reference internal" href="../library/unittest.html#unittest.TestCase.assertLogs" title="unittest.TestCase.assertLogs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertLogs()</span></code></a> 将确保给定的代码块使用 <a class="reference internal" href="../library/logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> 模块发出日志记录消息。 在默认情况下消息可来自任意日志记录器并具有 <code class="docutils literal notranslate"><span class="pre">INFO</span></code> 或更高的优先级，但要指明日志记录器名称和替代的最低日志级别。 可以在该上下文管理器所返回的对象中查询 <a class="reference internal" href="../library/logging.html#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 和/或所记录的已格式化消息。 （由 Antoine Pitrou 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18937">bpo-18937</a> 中贡献。）</p>
<p class="translated">现在测试发现将可用于命名空间包（由 Claudiu Popa 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=17457">bpo-17457</a> 中贡献。）.)</p>
<p class="translated">现在 <a class="reference internal" href="../library/unittest.mock.html#module-unittest.mock" title="unittest.mock: Mock object library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest.mock</span></code></a> 对象可以在匹配调用时检查其规范签名，这意味着现在可以通过位置或名称来匹配参数，而不是仅能通过位置。 （由 Antoine Pitrou 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=17015">bpo-17015</a> 中贡献。）</p>
<p class="translated">现在 <a class="reference internal" href="../library/unittest.mock.html#unittest.mock.mock_open" title="unittest.mock.mock_open"><code class="xref py py-func docutils literal notranslate"><span class="pre">mock_open()</span></code></a> 对象具有 <code class="docutils literal notranslate"><span class="pre">readline</span></code> 和 <code class="docutils literal notranslate"><span class="pre">readlines</span></code> 方法。 （由 Toshio Kuratomi 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=17467">bpo-17467</a> 中贡献。）</p>
</section>
<section id="venv">
<h3 class="translated">venv<a class="headerlink" href="#venv" title="Link to this heading">¶</a></h3>
<p class="translated">现在 <a class="reference internal" href="../library/venv.html#module-venv" title="venv: Creation of virtual environments."><code class="xref py py-mod docutils literal notranslate"><span class="pre">venv</span></code></a> 包括了用于 <code class="docutils literal notranslate"><span class="pre">csh</span></code> 和 <code class="docutils literal notranslate"><span class="pre">fish</span></code> shell 的激活脚本。 （由 Andrew Svetlov 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=15417">bpo-15417</a> 中贡献。）</p>
<p class="translated"><a class="reference internal" href="../library/venv.html#venv.EnvBuilder" title="venv.EnvBuilder"><code class="xref py py-class docutils literal notranslate"><span class="pre">EnvBuilder</span></code></a> 和 <a class="reference internal" href="../library/venv.html#venv.create" title="venv.create"><code class="xref py py-func docutils literal notranslate"><span class="pre">create()</span></code></a> 便捷函数接受新的关键字参数 <em>with_pip</em>，默认值为 <code class="docutils literal notranslate"><span class="pre">False</span></code>，它控制 <a class="reference internal" href="../library/venv.html#venv.EnvBuilder" title="venv.EnvBuilder"><code class="xref py py-class docutils literal notranslate"><span class="pre">EnvBuilder</span></code></a> 是否确保 <code class="docutils literal notranslate"><span class="pre">pip</span></code> 在虚拟环境中安装。 （作为 <span class="target" id="index-162"></span><a class="pep reference external" href="https://peps.python.org/pep-0453/"><strong>PEP 453</strong></a> 实现的组成部分由 Nick Coghlan 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19552">bpo-19552</a> 中贡献。）</p>
</section>
<section id="wave">
<h3 class="translated">wave<a class="headerlink" href="#wave" title="Link to this heading">¶</a></h3>
<p class="translated">现在 <a class="reference internal" href="../library/wave.html#wave.Wave_read.getparams" title="wave.Wave_read.getparams"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getparams()</span></code></a> 方法将返回一个具名元组而不是普通元组。 （由 Claudiu Popa 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=17487">bpo-17487</a> 中贡献。）</p>
<p class="translated">现在 <a class="reference internal" href="../library/wave.html#wave.open" title="wave.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wave.open()</span></code></a> 已支持上下文管理器协议。 （由 Claudiu Popa 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=17616">bpo-17616</a> 中贡献。）</p>
<p class="translated">现在 <a class="reference internal" href="../library/wave.html#module-wave" title="wave: Provide an interface to the WAV sound format."><code class="xref py py-mod docutils literal notranslate"><span class="pre">wave</span></code></a> 可以 <a class="reference internal" href="../library/wave.html#wave-write-objects"><span class="std std-ref">将输出写入到不可定位的文件</span></a>。 （由 David Jones, Guilherme Polo 和 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5202">bpo-5202</a> 中贡献。）</p>
<p class="translated">现在 <a class="reference internal" href="../library/wave.html#wave.Wave_write.writeframesraw" title="wave.Wave_write.writeframesraw"><code class="xref py py-meth docutils literal notranslate"><span class="pre">writeframesraw()</span></code></a> 和 <a class="reference internal" href="../library/wave.html#wave.Wave_write.writeframes" title="wave.Wave_write.writeframes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">writeframes()</span></code></a> 方法将接受任意 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>。 （由 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=8311">bpo-8311</a> 中贡献。）</p>
</section>
<section id="weakref">
<h3 class="translated">weakref<a class="headerlink" href="#weakref" title="Link to this heading">¶</a></h3>
<p class="translated">新增的 <a class="reference internal" href="../library/weakref.html#weakref.WeakMethod" title="weakref.WeakMethod"><code class="xref py py-class docutils literal notranslate"><span class="pre">WeakMethod</span></code></a> 类可模拟指向绑定方法的弱引用。 （由 Antoine Pitrou 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=14631">bpo-14631</a> 中贡献。）</p>
<p class="translated">新增的 <a class="reference internal" href="../library/weakref.html#weakref.finalize" title="weakref.finalize"><code class="xref py py-class docutils literal notranslate"><span class="pre">finalize</span></code></a> 类使得注册一个当对象被作为垃圾回收时唤起的回调成为可能，而无需小心地管理弱引用本身的生命周期。 （由 Richard Oudkerk 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=15528">bpo-15528</a> 中贡献。）</p>
<p class="translated">如果存在任何与 <a class="reference internal" href="../library/weakref.html#weakref.ref" title="weakref.ref"><code class="xref py py-class docutils literal notranslate"><span class="pre">ref</span></code></a> 相关联的回调，现在将通过 <a class="reference internal" href="../library/weakref.html#weakref.ref.__callback__" title="weakref.ref.__callback__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__callback__</span></code></a> 属性对外公开。 （由 Mark Dickinson 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=17643">bpo-17643</a> 中贡献。）</p>
</section>
<section id="xml-etree">
<h3 class="translated">xml.etree<a class="headerlink" href="#xml-etree" title="Link to this heading">¶</a></h3>
<p class="translated">新增的解析器 <a class="reference internal" href="../library/xml.etree.elementtree.html#xml.etree.ElementTree.XMLPullParser" title="xml.etree.ElementTree.XMLPullParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLPullParser</span></code></a> 允许用非阻塞的应用程序来解析 XML 文档。 相关示例可参见 <a class="reference internal" href="../library/xml.etree.elementtree.html#elementtree-pull-parsing"><span class="std std-ref">用于非阻塞解析的拉取 API</span></a>。 （由 Antoine Pitrou 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=17741">bpo-17741</a> 中贡献。）</p>
<p class="translated">现在 <a class="reference internal" href="../library/xml.etree.elementtree.html#module-xml.etree.ElementTree" title="xml.etree.ElementTree: Implementation of the ElementTree API."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.ElementTree</span></code></a> <a class="reference internal" href="../library/xml.etree.elementtree.html#xml.etree.ElementTree.tostring" title="xml.etree.ElementTree.tostring"><code class="xref py py-func docutils literal notranslate"><span class="pre">tostring()</span></code></a> 和 <a class="reference internal" href="../library/xml.etree.elementtree.html#xml.etree.ElementTree.tostringlist" title="xml.etree.ElementTree.tostringlist"><code class="xref py py-func docutils literal notranslate"><span class="pre">tostringlist()</span></code></a> 函数，以及 <a class="reference internal" href="../library/xml.etree.elementtree.html#xml.etree.ElementTree.ElementTree" title="xml.etree.ElementTree.ElementTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementTree</span></code></a> 的 <a class="reference internal" href="../library/xml.etree.elementtree.html#xml.etree.ElementTree.ElementTree.write" title="xml.etree.ElementTree.ElementTree.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a> 方法都具有一个 <em>short_empty_elements</em> <a class="reference internal" href="../glossary.html#keyword-only-parameter"><span class="std std-ref">仅限关键字形参</span></a> 用来提供对于无内容的元素要采取缩写 (<code class="docutils literal notranslate"><span class="pre">&lt;tag</span> <span class="pre">/&gt;</span></code>) 还是扩展 (<code class="docutils literal notranslate"><span class="pre">&lt;tag&gt;&lt;/tag&gt;</span></code>) 形式的控制。 （由 Ariel Poliak 和 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=14377">bpo-14377</a> 中贡献。）</p>
</section>
<section id="zipfile">
<h3 class="translated">zipfile<a class="headerlink" href="#zipfile" title="Link to this heading">¶</a></h3>
<p class="translated"><a class="reference internal" href="../library/zipfile.html#zipfile.PyZipFile" title="zipfile.PyZipFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">PyZipFile</span></code></a> 类的 <a class="reference internal" href="../library/zipfile.html#zipfile.PyZipFile.writepy" title="zipfile.PyZipFile.writepy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">writepy()</span></code></a> 方法新增的 <em>filterfunc</em> 选项可用来控制要将哪些目录添加到归档中。 例如，可以用它将测试文件排除在归档之外。 （由 Christian Tismer 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19274">bpo-19274</a> 中贡献。）</p>
<p class="translated">现在 <a class="reference internal" href="../library/zipfile.html#zipfile.ZipFile" title="zipfile.ZipFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">ZipFile</span></code></a> 和 <a class="reference internal" href="../library/zipfile.html#zipfile.PyZipFile" title="zipfile.PyZipFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">PyZipFile</span></code></a> 的 <em>allowZip64</em> 形参默认值为 <code class="docutils literal notranslate"><span class="pre">True</span></code>。 （由 William Mallard 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=17201">bpo-17201</a> 中贡献。）</p>
</section>
</section>
<section id="cpython-implementation-changes">
<h2 class="translated">CPython 实现的变化<a class="headerlink" href="#cpython-implementation-changes" title="Link to this heading">¶</a></h2>
<section id="pep-445-customization-of-cpython-memory-allocators">
<span id="whatsnew-pep-445"></span><h3 class="translated">PEP 445: 自定义 CPython 内存分配器<a class="headerlink" href="#pep-445-customization-of-cpython-memory-allocators" title="Link to this heading">¶</a></h3>
<p class="translated"><span class="target" id="index-163"></span><a class="pep reference external" href="https://peps.python.org/pep-0445/"><strong>PEP 445</strong></a> 添加了新的 C 层级接口用来在 CPython 解释器中对内存分配进行自定义。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-164"></span><a class="pep reference external" href="https://peps.python.org/pep-0445/"><strong>PEP 445</strong></a> -- 新增用于自定义 Python 内存分配器的 API</dt><dd><p class="translated">PEP 由 Victor Stinner 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-442-safe-object-finalization">
<span id="whatsnew-pep-442"></span><h3 class="translated">PEP 442: 安全的对象最终化<a class="headerlink" href="#pep-442-safe-object-finalization" title="Link to this heading">¶</a></h3>
<p class="translated"><span class="target" id="index-165"></span><a class="pep reference external" href="https://peps.python.org/pep-0442/"><strong>PEP 442</strong></a> 移除了 CPython 中有关对象终结的限制和特殊处理。 有了它，具有 <a class="reference internal" href="../reference/datamodel.html#object.__del__" title="object.__del__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__del__()</span></code></a> 方法的对象，以及具有 <a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 子句的生成器在有循环引用的情况下也可以被最终化。</p>
<p class="translated">作为此项改变的一部分，大多数情况下在解释器关闭期间模块的全局变量不会被强制设为 <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>，而是取决于循环垃圾回收器的正常操作。 这避免了大量的解释器关闭时错误，这类错误通常都涉及 <code class="docutils literal notranslate"><span class="pre">__del__</span></code> 方法，它们自循环 GC 首次被引入起就一直困扰着 Python。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-166"></span><a class="pep reference external" href="https://peps.python.org/pep-0442/"><strong>PEP 442</strong></a> -- 安全的对象最终化</dt><dd><p class="translated">PEP 由 Antoine Pitrou 撰写并实现</p>
</dd>
</dl>
</div>
</section>
<section id="pep-456-secure-and-interchangeable-hash-algorithm">
<span id="whatsnew-pep-456"></span><h3 class="translated">PEP 456: 安全且可互换的哈希算法<a class="headerlink" href="#pep-456-secure-and-interchangeable-hash-algorithm" title="Link to this heading">¶</a></h3>
<p class="translated"><span class="target" id="index-167"></span><a class="pep reference external" href="https://peps.python.org/pep-0456/"><strong>PEP 456</strong></a> 在早先对 Python 的哈希算法所做安全修复上更进一步以解决特定的 DOS 攻击问题，以字典查找为基础的对外公开的 API 可能面临此种攻击。（请参阅 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=14621">bpo-14621</a> 了解此轮改进的缘起。） 该 PEP 统一了 CPython 的哈希代码以使打包者能更容易地用不同哈希算法进行替换，并在具有 64 位数据类型的平台上将 Python 的默认实现切换为 SipHash 实现。 与旧版 FNV 算法相比只有很小的性能差异。</p>
<p class="translated">该 PEP 向 <a class="reference internal" href="../library/sys.html#sys.hash_info" title="sys.hash_info"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.hash_info</span></code></a> 具名元组添加了额外字段来描述当前正在执行的二进制文件所使用的哈希算法。 除此之外，该 PEP 没有改变任何现有的 CPython API。</p>
</section>
<section id="pep-436-argument-clinic">
<span id="whatsnew-pep-436"></span><h3 class="translated">PEP 436: Argument Clinic<a class="headerlink" href="#pep-436-argument-clinic" title="Link to this heading">¶</a></h3>
<p class="translated">现在 &quot;Argument Clinic&quot; (<span class="target" id="index-168"></span><a class="pep reference external" href="https://peps.python.org/pep-0436/"><strong>PEP 436</strong></a>) 是 CPython 构建过程的一部分并可被用于简化为内置对象和以 C 实现的标准库扩展模块定义和维护准确签名的过程。</p>
<p class="translated">在 Python 3.4 中有一些标准库模块已被转换为使用 Argument Clinic，而 <a class="reference internal" href="../library/pydoc.html#module-pydoc" title="pydoc: Documentation generator and online help system."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code></a> 和 <a class="reference internal" href="../library/inspect.html#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect</span></code></a> 也进行了相应的更新。</p>
<p class="translated">预期针对程序化内省的签名元数据将被添加到更多的以 C 实现的可调用对象中作为 Python 3.4 维护发布版的组成部分。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p class="translated">Argument Clinic PEP 尚未完整更新到与具体实现的状态相一致。 这种情况被发布版管理者和核心开发团队认为是可接受的，因为 Argument Clinic 在 Python 3.4 中将不会作为公有 API 提供给第三方。</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-50"></span><a class="pep reference external" href="https://peps.python.org/pep-0436/"><strong>PEP 436</strong></a> -- The Argument Clinic DSL</dt><dd><p class="translated">PEP 由 Larry Hastings 撰写并实现</p>
</dd>
</dl>
</div>
</section>
<section id="other-build-and-c-api-changes">
<h3 class="translated">其他的构建和 C API 的改变<a class="headerlink" href="#other-build-and-c-api-changes" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p class="translated">新的 <a class="reference internal" href="../c-api/type.html#c.PyType_GetSlot" title="PyType_GetSlot"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyType_GetSlot()</span></code></a> 函数已被添加到稳定 ABI，以允许在使用受限 API 时从指定的类型槽位提取函数指针。 （由 Martin von Löwis 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=17162">bpo-17162</a> 中贡献。）</p></li>
<li><p class="translated">新的 <code class="xref c c-func docutils literal notranslate"><span class="pre">Py_SetStandardStreamEncoding()</span></code> 预初始化 API 允许嵌入了 CPython 解释器的应用程序为标准流可靠地强制设置特定的编码格式和错误处理器。 （由 Bastien Montagne 和 Nick Coghlan 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16129">bpo-16129</a> 中贡献。）</p></li>
<li><p class="translated">大多数不修改字符串参数的 Python C API 现在已被正确地标记为接受 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code>。 （由 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1772673">bpo-1772673</a> 中贡献。）</p></li>
<li><p class="translated">一个新的 <code class="docutils literal notranslate"><span class="pre">python-config</span></code> 的 shell 版本即使在 python 解释器不可用时仍可被使用（例如，在交叉编译的场景中）。</p></li>
<li><p class="translated">现在 <a class="reference internal" href="../c-api/unicode.html#c.PyUnicode_FromFormat" title="PyUnicode_FromFormat"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyUnicode_FromFormat()</span></code></a> 支持为 <code class="docutils literal notranslate"><span class="pre">%s</span></code>, <code class="docutils literal notranslate"><span class="pre">%A</span></code>, <code class="docutils literal notranslate"><span class="pre">%U</span></code>, <code class="docutils literal notranslate"><span class="pre">%V</span></code>, <code class="docutils literal notranslate"><span class="pre">%S</span></code> 和 <code class="docutils literal notranslate"><span class="pre">%R</span></code> 使用宽度和精度说明符。 （由 Ysj Ray 和 Victor Stinner 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7330">bpo-7330</a> 中贡献。）</p></li>
<li><p class="translated">新的函数 <a class="reference internal" href="../c-api/tuple.html#c.PyStructSequence_InitType2" title="PyStructSequence_InitType2"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyStructSequence_InitType2()</span></code></a> 为现有的 <a class="reference internal" href="../c-api/tuple.html#c.PyStructSequence_InitType" title="PyStructSequence_InitType"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyStructSequence_InitType()</span></code></a> 函数提供了补充。 其不同之处在于它会在成功时返回 <code class="docutils literal notranslate"><span class="pre">0</span></code> 而在失败时返回 <code class="docutils literal notranslate"><span class="pre">-1</span></code>。</p></li>
<li><p class="translated">现在 CPython 源代码可以使用最近版本的 GCC 和 clang 的地址确定性检查特性进行编译：小对象分配器中的假警报已被消除。 （由 Dhiru Kholia 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18596">bpo-18596</a> 中贡献。）</p></li>
<li><p class="translated">Windows 构建版现在会使用 <a class="reference external" href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">寻址空间布局随机化</a> 和 <a class="reference external" href="https://en.wikipedia.org/wiki/Data_Execution_Prevention">数据执行保护</a>。 （由 Christian Heimes 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16632">bpo-16632</a> 中贡献。）</p></li>
<li><p class="translated">新的函数 <a class="reference internal" href="../c-api/object.html#c.PyObject_LengthHint" title="PyObject_LengthHint"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_LengthHint()</span></code></a> 是 <a class="reference internal" href="../library/operator.html#operator.length_hint" title="operator.length_hint"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.length_hint()</span></code></a> 的 C API 等价形式。 （由 Armin Ronacher 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16148">bpo-16148</a> 中贡献。）</p></li>
</ul>
</section>
<section id="other-improvements">
<span id="other-improvements-3-4"></span><h3 class="translated">其他改进<a class="headerlink" href="#other-improvements" title="Link to this heading">¶</a></h3>
<ul class="simple" id="whatsnew-isolated-mode">
<li><p class="translated"><a class="reference internal" href="../using/cmdline.html#using-on-cmdline"><span class="std std-ref">python</span></a> 命令增加了一个新的 <a class="reference internal" href="../using/cmdline.html#using-on-misc-options"><span class="std std-ref">选项</span></a> <code class="docutils literal notranslate"><span class="pre">-I</span></code>，将使其运行于“隔离模式”，即 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 将不包含脚本的目录和用户的 <code class="docutils literal notranslate"><span class="pre">site-packages</span></code> 目录，并且所有 <code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHON*</span></code> 环境变量都将被忽略（相当于 <code class="docutils literal notranslate"><span class="pre">-s</span></code> 和 <code class="docutils literal notranslate"><span class="pre">-E</span></code> 同时启用）。 未来还可能会应用其他的限制，其目的是将脚本执行与用户的环境隔离开来。 举例来说，当 Python 被用于运行系统脚本时此模式将是适当的。 在大多数 POSIX 系统上它可以并且应当在系统脚本的 <code class="docutils literal notranslate"><span class="pre">#!</span></code> 行中使用。 （由 Christian Heimes 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16499">bpo-16499</a> 中贡献。）</p></li>
<li><p class="translated">在支持 <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">readline</span></code></a> 的系统上的交互模式中现在将默认启用 Tab 键补全。 历史记录也将默认启用，并会写入到 <code class="file docutils literal notranslate"><span class="pre">~/.python-history</span></code> 文件（也会从中读取）。 （由 Antoine Pitrou 和 Éric Araujo 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5845">bpo-5845</a> 中贡献。）</p></li>
<li><p class="translated">现在附带 <code class="docutils literal notranslate"><span class="pre">--version</span></code> 唤起 Python 解释器将会把版本信息输出到标准输出而不是标准错误 (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18338">bpo-18338</a>)。 对于 <a class="reference internal" href="../library/argparse.html#module-argparse" title="argparse: Command-line option and argument parsing library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">argparse</span></code></a> (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18920">bpo-18920</a>) 和其他具有脚本类唤起功能的模块也做了类似的修改 (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18922">bpo-18922</a>)。</p></li>
<li><p class="translated">现在 CPython Windows 安装程序会在注册扩展名时将 <code class="docutils literal notranslate"><span class="pre">.py</span></code> 添加到 <span class="target" id="index-169"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PATHEXT</span></code> 变量，以允许用户在 windows 命令提示符下直接键入不带 <code class="docutils literal notranslate"><span class="pre">.py</span></code> 扩展名的 python 脚本名称来运行它。 （由 Paul Moore 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18569">bpo-18569</a> 中贡献。）</p></li>
<li><p class="translated">新的 <code class="docutils literal notranslate"><span class="pre">make</span></code> 目标 <a class="reference external" href="https://devguide.python.org/coverage/#measuring-coverage-of-c-code-with-gcov-and-lcov">coverage-report</a> 将使用 <code class="docutils literal notranslate"><span class="pre">gcov</span></code> 和 <a class="reference external" href="https://github.com/linux-test-project/lcov">lcov</a> 基于 C 代码库构建 python，运行测试套件并生成 HTML 消息报告。</p></li>
<li><p class="translated">现在 <a class="reference internal" href="../library/test.html#regrtest"><span class="std std-ref">python 回归测试套件</span></a> 的 <code class="docutils literal notranslate"><span class="pre">-R</span></code> 选项还将使用 <a class="reference internal" href="../library/sys.html#sys.getallocatedblocks" title="sys.getallocatedblocks"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getallocatedblocks()</span></code></a> 来检查内存分配泄漏。 （由 Antoine Pitrou 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=13390">bpo-13390</a> 中贡献。）</p></li>
<li><p class="translated">现在 <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-m</span></code> 将可用于命名空间包。</p></li>
<li><p class="translated">现在 <a class="reference internal" href="../library/stat.html#module-stat" title="stat: Utilities for interpreting the results of os.stat(), os.lstat() and os.fstat()."><code class="xref py py-mod docutils literal notranslate"><span class="pre">stat</span></code></a> 模块是用 C 实现的，这意味着它将从 C 头文件中获取其常量值，而不是像之前版本中那样将值码编码在 python 模块中。</p></li>
<li><p class="translated">现在将能够正确地从单个 OS 模块加载多个 (<code class="docutils literal notranslate"><span class="pre">.so</span></code>, <code class="docutils literal notranslate"><span class="pre">.dll</span></code>) python 模块（在之前版本中则会静默地返回文件中的第一个 python 模块）。 （由 Václav Šmilauer 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16421">bpo-16421</a> 中贡献。）</p></li>
<li><p class="translated">增加了新的操作码 <code class="xref std std-opcode docutils literal notranslate"><span class="pre">LOAD_CLASSDEREF</span></code> 用来修复一个在类体中加载自由变量时的程序缺陷，它可能因 <a class="reference internal" href="../reference/datamodel.html#prepare"><span class="std std-ref">__prepare__</span></a> 的特定用法而被触发。 （由 Benjamin Peterson 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=17853">bpo-17853</a> 中贡献。）</p></li>
<li><p class="translated">多个有关 MemoryError 的崩溃问题被 Victor Stinner 使用他基于 <span class="target" id="index-170"></span><a class="pep reference external" href="https://peps.python.org/pep-0445/"><strong>PEP 445</strong></a> 的 <code class="docutils literal notranslate"><span class="pre">pyfailmalloc</span></code> 工具加以确定并修复 (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18408">bpo-18408</a>, <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18520">bpo-18520</a>)。</p></li>
<li><p class="translated">现在 <code class="docutils literal notranslate"><span class="pre">pyvenv</span></code> 命令接受一个 <code class="docutils literal notranslate"><span class="pre">--copies</span></code> 选项以使用拷贝而不是符号链接，即使在默认使用符号链接的系统上也是如此。 （由 Vinay Sajip 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18807">bpo-18807</a> 中贡献。）</p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">pyvenv</span></code> 命令也接受一个 <code class="docutils literal notranslate"><span class="pre">--without-pip</span></code> 选项用来抑制在其他情况下将自动将 pip 初始设置到虚拟环境中。 （作为 <span class="target" id="index-171"></span><a class="pep reference external" href="https://peps.python.org/pep-0453/"><strong>PEP 453</strong></a> 实现的一部分由 Nick Coghlan 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19552">bpo-19552</a> 中贡献。）</p></li>
<li><p class="translated">现在编码格式名称在 <span class="target" id="index-172"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONIOENCODING"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONIOENCODING</span></code></a> 环境变量的设置值中将为可选项。 这使得只设置错误处理器而不改变默认编码格式成为可能。 （由 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18818">bpo-18818</a> 中贡献。）</p></li>
<li><p class="translated">现在 <a class="reference internal" href="../library/bz2.html#module-bz2" title="bz2: Interfaces for bzip2 compression and decompression."><code class="xref py py-mod docutils literal notranslate"><span class="pre">bz2</span></code></a>, <a class="reference internal" href="../library/lzma.html#module-lzma" title="lzma: A Python wrapper for the liblzma compression library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">lzma</span></code></a>, and <a class="reference internal" href="../library/gzip.html#module-gzip" title="gzip: Interfaces for gzip compression and decompression using file objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gzip</span></code></a> 模块的 <code class="docutils literal notranslate"><span class="pre">open</span></code> 函数已支持 <code class="docutils literal notranslate"><span class="pre">x</span></code> (独占式创建) 模式。 （由 Tim Heaney 和 Vajrasky Kok 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19201">bpo-19201</a>, <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19222">bpo-19222</a> 和 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19223">bpo-19223</a> 中贡献。）</p></li>
</ul>
</section>
<section id="significant-optimizations">
<h3 class="translated">显著的优化<a class="headerlink" href="#significant-optimizations" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p class="translated">现在 UTF-32 解码器获得了 3x 至 4x 的提速。 （由 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=14625">bpo-14625</a> 中贡献。）</p></li>
<li><p class="translated">针对集合的哈希碰撞的耗费现在已被降低。 每次哈希表检测现在会先检查一系列连续的、相邻的键/哈希值对再继续对整个哈希表执行随机检测。 这将利用缓存本地化来使得碰撞求解付出较少代价。 这种碰撞求解方案可被描述为线性检测和开放寻址的结合。 额外的线性检测数默认为九次。 这可以在编译时通过将 LINEAR_PROBES 定义为任意值来修改。 设置 LINEAR_PROBES=0 可完全关闭线性检测。 （由 Raymond Hettinger 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18771">bpo-18771</a> 中贡献。）</p></li>
<li><p class="translated">解释器启动速度加快了约 30%。 多项措施促成了此次加速。 解释器在启动时加载的模块有所减少，例如 <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a>, <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 和 <a class="reference internal" href="../library/locale.html#module-locale" title="locale: Internationalization services."><code class="xref py py-mod docutils literal notranslate"><span class="pre">locale</span></code></a> 模块及其依赖默认不再被导入。 marshal 模块得到改进以便更快速地加载已编译的 Python 代码。 （由 Antoine Pitrou, Christian Heimes 和 Victor Stinner 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19219">bpo-19219</a>, <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19218">bpo-19218</a>, <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19209">bpo-19209</a>, <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19205">bpo-19205</a> 和 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=9548">bpo-9548</a> 中贡献。）</p></li>
<li><p class="translated">现在 <a class="reference internal" href="../library/bz2.html#bz2.BZ2File" title="bz2.BZ2File"><code class="xref py py-class docutils literal notranslate"><span class="pre">bz2.BZ2File</span></code></a> 在多数情况下相比 Python2 版本速度都一样快更快或。 <a class="reference internal" href="../library/lzma.html#lzma.LZMAFile" title="lzma.LZMAFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">lzma.LZMAFile</span></code></a> 也获得了优化。 （由 Serhiy Storchaka 和 Nadeem Vawda 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16034">bpo-16034</a> 中贡献。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/random.html#random.getrandbits" title="random.getrandbits"><code class="xref py py-func docutils literal notranslate"><span class="pre">random.getrandbits()</span></code></a> 对于小整数（最常见的应用场景）可加速 20%-40%。 （由 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16674">bpo-16674</a> 中贡献。）</p></li>
<li><p class="translated">得益于字符串的新存储格式，对字符串执行 pickle 操作现在将有明显加速。 （由 Victor Stinner 和 Antoine Pitrou 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=15596">bpo-15596</a> 中贡献。）</p></li>
<li><p class="translated">一个 <code class="xref py py-meth docutils literal notranslate"><span class="pre">io.FileIO.readall()</span></code> 中的性能问题已被解决。 这对 Windows 有更具体的情况，将显著地提升通过 <a class="reference internal" href="../library/subprocess.html#module-subprocess" title="subprocess: Subprocess management."><code class="xref py py-mod docutils literal notranslate"><span class="pre">subprocess</span></code></a> 以管道方式传递大量数据这一应用场景下的速度。 （由 Richard Oudkerk 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=15758">bpo-15758</a> 中贡献。）</p></li>
<li><p class="translated">现在 <a class="reference internal" href="../library/html.html#html.escape" title="html.escape"><code class="xref py py-func docutils literal notranslate"><span class="pre">html.escape()</span></code></a> 获得了 10x 速度提升。 （由 Matt Bryant 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18020">bpo-18020</a> 中贡献。）</p></li>
<li><p class="translated">在 Windows 上，现在将使用原生的 <code class="docutils literal notranslate"><span class="pre">VirtualAlloc</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">obmalloc</span></code> 中的 CRT <code class="docutils literal notranslate"><span class="pre">malloc</span></code>。 人工基准测试显示可节省约 3% 的内存。</p></li>
<li><p class="translated">现在 <a class="reference internal" href="../library/os.html#os.urandom" title="os.urandom"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.urandom()</span></code></a> 会使用延迟打开的持久性文件描述符以避免在从多个线程并行时使用过多的文件描述符。 （由 Antoine Pitrou 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18756">bpo-18756</a> 中贡献。）</p></li>
</ul>
</section>
</section>
<section id="deprecated">
<span id="deprecated-3-4"></span><h2 class="translated">弃用<a class="headerlink" href="#deprecated" title="Link to this heading">¶</a></h2>
<p class="translated">本小节列出了已在 Python 3.4 中弃用，并将在 Python 3.5 或之后的版本中移除的各种 API 和其他特性。 在大多数（但并非全部）情况下，在解释器运行时设置了弃用警告时（例如通过使用 <code class="docutils literal notranslate"><span class="pre">-Wd</span></code> 选项）使用已弃用的 API 将产生 <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a>。</p>
<section id="deprecations-in-the-python-api">
<h3 class="translated">Python API 中的弃用<a class="headerlink" href="#deprecations-in-the-python-api" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p class="translated">正如 <a class="reference internal" href="#whatsnew-pep-451"><span class="std std-ref">PEP 451: 针对导入系统的 ModuleSpec 类型</span></a> 所提及的，<a class="reference internal" href="../library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a> 中的多个方法和函数已被弃用: <code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.find_loader()</span></code> 被 <a class="reference internal" href="../library/importlib.html#importlib.util.find_spec" title="importlib.util.find_spec"><code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.find_spec()</span></code></a> 替代; <code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.machinery.PathFinder.find_module()</span></code> 被 <a class="reference internal" href="../library/importlib.html#importlib.machinery.PathFinder.find_spec" title="importlib.machinery.PathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.machinery.PathFinder.find_spec()</span></code></a> 替代; <code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder.find_module()</span></code> 被 <a class="reference internal" href="../library/importlib.html#importlib.abc.MetaPathFinder.find_spec" title="importlib.abc.MetaPathFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.MetaPathFinder.find_spec()</span></code></a> 替代; <code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.PathEntryFinder.find_loader()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">find_module()</span></code> 被 <a class="reference internal" href="../library/importlib.html#importlib.abc.PathEntryFinder.find_spec" title="importlib.abc.PathEntryFinder.find_spec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.PathEntryFinder.find_spec()</span></code></a> 替代; 所有的 <code class="samp docutils literal notranslate"><em><span class="pre">xxx</span></em><span class="pre">Loader</span></code> ABC <code class="docutils literal notranslate"><span class="pre">load_module</span></code> 方法 (<code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.load_module()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader.load_module()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.FileLoader.load_module()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader.load_module()</span></code>) 应当不再被实现，加载器应当改为实现 <code class="docutils literal notranslate"><span class="pre">exec_module</span></code> 方法 (<a class="reference internal" href="../library/importlib.html#importlib.abc.Loader.exec_module" title="importlib.abc.Loader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.exec_module()</span></code></a>, <a class="reference internal" href="../library/importlib.html#importlib.abc.InspectLoader.exec_module" title="importlib.abc.InspectLoader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.InspectLoader.exec_module()</span></code></a> <a class="reference internal" href="../library/importlib.html#importlib.abc.SourceLoader.exec_module" title="importlib.abc.SourceLoader.exec_module"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader.exec_module()</span></code></a>) 并让导入系统处理其余的操作; 而 <code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.Loader.module_repr()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.util.module_for_loader()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.util.set_loader()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.util.set_package()</span></code> 已不再需要因为它们的功能现在将由导入系统自动处理。</p></li>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">imp</span></code> 模块已被弃用。 为保持与 Python 2/3 基础代码的兼容性，目前还没有移除该模块的计划。</p></li>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">formatter</span></code> 模块已被弃用并计划在 Python 3.6 中移除。</p></li>
<li><p class="translated">将 <code class="docutils literal notranslate"><span class="pre">MD5</span></code> 作为 <a class="reference internal" href="../library/hmac.html#hmac.new" title="hmac.new"><code class="xref py py-func docutils literal notranslate"><span class="pre">hmac.new()</span></code></a> 函数的默认 <em>digestmod</em> 的设置已被弃用。 Python 3.6 将要求以一个显式的摘要名称或构造器作为 <em>digestmod</em> 参数。</p></li>
<li><p class="translated">很长一段时间以来 <a class="reference internal" href="../library/ftplib.html#module-ftplib" title="ftplib: FTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ftplib</span></code></a> 模块中的内部 <code class="docutils literal notranslate"><span class="pre">Netrc</span></code> 类在其文档字符串中被声明为已弃用。 现在它将发出 <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a> 并将在 Python 3.5 中完全移除。</p></li>
<li><p class="translated">传给 <a class="reference internal" href="../library/subprocess.html#subprocess.Popen.wait" title="subprocess.Popen.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subprocess.Popen.wait()</span></code></a> 的未写入文档的 <em>endtime</em> 参数不应被公开也不应被使用；它已被弃用并很可能在 Python 3.5 中移除。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/html.parser.html#html.parser.HTMLParser" title="html.parser.HTMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTMLParser</span></code></a> 的 <em>strict</em> 参数已被弃用。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/plistlib.html#module-plistlib" title="plistlib: Generate and parse Apple plist files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">plistlib</span></code></a> <code class="xref py py-func docutils literal notranslate"><span class="pre">readPlist()</span></code>、<code class="xref py py-func docutils literal notranslate"><span class="pre">writePlist()</span></code>、<code class="xref py py-func docutils literal notranslate"><span class="pre">readPlistFromBytes()</span></code> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">writePlistToBytes()</span></code> 等函数已被弃用，应改用相应的新函数 <a class="reference internal" href="../library/plistlib.html#plistlib.load" title="plistlib.load"><code class="xref py py-func docutils literal notranslate"><span class="pre">load()</span></code></a>、 <a class="reference internal" href="../library/plistlib.html#plistlib.dump" title="plistlib.dump"><code class="xref py py-func docutils literal notranslate"><span class="pre">dump()</span></code></a>、 <a class="reference internal" href="../library/plistlib.html#plistlib.loads" title="plistlib.loads"><code class="xref py py-func docutils literal notranslate"><span class="pre">loads()</span></code></a> 和 <a class="reference internal" href="../library/plistlib.html#plistlib.dumps" title="plistlib.dumps"><code class="xref py py-func docutils literal notranslate"><span class="pre">dumps()</span></code></a>。 <code class="xref py py-func docutils literal notranslate"><span class="pre">Data()</span></code> 已被弃用，应直接使用 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 构造器。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/sysconfig.html#module-sysconfig" title="sysconfig: Python's configuration information"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sysconfig</span></code></a> 的键 <code class="docutils literal notranslate"><span class="pre">SO</span></code> 已被弃用，它已被 <code class="docutils literal notranslate"><span class="pre">EXT_SUFFIX</span></code> 所替代。</p></li>
<li><p class="translated">各种 <code class="docutils literal notranslate"><span class="pre">open</span></code> 函数所接受的 <code class="docutils literal notranslate"><span class="pre">U</span></code> 模式已被弃用。 在 Python3 中它已不再有任何实际作用，并应当改用适当的 <a class="reference internal" href="../library/io.html#io.TextIOWrapper" title="io.TextIOWrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.TextIOWrapper</span></code></a> (如有必要) 及其 <em>newline</em> 参数。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/xml.etree.elementtree.html#xml.etree.ElementTree.iterparse" title="xml.etree.ElementTree.iterparse"><code class="xref py py-func docutils literal notranslate"><span class="pre">xml.etree.ElementTree.iterparse()</span></code></a> 的 <em>parser</em> 参数，就如 <a class="reference internal" href="../library/xml.etree.elementtree.html#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-func docutils literal notranslate"><span class="pre">XMLParser()</span></code></a> 的 <em>html</em> 参数一样。 要对后者的移除做好准备，所有 <code class="docutils literal notranslate"><span class="pre">XMLParser</span></code> 的参数都应当以关键字形式传入。</p></li>
</ul>
</section>
<section id="deprecated-features">
<h3 class="translated">弃用的特性<a class="headerlink" href="#deprecated-features" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p class="translated">运行 <a class="reference internal" href="../library/idle.html#idle"><span class="std std-ref">IDLE --- Python 编辑器和 shell</span></a> 时附带 <code class="docutils literal notranslate"><span class="pre">-n</span></code> 旗标（无子进程）的做法已被弃用。 但是，该特性在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18823">bpo-18823</a> 解决之前将不会被移除。</p></li>
<li><p class="translated">site 模块在 &quot;site-python&quot; 目录存在的情况下 sys.path 添加该目录的做法已被弃用 (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19375">bpo-19375</a>)。</p></li>
</ul>
</section>
</section>
<section id="removed">
<h2 class="translated">移除<a class="headerlink" href="#removed" title="Link to this heading">¶</a></h2>
<section id="operating-systems-no-longer-supported">
<h3 class="translated">不再支持的操作系统<a class="headerlink" href="#operating-systems-no-longer-supported" title="Link to this heading">¶</a></h3>
<p class="translated">从源代码和构建工具中删除了对以下操作系统的支持：</p>
<ul class="simple">
<li><p class="translated">OS/2 (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16135">bpo-16135</a>).</p></li>
<li><p class="translated">Windows 2000（变更集e52df05b496a）。</p></li>
<li><p class="translated">Windows系统中 <code class="docutils literal notranslate"><span class="pre">COMSPEC</span></code> 指向 <code class="docutils literal notranslate"><span class="pre">command.com</span></code> 的版本（ <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=14470">bpo-14470</a> ）。</p></li>
<li><p class="translated">VMS (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16136">bpo-16136</a>).</p></li>
</ul>
</section>
<section id="api-and-feature-removals">
<h3 class="translated">API 与特性的移除<a class="headerlink" href="#api-and-feature-removals" title="Link to this heading">¶</a></h3>
<p class="translated">以下过时并在之前版本中弃用的 API 和特性现已被移除：</p>
<ul class="simple">
<li><p class="translated">不再继续维护的 <code class="docutils literal notranslate"><span class="pre">Misc/TextMate</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Misc/vim</span></code> 目录已被移除（请参阅 <a class="reference external" href="https://devguide.python.org">devguide</a> 了解相关替代器的使用建议）。</p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">SO</span></code> makefile 宏已被移除（被 <code class="docutils literal notranslate"><span class="pre">SHLIB_SUFFIX</span></code> 和 <code class="docutils literal notranslate"><span class="pre">EXT_SUFFIX</span></code> 宏所替代） (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16754">bpo-16754</a>)。</p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">PyThreadState.tick_counter</span></code> 字段已被移除；该字段值自 Python 3.2 即 &quot;新 GIL&quot; 被引入时起就不再有意义了 (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19199">bpo-19199</a>)。</p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">PyLoader</span></code> 和 <code class="docutils literal notranslate"><span class="pre">PyPycLoader</span></code> 已从 <a class="reference internal" href="../library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a> 中移除。 （由 Taras Lyapun 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=15641">bpo-15641</a> 中贡献。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/http.client.html#http.client.HTTPConnection" title="http.client.HTTPConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPConnection</span></code></a> 和 <a class="reference internal" href="../library/http.client.html#http.client.HTTPSConnection" title="http.client.HTTPSConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPSConnection</span></code></a> 的 <em>strict</em> 参数已被移除。 HTTP 0.9 风格的 &quot;简单响应&quot; 不再受到支持。</p></li>
<li><p class="translated">被弃用的 <a class="reference internal" href="../library/urllib.request.html#urllib.request.Request" title="urllib.request.Request"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request.Request</span></code></a> 读取和设置方法 <code class="docutils literal notranslate"><span class="pre">add_data</span></code>, <code class="docutils literal notranslate"><span class="pre">has_data</span></code>, <code class="docutils literal notranslate"><span class="pre">get_data</span></code>, <code class="docutils literal notranslate"><span class="pre">get_type</span></code>, <code class="docutils literal notranslate"><span class="pre">get_host</span></code>, <code class="docutils literal notranslate"><span class="pre">get_selector</span></code>, <code class="docutils literal notranslate"><span class="pre">set_proxy</span></code>, <code class="docutils literal notranslate"><span class="pre">get_origin_req_host</span></code> 和 <code class="docutils literal notranslate"><span class="pre">is_unverifiable</span></code> 已被移除（请改为直接属性访问）。</p></li>
<li><p class="translated">对加载已弃用的 <code class="docutils literal notranslate"><span class="pre">TYPE_INT64</span></code> 的支持已从 <a class="reference internal" href="../library/marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">marshal</span></code></a> 中被移除。 （由 Dan Riti 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=15480">bpo-15480</a> 中贡献。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/inspect.html#inspect.Signature" title="inspect.Signature"><code class="xref py py-class docutils literal notranslate"><span class="pre">inspect.Signature</span></code></a>: 仅限位置形参现在需要有一个合法的名称。</p></li>
<li><p class="translated"><a class="reference internal" href="../reference/datamodel.html#object.__format__" title="object.__format__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__format__()</span></code></a> 不再接受非空格式字符串，它现在会改为引发 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。 使用非空字符串自 Python 3.2 起已被弃用。 做出此项改变是为了防止当对象获得 __format__ 方法时之前可用（但不正确）的代码执行失败的情况，这意味着现在当你对没有用于处理 <code class="docutils literal notranslate"><span class="pre">'s'</span></code> 的 __format__ 方法的对象使用该格式代码时你的代码可能会引发 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。 请参阅 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7994">bpo-7994</a> 了解相关背景。</p></li>
<li><p class="translated"><code class="xref py py-meth docutils literal notranslate"><span class="pre">difflib.SequenceMatcher.isbjunk()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">difflib.SequenceMatcher.isbpopular()</span></code> 已在 3.2 中被弃用，现在已被移除：请使用 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">sm.bjunk</span></code> 和 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">sm.bpopular</span></code>，其中 <em>sm</em> 是一个 <a class="reference internal" href="../library/difflib.html#difflib.SequenceMatcher" title="difflib.SequenceMatcher"><code class="xref py py-class docutils literal notranslate"><span class="pre">SequenceMatcher</span></code></a> 对象 (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=13248">bpo-13248</a>)。</p></li>
</ul>
</section>
<section id="code-cleanups">
<h3 class="translated">代码清理<a class="headerlink" href="#code-cleanups" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p class="translated">未被使用并且未写入文档的内部 <code class="docutils literal notranslate"><span class="pre">Scanner</span></code> 类已从 <a class="reference internal" href="../library/pydoc.html#module-pydoc" title="pydoc: Documentation generator and online help system."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code></a> 模块中移除。</p></li>
<li><p class="translated">私有并且实际未使用的 <code class="docutils literal notranslate"><span class="pre">_gestalt</span></code> 模块已被移除，同时移除了私有的 <a class="reference internal" href="../library/platform.html#module-platform" title="platform: Retrieves as much platform identifying data as possible."><code class="xref py py-mod docutils literal notranslate"><span class="pre">platform</span></code></a> 函数 <code class="docutils literal notranslate"><span class="pre">_mac_ver_lookup</span></code>, <code class="docutils literal notranslate"><span class="pre">_mac_ver_gstalt</span></code> 和 <code class="docutils literal notranslate"><span class="pre">_bcd2str</span></code>，它们仅会在严重过时的 OSX 系统上被调用 (参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18393">bpo-18393</a>)。</p></li>
<li><p class="translated">曾经包括于 <a class="reference internal" href="../library/tarfile.html#module-tarfile" title="tarfile: Read and write tar-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tarfile</span></code></a> 模块命名空间的某些 <a class="reference internal" href="../library/stat.html#module-stat" title="stat: Utilities for interpreting the results of os.stat(), os.lstat() and os.fstat()."><code class="xref py py-mod docutils literal notranslate"><span class="pre">stat</span></code></a> 常量的硬编码副本已被移除。</p></li>
</ul>
</section>
</section>
<section id="porting-to-python-3-4">
<h2 class="translated">移植到 Python 3.4<a class="headerlink" href="#porting-to-python-3-4" title="Link to this heading">¶</a></h2>
<p class="translated">本节列出了先前描述的更改以及可能需要更改代码的其他错误修正.</p>
<section id="changes-in-python-command-behavior">
<h3 class="translated"> 'python' 命令行为的变化<a class="headerlink" href="#changes-in-python-command-behavior" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p class="translated">在 posix shell 中，将 <span class="target" id="index-173"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PATH</span></code> 环境变量设为空值就等于完全不设置。 不过，将 <span class="target" id="index-174"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONPATH"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONPATH</span></code></a> 设为空值则 <em>不等于</em> 完全不设置：将 <span class="target" id="index-175"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONPATH"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONPATH</span></code></a> 设为空值等于将其设为 <code class="docutils literal notranslate"><span class="pre">.</span></code>，这在类 <span class="target" id="index-176"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PATH</span></code> 运作方式来进行理解时会导致困惑。 现在的行为将与 posix 中 <span class="target" id="index-177"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PATH</span></code> 的惯例保持一致。</p></li>
<li><p class="translated">现在 CPython 解释器的调试构建版 (<code class="docutils literal notranslate"><span class="pre">--with-pydebug</span></code>) 的 [X refs, Y blocks] 输出默认将关闭。 可以使用 <code class="docutils literal notranslate"><span class="pre">-X</span> <span class="pre">showrefcount</span></code> 选项来重新启用它。 （由 Ezio Melotti 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=17323">bpo-17323</a> 中贡献。）</p></li>
<li><p class="translated">现在 python 命令和大多数标准库脚本（和 <a class="reference internal" href="../library/argparse.html#module-argparse" title="argparse: Command-line option and argument parsing library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">argparse</span></code></a> 一样）会将 <code class="docutils literal notranslate"><span class="pre">--version</span></code> 信息输出到 <code class="docutils literal notranslate"><span class="pre">stdout</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">stderr</span></code> (相关问题列表参见上面的 <a class="reference internal" href="#other-improvements-3-4"><span class="std std-ref">其他改进</span></a>)。</p></li>
</ul>
</section>
<section id="changes-in-the-python-api">
<h3 class="translated">Python API 的变化<a class="headerlink" href="#changes-in-the-python-api" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p class="translated">在 <a class="reference internal" href="../library/importlib.html#module-importlib.abc" title="importlib.abc: Abstract base classes related to import"><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib.abc</span></code></a> 中定义的 ABC 现在将会引发适当的异常或是返回默认值而不是无脑引发 <a class="reference internal" href="../library/exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a>。 这将只影响调用 <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a> 并一路下落到这些 ABC 的代码。 为保持兼容性，<a class="reference internal" href="../library/exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 和所需的相应异常都要被捕获。</p></li>
<li><p class="translated">模块类型现在默认会将 <a class="reference internal" href="../reference/datamodel.html#module.__package__" title="module.__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a> 和 <a class="reference internal" href="../reference/datamodel.html#module.__loader__" title="module.__loader__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__loader__</span></code></a> 属性初始化为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。 要确定这些属性是否以向下兼容的方式被设置，可使用像 <code class="docutils literal notranslate"><span class="pre">getattr(module,</span> <span class="pre">'__loader__',</span> <span class="pre">None)</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None</span></code> 这样的写法。 (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=17115">bpo-17115</a>。)</p></li>
<li><p class="translated">现在 <code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.util.module_for_loader()</span></code> 会无条件地设置 <code class="docutils literal notranslate"><span class="pre">__loader__</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__package__</span></code> 以正确地支持重加载。 如果不希望如此那么你将需要手动设置这些属性。 你可以使用 <code class="xref py py-func docutils literal notranslate"><span class="pre">importlib.util.module_to_load()</span></code> 进行模块管理。</p></li>
<li><p class="translated">当重载时 import 操作现在会无条件地重置相关属性 (例如 <code class="docutils literal notranslate"><span class="pre">__name__</span></code>, <code class="docutils literal notranslate"><span class="pre">__loader__</span></code>, <code class="docutils literal notranslate"><span class="pre">__package__</span></code>, <code class="docutils literal notranslate"><span class="pre">__file__</span></code>, <code class="docutils literal notranslate"><span class="pre">__cached__</span></code>)。 请注意在模块重载时会被重发现这一点上该操作恢复了 3.3 之前的行为 (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19413">bpo-19413</a>)。</p></li>
<li><p class="translated">冻结的包将不再把 <code class="docutils literal notranslate"><span class="pre">__path__</span></code> 设为一个包含包名的列表，它们现在会把它设为一个空列表。 当存在与冻结的包同名的目录时之前版本的行为可能会使导入系统错误地处理子模块。 确定一个模块是否属于包的正确方式是使用 <code class="docutils literal notranslate"><span class="pre">hasattr(module,</span> <span class="pre">'__path__')</span></code> (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18065">bpo-18065</a>)。</p></li>
<li><p class="translated">冻结的包将不再定义 <code class="docutils literal notranslate"><span class="pre">__file__</span></code> 属性。 对冻结模块设置该属性在语义上是不正确的因为它们并不是从任何显式位置加载。 如果你必须知道一个模块是来自冻结的代码那么你可以查看该模块的 <code class="docutils literal notranslate"><span class="pre">__spec__.location</span></code> 是否被设为 <code class="docutils literal notranslate"><span class="pre">'frozen'</span></code>，检测加载器是否为 <a class="reference internal" href="../library/importlib.html#importlib.machinery.FrozenImporter" title="importlib.machinery.FrozenImporter"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.FrozenImporter</span></code></a> 的子类，或者如果需要 Python 2 兼容性则可以使用 <code class="xref py py-func docutils literal notranslate"><span class="pre">imp.is_frozen()</span></code>。</p></li>
<li><p class="translated">现在 <a class="reference internal" href="../library/py_compile.html#py_compile.compile" title="py_compile.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">py_compile.compile()</span></code></a> 在它要写入的文件路径是符号链接或非常规文件时会引发 <a class="reference internal" href="../library/exceptions.html#FileExistsError" title="FileExistsError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FileExistsError</span></code></a>。 这是为了提示导入系统将用一个常规文件覆盖相应文件而不管原始文件路径是什么类型而发出的警告。</p></li>
<li><p class="translated">当被加载的源代码触发了 <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a> 或 <a class="reference internal" href="../library/exceptions.html#UnicodeDecodeError" title="UnicodeDecodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeDecodeError</span></code></a> 时 <a class="reference internal" href="../library/importlib.html#importlib.abc.SourceLoader.get_source" title="importlib.abc.SourceLoader.get_source"><code class="xref py py-meth docutils literal notranslate"><span class="pre">importlib.abc.SourceLoader.get_source()</span></code></a> 将不再引发 <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>。 因为 <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> 本意只是在应该找到源代码但却找不到时被引发，而在源代码已找到但结构不正确时使用此异常会感觉有些过度/过载。 如果你在之前是捕获 ImportError 并希望继续忽略语法或解码问题，现在应当捕获所有这三个异常。</p></li>
<li><p class="translated">现在 <a class="reference internal" href="../library/functools.html#functools.update_wrapper" title="functools.update_wrapper"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.update_wrapper()</span></code></a> 和 <a class="reference internal" href="../library/functools.html#functools.wraps" title="functools.wraps"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.wraps()</span></code></a> 会正确地将 <code class="docutils literal notranslate"><span class="pre">__wrapped__</span></code> 属性设为被包装的函数，即使该函数同样设置了 <code class="docutils literal notranslate"><span class="pre">__wrapped__</span></code> 属性。 这意味着 <code class="docutils literal notranslate"><span class="pre">__wrapped__</span></code> 属性现在会正确地链接由被装饰函数组成的栈而不是链中指向最内层函数的的每个 <code class="docutils literal notranslate"><span class="pre">__wrapped__</span></code> 属性。 确定要沿袭之前版本行为的内省库可以使用 <a class="reference internal" href="../library/inspect.html#inspect.unwrap" title="inspect.unwrap"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.unwrap()</span></code></a> 来访问链中没有 <code class="docutils literal notranslate"><span class="pre">__wrapped__</span></code> 属性的第一个函数。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/inspect.html#inspect.getfullargspec" title="inspect.getfullargspec"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.getfullargspec()</span></code></a> 已在 <a class="reference internal" href="../library/inspect.html#inspect.signature" title="inspect.signature"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.signature()</span></code></a> 之上重新实现因而能够处理比之前更多种类的可调用对象。 预计在 Python 3.4 系列发布过程中将会有更多内置和扩展模块的可调用对象获得签名元数据。 假定 <a class="reference internal" href="../library/inspect.html#inspect.getfullargspec" title="inspect.getfullargspec"><code class="xref py py-func docutils literal notranslate"><span class="pre">inspect.getfullargspec()</span></code></a> 会在非 Python 可调用对象上出错的代码可能需要做相应的调整。</p></li>
<li><p class="translated">对于空字符串 <a class="reference internal" href="../library/importlib.html#importlib.machinery.PathFinder" title="importlib.machinery.PathFinder"><code class="xref py py-class docutils literal notranslate"><span class="pre">importlib.machinery.PathFinder</span></code></a> 现在会将当前工作目录传给 <a class="reference internal" href="../library/sys.html#sys.path_hooks" title="sys.path_hooks"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_hooks</span></code></a> 中的对象。 这导致 <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> 绝不会包含 <code class="docutils literal notranslate"><span class="pre">''</span></code>，因此基于 <a class="reference internal" href="../library/sys.html#sys.path" title="sys.path"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path</span></code></a> 迭代 <a class="reference internal" href="../library/sys.html#sys.path_importer_cache" title="sys.path_importer_cache"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code></a> 将不无找出所有的键。 当从当前工作目录导入时模块的 <code class="docutils literal notranslate"><span class="pre">__file__</span></code> 现在也将是一个绝对路径，包括在命令行中指定解释器使用 <code class="docutils literal notranslate"><span class="pre">-m</span></code> 的情况（但当一个脚本已经直接使用相对路径被执行时的 <code class="docutils literal notranslate"><span class="pre">__main__.__file__</span></code> 除外） （由 Brett Cannon 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18416">bpo-18416</a> 中贡献）。 (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18416">bpo-18416</a>)。</p></li>
<li><p class="translated">传给 <a class="reference internal" href="../library/http.client.html#http.client.HTTPConnection" title="http.client.HTTPConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPConnection</span></code></a> 和 <a class="reference internal" href="../library/http.client.html#http.client.HTTPSConnection" title="http.client.HTTPSConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPSConnection</span></code></a> 的 <em>strict</em> 参数被移除会改变剩余参数的含义，如果你是以位置参数而不是关键字参数方式指定它们的话。 如果你已经注意到弃用警告那么你的代码应当已经通过关键字参数方式指定所有额外参数了。</p></li>
<li><p class="translated">现在 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">...</span></code> 语句之间的字符串 <em>总是</em> 会引发 <a class="reference internal" href="../library/exceptions.html#SyntaxError" title="SyntaxError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxError</span></code></a>。 在之前版本中如果没有开头的文档字符串，则中间的字符串有时会被忽略。 这使得 CPython 与语言规范保持一致；Jython 和 PyPy 已经是这样了。 (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=17434">bpo-17434</a>)。</p></li>
<li><p class="translated">当 <code class="docutils literal notranslate"><span class="pre">SSLSocket</span></code> 未连接时 <a class="reference internal" href="../library/ssl.html#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLSocket.getpeercert()</span></code></a> 和 <a class="reference internal" href="../library/ssl.html#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLSocket.do_handshake()</span></code></a> 现在会引发 <a class="reference internal" href="../library/exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 并附带 <code class="docutils literal notranslate"><span class="pre">ENOTCONN</span></code>，而非如之前版本的行为那样引发 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>。 此外，当握手尚未完成时 <a class="reference internal" href="../library/ssl.html#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getpeercert()</span></code></a> 将会引发 <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p></li>
<li><p class="translated">当输入字符串包含 non-b32-alphabet 字符时 <a class="reference internal" href="../library/base64.html#base64.b32decode" title="base64.b32decode"><code class="xref py py-func docutils literal notranslate"><span class="pre">base64.b32decode()</span></code></a> 现在会引发 <a class="reference internal" href="../library/binascii.html#binascii.Error" title="binascii.Error"><code class="xref py py-exc docutils literal notranslate"><span class="pre">binascii.Error</span></code></a>，而不是 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。 之前在其他 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 被转换时这个 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 被忽略了。 （由 Serhiy Storchaka 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18011">bpo-18011</a> 中贡献。） 注意：这项修改也被非故意地应用到了 Python 3.3.3。</p></li>
<li><p class="translated">当正在创建的 <code class="xref py py-class docutils literal notranslate"><span class="pre">cgi.FieldStorage</span></code> 实例被作为垃圾回收时 <code class="xref py py-attr docutils literal notranslate"><span class="pre">file</span></code> 属性现在会自动关闭。 如果你要单独从 <code class="xref py py-class docutils literal notranslate"><span class="pre">cgi.FieldStorage</span></code> 实例取出文件对象而不让该实例保持存活，那么你应当在 <code class="xref py py-class docutils literal notranslate"><span class="pre">cgi.FieldStorage</span></code> 实例被作为垃圾回收之前存储整个 <code class="xref py py-class docutils literal notranslate"><span class="pre">cgi.FieldStorage</span></code> 实例或读取文件的内容。</p></li>
<li><p class="translated">在已关闭的 SSL 套接字上调用 <code class="docutils literal notranslate"><span class="pre">read</span></code> 或 <code class="docutils literal notranslate"><span class="pre">write</span></code> 现在会引发更具信息量的 <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 而非之前更令人困惑的 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a> (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=9177">bpo-9177</a>)。</p></li>
<li><p class="translated">对于巨大数值 <a class="reference internal" href="../reference/datamodel.html#slice.indices" title="slice.indices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">slice.indices()</span></code></a> 将不再产生 <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a>。 作为此项修复的结果，当给予负的长度时 <a class="reference internal" href="../reference/datamodel.html#slice.indices" title="slice.indices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">slice.indices()</span></code></a> 现在会引发 <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>；在之前版本中它会返回无意义的值 (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=14794">bpo-14794</a>)。</p></li>
<li><p class="translated">与 <a class="reference internal" href="../library/cmath.html#module-cmath" title="cmath: Mathematical functions for complex numbers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmath</span></code></a> 中的函数不同，当一个对象的 <code class="docutils literal notranslate"><span class="pre">__complex__</span></code> 特殊方法返回 <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 值时 <a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a> 构造器会不正确地接受它。 现在这会引发 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。 (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16290">bpo-16290</a>。)</p></li>
<li><p class="translated">在 3.2 和 3.3 中的 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 构造器会错误地接受 <a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 值作为 <em>base</em> 形参。 多数人不太可能这样做，但如果真的如此，现在它将引发 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16772">bpo-16772</a>)。</p></li>
<li><p class="translated">现在仅限关键字参数的默认值将在常规关键字参数的默认值 <em>之后</em> 被求值，而非之前。 希望没有人写过任何依赖于之前的有缺陷行为的代码 (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16967">bpo-16967</a>)。</p></li>
<li><p class="translated">现在陈旧的线程状态将在 <a class="reference internal" href="../library/os.html#os.fork" title="os.fork"><code class="xref py py-func docutils literal notranslate"><span class="pre">fork()</span></code></a> 之后被清除。 这可能导致某些之前被不正确地保持永久存活的系统资源（例如，保存在本线程存储中的数据库连接）被释放。 (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=17094">bpo-17094</a>。)</p></li>
<li><p class="translated">现在 <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> 字典中的形参名称将被正确地处理，具体方式与 <a class="reference internal" href="../reference/datamodel.html#function.__kwdefaults__" title="function.__kwdefaults__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__kwdefaults__</span></code></a> 类似。 （由 Yury Selivanov 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=20625">bpo-20625</a> 中贡献。）</p></li>
<li><p class="translated">现在 <a class="reference internal" href="../library/hashlib.html#hashlib.hash.name" title="hashlib.hash.name"><code class="xref py py-attr docutils literal notranslate"><span class="pre">hashlib.hash.name</span></code></a> 将总是返回小写形式的标识符。 在之前版本中某些内置哈希具有大写的名称，但现在它已成为命名方式保持一致的正式公有接口 (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=18532">bpo-18532</a>)。</p></li>
<li><p class="translated">因为现在 <a class="reference internal" href="../library/unittest.html#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest.TestSuite</span></code></a> 会在测试被运行后丢弃对它们的引用，所以那些重用 <a class="reference internal" href="../library/unittest.html#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestSuite</span></code></a> 来重新运行测试集的测试套件可能会失败。 测试套件不应以这样的方式被重用，因为这意味着状态会在多次测试运行之间保持不变，破坏 <a class="reference internal" href="../library/unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 设计时要提供的测试状态隔离。 不过，如果缺乏隔离被视为是可接受的，则可通过创建定义了不执行任何操作的 <code class="docutils literal notranslate"><span class="pre">_removeTestAtIndex</span></code> 方法的 <a class="reference internal" href="../library/unittest.html#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-mod docutils literal notranslate"><span class="pre">TestSuite</span></code></a> 子类来恢复旧版行为 (参见 <a class="reference internal" href="../library/unittest.html#unittest.TestSuite.__iter__" title="unittest.TestSuite.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TestSuite.__iter__()</span></code></a>) (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=11798">bpo-11798</a>)。</p></li>
<li><p class="translated">现在 <a class="reference internal" href="../library/unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 会使用 <a class="reference internal" href="../library/argparse.html#module-argparse" title="argparse: Command-line option and argument parsing library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">argparse</span></code></a> 执行命令行解析。 有些过去可用的不合法命令形式将不再被允许；理论上说这不会导致向下兼容性问题因为这些不允许的命令形式没有任何意义也不大可能会被使用。</p></li>
<li><p class="translated">现在 <a class="reference internal" href="../library/re.html#re.split" title="re.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.split()</span></code></a>、<a class="reference internal" href="../library/re.html#re.findall" title="re.findall"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.findall()</span></code></a> 和 <a class="reference internal" href="../library/re.html#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.sub()</span></code></a> 函数，以及 <code class="docutils literal notranslate"><span class="pre">match</span></code> 对象的 <a class="reference internal" href="../library/re.html#re.Match.group" title="re.Match.group"><code class="xref py py-meth docutils literal notranslate"><span class="pre">group()</span></code></a> 和 <a class="reference internal" href="../library/re.html#re.Match.groups" title="re.Match.groups"><code class="xref py py-meth docutils literal notranslate"><span class="pre">groups()</span></code></a> 方法在匹配字符串为 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 时始终返回 <em>bytes</em> 对象。 此前返回类型与输入类型匹配，因此如果你的代码依赖返回值类型 (例如 <code class="docutils literal notranslate"><span class="pre">bytearray</span></code>)，则需要修改代码。</p></li>
<li><p class="translated">现在当输入字符串时 <code class="xref py py-mod docutils literal notranslate"><span class="pre">audioop</span></code> 的函数会立即引发错误，而不是稍后随机出错 (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16685">bpo-16685</a>)。</p></li>
<li><p class="translated">新增的传给 <a class="reference internal" href="../library/html.parser.html#html.parser.HTMLParser" title="html.parser.HTMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTMLParser</span></code></a> 的 <em>convert_charrefs</em> 参数目前默认为 <code class="docutils literal notranslate"><span class="pre">False</span></code> 以保持向下兼容，但最终将修改成默认为 <code class="docutils literal notranslate"><span class="pre">True</span></code>。 建议你在你的代码中为所有 <a class="reference internal" href="../library/html.parser.html#html.parser.HTMLParser" title="html.parser.HTMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTMLParser</span></code></a> 调用添加此关键字，并设置适当的值 (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=13633">bpo-13633</a>)。</p></li>
<li><p class="translated">由于传给 <a class="reference internal" href="../library/hmac.html#hmac.new" title="hmac.new"><code class="xref py py-func docutils literal notranslate"><span class="pre">hmac.new()</span></code></a> 函数的 <em>digestmod</em> 参数在未来将不设默认值，所有对 <a class="reference internal" href="../library/hmac.html#hmac.new" title="hmac.new"><code class="xref py py-func docutils literal notranslate"><span class="pre">hmac.new()</span></code></a> 的调用都应当修改为显式地指定 <em>digestmod</em> (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=17276">bpo-17276</a>)。</p></li>
<li><p class="translated">附带 <code class="docutils literal notranslate"><span class="pre">SO</span></code> 键调用 <a class="reference internal" href="../library/sysconfig.html#sysconfig.get_config_var" title="sysconfig.get_config_var"><code class="xref py py-func docutils literal notranslate"><span class="pre">sysconfig.get_config_var()</span></code></a>，或者在对 <a class="reference internal" href="../library/sysconfig.html#sysconfig.get_config_vars" title="sysconfig.get_config_vars"><code class="xref py py-func docutils literal notranslate"><span class="pre">sysconfig.get_config_vars()</span></code></a> 的调用结果中查找 <code class="docutils literal notranslate"><span class="pre">SO</span></code> 的做法已被弃用。 该键应当被 <code class="docutils literal notranslate"><span class="pre">EXT_SUFFIX</span></code> 或 <code class="docutils literal notranslate"><span class="pre">SHLIB_SUFFIX</span></code> 替代，由具体场景决定 (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=19555">bpo-19555</a>)。</p></li>
<li><p class="translated">任何指定了 <code class="docutils literal notranslate"><span class="pre">U</span></code> 的 <code class="docutils literal notranslate"><span class="pre">open</span></code> 函数调用都应当被修改。 <code class="docutils literal notranslate"><span class="pre">U</span></code> 在 Python3 将没有效果并且最终会在被使用时引发错误。 对于该函数，要得到与它的旧 Python2 行为相同的效果可以使用 <em>newline</em> 参数，或者在必要时将流包装在 <a class="reference internal" href="../library/io.html#io.TextIOWrapper" title="io.TextIOWrapper"><code class="xref py py-mod docutils literal notranslate"><span class="pre">TextIOWrapper</span></code></a> 以使用其 <em>newline</em> 参数 (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=15204">bpo-15204</a>)。</p></li>
<li><p class="translated">如果你在脚本中使用 <code class="docutils literal notranslate"><span class="pre">pyvenv</span></code> 并且希望 <em>不要</em> 安装 pip，你必须在你的唤起命令中添加 <code class="docutils literal notranslate"><span class="pre">--without-pip</span></code>。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/json.html#json.dump" title="json.dump"><code class="xref py py-func docutils literal notranslate"><span class="pre">json.dump()</span></code></a> 和 <a class="reference internal" href="../library/json.html#json.dumps" title="json.dumps"><code class="xref py py-func docutils literal notranslate"><span class="pre">json.dumps()</span></code></a> 在指定了缩进值时的默认行为已被改变：它不会在行末的条目分隔逗号后面再附加空格。 此项改变仅在你使用了对这样的输出执行空格敏感比较的测试时才会有影响 (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16333">bpo-16333</a>)。</p></li>
<li><p class="translated">现在 <a class="reference internal" href="../library/doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> 会在扩展模块的 <code class="docutils literal notranslate"><span class="pre">__doc__</span></code> 字符串中寻找 doctest，因此如果你的 doctest 测试发现包括具有类似 doctest 内容的扩展模块那么你可能会遇到在你之前运行测试时从未遇到过的测试失败 (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=3158">bpo-3158</a>)。</p></li>
<li><p class="translated">作为 Python 启动过程改进的一部分 <a class="reference internal" href="../library/collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a> 模块进行了小幅度的重构。 作为此项重构的结果，导入 <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 将不再自动导入 <a class="reference internal" href="../library/collections.abc.html#module-collections.abc" title="collections.abc: Abstract base classes for containers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections.abc</span></code></a>。 如果你的程序依赖于这个（未写入文档的）隐式导入，你将需要添加显式的 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">collections.abc</span></code> (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=20784">bpo-20784</a>)。</p></li>
</ul>
</section>
<section id="changes-in-the-c-api">
<h3 class="translated">C API 的变化<a class="headerlink" href="#changes-in-the-c-api" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p class="translated">现在 <a class="reference internal" href="../c-api/veryhigh.html#c.PyEval_EvalFrameEx" title="PyEval_EvalFrameEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_EvalFrameEx()</span></code></a>, <a class="reference internal" href="../c-api/object.html#c.PyObject_Repr" title="PyObject_Repr"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Repr()</span></code></a> 和 <a class="reference internal" href="../c-api/object.html#c.PyObject_Str" title="PyObject_Str"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Str()</span></code></a> 以及其他一些内部 C API 都包括了一个调试断言，以确保它们不会在可能会静默地丢弃当前活动异常的情况下使用。 在预期并且希望丢弃活动异常的情况下（例如，由于已通过 <a class="reference internal" href="../c-api/exceptions.html#c.PyErr_Fetch" title="PyErr_Fetch"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyErr_Fetch()</span></code></a> 将其保存在本地或是有意将其替换为不同的异常 ），则需调用显式的 <a class="reference internal" href="../c-api/exceptions.html#c.PyErr_Clear" title="PyErr_Clear"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyErr_Clear()</span></code></a> 以避免在（直接或间接）唤起这些操作和针对启用断言编译的 Python 的版本运行时触发断言。</p></li>
<li><p class="translated">现在 <a class="reference internal" href="../c-api/exceptions.html#c.PyErr_SetImportError" title="PyErr_SetImportError"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyErr_SetImportError()</span></code></a> 在其 <strong>msg</strong> 参数未被设置时会设置 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。 在之前版本中仅会返回 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 而不设置异常。</p></li>
<li><p class="translated">现在 <a class="reference internal" href="../c-api/veryhigh.html#c.PyOS_ReadlineFunctionPointer" title="PyOS_ReadlineFunctionPointer"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyOS_ReadlineFunctionPointer</span></code></a> 回调的结果必须是一个由 <a class="reference internal" href="../c-api/memory.html#c.PyMem_RawMalloc" title="PyMem_RawMalloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawMalloc()</span></code></a> 或 <a class="reference internal" href="../c-api/memory.html#c.PyMem_RawRealloc" title="PyMem_RawRealloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_RawRealloc()</span></code></a> 分配的字符串，或者如果发生错误则为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，而不是由 <a class="reference internal" href="../c-api/memory.html#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Malloc()</span></code></a> 或 <a class="reference internal" href="../c-api/memory.html#c.PyMem_Realloc" title="PyMem_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Realloc()</span></code></a> 分配的字符串 (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=16742">bpo-16742</a>)</p></li>
<li><p class="translated">现在 <a class="reference internal" href="../c-api/init.html#c.PyThread_set_key_value" title="PyThread_set_key_value"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyThread_set_key_value()</span></code></a> 总是会设置值。 在 Python 3.3 中，如果键已存在（如果当前值为非 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针）该函数将不执行任何操作。</p></li>
<li><p class="translated"><a class="reference internal" href="../c-api/frame.html#c.PyFrameObject" title="PyFrameObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyFrameObject</span></code></a> 结构体的 <code class="docutils literal notranslate"><span class="pre">f_tstate</span></code> (线程状态) 字段已被移除以修复一个程序错误；相关理由参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=14432">bpo-14432</a>。</p></li>
</ul>
</section>
</section>
<section id="changed-in-3-4-3">
<h2 class="translated">3.4.3 的变化<a class="headerlink" href="#changed-in-3-4-3" title="Link to this heading">¶</a></h2>
<section id="pep-476-enabling-certificate-verification-by-default-for-stdlib-http-clients">
<span id="pep-476"></span><h3 class="translated">PEP 476: 默认为 stdlib http 客户端启用证书验证<a class="headerlink" href="#pep-476-enabling-certificate-verification-by-default-for-stdlib-http-clients" title="Link to this heading">¶</a></h3>
<p class="translated"><a class="reference internal" href="../library/http.client.html#module-http.client" title="http.client: HTTP and HTTPS protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">http.client</span></code></a> 及其他依赖它的模块，比如 <a class="reference internal" href="../library/urllib.request.html#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib.request</span></code></a> 和 <a class="reference internal" href="../library/xmlrpc.client.html#module-xmlrpc.client" title="xmlrpc.client: XML-RPC client access."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xmlrpc.client</span></code></a>，现在将验证服务器是否提供了由平台信任的仓库中的 CA 签名的证书并且其主机名与默认被请求的主机名相匹配，这将显著提升许多应用程序的安全性。</p>
<p class="translated">对于需要之前版本的旧有行为的应用程序，可以传入一个替代的上下文:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">urllib.request</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">ssl</span>

<span class="c1"># 这将禁用所有验证</span>
<span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">_create_unverified_context</span><span class="p">()</span>

<span class="c1"># 这将允许为主机使用指定证书，</span>
<span class="c1"># 它无须位于受信任的证书存储库中</span>
<span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">(</span><span class="n">cafile</span><span class="o">=</span><span class="s2">&quot;/path/to/file.crt&quot;</span><span class="p">)</span>

<span class="n">urllib</span><span class="o">.</span><span class="n">request</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s2">&quot;https://invalid-cert&quot;</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#">Python 3.4 有什么新变化</a><ul>
<li><a class="reference internal" href="#summary-release-highlights">摘要 - 发布重点</a></li>
<li><a class="reference internal" href="#new-features">新的特性</a><ul>
<li><a class="reference internal" href="#pep-453-explicit-bootstrapping-of-pip-in-python-installations">PEP 453: 在 Python 安装版中对 PIP 的显式初始设置</a><ul>
<li><a class="reference internal" href="#bootstrapping-pip-by-default">默认对 pip 进行初始设置</a></li>
<li><a class="reference internal" href="#documentation-changes">文档更改</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pep-446-newly-created-file-descriptors-are-non-inheritable">PEP 446: 新创建的文件描述符将设为不可继承</a></li>
<li><a class="reference internal" href="#improvements-to-codec-handling">编解码器处理方式的改进</a></li>
<li><a class="reference internal" href="#pep-451-a-modulespec-type-for-the-import-system">PEP 451: 针对导入系统的 ModuleSpec 类型</a></li>
<li><a class="reference internal" href="#other-language-changes">其他语言特性修改</a></li>
</ul>
</li>
<li><a class="reference internal" href="#new-modules">新增模块</a><ul>
<li><a class="reference internal" href="#asyncio">asyncio</a></li>
<li><a class="reference internal" href="#ensurepip">ensurepip</a></li>
<li><a class="reference internal" href="#enum">enum</a></li>
<li><a class="reference internal" href="#pathlib">pathlib</a></li>
<li><a class="reference internal" href="#selectors">selectors</a></li>
<li><a class="reference internal" href="#statistics">statistics</a></li>
<li><a class="reference internal" href="#tracemalloc">tracemalloc</a></li>
</ul>
</li>
<li><a class="reference internal" href="#improved-modules">改进的模块</a><ul>
<li><a class="reference internal" href="#abc">abc</a></li>
<li><a class="reference internal" href="#aifc">aifc</a></li>
<li><a class="reference internal" href="#argparse">argparse</a></li>
<li><a class="reference internal" href="#audioop">audioop</a></li>
<li><a class="reference internal" href="#base64">base64</a></li>
<li><a class="reference internal" href="#collections">collections</a></li>
<li><a class="reference internal" href="#colorsys">colorsys</a></li>
<li><a class="reference internal" href="#contextlib">contextlib</a></li>
<li><a class="reference internal" href="#dbm">dbm</a></li>
<li><a class="reference internal" href="#dis">dis</a></li>
<li><a class="reference internal" href="#doctest">doctest</a></li>
<li><a class="reference internal" href="#email">email</a></li>
<li><a class="reference internal" href="#filecmp">filecmp</a></li>
<li><a class="reference internal" href="#functools">functools</a></li>
<li><a class="reference internal" href="#gc">gc</a></li>
<li><a class="reference internal" href="#glob">glob</a></li>
<li><a class="reference internal" href="#hashlib">hashlib</a></li>
<li><a class="reference internal" href="#hmac">hmac</a></li>
<li><a class="reference internal" href="#html">html</a></li>
<li><a class="reference internal" href="#http">http</a></li>
<li><a class="reference internal" href="#idlelib-and-idle">idlelib 与 IDLE</a></li>
<li><a class="reference internal" href="#importlib">importlib</a></li>
<li><a class="reference internal" href="#inspect">inspect</a></li>
<li><a class="reference internal" href="#ipaddress">ipaddress</a></li>
<li><a class="reference internal" href="#logging">logging</a></li>
<li><a class="reference internal" href="#marshal">marshal</a></li>
<li><a class="reference internal" href="#mmap">mmap</a></li>
<li><a class="reference internal" href="#multiprocessing">multiprocessing</a></li>
<li><a class="reference internal" href="#operator">operator</a></li>
<li><a class="reference internal" href="#os">os</a></li>
<li><a class="reference internal" href="#pdb">pdb</a></li>
<li><a class="reference internal" href="#pickle">pickle</a></li>
<li><a class="reference internal" href="#plistlib">plistlib</a></li>
<li><a class="reference internal" href="#poplib">poplib</a></li>
<li><a class="reference internal" href="#pprint">pprint</a></li>
<li><a class="reference internal" href="#pty">pty</a></li>
<li><a class="reference internal" href="#pydoc">pydoc</a></li>
<li><a class="reference internal" href="#re">re</a></li>
<li><a class="reference internal" href="#resource">resource</a></li>
<li><a class="reference internal" href="#select">select</a></li>
<li><a class="reference internal" href="#shelve">shelve</a></li>
<li><a class="reference internal" href="#shutil">shutil</a></li>
<li><a class="reference internal" href="#smtpd">smtpd</a></li>
<li><a class="reference internal" href="#smtplib">smtplib</a></li>
<li><a class="reference internal" href="#socket">socket</a></li>
<li><a class="reference internal" href="#sqlite3">sqlite3</a></li>
<li><a class="reference internal" href="#ssl">ssl</a></li>
<li><a class="reference internal" href="#stat">stat</a></li>
<li><a class="reference internal" href="#struct">struct</a></li>
<li><a class="reference internal" href="#subprocess">subprocess</a></li>
<li><a class="reference internal" href="#sunau">sunau</a></li>
<li><a class="reference internal" href="#sys">sys</a></li>
<li><a class="reference internal" href="#tarfile">tarfile</a></li>
<li><a class="reference internal" href="#textwrap">textwrap</a></li>
<li><a class="reference internal" href="#threading">threading</a></li>
<li><a class="reference internal" href="#traceback">回溯</a></li>
<li><a class="reference internal" href="#types">types</a></li>
<li><a class="reference internal" href="#urllib">urllib</a></li>
<li><a class="reference internal" href="#unittest">unittest</a></li>
<li><a class="reference internal" href="#venv">venv</a></li>
<li><a class="reference internal" href="#wave">wave</a></li>
<li><a class="reference internal" href="#weakref">weakref</a></li>
<li><a class="reference internal" href="#xml-etree">xml.etree</a></li>
<li><a class="reference internal" href="#zipfile">zipfile</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cpython-implementation-changes">CPython 实现的变化</a><ul>
<li><a class="reference internal" href="#pep-445-customization-of-cpython-memory-allocators">PEP 445: 自定义 CPython 内存分配器</a></li>
<li><a class="reference internal" href="#pep-442-safe-object-finalization">PEP 442: 安全的对象最终化</a></li>
<li><a class="reference internal" href="#pep-456-secure-and-interchangeable-hash-algorithm">PEP 456: 安全且可互换的哈希算法</a></li>
<li><a class="reference internal" href="#pep-436-argument-clinic">PEP 436: Argument Clinic</a></li>
<li><a class="reference internal" href="#other-build-and-c-api-changes">其他的构建和 C API 的改变</a></li>
<li><a class="reference internal" href="#other-improvements">其他改进</a></li>
<li><a class="reference internal" href="#significant-optimizations">显著的优化</a></li>
</ul>
</li>
<li><a class="reference internal" href="#deprecated">弃用</a><ul>
<li><a class="reference internal" href="#deprecations-in-the-python-api">Python API 中的弃用</a></li>
<li><a class="reference internal" href="#deprecated-features">弃用的特性</a></li>
</ul>
</li>
<li><a class="reference internal" href="#removed">移除</a><ul>
<li><a class="reference internal" href="#operating-systems-no-longer-supported">不再支持的操作系统</a></li>
<li><a class="reference internal" href="#api-and-feature-removals">API 与特性的移除</a></li>
<li><a class="reference internal" href="#code-cleanups">代码清理</a></li>
</ul>
</li>
<li><a class="reference internal" href="#porting-to-python-3-4">移植到 Python 3.4</a><ul>
<li><a class="reference internal" href="#changes-in-python-command-behavior"> 'python' 命令行为的变化</a></li>
<li><a class="reference internal" href="#changes-in-the-python-api">Python API 的变化</a></li>
<li><a class="reference internal" href="#changes-in-the-c-api">C API 的变化</a></li>
</ul>
</li>
<li><a class="reference internal" href="#changed-in-3-4-3">3.4.3 的变化</a><ul>
<li><a class="reference internal" href="#pep-476-enabling-certificate-verification-by-default-for-stdlib-http-clients">PEP 476: 默认为 stdlib http 客户端启用证书验证</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一主题</h4>
    <p class="topless"><a href="3.5.html"
                          title="上一章">Python 3.5 有什么新变化</a></p>
  </div>
  <div>
    <h4>下一主题</h4>
    <p class="topless"><a href="3.3.html"
                          title="下一章">Python 3.3 有什么新变化</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">报告代码错误</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/whatsnew/3.4.rst?plain=1"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="折叠边栏">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="3.3.html" title="Python 3.3 有什么新变化"
             >下一页</a> |</li>
        <li class="right" >
          <a href="3.5.html" title="Python 3.5 有什么新变化"
             >上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.14.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python的新变化</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Python 3.4 有什么新变化</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q" id="search-box">
          <input type="submit" value="转到">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    主题
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>自动</option>
        <option value="light">明亮</option>
        <option value="dark">黑暗</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版权</a> 2001 Python Software Foundation.
    <br>
    本页面采用 Python 软件基金会许可证第 2 版授权。
    <br>
    文档中的示例、代码片段及其他代码内容额外采用零条款 BSD 许可证授权。
    <br>
    
      更多信息请参阅《<a href="/license.html"> 历史与许可 </a>》。<br>
    
    
    <br>

    Python 软件基金会是一家非营利性公司。
<a href="https://www.python.org/psf/donations/">请进行捐赠。</a>
<br>
    <br>
      最后更新于11月 25, 2025 (07:24 UTC) 。
    
      <a href="/bugs.html">发现了错误</a>？
    
    <br>

    使用<a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3 创建。
    </div>

  </body>
</html>
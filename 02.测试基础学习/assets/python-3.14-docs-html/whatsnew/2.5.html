<!DOCTYPE html>

<html lang="zh-CN" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="Python 2.5 有什么新变化" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/whatsnew/2.5.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="作者, A.M. Kuchling,. 本文介绍了 Python 2.5 的新增特性。 Python 2.5 预定的最终发布时间为 2006 年 8 月； PEP 356 描述了预定的发布日程。 Python 2.5 实际发布于 2006 年 9 月 19 日。 Python 2.5 中的变化是语言本身和标准库改进的有趣混合。 我想，库的加强对 Python 的用户社区来说会更重要一些，因为..." />
<meta property="og:image:width" content="1146" />
<meta property="og:image:height" content="600" />
<meta property="og:image" content="https://docs.python.org/3.14/zh-cn/_images/social_previews/summary_whatsnew_2.5_a035ba22.png" />
<meta property="og:image:alt" content="作者, A.M. Kuchling,. 本文介绍了 Python 2.5 的新增特性。 Python 2.5 预定的最终发布时间为 2006 年 8 月； PEP 356 描述了预定的发布日程。 Python 2.5 实际发布于 2006 年 9 月 19 日。 Python 2.5 中的变化是语言本身和标准库改进的有趣混合。 我想，库的加强对 Python 的用户社区来说会更重要一些，因为..." />
<meta name="description" content="作者, A.M. Kuchling,. 本文介绍了 Python 2.5 的新增特性。 Python 2.5 预定的最终发布时间为 2006 年 8 月； PEP 356 描述了预定的发布日程。 Python 2.5 实际发布于 2006 年 9 月 19 日。 Python 2.5 中的变化是语言本身和标准库改进的有趣混合。 我想，库的加强对 Python 的用户社区来说会更重要一些，因为..." />
<meta name="twitter:card" content="summary_large_image" />
<meta name="theme-color" content="#3776ab">

    <title>Python 2.5 有什么新变化 &#8212; Python 3.14.0 文档</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=234b1a7c" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=8cd84f99" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=5349f25f" />
    
    <script src="../_static/documentation_options.js?v=a595ec0e"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=beaddf03"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.14.0 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于此文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权" href="../copyright.html" />
    <link rel="next" title="Python 2.4 有什么新变化" href="2.4.html" />
    <link rel="prev" title="Python 2.6 有什么新变化" href="2.6.html" />
    
      
      <script defer file-types="bz2,epub,zip" data-domain="docs.python.org" src="https://analytics.python.org/js/script.file-downloads.outbound-links.js"></script>
      
      <link rel="canonical" href="https://docs.python.org/3/whatsnew/2.5.html">
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg">
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="菜单">
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo">
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q">
                <input type="submit" value="转到">
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    主题
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>自动</option>
        <option value="light">明亮</option>
        <option value="dark">黑暗</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#">Python 2.5 有什么新变化</a><ul>
<li><a class="reference internal" href="#pep-308-conditional-expressions">PEP 308: 条件表达式</a></li>
<li><a class="reference internal" href="#pep-309-partial-function-application">PEP 309: 部分功能应用</a></li>
<li><a class="reference internal" href="#pep-314-metadata-for-python-software-packages-v1-1">PEP 314: Python软件包的元数据 v1.1</a></li>
<li><a class="reference internal" href="#pep-328-absolute-and-relative-imports">PEP 328: 绝对导入和相对导入</a></li>
<li><a class="reference internal" href="#pep-338-executing-modules-as-scripts">PEP 338: 将模块作为脚本执行</a></li>
<li><a class="reference internal" href="#pep-341-unified-try-except-finally">PEP 341: 统一 try/except/finally</a></li>
<li><a class="reference internal" href="#pep-342-new-generator-features">PEP 342: 生成器的新特性</a></li>
<li><a class="reference internal" href="#pep-343-the-with-statement">PEP 343: &quot;with&quot; 语句</a><ul>
<li><a class="reference internal" href="#writing-context-managers">编写上下文管理器</a></li>
<li><a class="reference internal" href="#the-contextlib-module">contextlib 模块</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pep-352-exceptions-as-new-style-classes">PEP 352: 异常作为新型的类</a></li>
<li><a class="reference internal" href="#pep-353-using-ssize-t-as-the-index-type">PEP 353: 使用ssize_t作为索引类型</a></li>
<li><a class="reference internal" href="#pep-357-the-index-method">PEP 357: '__index__' 方法</a></li>
<li><a class="reference internal" href="#other-language-changes">其他语言特性修改</a><ul>
<li><a class="reference internal" href="#interactive-interpreter-changes">交互解释器变更</a></li>
<li><a class="reference internal" href="#optimizations">性能优化</a></li>
</ul>
</li>
<li><a class="reference internal" href="#new-improved-and-removed-modules">新增，改进和删除的模块</a><ul>
<li><a class="reference internal" href="#the-ctypes-package">ctypes 包</a></li>
<li><a class="reference internal" href="#the-elementtree-package">ElementTree 包</a></li>
<li><a class="reference internal" href="#the-hashlib-package">hashlib 包</a></li>
<li><a class="reference internal" href="#the-sqlite3-package">sqlite3 包</a></li>
<li><a class="reference internal" href="#the-wsgiref-package">wsgiref 包</a></li>
</ul>
</li>
<li><a class="reference internal" href="#build-and-c-api-changes">构建和 C API 的变更</a><ul>
<li><a class="reference internal" href="#port-specific-changes">移植专属的改变</a></li>
</ul>
</li>
<li><a class="reference internal" href="#porting-to-python-2-5">移植到Python 2.5</a></li>
<li><a class="reference internal" href="#acknowledgements">致谢</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一主题</h4>
    <p class="topless"><a href="2.6.html"
                          title="上一章">Python 2.6 有什么新变化</a></p>
  </div>
  <div>
    <h4>下一主题</h4>
    <p class="topless"><a href="2.4.html"
                          title="下一章">Python 2.4 有什么新变化</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">报告代码错误</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/whatsnew/2.5.rst?plain=1"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="2.4.html" title="Python 2.4 有什么新变化"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="2.6.html" title="Python 2.6 有什么新变化"
             accesskey="P">上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.14.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python的新变化</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Python 2.5 有什么新变化</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q" id="search-box">
          <input type="submit" value="转到">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    主题
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>自动</option>
        <option value="light">明亮</option>
        <option value="dark">黑暗</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="what-s-new-in-python-2-5">
<h1 class="translated">Python 2.5 有什么新变化<a class="headerlink" href="#what-s-new-in-python-2-5" title="Link to this heading">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd translated">作者<span class="colon">:</span></dt>
<dd class="field-odd translated"><p class="translated">A.M. Kuchling</p>
</dd>
</dl>
<p class="translated">本文介绍了 Python 2.5 的新增特性。 Python 2.5 预定的最终发布时间为 2006 年 8 月；<span class="target" id="index-63"></span><a class="pep reference external" href="https://peps.python.org/pep-0356/"><strong>PEP 356</strong></a> 描述了预定的发布日程。 Python 2.5 实际发布于 2006 年 9 月 19 日。</p>
<p class="translated">Python 2.5 中的变化是语言本身和标准库改进的有趣混合。 我想，库的加强对 Python 的用户社区来说会更重要一些，因为增加了多个被广泛应用的包。 新增模块包括用于 XML 处理的 ElementTree (<code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree</span></code>)，SQLite 数据库模块 (<code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite</span></code>)，以及用于调用 C 函数的 <a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 模块。</p>
<p class="translated">语言变更具有中等重要性。一些令人愉悦的新功能被添加进来，但其中大多数并不是你每天都会使用的功能。条件表达式终于以新颖的语法被添加到语言中；参见章节 <a class="reference internal" href="#pep-308"><span class="std std-ref">PEP 308: 条件表达式</span></a>。新的 '<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>' 语句将使编写清理代码变得更容易（章节 <a class="reference internal" href="#pep-343"><span class="std std-ref">PEP 343: &quot;with&quot; 语句</span></a>）。现在可以将值传递给生成器（章节 <a class="reference internal" href="#pep-342"><span class="std std-ref">PEP 342: 生成器的新特性</span></a>）。导入现在可以明确为绝对或相对（章节 <a class="reference internal" href="#pep-328"><span class="std std-ref">PEP 328: 绝对导入和相对导入</span></a>）。一些异常处理的边缘情况得到了更好的处理（章节 <a class="reference internal" href="#pep-341"><span class="std std-ref">PEP 341: 统一 try/except/finally</span></a>）。所有这些改进都是有价值的，但它们都是对特定语言功能的改进； none of them are broad modifications to Python's semantics.</p>
<p class="translated">除了语言和库的添加之外，整个源代码树中还进行了其他改进和错误修复。通过搜索SVN变更日志发现，在Python 2.4和2.5之间应用了353个补丁并修复了458个错误。（这两个数字都可能是低估的。）</p>
<p class="translated">本文并不试图成为新功能的完整规范；相反，通过有帮助的示例简要介绍了这些变更。有关完整详情，你应始终参考Python 2.5的文档，网址为https://docs.python.org。如果你想了解完整的实现和设计原理，请参考特定新功能的PEP。</p>
<p class="translated">欢迎对本文档提出评论、建议和错误报告；请通过电子邮件发送给作者或在Python错误跟踪器中打开一个错误报告。</p>
<section id="pep-308-conditional-expressions">
<span id="pep-308"></span><h2 class="translated">PEP 308: 条件表达式<a class="headerlink" href="#pep-308-conditional-expressions" title="Link to this heading">¶</a></h2>
<p class="translated">长期以来，人们一直要求有一种方法来编写条件表达式，这种表达式根据布尔值的真或假返回值A或值B。条件表达式允许你编写一个赋值语句，其效果与以下相同:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">condition</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">true_value</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">false_value</span>
</pre></div>
</div>
<p class="translated">在python-dev和comp.lang.python上，关于语法的无尽乏味讨论已经屡见不鲜。甚至进行了一次投票，发现大多数投票者希望以某种形式引入条件表达式，但没有一种语法获得了明显多数的支持。候选语法包括C语言的``cond ? true_v : false_v``、<code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">cond</span> <span class="pre">then</span> <span class="pre">true_v</span> <span class="pre">else</span> <span class="pre">false_v</span></code> 以及16种其他变体。</p>
<p class="translated">Guido van Rossum 最终选择了一种令人惊讶的语法：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">true_value</span> <span class="k">if</span> <span class="n">condition</span> <span class="k">else</span> <span class="n">false_value</span>
</pre></div>
</div>
<p class="translated">评估仍然像现有的布尔表达式一样是惰性的，因此评估顺序会有些跳跃。中间的 <em>condition</em> 表达式首先被评估，<em>true_value</em> 表达式只有在条件为真时才会被评估。同样，<em>false_value</em> 表达式只有在条件为假时才会被评估。</p>
<p class="translated">这种语法可能看起来奇怪且倒置；为什么条件要放在表达式的*中间*，而不是像C语言中的``c ? x : y``那样放在前面？这一决定是通过将新语法应用于标准库中的模块，并查看生成的代码的可读性来验证的。在许多使用条件表达式的情况下，一个值似乎是'常见情况'，而另一个值是'特殊情况'，仅在条件不满足的罕见情况下使用。条件语法使这种模式更加明显:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">contents</span> <span class="o">=</span> <span class="p">((</span><span class="n">doc</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">doc</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">我将上述声明理解为“通常 <em>contents</em> 被赋值为 <code class="docutils literal notranslate"><span class="pre">doc+'\n'</span></code>；有时 <em>doc</em> 为空，在这种情况下返回空字符串。”我怀疑在不存在明显常见和不常见情况的地方，我不会经常使用条件表达式。</p>
<p class="translated">曾经有过一些讨论，关于是否应该要求在条件表达式周围加上括号。决定是不在 Python 语言的语法中要求括号，但出于风格考虑，我认为你应该总是使用它们。考虑以下两个语句:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 第一个版本 -- 无括号</span>
<span class="n">level</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">logging</span> <span class="k">else</span> <span class="mi">0</span>

<span class="c1"># 第二个版本 -- 有括号</span>
<span class="n">level</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">logging</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">在第一个版本中，我认为读者的视线可能会将语句分为'level = 1'、'if logging'、'else 0'，并认为条件决定了是否对*level*进行赋值。在我看来，第二个版本读起来更好，因为它清楚地表明赋值始终执行，只是在两个值之间进行选择。</p>
<p class="translated">包含括号还有一个原因：一些列表推导式和lambda表达式的奇怪组合可能看起来像错误的条件表达式。参见 <span class="target" id="index-64"></span><a class="pep reference external" href="https://peps.python.org/pep-0308/"><strong>PEP 308</strong></a> 了解一些示例。如果你在条件表达式周围加上括号，就不会遇到这种情况。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-65"></span><a class="pep reference external" href="https://peps.python.org/pep-0308/"><strong>PEP 308</strong></a> - 条件表达式</dt><dd><p class="translated">PEP 由 Guido van Rossum 和 Raymond D 撰写，由 Thomas Wouters 实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-309-partial-function-application">
<span id="pep-309"></span><h2 class="translated">PEP 309: 部分功能应用<a class="headerlink" href="#pep-309-partial-function-application" title="Link to this heading">¶</a></h2>
<p class="translated"><a class="reference internal" href="../library/functools.html#module-functools" title="functools: Higher-order functions and operations on callable objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">functools</span></code></a> 模块旨在包含用于函数式编程风格的工具。</p>
<p class="translated">这个模块中一个有用的工具是 <code class="xref py py-func docutils literal notranslate"><span class="pre">partial()</span></code> 函数。对于用函数式风格编写的程序，有时你会想要构造一些现有函数的变体，其中部分参数已填充。考虑一个Python函数``f(a, b, c)``；你可以创建一个新函数``g(b, c)``，它等同于``f(1, b, c)``。这被称为“部分函数应用”。</p>
<p class="translated"><code class="xref py py-func docutils literal notranslate"><span class="pre">partial()</span></code> 接受参数 <code class="docutils literal notranslate"><span class="pre">(function,</span> <span class="pre">arg1,</span> <span class="pre">arg2,</span> <span class="pre">...</span> <span class="pre">kwarg1=value1,</span> <span class="pre">kwarg2=value2)</span></code>。生成的对象是可调用的，因此你可以直接调用它来使用填充的参数调用*function*。</p>
<p class="translated">这里有一个很小但很现实的例子:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">functools</span>

<span class="k">def</span><span class="w"> </span><span class="nf">log</span> <span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">subsystem</span><span class="p">):</span>
    <span class="s2">&quot;将 &#39;message&#39; 的内容写到指定的子系统。&quot;</span>
    <span class="nb">print</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">subsystem</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
    <span class="o">...</span>

<span class="n">server_log</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">subsystem</span><span class="o">=</span><span class="s1">&#39;server&#39;</span><span class="p">)</span>
<span class="n">server_log</span><span class="p">(</span><span class="s1">&#39;Unable to open socket&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">这里还有一个例子，来自一个使用PyGTK的程序。这里正在动态构建一个上下文敏感的弹出菜单。为菜单选项提供的回调是一个部分应用的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">open_item()</span></code> 方法版本，其中第一个参数已经提供。</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Application</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">open_item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
       <span class="o">...</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">init</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">open_func</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">open_item</span><span class="p">,</span> <span class="n">item_path</span><span class="p">)</span>
        <span class="n">popup_menu</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="s2">&quot;Open&quot;</span><span class="p">,</span> <span class="n">open_func</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p class="translated">在 <a class="reference internal" href="../library/functools.html#module-functools" title="functools: Higher-order functions and operations on callable objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">functools</span></code></a> 模块中，另一个函数是 <code class="docutils literal notranslate"><span class="pre">update_wrapper(wrapper,</span> <span class="pre">wrapped)</span></code>，它可以帮助你编写行为良好的装饰器。<code class="xref py py-func docutils literal notranslate"><span class="pre">update_wrapper()</span></code> 将名称、模块和文档字符串属性复制到包装函数中，以便更容易理解包装函数内的追溯信息。例如，你可能这样写:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">my_decorator</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="nb">print</span> <span class="s1">&#39;Calling decorated function&#39;</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
    <span class="n">functools</span><span class="o">.</span><span class="n">update_wrapper</span><span class="p">(</span><span class="n">wrapper</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</pre></div>
</div>
<p class="translated"><code class="xref py py-func docutils literal notranslate"><span class="pre">wraps()</span></code> 是一个装饰器，可以在你自己的装饰器中使用，以复制被包装函数的信息。上一个示例的另一种版本可能是:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">my_decorator</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="nb">print</span> <span class="s1">&#39;Calling decorated function&#39;</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-66"></span><a class="pep reference external" href="https://peps.python.org/pep-0309/"><strong>PEP 309</strong></a> - 部分函数应用</dt><dd><p class="translated">PEP由 Peter Harris 提出并撰写；由 Hye-Shik Chang 和 Nick Coghlan 实现，并由 Raymond Hettinger 适配。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-314-metadata-for-python-software-packages-v1-1">
<span id="pep-314"></span><h2 class="translated">PEP 314: Python软件包的元数据 v1.1<a class="headerlink" href="#pep-314-metadata-for-python-software-packages-v1-1" title="Link to this heading">¶</a></h2>
<p class="translated">Distutils 中添加了一些简单的依赖支持。<code class="xref py py-func docutils literal notranslate"><span class="pre">setup()</span></code> 函数现在有了 <code class="docutils literal notranslate"><span class="pre">requires</span></code>、<code class="docutils literal notranslate"><span class="pre">provides</span></code> 和 <code class="docutils literal notranslate"><span class="pre">obsoletes</span></code> 关键字参数。当你使用 <code class="docutils literal notranslate"><span class="pre">sdist</span></code> 命令构建源代码分发时，依赖信息将被记录在 <code class="file docutils literal notranslate"><span class="pre">PKG-INFO</span></code> 文件中。</p>
<p class="translated">另一个新的关键字参数是 <code class="docutils literal notranslate"><span class="pre">download_url</span></code>，它应该设置为包源代码的 URL。这意味着现在可以查找包索引中的条目，确定包的依赖关系，并下载所需的包。:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">VERSION</span> <span class="o">=</span> <span class="s1">&#39;1.0&#39;</span>
<span class="n">setup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;PyPackage&#39;</span><span class="p">,</span>
      <span class="n">version</span><span class="o">=</span><span class="n">VERSION</span><span class="p">,</span>
      <span class="n">requires</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;numarray&#39;</span><span class="p">,</span> <span class="s1">&#39;zlib (&gt;=1.1.4)&#39;</span><span class="p">],</span>
      <span class="n">obsoletes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;OldPackage&#39;</span><span class="p">]</span>
      <span class="n">download_url</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/pypackage/dist/pkg-</span><span class="si">%s</span><span class="s1">.tar.gz&#39;</span>
                    <span class="o">%</span> <span class="n">VERSION</span><span class="p">),</span>
     <span class="p">)</span>
</pre></div>
</div>
<p class="translated">Python 包索引 <a class="reference external" href="https://pypi.org">https://pypi.org</a> 的另一个新增强功能是存储包的源代码和二进制存档。新的 <strong class="command">upload</strong> Distutils 命令将上传包到仓库。</p>
<p class="translated">在包可以上传之前，你必须能够使用 <strong class="command">sdist</strong> Distutils 命令构建分发。一旦那个工作完成，你可以运行 <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">upload</span></code> 将你的包添加到 PyPI 存档中。可选地，你可以通过提供 <code class="xref std std-option docutils literal notranslate"><span class="pre">--sign</span></code> 和 <code class="xref std std-option docutils literal notranslate"><span class="pre">--identity</span></code> 选项来对包进行 GPG 签名。</p>
<p class="translated">包上传操作由 Martin von Löwis 和 Richard Jones 实现。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-67"></span><a class="pep reference external" href="https://peps.python.org/pep-0314/"><strong>PEP 314</strong></a> - Python软件包的元数据 v1.1</dt><dd><p class="translated">PEP 由 A.M. Kuchling, Richard Jones 和 Fred Drake 提出并撰写，由 Richard Jones 和 Fred Drake 实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-328-absolute-and-relative-imports">
<span id="pep-328"></span><h2 class="translated">PEP 328: 绝对导入和相对导入<a class="headerlink" href="#pep-328-absolute-and-relative-imports" title="Link to this heading">¶</a></h2>
<p class="translated"><span class="target" id="index-68"></span><a class="pep reference external" href="https://peps.python.org/pep-0328/"><strong>PEP 328</strong></a> 的较简单部分已在 Python 2.4 中实现：现在可以用圆括号将使用 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">...</span> <span class="pre">import</span> <span class="pre">...</span></code> 语句导入的名称括起来，以便能够更容易地导入大量不同的名称。</p>
<p class="translated">更复杂的部分已在 Python 2.5 中实现：可以指定使用绝对的或相对于包的导入方式来导入模块。 计划在未来的 Python 版本中将绝对导入方式设为默认。</p>
<p class="translated">比如说你有这样一个包目录:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">pkg</span><span class="o">/</span>
<span class="n">pkg</span><span class="o">/</span><span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
<span class="n">pkg</span><span class="o">/</span><span class="n">main</span><span class="o">.</span><span class="n">py</span>
<span class="n">pkg</span><span class="o">/</span><span class="n">string</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p class="translated">这定义了一个名为 <code class="xref py py-mod docutils literal notranslate"><span class="pre">pkg</span></code> 的包，其中包含 <code class="xref py py-mod docutils literal notranslate"><span class="pre">pkg.main</span></code> 和 <code class="xref py py-mod docutils literal notranslate"><span class="pre">pkg.string</span></code> 子模块。</p>
<p class="translated">考虑在 <code class="file docutils literal notranslate"><span class="pre">main.py</span></code> 模块中的代码。如果它执行了语句 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">string</span></code> 会发生什么？在 Python 2.4 及更早版本中，它首先会在包的目录中查找以进行相对导入，找到 <code class="file docutils literal notranslate"><span class="pre">pkg/string.py</span></code>，将该文件的内容导入为 <code class="xref py py-mod docutils literal notranslate"><span class="pre">pkg.string</span></code> 模块，并且该模块绑定到 <code class="xref py py-mod docutils literal notranslate"><span class="pre">pkg.main</span></code> 模块命名空间中的名称 <code class="docutils literal notranslate"><span class="pre">string</span></code>。</p>
<p class="translated">如果 <code class="xref py py-mod docutils literal notranslate"><span class="pre">pkg.string</span></code> 是你想要的，那没问题。但如果你想要的是 Python 的标准 <a class="reference internal" href="../library/string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code></a> 模块呢？没有一种干净的方法来忽略 <code class="xref py py-mod docutils literal notranslate"><span class="pre">pkg.string</span></code> 并查找标准模块；通常你需要查看 <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code> 的内容，这稍微有些不干净。Holger Krekel 的 <code class="xref py py-mod docutils literal notranslate"><span class="pre">py.std</span></code> 包提供了一种更整洁的方式来从标准库进行导入，<code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">py;</span> <span class="pre">py.std.string.join()</span></code>，但该包并非在所有 Python 安装中都可用。</p>
<p class="translated">阅读依赖相对导入的代码也不够清晰，因为读者可能会对意图使用哪个模块，<a class="reference internal" href="../library/string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code></a> 还是 <code class="xref py py-mod docutils literal notranslate"><span class="pre">pkg.string</span></code>，感到困惑。Python 用户很快学会了不要在他们的包子模块名称中重复标准库模块的名称，但你无法防止你的子模块名称被用于未来版本 Python 中添加的新模块。</p>
<p class="translated">在 Python 2.5 中，你可以通过使用 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">absolute_import</span></code> 指令将 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 的行为切换为绝对导入。这种绝对导入行为将在未来版本（可能是 Python 2.7）中成为默认行为。一旦绝对导入成为默认行为，<code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">string</span></code> 将始终找到标准库的版本。建议用户尽可能开始使用绝对导入，因此最好在代码中开始写 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">pkg</span> <span class="pre">import</span> <span class="pre">string</span></code>。</p>
<p class="translated">通过在使用 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">...</span> <span class="pre">import</span></code> 形式时在模块名称前添加一个前导点，仍然可以进行相对导入：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 从 pkg.string 导入名称</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.string</span><span class="w"> </span><span class="kn">import</span> <span class="n">name1</span><span class="p">,</span> <span class="n">name2</span>
<span class="c1"># 导入 pkg.string</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">string</span>
</pre></div>
</div>
<p class="translated">这会相对当前包导入 <a class="reference internal" href="../library/string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code></a> 模块，所以在 <code class="xref py py-mod docutils literal notranslate"><span class="pre">pkg.main</span></code> 中这将导入 <em>name1</em> 和 <em>name2</em> 来自 <code class="xref py py-mod docutils literal notranslate"><span class="pre">pkg.string</span></code>。额外的前导点号从当前包的父包开始执行相对导入。例如，在 <code class="xref py py-mod docutils literal notranslate"><span class="pre">A.B.C</span></code> 模块中的代码可以这样做:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">D</span>                 <span class="c1"># 导入 A.B.D</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..</span><span class="w"> </span><span class="kn">import</span> <span class="n">E</span>                <span class="c1"># 导入 A.E</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..F</span><span class="w"> </span><span class="kn">import</span> <span class="n">G</span>               <span class="c1"># 导入 A.F.G</span>
</pre></div>
</div>
<p class="translated">开头的句点不可用于 import 语句的 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">modname</span></code> 形式，只能用于 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">...</span> <span class="pre">import</span></code> 形式。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-69"></span><a class="pep reference external" href="https://peps.python.org/pep-0328/"><strong>PEP 328</strong></a> - 导入：多行和绝对/相对导入</dt><dd><p class="translated">PEP 由 Aahz 撰写，由 Thomas Wouters 实现。</p>
</dd>
<dt class="translated"><a class="reference external" href="https://pylib.readthedocs.io/">https://pylib.readthedocs.io/</a></dt><dd><p class="translated">由 Holger Krekel 编写 py 库，其中包含 <code class="xref py py-mod docutils literal notranslate"><span class="pre">py.std</span></code> 包。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-338-executing-modules-as-scripts">
<span id="pep-338"></span><h2 class="translated">PEP 338: 将模块作为脚本执行<a class="headerlink" href="#pep-338-executing-modules-as-scripts" title="Link to this heading">¶</a></h2>
<p class="translated">Python 2.4 中添加的 <a class="reference internal" href="../using/cmdline.html#cmdoption-m"><code class="xref std std-option docutils literal notranslate"><span class="pre">-m</span></code></a> 开关用于将模块作为脚本执行，获得了一些新能力。这个开关现在不再使用 Python 解释器内部的 C 代码实现，而是使用一个新模块 <a class="reference internal" href="../library/runpy.html#module-runpy" title="runpy: Locate and run Python modules without importing them first."><code class="xref py py-mod docutils literal notranslate"><span class="pre">runpy</span></code></a> 中的实现。</p>
<p class="translated"><a class="reference internal" href="../library/runpy.html#module-runpy" title="runpy: Locate and run Python modules without importing them first."><code class="xref py py-mod docutils literal notranslate"><span class="pre">runpy</span></code></a> 模块实现了一个更复杂的导入机制，现在可以运行包中的模块，例如 <code class="xref py py-mod docutils literal notranslate"><span class="pre">pychecker.checker</span></code>。该模块还支持其他导入机制，例如 <a class="reference internal" href="../library/zipimport.html#module-zipimport" title="zipimport: Support for importing Python modules from ZIP archives."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipimport</span></code></a> 模块。这意味着你可以将 .zip 归档的路径添加到 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> 中，然后使用 <a class="reference internal" href="../using/cmdline.html#cmdoption-m"><code class="xref std std-option docutils literal notranslate"><span class="pre">-m</span></code></a> 开关来执行归档中的代码。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-70"></span><a class="pep reference external" href="https://peps.python.org/pep-0338/"><strong>PEP 338</strong></a> - 将模块作为脚本执行</dt><dd><p class="translated">PEP 由 Nick Coghlan 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-341-unified-try-except-finally">
<span id="pep-341"></span><h2 class="translated">PEP 341: 统一 try/except/finally<a class="headerlink" href="#pep-341-unified-try-except-finally" title="Link to this heading">¶</a></h2>
<p class="translated">直到 Python 2.5，<a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a> 语句有两种形式。你可以使用 <a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 块确保代码总是被执行，或者使用一个或多个 <a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> 块来捕获特定异常。你不能同时组合 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code> 块和 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code> 块，因为生成正确字节码的合并版本很复杂，并且不清楚合并语句的语义应该是什么。</p>
<p class="translated">Guido van Rossum 花了一些时间研究 Java，后者支持组合 <a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> 块和 <a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 块的等价物，这澄清了该语句应该是什么意思。在 Python 2.5 中，你现在可以写:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">block</span><span class="o">-</span><span class="mi">1</span> <span class="o">...</span>
<span class="k">except</span> <span class="n">Exception1</span><span class="p">:</span>
    <span class="n">handler</span><span class="o">-</span><span class="mi">1</span> <span class="o">...</span>
<span class="k">except</span> <span class="n">Exception2</span><span class="p">:</span>
    <span class="n">handler</span><span class="o">-</span><span class="mi">2</span> <span class="o">...</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">else</span><span class="o">-</span><span class="n">block</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">final</span><span class="o">-</span><span class="n">block</span>
</pre></div>
</div>
<p class="translated">执行 <em>block-1</em> 中的代码。如果代码引发异常，将测试各个 <a class="reference internal" href="../reference/compound_stmts.html#except"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">except</span></code></a> 块：如果异常属于 <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception1</span></code> 类，则执行 <em>handler-1</em>；否则，如果它属于 <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception2</span></code> 类，则执行 <em>handler-2</em>，依此类推。如果没有引发异常，则执行 <em>else-block</em>。</p>
<p class="translated">无论之前发生了什么，一旦代码块完成并且处理了任何引发的异常，<em>final-block</em> 都会被执行一次。即使异常处理程序或 <em>else-block</em> 中出现错误并引发了新的异常，<em>final-block</em> 中的代码仍然会运行。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-71"></span><a class="pep reference external" href="https://peps.python.org/pep-0341/"><strong>PEP 341</strong></a> - 统一 try-except 和 try-finally</dt><dd><p class="translated">PEP 由 Georg Brandl 撰写，由 Thomas Lee 实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-342-new-generator-features">
<span id="pep-342"></span><h2 class="translated">PEP 342: 生成器的新特性<a class="headerlink" href="#pep-342-new-generator-features" title="Link to this heading">¶</a></h2>
<p class="translated">Python 2.5 添加了一种简单的方法来将值 <em>传入</em> 生成器。如在 Python 2.3 中引入的，生成器仅产生输出；一旦生成器的代码被调用以创建迭代器，当其执行恢复时，无法将任何新信息传递到函数中。有时能够传递一些信息会很有用。对此的权宜之计包括让生成器的代码查看全局变量，然后更改全局变量的值，或者传入一些可变对象，然后调用者修改它。</p>
<p class="translated">为了刷新你对基本生成器的记忆，这里有一个简单的例子：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">counter</span> <span class="p">(</span><span class="n">maximum</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maximum</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">i</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p class="translated">当你调用 <code class="docutils literal notranslate"><span class="pre">counter(10)</span></code> 时，结果是一个迭代器，它返回从 0 到 9 的值。在遇到 <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 语句时，迭代器返回提供的值并挂起函数的执行，保留局部变量。执行在下次调用迭代器的 <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-meth docutils literal notranslate"><span class="pre">next()</span></code></a> 方法时恢复，从 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 语句之后开始。</p>
<p class="translated">在 Python 2.3 中，<a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 是一个语句；它不返回任何值。在 2.5 中，<code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 现在是一个表达式，返回一个可以赋值给变量或进行其他操作的值：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span> <span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">我建议在处理返回值时，总是将 <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 表达式用括号括起来，如上例所示。括号并非总是必要，但总是添加它们比记住何时需要它们要容易。</p>
<p class="translated">(<span class="target" id="index-72"></span><a class="pep reference external" href="https://peps.python.org/pep-0342/"><strong>PEP 342</strong></a> 解释了确切的规则，即 <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a>-表达式必须总是括起来，除非它出现在赋值右侧的顶层表达式中。这意味着你可以写 <code class="docutils literal notranslate"><span class="pre">val</span> <span class="pre">=</span> <span class="pre">yield</span> <span class="pre">i</span></code>，但在有操作时必须使用括号，如 <code class="docutils literal notranslate"><span class="pre">val</span> <span class="pre">=</span> <span class="pre">(yield</span> <span class="pre">i)</span> <span class="pre">+</span> <span class="pre">12</span></code>。）</p>
<p class="translated">通过调用生成器的 <code class="docutils literal notranslate"><span class="pre">send(value)</span></code> 方法将值发送到生成器中。然后生成器的代码继续执行，<a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 表达式返回指定的 <em>value</em>。如果调用常规的 <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-meth docutils literal notranslate"><span class="pre">next()</span></code></a> 方法，<code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 返回 <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>。</p>
<p class="translated">以下是修改后的示例，允许更改内部计数器的值。</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">counter</span> <span class="p">(</span><span class="n">maximum</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maximum</span><span class="p">:</span>
        <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span> <span class="n">i</span><span class="p">)</span>
        <span class="c1"># 如果提供了值，更改计数器</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p class="translated">以下是更改计数器的示例:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">it</span> <span class="o">=</span> <span class="n">counter</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">it</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;t.py&quot;</span>, line <span class="m">15</span>, in <span class="n">?</span>
<span class="w">    </span><span class="nb">print</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="gr">StopIteration</span>
</pre></div>
</div>
<p class="translated"><a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 通常会返回 <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a>，因此你应该总是检查这种情况。不要仅在表达式中使用它的值，除非你确信 <code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code> 方法将是唯一用于恢复生成器函数的方法。</p>
<p class="translated">除了 <code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code>，生成器上还有另外两个新方法：</p>
<ul>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">throw(type,</span> <span class="pre">value=None,</span> <span class="pre">traceback=None)</span></code> 用于在生成器内部引发异常；异常由 <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 表达式在生成器执行暂停的地方引发。</p></li>
<li><p class="translated"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code> 方法在生成器内部引发一个新的 <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> 异常以终止迭代。接收到此异常时，生成器的代码必须要么引发 <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a>，要么引发 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a>。捕获 <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> 异常并返回值是不合法的，将会触发 <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a>；如果函数引发其他异常，该异常将传播给调用者。<code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code> 方法还将在生成器被垃圾回收时由 Python 的垃圾回收器调用。</p>
<p class="translated">如果你需要在 <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> 发生的时候运行清理代码，我建议使用 <code class="docutils literal notranslate"><span class="pre">try:</span> <span class="pre">...</span> <span class="pre">finally:</span></code> 组合来代替捕获 <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a>。</p>
</li>
</ul>
<p class="translated">这些改变的累积效应是，让生成器从单向的信息生产者变成了既是生产者，又是消费者。</p>
<p class="translated">生成器还可以成为 <em>协程</em>，这是一种更通用的子程序形式。子程序从一个点进入并在另一个点退出（函数顶部和 <a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 语句），但协程可以在许多不同的点进入、退出和恢复（<a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 语句）。我们需要找出在 Python 中有效使用协程的模式。</p>
<p class="translated">添加 <code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code> 方法有一个不明显的影响。当生成器被垃圾回收时，会调用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code>，这意味着生成器的代码在生成器被销毁之前有最后一次运行的机会。这最后一次机会意味着生成器中的 <code class="docutils literal notranslate"><span class="pre">try...finally</span></code> 语句现在可以保证工作；<a class="reference internal" href="../reference/compound_stmts.html#finally"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code></a> 子句现在总能得到运行的机会。因此，之前的语法限制——不能将 <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 语句与 <code class="docutils literal notranslate"><span class="pre">try...finally</span></code> 块混合使用——已经被移除。这看起来像是语言的小细节，但实际上使用生成器和 <code class="docutils literal notranslate"><span class="pre">try...finally</span></code> 对于实现 <span class="target" id="index-73"></span><a class="pep reference external" href="https://peps.python.org/pep-0343/"><strong>PEP 343</strong></a> 中描述的 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 语句是必要的。我将在下一节中探讨这个新语句。</p>
<p class="translated">这个变化的另一个更神秘的影响是：以前，生成器的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">gi_frame</span></code> 属性总是一个帧对象。现在，一旦生成器耗尽，<code class="xref py py-attr docutils literal notranslate"><span class="pre">gi_frame</span></code> 有可能变为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl>
<dt class="translated"><span class="target" id="index-74"></span><a class="pep reference external" href="https://peps.python.org/pep-0342/"><strong>PEP 342</strong></a> - 通过增强型生成器实现协程</dt><dd><p class="translated">PEP 由 Guido van Rossum 和 Phillip J. Eby 撰写，由 Phillip J. Eby 实现。包括一些更高级的使用生成器作为协程的示例。</p>
<p class="translated">这些功能的早期版本在 <span class="target" id="index-75"></span><a class="pep reference external" href="https://peps.python.org/pep-0288/"><strong>PEP 288</strong></a> （由 Raymond Hettinger 撰写） 和 <span class="target" id="index-76"></span><a class="pep reference external" href="https://peps.python.org/pep-0325/"><strong>PEP 325</strong></a> （由 Samuele Pedroni 撰写）中提出。</p>
</dd>
<dt class="translated"><a class="reference external" href="https://en.wikipedia.org/wiki/Coroutine">https://en.wikipedia.org/wiki/Coroutine</a></dt><dd><p class="translated">协程的Wikipedia条目。</p>
</dd>
<dt class="translated"><a class="reference external" href="https://web.archive.org/web/20160321211320/http://www.sidhe.org/~dan/blog/archives/000178.html">https://web.archive.org/web/20160321211320/http://www.sidhe.org/~dan/blog/archives/000178.html</a></dt><dd><p class="translated">基于 Perl 视角对协程的介绍，由 Dan Sugalski 撰写。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-343-the-with-statement">
<span id="pep-343"></span><h2 class="translated">PEP 343: &quot;with&quot; 语句<a class="headerlink" href="#pep-343-the-with-statement" title="Link to this heading">¶</a></h2>
<p class="translated">'<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>' 语句澄清了之前使用 <code class="docutils literal notranslate"><span class="pre">try...finally</span></code> 块来确保执行清理代码的代码。在本节中，我将讨论该语句的常见用法。在下一节中，我将探讨实现细节，并展示如何编写与该语句一起使用的对象。</p>
<p class="translated">'<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>' 语句是一个新的控制流结构，其基本结构如下:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">expression</span> <span class="p">[</span><span class="k">as</span> <span class="n">variable</span><span class="p">]:</span>
    <span class="k">with</span><span class="o">-</span><span class="n">block</span>
</pre></div>
</div>
<p class="translated">表达式被评估，并且应该生成一个支持上下文管理协议的对象（即具有 <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> 和 <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 方法的对象）。</p>
<p class="translated">在执行 <em>with-block</em> 之前调用对象的 <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> 方法，因此可以运行设置代码。它还可以返回一个值，该值绑定到名称 <em>variable*（如果给出）。请注意，*variable</em> 并不是被赋值为 <em>expression</em> 的结果。</p>
<p class="translated">在 <em>with-block</em> 执行完成后，调用对象的 <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 方法，即使块引发了异常，也可以运行清理代码。</p>
<p class="translated">要在 Python 2.5 中启用该语句，你需要向你的模块添加以下指令:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">with_statement</span>
</pre></div>
</div>
<p class="translated">该语句在Python 2.6 中始终启用。</p>
<p class="translated">一些标准 Python 对象现在已支持上下文管理协议并可被用于 '<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>' 语句。 文件对象就是一个例子:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/etc/passwd&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
        <span class="nb">print</span> <span class="n">line</span>
        <span class="o">...</span> <span class="n">更多处理代码</span> <span class="o">...</span>
</pre></div>
</div>
<p class="translated">在此语句被执行之后，文件对象 <em>f</em> 将被自动关闭，即使是当 <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 循环在代码块中间位置引发了异常的时候也是如此。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p class="translated">在此情况下，<em>f</em> 就是由 <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 所创建的对象，因为 <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> 会返回 <em>self</em>。</p>
</div>
<p class="translated"><a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> 模块的加锁和条件变量也支持 '<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>' 语句:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
<span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
    <span class="c1"># 关键代码段</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated">这个锁会在代码块被执行之前锁定并总是会在代码块完成之后释放。</p>
<p class="translated">在 <a class="reference internal" href="../library/decimal.html#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic Specification."><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code></a> 模块中的新 <code class="xref py py-func docutils literal notranslate"><span class="pre">localcontext()</span></code> 函数可以轻松保存和恢复当前的十进制上下文，该上下文封装了计算所需的精度和舍入特性:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">decimal</span><span class="w"> </span><span class="kn">import</span> <span class="n">Decimal</span><span class="p">,</span> <span class="n">Context</span><span class="p">,</span> <span class="n">localcontext</span>

<span class="c1"># 使用默认精度 28 位显示</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;578&#39;</span><span class="p">)</span>
<span class="nb">print</span> <span class="n">v</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>

<span class="k">with</span> <span class="n">localcontext</span><span class="p">(</span><span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">16</span><span class="p">)):</span>
    <span class="c1"># 此块中的所有代码使用 16 位精度。</span>
    <span class="c1"># 块退出时恢复原始上下文。</span>
    <span class="nb">print</span> <span class="n">v</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>
</pre></div>
</div>
<section id="writing-context-managers">
<span id="new-25-context-managers"></span><h3 class="translated">编写上下文管理器<a class="headerlink" href="#writing-context-managers" title="Link to this heading">¶</a></h3>
<p class="translated">在幕后，'<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>' 语句相当复杂。大多数人只会与现有对象一起使用 '<code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code>'，不需要了解这些细节，所以如果你愿意，可以跳过本节的其余部分。新对象的作者需要理解底层实现的细节，应该继续阅读。</p>
<p class="translated">在更高层级上对于上下文管理器协议的解释:</p>
<ul class="simple">
<li><p class="translated">表达式将被求值，并应生成一个称为“上下文管理器”的对象。上下文管理器必须具有 <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> 和 <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 方法。</p></li>
<li><p class="translated">调用上下文管理器的 <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> 方法。返回的值被赋给 <em>VAR</em>。如果没有 <code class="docutils literal notranslate"><span class="pre">'as</span> <span class="pre">VAR'</span></code> 子句，该值将被丢弃。</p></li>
<li><p class="translated"><em>BLOCK</em> 中的代码会被执行。</p></li>
<li><p class="translated">如果 <em>BLOCK</em> 引发异常，将调用 <code class="docutils literal notranslate"><span class="pre">__exit__(type,</span> <span class="pre">value,</span> <span class="pre">traceback)</span></code> 方法，并传入异常详细信息，这些值与 <a class="reference internal" href="../library/sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> 返回的值相同。该方法的返回值控制是否重新抛出异常：任何假值将重新抛出异常，而 <code class="docutils literal notranslate"><span class="pre">True</span></code> 将导致异常被抑制。通常情况下，你很少会想要抑制异常，因为如果你这么做，包含 '<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>' 语句的代码作者将永远不会意识到出了问题。</p></li>
<li><p class="translated">如果 <em>BLOCK</em> 没有引发异常，仍然会调用 <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 方法，但 <em>type</em>、<em>value</em> 和 <em>traceback</em> 都是 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p></li>
</ul>
<p class="translated">让我们通过一个例子来思考。我将不展示详细的代码，而只是概述支持事务的数据库所需的方法。</p>
<p class="translated">（对于不熟悉数据库术语的人：对数据库的一系列更改被组合成一个事务。事务可以被提交，意味着所有更改都被写入数据库，或者被回滚，意味着所有更改都被丢弃，数据库保持不变。更多信息请参阅任何数据库教材。）</p>
<p class="translated">假设有一个表示数据库连接的对象。我们的目标将是让用户编写如下代码：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">db_connection</span> <span class="o">=</span> <span class="n">DatabaseConnection</span><span class="p">()</span>
<span class="k">with</span> <span class="n">db_connection</span> <span class="k">as</span> <span class="n">cursor</span><span class="p">:</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;insert into ...&#39;</span><span class="p">)</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;delete from ...&#39;</span><span class="p">)</span>
    <span class="c1"># ... 更多操作 ...</span>
</pre></div>
</div>
<p class="translated">如果块中的代码完美运行，事务应该被提交；如果出现异常，事务应该被回滚。以下是我假设的 <code class="xref py py-class docutils literal notranslate"><span class="pre">DatabaseConnection</span></code> 的基本接口：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">DatabaseConnection</span><span class="p">:</span>
    <span class="c1"># 数据库接口</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cursor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;返回一个游标对象并开始一个新的事务&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">commit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;提交当前事务&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">rollback</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;回滚当前事务&quot;</span>
</pre></div>
</div>
<p class="translated">The <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> 方法非常简单，只需开始一个新的事务。对于这个应用程序，生成的游标对象将是一个有用的结果，因此该方法将返回它。用户可以在他们的 '<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>' 语句中添加 <code class="docutils literal notranslate"><span class="pre">as</span> <span class="pre">cursor</span></code> 来将游标绑定到一个变量名。:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">DatabaseConnection</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># 开始一个新事务的代码</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">cursor</span>
</pre></div>
</div>
<p class="translated">The <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 方法是最复杂的，因为大部分工作需要在这里完成。该方法需要检查是否发生了异常。如果没有异常，事务将被提交。如果发生了异常，事务将被回滚。</p>
<p class="translated">在下面的代码中，执行将直接从函数末尾跳出，返回默认值 <code class="docutils literal notranslate"><span class="pre">None</span></code>。<code class="docutils literal notranslate"><span class="pre">None</span></code> 是假值，因此异常将自动重新抛出。如果你愿意，你可以更明确地添加一个 <a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 语句在标记的位置。:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">DatabaseConnection</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__exit__</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">tb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># 没有异常，因此提交</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 发生异常，因此回滚。</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>
            <span class="c1"># 返回 False</span>
</pre></div>
</div>
</section>
<section id="the-contextlib-module">
<span id="contextlibmod"></span><h3 class="translated">contextlib 模块<a class="headerlink" href="#the-contextlib-module" title="Link to this heading">¶</a></h3>
<p class="translated">新的 <a class="reference internal" href="../library/contextlib.html#module-contextlib" title="contextlib: Utilities for with-statement contexts."><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextlib</span></code></a> 模块提供了一些函数和一个装饰器，用于编写与 '<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>' 语句一起使用的对象。</p>
<p class="translated">该装饰器称为 <code class="xref py py-func docutils literal notranslate"><span class="pre">contextmanager()</span></code>，它允许你编写单个生成器函数，而不是定义一个新的类。生成器应该产生恰好一个值。<a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 之前的代码将作为 <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> 方法执行，产生的值将是该方法的返回值，该值将绑定到 '<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>' 语句的 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code> 子句中的变量（如果有的话）。<a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 之后的代码将在 <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 方法中执行。块中引发的任何异常将由 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 语句引发。</p>
<p class="translated">上一节中的数据库示例可以使用这个装饰器编写为:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">contextlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">contextmanager</span>

<span class="nd">@contextmanager</span>
<span class="k">def</span><span class="w"> </span><span class="nf">db_transaction</span> <span class="p">(</span><span class="n">connection</span><span class="p">):</span>
    <span class="n">cursor</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">cursor</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">connection</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>
        <span class="k">raise</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">connection</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

<span class="n">db</span> <span class="o">=</span> <span class="n">DatabaseConnection</span><span class="p">()</span>
<span class="k">with</span> <span class="n">db_transaction</span><span class="p">(</span><span class="n">db</span><span class="p">)</span> <span class="k">as</span> <span class="n">cursor</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated"><a class="reference internal" href="../library/contextlib.html#module-contextlib" title="contextlib: Utilities for with-statement contexts."><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextlib</span></code></a> 模块还有一个``nested(mgr1, mgr2, ...)``函数，它可以将多个上下文管理器组合在一起，这样你就不需要编写嵌套的'<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>'语句。在这个例子中，单个'<code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code>'语句既启动数据库事务又获取线程锁:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
<span class="k">with</span> <span class="n">nested</span> <span class="p">(</span><span class="n">db_transaction</span><span class="p">(</span><span class="n">db</span><span class="p">),</span> <span class="n">lock</span><span class="p">)</span> <span class="k">as</span> <span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">locked</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated">最后，<code class="docutils literal notranslate"><span class="pre">closing(object)</span></code> 函数返回 <em>object</em>，以便它可以绑定到变量，并在块的末尾调用 <code class="docutils literal notranslate"><span class="pre">object.close</span></code>。:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">urllib</span><span class="o">,</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">contextlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">closing</span>

<span class="k">with</span> <span class="n">closing</span><span class="p">(</span><span class="n">urllib</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.yahoo.com&#39;</span><span class="p">))</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-77"></span><a class="pep reference external" href="https://peps.python.org/pep-0343/"><strong>PEP 343</strong></a> - &quot;with&quot; 语句</dt><dd><p class="translated">PEP由Guido van Rossum和Nick Coghlan编写；由Mike Bland、Guido van Rossum和Neal Norwitz实现。PEP展示了为'<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>'语句生成的代码，这对于学习该语句的工作原理很有帮助。</p>
</dd>
</dl>
<p class="translated"><a class="reference internal" href="../library/contextlib.html#module-contextlib" title="contextlib: Utilities for with-statement contexts."><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextlib</span></code></a> 模块的文档。</p>
</div>
</section>
</section>
<section id="pep-352-exceptions-as-new-style-classes">
<span id="pep-352"></span><h2 class="translated">PEP 352: 异常作为新型的类<a class="headerlink" href="#pep-352-exceptions-as-new-style-classes" title="Link to this heading">¶</a></h2>
<p class="translated">异常类现在可以是新式类，而不仅仅是经典类，内置的 <a class="reference internal" href="../library/exceptions.html#Exception" title="Exception"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Exception</span></code></a> 类和所有标准内置异常（<a class="reference internal" href="../library/exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a>、<a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 等）现在都是新式类。</p>
<p class="translated">异常的继承层次结构已经稍微重新排列了一下。在2.5中，继承关系如下:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="ne">BaseException</span>       <span class="c1"># New in Python 2.5</span>
<span class="o">|-</span> <span class="ne">KeyboardInterrupt</span>
<span class="o">|-</span> <span class="ne">SystemExit</span>
<span class="o">|-</span> <span class="ne">Exception</span>
   <span class="o">|-</span> <span class="p">(</span><span class="nb">all</span> <span class="n">other</span> <span class="n">current</span> <span class="n">built</span><span class="o">-</span><span class="ow">in</span> <span class="n">exceptions</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">这种重新排列是因为人们通常希望捕获所有表示程序错误的异常。然而，<a class="reference internal" href="../library/exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> 和 <a class="reference internal" href="../library/exceptions.html#SystemExit" title="SystemExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SystemExit</span></code></a> 并不是错误，它们通常表示用户执行了明确的操作，例如按下 <kbd class="kbd docutils literal notranslate">Control</kbd>-<kbd class="kbd docutils literal notranslate">C</kbd> 或代码调用 <a class="reference internal" href="../library/sys.html#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exit()</span></code></a>。一个裸露的 <code class="docutils literal notranslate"><span class="pre">except:</span></code> 会捕获所有异常，因此通常需要列出 <a class="reference internal" href="../library/exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> 和 <a class="reference internal" href="../library/exceptions.html#SystemExit" title="SystemExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SystemExit</span></code></a> 以重新抛出它们。通常的模式是:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">except</span> <span class="p">(</span><span class="ne">KeyboardInterrupt</span><span class="p">,</span> <span class="ne">SystemExit</span><span class="p">):</span>
    <span class="k">raise</span>
<span class="k">except</span><span class="p">:</span>
    <span class="c1"># 记录错误...</span>
    <span class="c1"># 继续运行程序...</span>
</pre></div>
</div>
<p class="translated">在 Python 2.5 中，你现在可以写 <code class="docutils literal notranslate"><span class="pre">except</span> <span class="pre">Exception</span></code> 来达到同样的效果，捕获所有通常表示错误的异常，但不包括 <a class="reference internal" href="../library/exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> 和 <a class="reference internal" href="../library/exceptions.html#SystemExit" title="SystemExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SystemExit</span></code></a>。与之前的版本一样，裸露的 <code class="docutils literal notranslate"><span class="pre">except:</span></code> 仍然会捕获所有异常。</p>
<p class="translated">Python 3.0 的目标要求任何作为异常抛出的类都必须从 <a class="reference internal" href="../library/exceptions.html#BaseException" title="BaseException"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseException</span></code></a> 或 <a class="reference internal" href="../library/exceptions.html#BaseException" title="BaseException"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseException</span></code></a> 的子类派生，未来 Python 2.x 系列的版本可能会开始强制执行这一约束。因此，我建议你现在就开始让你的所有异常类从 <a class="reference internal" href="../library/exceptions.html#Exception" title="Exception"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Exception</span></code></a> 派生。有人建议在 Python 3.0 中移除裸露的 <code class="docutils literal notranslate"><span class="pre">except:</span></code> 形式，但 Guido van Rossum 还未决定是否这样做。</p>
<p class="translated">在 Python 2.5 中，将字符串作为异常抛出，如 <code class="docutils literal notranslate"><span class="pre">raise</span> <span class="pre">&quot;Error</span> <span class="pre">occurred&quot;</span></code>，已被弃用，并会触发警告。目标是在几个版本后能够移除字符串异常功能。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-78"></span><a class="pep reference external" href="https://peps.python.org/pep-0352/"><strong>PEP 352</strong></a> - 异常所需的超类</dt><dd><p class="translated">PEP 由 Brett Cannon 和 Guido van Rossum 撰写，由 Brett Cannon 实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-353-using-ssize-t-as-the-index-type">
<span id="pep-353"></span><h2 class="translated">PEP 353: 使用ssize_t作为索引类型<a class="headerlink" href="#pep-353-using-ssize-t-as-the-index-type" title="Link to this heading">¶</a></h2>
<p class="translated">对 Python 的 C API 进行了广泛的更改，使用新的 <a class="reference internal" href="../c-api/intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a> 类型定义代替 <span class="c-expr sig sig-inline c"><span class="kt">int</span></span>，这将允许解释器在 64 位平台上处理更多数据。这一更改不影响 Python 在 32 位平台上的能力。</p>
<p class="translated">Python解释器的各个部分使用C语言的 <span class="c-expr sig sig-inline c"><span class="kt">int</span></span> 类型来存储大小或计数；例如，列表或元组中的项目数量存储在一个 <span class="c-expr sig sig-inline c"><span class="kt">int</span></span> 中。大多数64位平台的C编译器仍然将 <span class="c-expr sig sig-inline c"><span class="kt">int</span></span> 定义为32位类型，这意味着列表最多只能容纳 <code class="docutils literal notranslate"><span class="pre">2**31</span> <span class="pre">-</span> <span class="pre">1</span></code> = 2147483647个项目。（实际上，64位C编译器可以使用几种不同的编程模型——参见 <a class="reference external" href="https://unix.org/version2/whatsnew/lp64_wp.html">https://unix.org/version2/whatsnew/lp64_wp.html</a> 进行讨论——但最常用的模型将 <span class="c-expr sig sig-inline c"><span class="kt">int</span></span> 保留为32位。）</p>
<p class="translated">在32位平台上，2147483647个项目的限制实际上并不重要，因为在达到长度限制之前你就会耗尽内存。每个列表项需要为指针分配空间，指针为4字节，再加上表示该项的 <a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject</span></code></a> 所需的空间。2147483647*4已经超过了32位地址空间所能容纳的字节数。</p>
<p class="translated">然而，在64位平台上，可以寻址这么多的内存。这么大列表的指针只需要16 GiB的空间，因此Python程序员可能会构造如此大的列表，这是合理的。因此，Python解释器必须改为使用某种不同于 <span class="c-expr sig sig-inline c"><span class="kt">int</span></span> 的类型，并且在64位平台上这将是一个64位类型。这一变更将在64位机器上引起不兼容，因此现在进行过渡被认为是值得的，因为64位用户数量仍然相对较少。（在5年或10年后，我们可能 <em>都</em> 在使用64位机器，届时过渡会更加痛苦。）</p>
<p class="translated">这一变更对C扩展模块的作者影响最大。Python字符串和容器类型（如列表和元组）现在使用 <a class="reference internal" href="../c-api/intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a> 来存储其大小。诸如 <a class="reference internal" href="../c-api/list.html#c.PyList_Size" title="PyList_Size"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyList_Size()</span></code></a> 之类的函数现在返回 <a class="reference internal" href="../c-api/intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a>。因此，扩展模块中的代码可能需要将一些变量改为 <a class="reference internal" href="../c-api/intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a>。</p>
<p class="translated"><a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> 和 <a class="reference internal" href="../c-api/arg.html#c.Py_BuildValue" title="Py_BuildValue"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_BuildValue()</span></code></a> 函数新增了一个转换代码 <code class="docutils literal notranslate"><span class="pre">n</span></code>，用于 <a class="reference internal" href="../c-api/intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a>。<a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> 的 <code class="docutils literal notranslate"><span class="pre">s#</span></code> 和 <code class="docutils literal notranslate"><span class="pre">t#</span></code> 默认仍输出 <span class="c-expr sig sig-inline c"><span class="kt">int</span></span>，但你可以在包含 <code class="file docutils literal notranslate"><span class="pre">Python.h</span></code> 之前定义宏 <code class="xref c c-macro docutils literal notranslate"><span class="pre">PY_SSIZE_T_CLEAN</span></code>，以使它们返回 <a class="reference internal" href="../c-api/intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a>。</p>
<p class="translated"><span class="target" id="index-79"></span><a class="pep reference external" href="https://peps.python.org/pep-0353/"><strong>PEP 353</strong></a> 中有一节关于转换指南的内容，扩展作者应阅读以了解如何支持64位平台。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-80"></span><a class="pep reference external" href="https://peps.python.org/pep-0353/"><strong>PEP 353</strong></a> - 使用ssize_t作为索引类型</dt><dd><p class="translated">PEP 由 Martin von Löwis 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-357-the-index-method">
<span id="pep-357"></span><h2 class="translated">PEP 357: '__index__' 方法<a class="headerlink" href="#pep-357-the-index-method" title="Link to this heading">¶</a></h2>
<p class="translated">NumPy 开发者遇到了一个问题，只能通过添加一个新的特殊方法 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code> 来解决。在使用切片表示法时，如 <code class="docutils literal notranslate"><span class="pre">[start:stop:step]</span></code>，<em>start</em>、<em>stop</em> 和 <em>step</em> 索引的值都必须是整数或长整数。NumPy 定义了多种专门的整数类型，对应于8、16、32和64位的无符号和有符号整数，但没有方法表明这些类型可以用作切片索引。</p>
<p class="translated">切片不能直接使用现有的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code> 方法，因为该方法也用于实现强制转换为整数。如果切片使用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code>，浮点数也将成为合法的切片索引，这显然是不希望的行为。</p>
<p class="translated">相反，添加了一个新的特殊方法 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code>。它不接受任何参数，返回一个整数，给出要使用的切片索引。例如：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__index__</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
</pre></div>
</div>
<p class="translated">返回值必须是 Python 整数或长整数。解释器将检查返回的类型是否正确，如果不满足此要求，将引发 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p>
<p class="translated">在 C 级别的 <a class="reference internal" href="../c-api/typeobj.html#c.PyNumberMethods" title="PyNumberMethods"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyNumberMethods</span></code></a> 结构中添加了一个相应的 <a class="reference internal" href="../c-api/typeobj.html#c.PyNumberMethods.nb_index" title="PyNumberMethods.nb_index"><code class="xref c c-member docutils literal notranslate"><span class="pre">nb_index</span></code></a> 插槽，以便 C 扩展实现此协议。<code class="docutils literal notranslate"><span class="pre">PyNumber_Index(obj)</span></code> 可在扩展代码中使用，以调用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code> 函数并获取其结果。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-81"></span><a class="pep reference external" href="https://peps.python.org/pep-0357/"><strong>PEP 357</strong></a> - 允许将任何对象用于切片</dt><dd><p class="translated">PEP 由 Travis Oliphant 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="other-language-changes">
<span id="other-lang"></span><h2 class="translated">其他语言特性修改<a class="headerlink" href="#other-language-changes" title="Link to this heading">¶</a></h2>
<p class="translated">以下是 Python 2.5 针对核心 Python 语言的所有改变。</p>
<ul>
<li><p class="translated"><a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 类型新增了一个钩子，允许子类在字典中不包含某个键时提供默认值。当找不到键时，将调用字典的 <code class="docutils literal notranslate"><span class="pre">__missing__(key)</span></code> 方法。这个钩子用于在 <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 模块中实现新的 <code class="xref py py-class docutils literal notranslate"><span class="pre">defaultdict</span></code> 类。以下示例定义了一个字典，对于任何缺失的键返回零:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">zerodict</span> <span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__missing__</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">zerodict</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="p">})</span>
<span class="nb">print</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>   <span class="c1"># 输出 1, 2</span>
<span class="nb">print</span> <span class="n">d</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>   <span class="c1"># 输出 0, 0</span>
</pre></div>
</div>
</li>
<li><p class="translated">8位字符串和Unicode字符串都新增了 <code class="docutils literal notranslate"><span class="pre">partition(sep)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">rpartition(sep)</span></code> 方法，简化了常见的用例。</p>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">find(S)</span></code> 方法通常用于获取一个索引，然后使用该索引来切片字符串，获取分隔符之前和之后的部分。<code class="docutils literal notranslate"><span class="pre">partition(sep)</span></code> 将这种模式浓缩为单个方法调用，返回一个包含分隔符之前子字符串、分隔符本身和分隔符之后子字符串的3元组。如果找不到分隔符，元组的第一个元素是整个字符串，其他两个元素为空。<code class="docutils literal notranslate"><span class="pre">rpartition(sep)</span></code> 也返回一个3元组，但从字符串末尾开始搜索；<code class="docutils literal notranslate"><span class="pre">r</span></code> 代表 'reverse'。</p>
<p class="translated">示例如下：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="s1">&#39;http://www.python.org&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s1">&#39;://&#39;</span><span class="p">)</span>
<span class="go">(&#39;http&#39;, &#39;://&#39;, &#39;www.python.org&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="s1">&#39;file:/usr/share/doc/index.html&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s1">&#39;://&#39;</span><span class="p">)</span>
<span class="go">(&#39;file:/usr/share/doc/index.html&#39;, &#39;&#39;, &#39;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="sa">u</span><span class="s1">&#39;Subject: a quick question&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
<span class="go">(u&#39;Subject&#39;, u&#39;:&#39;, u&#39; a quick question&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;www.python.org&#39;</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
<span class="go">(&#39;www.python&#39;, &#39;.&#39;, &#39;org&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;www.python.org&#39;</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
<span class="go">(&#39;&#39;, &#39;&#39;, &#39;www.python.org&#39;)</span>
</pre></div>
</div>
<p class="translated">（由 Fredrik Lundh 在 Raymond Hettinger 的建议下实现。）</p>
</li>
<li><p class="translated">现在字符串类型的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">startswith()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">endswith()</span></code> 方法可接受字符串元组供检查。</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">is_image_file</span> <span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">((</span><span class="s1">&#39;.gif&#39;</span><span class="p">,</span> <span class="s1">&#39;.jpg&#39;</span><span class="p">,</span> <span class="s1">&#39;.tiff&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p class="translated">（由 Georg Brandl 实现，基于 Tom Lynn 的建议。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/functions.html#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a> 和 <a class="reference internal" href="../library/functions.html#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a> 内置函数新增了一个 <code class="docutils literal notranslate"><span class="pre">key</span></code> 关键字参数，类似于 <code class="xref py py-meth docutils literal notranslate"><span class="pre">sort()</span></code> 的 <code class="docutils literal notranslate"><span class="pre">key</span></code> 参数。这个参数提供一个函数，该函数接受单个参数，并对列表中的每个值调用；<a class="reference internal" href="../library/functions.html#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a>/<a class="reference internal" href="../library/functions.html#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a> 将返回该函数返回值最小/最大的元素。例如，要找到列表中最长的字符串，可以这样做:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;medium&#39;</span><span class="p">,</span> <span class="s1">&#39;longest&#39;</span><span class="p">,</span> <span class="s1">&#39;short&#39;</span><span class="p">]</span>
<span class="c1"># 打印 &#39;longest&#39;</span>
<span class="nb">print</span> <span class="nb">max</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">)</span>
<span class="c1"># 打印 &#39;short&#39;，因为在字典序上 &#39;short&#39; 的值最大</span>
<span class="nb">print</span> <span class="nb">max</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">（由 Steven Bethard 和 Raymond Hettinger 贡献。）</p>
</li>
<li><p class="translated">两个新的内置函数，<a class="reference internal" href="../library/functions.html#any" title="any"><code class="xref py py-func docutils literal notranslate"><span class="pre">any()</span></code></a> 和 <a class="reference internal" href="../library/functions.html#all" title="all"><code class="xref py py-func docutils literal notranslate"><span class="pre">all()</span></code></a>，用于评估迭代器中是否包含任何真值或假值。<a class="reference internal" href="../library/functions.html#any" title="any"><code class="xref py py-func docutils literal notranslate"><span class="pre">any()</span></code></a> 如果迭代器返回的任何值为真，则返回 <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>；否则返回 <a class="reference internal" href="../library/constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>。<a class="reference internal" href="../library/functions.html#all" title="all"><code class="xref py py-func docutils literal notranslate"><span class="pre">all()</span></code></a> 只有当迭代器返回的所有值都为真时，才返回 <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>。（由 Guido van Rossum 建议，Raymond Hettinger 实现。）</p></li>
<li><p class="translated">类的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> 方法的返回结果现在可以是长整数或常规整数。如果返回的是长整数，则取该值的哈希。在早期版本中，哈希值必须是常规整数，但在 2.5 版中，<a class="reference internal" href="../library/functions.html#id" title="id"><code class="xref py py-func docutils literal notranslate"><span class="pre">id()</span></code></a> 内置函数被改为总是返回非负数，用户通常在 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> 方法中使用 <code class="docutils literal notranslate"><span class="pre">id(self)</span></code> (尽管不推荐这样做) 。</p>
</li>
<li><p class="translated">ASCII 现在是模块的默认编码。如果模块包含带有 8 位字符的字符串字面量但没有编码声明，则会引发语法错误。在 Python 2.4 中，这会触发警告，而不是语法错误。参见 <span class="target" id="index-82"></span><a class="pep reference external" href="https://peps.python.org/pep-0263/"><strong>PEP 263</strong></a> 了解如何声明模块的编码；例如，你可以在源文件顶部附近添加如下行：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># -*- coding: latin1 -*-</span>
</pre></div>
</div>
</li>
<li><p class="translated">一个新的警告，<a class="reference internal" href="../library/exceptions.html#UnicodeWarning" title="UnicodeWarning"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnicodeWarning</span></code></a>，在你尝试比较一个 Unicode 字符串和一个无法使用默认 ASCII 编码转换为 Unicode 的 8 位字符串时触发。比较的结果为假：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">chr</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span> <span class="o">==</span> <span class="n">unichr</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>   <span class="c1"># 无法将 chr(128) 转换为 Unicode</span>
<span class="go">__main__:1: UnicodeWarning: Unicode 等值比较失败</span>
<span class="go">  无法将两个参数都转换为 Unicode - 解释为不等</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">chr</span><span class="p">(</span><span class="mi">127</span><span class="p">)</span> <span class="o">==</span> <span class="n">unichr</span><span class="p">(</span><span class="mi">127</span><span class="p">)</span>   <span class="c1"># chr(127) 可以转换</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="translated">以前这会引发一个 <a class="reference internal" href="../library/exceptions.html#UnicodeDecodeError" title="UnicodeDecodeError"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnicodeDecodeError</span></code></a> 异常，但在2.5版本中，这可能会导致在访问字典时出现令人困惑的问题。如果你查找 <code class="docutils literal notranslate"><span class="pre">unichr(128)</span></code> 而 <code class="docutils literal notranslate"><span class="pre">chr(128)</span></code> 被用作键，你会得到一个 <a class="reference internal" href="../library/exceptions.html#UnicodeDecodeError" title="UnicodeDecodeError"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnicodeDecodeError</span></code></a> 异常。2.5版本中的其他更改导致这个异常被抛出，而不是被实现字典的 <code class="file docutils literal notranslate"><span class="pre">dictobject.c</span></code> 中的代码抑制。</p>
<p class="translated">对于这种比较引发异常是严格正确的，但这个更改可能会破坏代码，所以引入了 <a class="reference internal" href="../library/exceptions.html#UnicodeWarning" title="UnicodeWarning"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnicodeWarning</span></code></a>。</p>
<p class="translated">（由 Marc-André Lemburg 实现。）</p>
</li>
<li><p class="translated">Python程序员有时会犯的一个错误是忘记在包目录中包含一个 <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code> 模块。调试这个错误可能会令人困惑，通常需要使用 <a class="reference internal" href="../using/cmdline.html#cmdoption-v"><code class="xref std std-option docutils literal notranslate"><span class="pre">-v</span></code></a> 开关运行Python来记录所有搜索的路径。在Python 2.5中，当导入操作本应将一个目录作为包但未找到 <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code> 时，会触发新的 <a class="reference internal" href="../library/exceptions.html#ImportWarning" title="ImportWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportWarning</span></code></a> 警告。默认情况下，这个警告被静默忽略；在运行Python可执行文件时提供 <a class="reference internal" href="../using/cmdline.html#cmdoption-W"><code class="xref std std-option docutils literal notranslate"><span class="pre">-Wd</span></code></a> 选项来显示警告消息。（由 Thomas Wouters 实现。）</p></li>
<li><p class="translated">类定义中的基类列表现在可以是空的。例如，以下现在是合法的:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="p">():</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p class="translated">（由 Brett Cannon 实现。）</p>
</li>
</ul>
<section id="interactive-interpreter-changes">
<span id="interactive"></span><h3 class="translated">交互解释器变更<a class="headerlink" href="#interactive-interpreter-changes" title="Link to this heading">¶</a></h3>
<p class="translated">在交互式解释器中，<code class="docutils literal notranslate"><span class="pre">quit</span></code> 和 <code class="docutils literal notranslate"><span class="pre">exit</span></code> 长期以来一直是字符串，以便新用户在尝试退出时得到一些有帮助的消息:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">quit</span>
<span class="go">&#39;使用Ctrl-D（即EOF）退出。&#39;</span>
</pre></div>
</div>
<p class="translated">在Python 2.5中，<code class="docutils literal notranslate"><span class="pre">quit</span></code> 和 <code class="docutils literal notranslate"><span class="pre">exit</span></code> 现在是对象，它们仍然产生自己的字符串表示，但也是可调用的。新手尝试 <code class="docutils literal notranslate"><span class="pre">quit()</span></code> 或 <code class="docutils literal notranslate"><span class="pre">exit()</span></code> 现在将如他们所期望的那样退出解释器。（由Georg Brandl实现。）</p>
<p class="translated">Python可执行文件现在接受标准的长选项 <a class="reference internal" href="../using/cmdline.html#cmdoption-help"><code class="xref std std-option docutils literal notranslate"><span class="pre">--help</span></code></a> 和 <a class="reference internal" href="../using/cmdline.html#cmdoption-version"><code class="xref std std-option docutils literal notranslate"><span class="pre">--version</span></code></a>；在Windows上，它还接受 <a class="reference internal" href="../using/cmdline.html#cmdoption-0"><code class="xref std std-option docutils literal notranslate"><span class="pre">/?</span></code></a> 选项来显示帮助消息。（由 Georg Brandl 实现。）</p>
</section>
<section id="optimizations">
<span id="opts"></span><h3 class="translated">性能优化<a class="headerlink" href="#optimizations" title="Link to this heading">¶</a></h3>
<p class="translated">多项优化是在2006年5月21日至28日在冰岛雷克雅未克举行的NeedForSpeed冲刺活动中开发的。该冲刺活动专注于提升CPython实现的速度，由EWT LLC资助，并得到了CCP Games的本地支持。在此冲刺中添加的优化在以下列表中特别标注。</p>
<ul class="simple">
<li><p class="translated">在Python 2.4中引入时，内置的 <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> 和 <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> 类型是基于Python的字典类型构建的。在2.5中，内部数据结构已为实现集合进行了定制，因此集合将使用少三分之一的内存，并且速度有所提高。（由 Raymond Hettinger 实现。）</p></li>
<li><p class="translated">一些Unicode操作的速度，如查找子字符串、字符串分割以及字符映射的编码和解码，已得到提升。（子字符串搜索和分割改进由Fredrik Lundh和Andrew Dalke在NeedForSpeed冲刺中添加。字符映射由Walter Dörwald和Martin von Löwis改进。）</p>
</li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">long(str,</span> <span class="pre">base)</span></code> 函数现在在处理长数字字符串时更快，因为计算的中间结果更少。峰值出现在约 800 到 1000 位的字符串上，此时函数速度提升了 6 倍。（由 Alan McIntyre 贡献，并在 NeedForSpeed 冲刺中提交。）</p>
</li>
<li><p class="translated">现在禁止在用 <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">line</span> <span class="pre">in</span> <span class="pre">file</span></code> 迭代文件的同时调用文件对象的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code>/<a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code></a>/<code class="xref py py-meth docutils literal notranslate"><span class="pre">readlines()</span></code> 方法。迭代使用内部缓冲区，而 <code class="xref py py-meth docutils literal notranslate"><span class="pre">read*()</span></code> 方法不使用该缓冲区。相反，它们会返回缓冲区之后的数据，导致数据顺序混乱。混合使用迭代和这些方法现在会从 <code class="xref py py-meth docutils literal notranslate"><span class="pre">read*()</span></code> 方法触发一个 <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。（由 Thomas Wouters 实现。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> 模块现在将结构格式字符串编译成内部表示并缓存此表示，从而提高了20%的速度。（由Bob Ippolito在NeedForSpeed冲刺中贡献。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 模块通过切换到 Python 的分配器函数而不是系统的 <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> 和 <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code>，获得了 1% 到 2% 的速度提升。（由 Jack Diederich 在 NeedForSpeed sprint 中贡献。）</p></li>
<li><p class="translated">代码生成器的窥孔优化器现在可以在表达式中执行简单的常量折叠。如果你写类似 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">2+3</span></code> 的代码，代码生成器将进行算术运算并生成对应于 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">5</span></code> 的代码。（由 Raymond Hettinger 提议并实现。）</p></li>
<li><p class="translated">函数调用现在更快了，因为代码对象现在将最近完成的帧（一个“僵尸帧”）保存在代码对象的内部字段中，下次调用代码对象时重用它。（原始补丁由 Michael Hudson 提供，由 Armin Rigo 和 Richard Jones 修改；在 NeedForSpeed sprint 中提交。）帧对象也稍微变小了，这可能会改善缓存局部性并略微减少内存使用。（由 Neal Norwitz 贡献。）</p>
</li>
<li><p class="translated">Python 的内置异常现在都是新式类，这一改变显著加快了实例化速度。因此，Python 2.5 中的异常处理比 2.4 快约 30%。（由 Richard Jones、Georg Brandl 和 Sean Reifschneider 在 NeedForSpeed sprint 中贡献。）</p></li>
<li><p class="translated">导入现在会缓存尝试过的路径，记录它们是否存在，以便解释器在启动时减少对 <code class="xref c c-func docutils literal notranslate"><span class="pre">open()</span></code> 和 <code class="xref c c-func docutils literal notranslate"><span class="pre">stat()</span></code> 的调用。（由 Martin von Löwis 和 Georg Brandl 贡献。）</p>
</li>
</ul>
</section>
</section>
<section id="new-improved-and-removed-modules">
<span id="modules"></span><h2 class="translated">新增，改进和删除的模块<a class="headerlink" href="#new-improved-and-removed-modules" title="Link to this heading">¶</a></h2>
<p class="translated">Python 2.5 中的标准库收到了许多增强和 bug 修复。以下是按模块名称字母顺序排序的最显著变化的部分列表。查阅源树中的 <code class="file docutils literal notranslate"><span class="pre">Misc/NEWS</span></code> 文件以获取更完整的变化列表，或通过 SVN 日志查看所有详细信息。</p>
<ul>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">audioop</span></code> 模块现在支持 a-LAW 编码，并且 u-LAW 编码的代码已得到改进。（由 Lars Immisch 贡献。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code></a> 模块增加了对增量编解码器的支持。<code class="xref py py-func docutils literal notranslate"><span class="pre">codec.lookup()</span></code> 函数现在返回一个 <code class="xref py py-class docutils literal notranslate"><span class="pre">CodecInfo</span></code> 实例，而不是一个元组。<code class="xref py py-class docutils literal notranslate"><span class="pre">CodecInfo</span></code> 实例表现得像一个4元组，以保持向后兼容性，但同时也具有以下属性：<code class="xref py py-attr docutils literal notranslate"><span class="pre">encode</span></code>、<code class="xref py py-attr docutils literal notranslate"><span class="pre">decode</span></code>、<code class="xref py py-attr docutils literal notranslate"><span class="pre">incrementalencoder</span></code>、<code class="xref py py-attr docutils literal notranslate"><span class="pre">incrementaldecoder</span></code>、<code class="xref py py-attr docutils literal notranslate"><span class="pre">streamwriter</span></code> 和 <code class="xref py py-attr docutils literal notranslate"><span class="pre">streamreader</span></code>。增量编解码器可以分多次接收输入并生成输出；输出与非增量编解码器一次性接收全部输入的输出相同。详细信息请参阅 <a class="reference internal" href="../library/codecs.html#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code></a> 模块文档。（由 Walter Dörwald 设计并实现。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 模块新增了一种类型，<code class="xref py py-class docutils literal notranslate"><span class="pre">defaultdict</span></code>，它是标准 <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 类型的子类。这种新类型在大多数情况下表现得像字典，但当键不存在时，会构造一个默认值，并自动将其添加到字典中，对应请求的键值。</p>
<p class="translated"><code class="xref py py-class docutils literal notranslate"><span class="pre">defaultdict</span></code> 构造函数的第一个参数是一个工厂函数，当请求的键未找到时，会调用此函数。这个工厂函数不接受任何参数，因此你可以使用内置类型构造函数，如 <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-func docutils literal notranslate"><span class="pre">list()</span></code></a> 或 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a>。例如，你可以按首字母创建一个单词索引，如下所示：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">words</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Nel mezzo del cammin di nostra vita</span>
<span class="s2">mi ritrovai per una selva oscura</span>
<span class="s2">che la diritta via era smarrita&quot;&quot;&quot;</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

<span class="n">index</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

<span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
    <span class="n">init_letter</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">index</span><span class="p">[</span><span class="n">init_letter</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">打印 <code class="docutils literal notranslate"><span class="pre">index</span></code> 导致以下输出:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">defaultdict</span><span class="p">(</span><span class="o">&lt;</span><span class="nb">type</span> <span class="s1">&#39;list&#39;</span><span class="o">&gt;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;cammin&#39;</span><span class="p">,</span> <span class="s1">&#39;che&#39;</span><span class="p">],</span> <span class="s1">&#39;e&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;era&#39;</span><span class="p">],</span>
        <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;del&#39;</span><span class="p">,</span> <span class="s1">&#39;di&#39;</span><span class="p">,</span> <span class="s1">&#39;diritta&#39;</span><span class="p">],</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;mezzo&#39;</span><span class="p">,</span> <span class="s1">&#39;mi&#39;</span><span class="p">],</span>
        <span class="s1">&#39;l&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;la&#39;</span><span class="p">],</span> <span class="s1">&#39;o&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;oscura&#39;</span><span class="p">],</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;nel&#39;</span><span class="p">,</span> <span class="s1">&#39;nostra&#39;</span><span class="p">],</span>
        <span class="s1">&#39;p&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;per&#39;</span><span class="p">],</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;selva&#39;</span><span class="p">,</span> <span class="s1">&#39;smarrita&#39;</span><span class="p">],</span>
        <span class="s1">&#39;r&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;ritrovai&#39;</span><span class="p">],</span> <span class="s1">&#39;u&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;una&#39;</span><span class="p">],</span> <span class="s1">&#39;v&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;vita&#39;</span><span class="p">,</span> <span class="s1">&#39;via&#39;</span><span class="p">]})</span>
</pre></div>
</div>
<p class="translated">（由 Guido van Rossum 贡献。）</p>
</li>
<li><p class="translated"><code class="xref py py-class docutils literal notranslate"><span class="pre">deque</span></code> 双端队列类型由 <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 模块提供，现在新增了 <code class="docutils literal notranslate"><span class="pre">remove(value)</span></code> 方法，用于移除队列中第一次出现的 <em>value</em>，如果未找到该值则抛出 <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。（由 Raymond Hettinger 贡献。）</p></li>
<li><p class="translated">新模块：<a class="reference internal" href="../library/contextlib.html#module-contextlib" title="contextlib: Utilities for with-statement contexts."><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextlib</span></code></a> 模块包含用于新 '<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>' 语句的辅助函数。更多信息请参见 <a class="reference internal" href="#contextlibmod"><span class="std std-ref">contextlib 模块</span></a> 部分。</p></li>
<li><p class="translated">新模块：<a class="reference internal" href="../library/profile.html#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a> 模块是现有 <a class="reference internal" href="../library/profile.html#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a> 模块的 C 语言实现，具有更低的开销。该模块的接口与 <a class="reference internal" href="../library/profile.html#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a> 相同：你可以通过运行 <code class="docutils literal notranslate"><span class="pre">cProfile.run('main()')</span></code> 来分析函数，可以将分析数据保存到文件等。目前尚不清楚 Hotshot 分析器（同样用 C 语言编写，但接口与 <a class="reference internal" href="../library/profile.html#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a> 模块不匹配）是否会在 Python 的未来版本中继续维护。（由 Armin Rigo 贡献。）</p>
<p class="translated">此外，用于分析分析器测量数据的 <a class="reference internal" href="../library/profile.html#module-pstats" title="pstats: Statistics object for use with the profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pstats</span></code></a> 模块现在支持通过向 <code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code> 构造函数提供 <em>stream</em> 参数来将输出定向到任何文件对象。（由 Skip Montanaro 贡献。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/csv.html#module-csv" title="csv: Write and read tabular data to and from delimited files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">csv</span></code></a> 模块用于解析逗号分隔值格式的文件，收到了多项增强和多个 bug 修复。你现在可以通过调用 <code class="docutils literal notranslate"><span class="pre">csv.field_size_limit(new_limit)</span></code> 函数来设置字段的最大字节数；省略 <em>new_limit</em> 参数将返回当前设置的限值。<code class="xref py py-class docutils literal notranslate"><span class="pre">reader</span></code> 类现在有一个 <code class="xref py py-attr docutils literal notranslate"><span class="pre">line_num</span></code> 属性，用于计数从源文件读取的物理行数；记录可以跨越多个物理行，因此 <code class="xref py py-attr docutils literal notranslate"><span class="pre">line_num</span></code> 与读取的记录数不同。</p>
<p class="translated">CSV解析器现在对多行引号字段更为严格。之前，如果在引号字段内一行结束而没有终止换行符，会在返回的字段中插入一个换行符。这种行为在读取字段内包含回车字符的文件时会导致问题，因此代码已更改，返回字段时不插入换行符。因此，如果字段内嵌入的换行符很重要，输入应在保持换行符的方式下拆分成行。</p>
<p class="translated">（由Skip Montanaro 和 Andrew McNamara 贡献。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/datetime.html#module-datetime" title="datetime: Basic date and time types."><code class="xref py py-mod docutils literal notranslate"><span class="pre">datetime</span></code></a> 模块中的 <a class="reference internal" href="../library/datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime</span></code></a> 类现在有一个 <code class="docutils literal notranslate"><span class="pre">strptime(string,</span> <span class="pre">format)</span></code> 方法用于解析日期字符串，由Josh Spoerri贡献。它使用与 <a class="reference internal" href="../library/time.html#time.strptime" title="time.strptime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.strptime()</span></code></a> 和 <a class="reference internal" href="../library/time.html#time.strftime" title="time.strftime"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.strftime()</span></code></a> 相同的格式字符：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span>

<span class="n">ts</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="s1">&#39;10:13:15 2006-03-07&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;%H:%M:%S %Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="translated"><a class="reference internal" href="../library/difflib.html#module-difflib" title="difflib: Helpers for computing differences between objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">difflib</span></code></a> 模块中的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">SequenceMatcher.get_matching_blocks()</span></code> 方法现在保证返回描述匹配子序列的最小块列表。之前，算法偶尔会将一个匹配元素块拆分成两个列表条目。（由Tim Peters增强。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> 模块增加了一个 <code class="docutils literal notranslate"><span class="pre">SKIP</span></code> 选项，用于完全跳过示例的执行。这是为了那些作为读者使用示例的代码片段，而不是实际的测试用例。</p>
<p class="translated">在 <code class="xref py py-func docutils literal notranslate"><span class="pre">testfile()</span></code> 函数和 <code class="xref py py-class docutils literal notranslate"><span class="pre">DocFileSuite</span></code> 类中添加了 <em>encoding</em> 参数，用于指定文件的编码。这使得在文档字符串中包含的测试中使用非ASCII字符变得更加容易。（由Bjorn Tillenius贡献。)</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code></a> 包已经升级到 4.0版 （由 Barry Warsaw 贡献）</p>
</li>
<li id="index-20"><p class="translated"><a class="reference internal" href="../library/fileinput.html#module-fileinput" title="fileinput: Loop over standard input or a list of files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">fileinput</span></code></a> 模块变得更加灵活。现在支持 Unicode 文件名，并且在 <a class="reference internal" href="../library/functions.html#input" title="input"><code class="xref py py-func docutils literal notranslate"><span class="pre">input()</span></code></a> 函数中添加了一个默认为 <code class="docutils literal notranslate"><span class="pre">&quot;r&quot;</span></code> 的 <em>mode</em> 参数，以便以二进制或 <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">通用换行</span></a> 模式打开文件。另一个新参数 <em>openhook</em> 允许使用除 <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 之外的其他函数来打开输入文件。在迭代文件集时，<code class="xref py py-class docutils literal notranslate"><span class="pre">FileInput</span></code> 对象的新 <a class="reference internal" href="../library/fileinput.html#fileinput.fileno" title="fileinput.fileno"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fileno()</span></code></a> 方法返回当前打开文件的文件描述符。（由 Georg Brandl 贡献。）</p></li>
<li><p class="translated">在 <a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> 模块中，新的 <code class="xref py py-func docutils literal notranslate"><span class="pre">get_count()</span></code> 函数返回一个包含三个 GC 世代当前收集计数的 3 元组。这是垃圾收集器的统计信息；当这些计数达到指定阈值时，将进行垃圾收集扫描。现有的 <a class="reference internal" href="../library/gc.html#gc.collect" title="gc.collect"><code class="xref py py-func docutils literal notranslate"><span class="pre">gc.collect()</span></code></a> 函数现在接受一个可选的 <em>generation</em> 参数，值为 0、1 或 2，以指定要收集的世代。（由 Barry Warsaw 贡献。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/heapq.html#module-heapq" title="heapq: Heap queue algorithm (a.k.a. priority queue)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">heapq</span></code></a> 模块中的 <code class="xref py py-func docutils literal notranslate"><span class="pre">nsmallest()</span></code> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">nlargest()</span></code> 函数现在支持类似于 <a class="reference internal" href="../library/functions.html#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a>/<a class="reference internal" href="../library/functions.html#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a> 函数和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">sort()</span></code> 方法提供的 <code class="docutils literal notranslate"><span class="pre">key</span></code> 关键字参数。例如：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">heapq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;short&quot;</span><span class="p">,</span> <span class="s1">&#39;medium&#39;</span><span class="p">,</span> <span class="s1">&#39;longest&#39;</span><span class="p">,</span> <span class="s1">&#39;longer still&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">heapq</span><span class="o">.</span><span class="n">nsmallest</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>  <span class="c1"># 按字典序返回两个最低的元素</span>
<span class="go">[&#39;longer still&#39;, &#39;longest&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">heapq</span><span class="o">.</span><span class="n">nsmallest</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">)</span>   <span class="c1"># 返回两个最短的元素</span>
<span class="go">[&#39;short&#39;, &#39;medium&#39;]</span>
</pre></div>
</div>
<p class="translated">（由 Raymond Hettinger 贡献。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/itertools.html#itertools.islice" title="itertools.islice"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.islice()</span></code></a> 函数现在接受 <code class="docutils literal notranslate"><span class="pre">None</span></code> 作为 start 和 step 参数。这使得它与切片对象的属性更加兼容，因此你现在可以写出以下代码：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>     <span class="c1"># 创建切片对象</span>
<span class="n">itertools</span><span class="o">.</span><span class="n">islice</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">（由 Raymond Hettinger 贡献。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/locale.html#module-locale" title="locale: Internationalization services."><code class="xref py py-mod docutils literal notranslate"><span class="pre">locale</span></code></a> 模块中的 <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> 函数已被修改，并添加了两个新函数：<code class="xref py py-func docutils literal notranslate"><span class="pre">format_string()</span></code> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">currency()</span></code>。</p>
<p class="translated"><a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> 函数的 <em>val</em> 参数以前可以是字符串，只要不超过一个 %char 指定符；现在该参数必须正好是一个 %char 指定符，且周围没有文本。还添加了一个可选的 <em>monetary</em> 参数，如果为 <code class="docutils literal notranslate"><span class="pre">True</span></code>，将使用区域设置的规则来格式化货币，在每三位数字之间放置分隔符。</p>
<p class="translated">要格式化带有多个 %char 指定符的字符串，请使用新的 <code class="xref py py-func docutils literal notranslate"><span class="pre">format_string()</span></code> 函数，它类似于 <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a>，但还支持将 %char 指定符与任意文本混合。</p>
<p class="translated">还添加了一个新的 <code class="xref py py-func docutils literal notranslate"><span class="pre">currency()</span></code> 函数，它根据当前区域设置的规则来格式化数字。</p>
<p class="translated">（由Georg Brandl 贡献。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/mailbox.html#module-mailbox" title="mailbox: Manipulate mailboxes in various formats"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mailbox</span></code></a> 模块进行了大规模重写，以增加修改邮箱的能力，而不仅仅是读取邮箱。一组新的类，包括 <code class="xref py py-class docutils literal notranslate"><span class="pre">mbox</span></code>、<code class="xref py py-class docutils literal notranslate"><span class="pre">MH</span></code> 和 <code class="xref py py-class docutils literal notranslate"><span class="pre">Maildir</span></code>，用于读取邮箱，并具有 <code class="docutils literal notranslate"><span class="pre">add(message)</span></code> 方法来添加消息，<code class="docutils literal notranslate"><span class="pre">remove(key)</span></code> 来删除消息，以及 <code class="xref py py-meth docutils literal notranslate"><span class="pre">lock()</span></code>/<code class="xref py py-meth docutils literal notranslate"><span class="pre">unlock()</span></code> 来锁定/解锁邮箱。以下示例将 maildir 格式的邮箱转换为 mbox 格式的邮箱：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">mailbox</span>

<span class="c1"># &#39;factory=None&#39; 使用 email.Message.Message 作为表示</span>
<span class="c1"># 单个消息的类。</span>
<span class="n">src</span> <span class="o">=</span> <span class="n">mailbox</span><span class="o">.</span><span class="n">Maildir</span><span class="p">(</span><span class="s1">&#39;maildir&#39;</span><span class="p">,</span> <span class="n">factory</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="n">dest</span> <span class="o">=</span> <span class="n">mailbox</span><span class="o">.</span><span class="n">mbox</span><span class="p">(</span><span class="s1">&#39;/tmp/mbox&#39;</span><span class="p">)</span>

<span class="k">for</span> <span class="n">msg</span> <span class="ow">in</span> <span class="n">src</span><span class="p">:</span>
    <span class="n">dest</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">（由 Gregory K. Johnson 贡献。资金由 Google 2005 年夏季代码提供。）</p>
</li>
<li><p class="translated">新模块：<code class="xref py py-mod docutils literal notranslate"><span class="pre">msilib</span></code> 模块允许创建 Microsoft Installer <code class="file docutils literal notranslate"><span class="pre">.msi</span></code> 文件和 CAB 文件。还包括一些支持读取 <code class="file docutils literal notranslate"><span class="pre">.msi</span></code> 数据库的功能。（由 Martin von Löwis 贡献。）</p></li>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nis</span></code> 模块现在支持通过向 <code class="xref py py-func docutils literal notranslate"><span class="pre">nis.match()</span></code> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">nis.maps()</span></code> 函数提供 <em>domain</em> 参数来访问系统默认域以外的其他域。（由 Ben Bell 贡献。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/operator.html#module-operator" title="operator: Functions corresponding to the standard operators."><code class="xref py py-mod docutils literal notranslate"><span class="pre">operator</span></code></a> 模块的 <code class="xref py py-func docutils literal notranslate"><span class="pre">itemgetter()</span></code> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">attrgetter()</span></code> 函数现在支持多个字段。例如，调用 <code class="docutils literal notranslate"><span class="pre">operator.attrgetter('a',</span> <span class="pre">'b')</span></code> 将返回一个函数，该函数检索 <code class="xref py py-attr docutils literal notranslate"><span class="pre">a</span></code> 和 <code class="xref py py-attr docutils literal notranslate"><span class="pre">b</span></code> 属性。结合这一新特性与 <code class="xref py py-meth docutils literal notranslate"><span class="pre">sort()</span></code> 方法的 <code class="docutils literal notranslate"><span class="pre">key</span></code> 参数，可以轻松地使用多个字段对列表进行排序。（由 Raymond Hettinger 贡献。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/optparse.html#module-optparse" title="optparse: Command-line option parsing library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">optparse</span></code></a> 模块已更新至 Optik 库的 1.5.1 版本。<code class="xref py py-class docutils literal notranslate"><span class="pre">OptionParser</span></code> 类新增了 <code class="xref py py-attr docutils literal notranslate"><span class="pre">epilog</span></code> 属性，该字符串将在帮助信息后打印，并新增了 <code class="xref py py-meth docutils literal notranslate"><span class="pre">destroy()</span></code> 方法以打破对象创建的引用循环。（由 Greg Ward 贡献。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os</span></code></a> 模块进行了多项更改。<code class="xref py py-attr docutils literal notranslate"><span class="pre">stat_float_times</span></code> 变量现在默认为 true，意味着 <a class="reference internal" href="../library/os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.stat()</span></code></a> 将返回浮点数形式的时间值。（这并不一定意味着 <a class="reference internal" href="../library/os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.stat()</span></code></a> 返回的时间精确到秒的小数部分；并非所有系统都支持这种精度。）</p>
<p class="translated">添加了名为 <a class="reference internal" href="../library/os.html#os.SEEK_SET" title="os.SEEK_SET"><code class="xref py py-const docutils literal notranslate"><span class="pre">os.SEEK_SET</span></code></a>、<a class="reference internal" href="../library/os.html#os.SEEK_CUR" title="os.SEEK_CUR"><code class="xref py py-const docutils literal notranslate"><span class="pre">os.SEEK_CUR</span></code></a> 和 <a class="reference internal" href="../library/os.html#os.SEEK_END" title="os.SEEK_END"><code class="xref py py-const docutils literal notranslate"><span class="pre">os.SEEK_END</span></code></a> 的常量；这些是 <a class="reference internal" href="../library/os.html#os.lseek" title="os.lseek"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.lseek()</span></code></a> 函数的参数。用于锁定的两个新常量是 <a class="reference internal" href="../library/os.html#os.O_SHLOCK" title="os.O_SHLOCK"><code class="xref py py-const docutils literal notranslate"><span class="pre">os.O_SHLOCK</span></code></a> 和 <a class="reference internal" href="../library/os.html#os.O_EXLOCK" title="os.O_EXLOCK"><code class="xref py py-const docutils literal notranslate"><span class="pre">os.O_EXLOCK</span></code></a>。</p>
<p class="translated">添加了两个新函数 <code class="xref py py-func docutils literal notranslate"><span class="pre">wait3()</span></code> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">wait4()</span></code>。它们类似于 <code class="xref py py-func docutils literal notranslate"><span class="pre">waitpid()</span></code> 函数，后者等待子进程退出并返回进程 ID 及其退出状态的元组，但 <code class="xref py py-func docutils literal notranslate"><span class="pre">wait3()</span></code> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">wait4()</span></code> 返回更多信息。<code class="xref py py-func docutils literal notranslate"><span class="pre">wait3()</span></code> 不接受进程 ID 作为输入，因此它等待任何子进程退出并返回一个 3 元组，包括 <em>process-id</em>、<em>exit-status</em> 和 <em>resource-usage</em>，这些信息来自 <a class="reference internal" href="../library/resource.html#resource.getrusage" title="resource.getrusage"><code class="xref py py-func docutils literal notranslate"><span class="pre">resource.getrusage()</span></code></a> 函数。<code class="docutils literal notranslate"><span class="pre">wait4(pid)</span></code> 接受进程 ID。（由 Chad J. Schroeder 贡献。）</p>
<p class="translated">在 FreeBSD 上，<a class="reference internal" href="../library/os.html#os.stat" title="os.stat"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.stat()</span></code></a> 函数现在返回具有纳秒分辨率的时间，返回的对象现在包含 <code class="xref py py-attr docutils literal notranslate"><span class="pre">st_gen</span></code> 和 <code class="xref py py-attr docutils literal notranslate"><span class="pre">st_birthtime</span></code>。如果平台支持，<code class="xref py py-attr docutils literal notranslate"><span class="pre">st_flags</span></code> 属性也可用。（由 Antti Louko 和 Diego Pettenò 贡献。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/pdb.html#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pdb</span></code></a> 模块提供的 Python 调试器现在可以存储一系列命令，当达到断点并停止执行时执行这些命令。一旦创建了断点 #1，输入 <code class="docutils literal notranslate"><span class="pre">commands</span> <span class="pre">1</span></code> 并输入一系列要执行的命令，最后用 <code class="docutils literal notranslate"><span class="pre">end</span></code> 结束列表。命令列表可以包括恢复执行的命令，如 <code class="docutils literal notranslate"><span class="pre">continue</span></code> 或 <code class="docutils literal notranslate"><span class="pre">next</span></code>。（由 Grégoire Dooms 贡献。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 和 <code class="xref py py-mod docutils literal notranslate"><span class="pre">cPickle</span></code> 模块不再接受 <a class="reference internal" href="../library/pickle.html#object.__reduce__" title="object.__reduce__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code></a> 方法返回的 <code class="docutils literal notranslate"><span class="pre">None</span></code> 值；该方法必须返回一个参数元组。在 Python 2.4 中已弃用返回 <code class="docutils literal notranslate"><span class="pre">None</span></code> 的能力，因此这完成了该特性的移除。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/pkgutil.html#module-pkgutil" title="pkgutil: Utilities for the import system."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pkgutil</span></code></a> 模块包含用于查找包的各种实用函数，已增强以支持 <span class="target" id="index-83"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a> 的导入钩子，现在也适用于存储在 ZIP 格式归档中的包。（由 Phillip J. Eby 贡献。）</p></li>
<li><p class="translated">Marc-André Lemburg 开发的 pybench 基准测试套件现在包含在 <code class="file docutils literal notranslate"><span class="pre">Tools/pybench</span></code> 目录中。pybench 套件是对常用的 <code class="file docutils literal notranslate"><span class="pre">pystone.py</span></code> 程序的改进，因为 pybench 提供了对解释器速度的更详细测量。它计时特定操作，如函数调用、元组切片、方法查找和数值操作，而不是执行许多不同操作并将结果简化为一个数字，如 <code class="file docutils literal notranslate"><span class="pre">pystone.py</span></code> 所做的那样。</p></li>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyexpat</span></code> 模块现在使用 Expat 解析器的 2.0 版。 （由 Trent Mick 贡献。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/queue.html#queue.Queue" title="queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> 类由 <code class="xref py py-mod docutils literal notranslate"><span class="pre">Queue</span></code> 模块提供，新增了两个方法。<code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code> 方法会阻塞，直到队列中的所有项都被检索并完成所有处理工作。工作线程调用另一个新方法 <code class="xref py py-meth docutils literal notranslate"><span class="pre">task_done()</span></code>，以指示某项的处理已完成。（由 Raymond Hettinger 贡献。）</p></li>
<li><p class="translated">自 Python 2.0 起已被弃用的旧模块 <code class="xref py py-mod docutils literal notranslate"><span class="pre">regex</span></code> 和 <code class="xref py py-mod docutils literal notranslate"><span class="pre">regsub</span></code> 终于被删除。其他被删除的模块包括：<code class="xref py py-mod docutils literal notranslate"><span class="pre">statcache</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">tzparse</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">whrandom</span></code>。</p></li>
<li><p class="translated">同样被删除的还有 <code class="file docutils literal notranslate"><span class="pre">lib-old</span></code> 目录，该目录包含古老的模块如 <code class="xref py py-mod docutils literal notranslate"><span class="pre">dircmp</span></code> 和 <code class="xref py py-mod docutils literal notranslate"><span class="pre">ni</span></code>，已被移除。<code class="file docutils literal notranslate"><span class="pre">lib-old</span></code> 不在默认的 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> 中，因此除非你的程序显式将该目录添加到 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>，否则此次移除不应影响你的代码。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/rlcompleter.html#module-rlcompleter" title="rlcompleter: Python identifier completion, suitable for the GNU readline library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">rlcompleter</span></code></a> 模块不再依赖于导入 <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">readline</span></code></a> 模块，因此现在可以在非 Unix 平台上工作。（由 Robert Kiendl 提供的补丁。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/xmlrpc.server.html#module-xmlrpc.server" title="xmlrpc.server: Basic XML-RPC server implementations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">SimpleXMLRPCServer</span></code></a> 和 <a class="reference internal" href="../library/xmlrpc.server.html#module-xmlrpc.server" title="xmlrpc.server: Basic XML-RPC server implementations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">DocXMLRPCServer</span></code></a> 类现在有一个 <code class="xref py py-attr docutils literal notranslate"><span class="pre">rpc_paths</span></code> 属性，用于限制 XML-RPC 操作到有限的 URL 路径集；默认只允许 <code class="docutils literal notranslate"><span class="pre">'/'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">'/RPC2'</span></code>。将 <code class="xref py py-attr docutils literal notranslate"><span class="pre">rpc_paths</span></code> 设置为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 或空元组将禁用此路径检查。</p>
</li>
<li><p class="translated">由于 Philippe Biondi 提供的补丁，<a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> 模块现在在 Linux 上支持 <code class="xref py py-const docutils literal notranslate"><span class="pre">AF_NETLINK</span></code> 套接字。Netlink 套接字是 Linux 特有的用户空间进程与内核代码之间的通信机制；关于它们的入门文章见 <a class="reference external" href="https://www.linuxjournal.com/article/7356">https://www.linuxjournal.com/article/7356</a>。在 Python 代码中，netlink 地址表示为两个整数的元组 <code class="docutils literal notranslate"><span class="pre">(pid,</span> <span class="pre">group_mask)</span></code>。</p>
<p class="translated">套接字对象上的两个新方法 <code class="docutils literal notranslate"><span class="pre">recv_into(buffer)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">recvfrom_into(buffer)</span></code> 将接收到的数据存储在支持缓冲协议的对象中，而不是将数据作为字符串返回。这意味着你可以直接将数据放入数组或内存映射文件中。</p>
<p class="translated">套接字对象还增加了 <code class="xref py py-meth docutils literal notranslate"><span class="pre">getfamily()</span></code>、<code class="xref py py-meth docutils literal notranslate"><span class="pre">gettype()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">getproto()</span></code> 访问器方法，用于检索套接字的族、类型和协议值。</p>
</li>
<li><p class="translated">新模块：<code class="xref py py-mod docutils literal notranslate"><span class="pre">spwd</span></code> 模块提供了在支持影子密码的系统上访问影子密码数据库的函数。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> 模块现在更快了，因为它将格式字符串编译成具有 <code class="xref py py-meth docutils literal notranslate"><span class="pre">pack()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">unpack()</span></code> 方法的 <code class="xref py py-class docutils literal notranslate"><span class="pre">Struct</span></code> 对象。这类似于 <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 模块允许你创建编译后的正则表达式对象。你仍然可以使用模块级别的 <code class="xref py py-func docutils literal notranslate"><span class="pre">pack()</span></code> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">unpack()</span></code> 函数；它们会创建并缓存 <code class="xref py py-class docutils literal notranslate"><span class="pre">Struct</span></code> 对象。或者你可以直接使用 <code class="xref py py-class docutils literal notranslate"><span class="pre">Struct</span></code> 实例：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">Struct</span><span class="p">(</span><span class="s1">&#39;ih3s&#39;</span><span class="p">)</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="mi">1972</span><span class="p">,</span> <span class="mi">187</span><span class="p">,</span> <span class="s1">&#39;abc&#39;</span><span class="p">)</span>
<span class="n">year</span><span class="p">,</span> <span class="n">number</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">你还可以使用 <code class="docutils literal notranslate"><span class="pre">pack_into(buffer,</span> <span class="pre">offset,</span> <span class="pre">v1,</span> <span class="pre">v2,</span> <span class="pre">...)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">unpack_from(buffer,</span> <span class="pre">offset)</span></code> 方法直接将数据打包和解包到缓冲对象中。这允许你直接将数据存储到数组或内存映射文件中。</p>
<p class="translated">（<code class="xref py py-class docutils literal notranslate"><span class="pre">Struct</span></code> 对象由 Bob Ippolito 在 NeedForSpeed sprint 中实现。缓冲对象的支持由 Martin Blais 在同一 sprint 中添加。）</p>
</li>
<li><p class="translated">Python 开发者在 2.5 开发过程中从 CVS 切换到 Subversion。关于确切构建版本的信息可通过 <code class="docutils literal notranslate"><span class="pre">sys.subversion</span></code> 变量获取，这是一个包含 <code class="docutils literal notranslate"><span class="pre">(解释器名称,</span> <span class="pre">分支名称,</span> <span class="pre">版本范围)</span></code> 的 3 元组。例如，在撰写本文时，我的 2.5 版本报告为 <code class="docutils literal notranslate"><span class="pre">('CPython',</span> <span class="pre">'trunk',</span> <span class="pre">'45313:45315')</span></code>。</p>
<p class="translated">此信息也可通过 <a class="reference internal" href="../c-api/init.html#c.Py_GetBuildInfo" title="Py_GetBuildInfo"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetBuildInfo()</span></code></a> 函数供 C 扩展使用，该函数返回一个构建信息字符串，例如：<code class="docutils literal notranslate"><span class="pre">&quot;trunk:45355:45356M,</span> <span class="pre">Apr</span> <span class="pre">13</span> <span class="pre">2006,</span> <span class="pre">07:42:19&quot;</span></code>。 (由 Barry Warsaw 贡献。)</p>
</li>
<li><p class="translated">另一个新函数 <a class="reference internal" href="../library/sys.html#sys._current_frames" title="sys._current_frames"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys._current_frames()</span></code></a> 返回所有运行线程的当前堆栈帧，作为字典映射，其中线程标识符映射到在该函数调用时该线程中当前活动的最顶层堆栈帧。 (由 Tim Peters 贡献。)</p></li>
<li><p class="translated"><a class="reference internal" href="../library/tarfile.html#module-tarfile" title="tarfile: Read and write tar-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tarfile</span></code></a> 模块中的 <code class="xref py py-class docutils literal notranslate"><span class="pre">TarFile</span></code> 类现在有一个 <code class="xref py py-meth docutils literal notranslate"><span class="pre">extractall()</span></code> 方法，用于将存档中的所有成员提取到当前工作目录。也可以设置不同的目录作为提取目标，并且可以选择仅解压存档的子集成员。</p>
<p class="translated">在流模式下打开的 tarfile 的压缩类型现在可以通过模式 <code class="docutils literal notranslate"><span class="pre">'r|*'</span></code> 自动检测。 (由 Lars Gustäbel 贡献。)</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> 模块现在允许你设置创建新线程时使用的堆栈大小。<code class="docutils literal notranslate"><span class="pre">stack_size([*size*])</span></code> 函数返回当前配置的堆栈大小，提供可选的 <em>size</em> 参数可以设置新值。并非所有平台都支持更改堆栈大小，但 Windows、POSIX 线程和 OS/2 都支持。 (由 Andrew MacIntyre 贡献。)</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/unicodedata.html#module-unicodedata" title="unicodedata: Access the Unicode Database."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unicodedata</span></code></a> 模块已更新为使用 Unicode 字符数据库版本 4.1.0。某些规范要求版本 3.2.0，因此它仍然作为 <a class="reference internal" href="../library/unicodedata.html#unicodedata.ucd_3_2_0" title="unicodedata.ucd_3_2_0"><code class="xref py py-data docutils literal notranslate"><span class="pre">unicodedata.ucd_3_2_0</span></code></a> 可用。</p></li>
<li><p class="translated">新模块：<a class="reference internal" href="../library/uuid.html#module-uuid" title="uuid: UUID objects (universally unique identifiers) according to RFC 9562"><code class="xref py py-mod docutils literal notranslate"><span class="pre">uuid</span></code></a> 模块根据 <span class="target" id="index-84"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4122.html"><strong>RFC 4122</strong></a> 生成通用唯一标识符（UUID）。RFC 定义了几种不同的 UUID 版本，这些版本可以从起始字符串、系统属性或纯随机生成。此模块包含一个 <code class="xref py py-class docutils literal notranslate"><span class="pre">UUID</span></code> 类和名为 <code class="xref py py-func docutils literal notranslate"><span class="pre">uuid1()</span></code>、<code class="xref py py-func docutils literal notranslate"><span class="pre">uuid3()</span></code>、<code class="xref py py-func docutils literal notranslate"><span class="pre">uuid4()</span></code> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">uuid5()</span></code> 的函数，用于生成不同版本的 UUID。（版本 2 的 UUID 在 <span class="target" id="index-85"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc4122.html"><strong>RFC 4122</strong></a> 中未指定，且此模块不支持。）:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">uuid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 基于主机 ID 和当前时间生成一个 UUID</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid1</span><span class="p">()</span>
<span class="go">UUID(&#39;a8098c1a-f86e-11da-bd1a-00112444be1e&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 使用命名空间 UUID 和名称的 MD5 哈希生成一个 UUID</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid3</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">NAMESPACE_DNS</span><span class="p">,</span> <span class="s1">&#39;python.org&#39;</span><span class="p">)</span>
<span class="go">UUID(&#39;6fa459ea-ee8a-3ca4-894e-db77e160355e&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 生成一个随机 UUID</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">()</span>
<span class="go">UUID(&#39;16fd2706-8baf-433b-82eb-8c7fada847da&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 使用命名空间 UUID 和名称的 SHA-1 哈希生成一个 UUID</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid5</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">NAMESPACE_DNS</span><span class="p">,</span> <span class="s1">&#39;python.org&#39;</span><span class="p">)</span>
<span class="go">UUID(&#39;886313e1-3b8a-5372-9b90-0c9aee199e5d&#39;)</span>
</pre></div>
</div>
<p class="translated">（由 Ka-Ping Yee 贡献。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/weakref.html#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal notranslate"><span class="pre">weakref</span></code></a> 模块的 <code class="xref py py-class docutils literal notranslate"><span class="pre">WeakKeyDictionary</span></code> 和 <code class="xref py py-class docutils literal notranslate"><span class="pre">WeakValueDictionary</span></code> 类型新增了用于迭代字典中包含的弱引用的方法。<code class="xref py py-class docutils literal notranslate"><span class="pre">WeakKeyDictionary</span></code> 添加了 <code class="xref py py-meth docutils literal notranslate"><span class="pre">iterkeyrefs()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">keyrefs()</span></code> 方法，<code class="xref py py-class docutils literal notranslate"><span class="pre">WeakValueDictionary</span></code> 添加了 <code class="xref py py-meth docutils literal notranslate"><span class="pre">itervaluerefs()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">valuerefs()</span></code> 方法。（由 Fred L. Drake, Jr. 贡献。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/webbrowser.html#module-webbrowser" title="webbrowser: Easy-to-use controller for web browsers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">webbrowser</span></code></a> 模块获得了一系列增强。现在可以作为脚本使用，通过 <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-m</span> <span class="pre">webbrowser</span></code> 命令，并接受一个 URL 作为参数；还有一些开关用于控制行为（<code class="xref std std-option docutils literal notranslate"><span class="pre">-n</span></code> 用于新浏览器窗口，<code class="xref std std-option docutils literal notranslate"><span class="pre">-t</span></code> 用于新标签页）。新增了模块级别的函数 <code class="xref py py-func docutils literal notranslate"><span class="pre">open_new()</span></code> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">open_new_tab()</span></code> 以支持这一功能。模块的 <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 函数支持一个附加特性，即 <em>autoraise</em> 参数，用于指示是否在可能的情况下提升打开的窗口。支持的浏览器列表中新增了 Firefox、Opera、Konqueror 和 elinks 等浏览器。（由 Oleg Broytmann 和 Georg Brandl 贡献。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/xmlrpc.client.html#module-xmlrpc.client" title="xmlrpc.client: XML-RPC client access."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xmlrpclib</span></code></a> 模块现在支持将 XML-RPC 日期类型返回为 <a class="reference internal" href="../library/datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime</span></code></a> 对象。向 <a class="reference internal" href="../library/xmlrpc.client.html#xmlrpc.client.loads" title="xmlrpc.client.loads"><code class="xref py py-func docutils literal notranslate"><span class="pre">loads()</span></code></a> 函数或 <code class="xref py py-class docutils literal notranslate"><span class="pre">Unmarshaller</span></code> 类提供 <code class="docutils literal notranslate"><span class="pre">use_datetime=True</span></code> 参数以启用此功能。（由 Skip Montanaro 贡献。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/zipfile.html#module-zipfile" title="zipfile: Read and write ZIP-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipfile</span></code></a> 模块现在支持 ZIP64 版本的格式，这意味着 .zip 归档文件现在可以大于 4 GiB，并且可以包含大于 4 GiB 的单个文件。（由 Ronald Oussoren 贡献。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zlib</span></code></a> 模块的 <code class="xref py py-class docutils literal notranslate"><span class="pre">Compress</span></code> 和 <code class="xref py py-class docutils literal notranslate"><span class="pre">Decompress</span></code> 对象现在支持 <a class="reference internal" href="../library/copy.html#module-copy" title="copy: Shallow and deep copy operations."><code class="xref py py-meth docutils literal notranslate"><span class="pre">copy()</span></code></a> 方法，该方法复制对象的内部状态并返回一个新的 <code class="xref py py-class docutils literal notranslate"><span class="pre">Compress</span></code> 或 <code class="xref py py-class docutils literal notranslate"><span class="pre">Decompress</span></code> 对象。（由 Chris AtLee 贡献。）</p>
</li>
</ul>
<section id="the-ctypes-package">
<span id="module-ctypes"></span><h3 class="translated">ctypes 包<a class="headerlink" href="#the-ctypes-package" title="Link to this heading">¶</a></h3>
<p class="translated">由 Thomas Heller 编写的 <a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 包已被添加到标准库中。<a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 允许你调用共享库或 DLL 中的任意函数。长期用户可能记得 <code class="xref py py-mod docutils literal notranslate"><span class="pre">dl</span></code> 模块，它提供了加载共享库和调用其中函数的功能。<a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 包要高级得多。</p>
<p class="translated">要加载共享库或DLL，你必须创建一个 <code class="xref py py-class docutils literal notranslate"><span class="pre">CDLL</span></code> 类的实例，并提供共享库或DLL的名称或路径。完成后，你可以通过将其作为 <code class="xref py py-class docutils literal notranslate"><span class="pre">CDLL</span></code> 对象的属性来调用任意函数。</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">ctypes</span>

<span class="n">libc</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">CDLL</span><span class="p">(</span><span class="s1">&#39;libc.so.6&#39;</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Line of output</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">为各种C类型提供了类型构造器：<code class="xref py py-func docutils literal notranslate"><span class="pre">c_int()</span></code>、<code class="xref py py-func docutils literal notranslate"><span class="pre">c_float()</span></code>、<code class="xref py py-func docutils literal notranslate"><span class="pre">c_double()</span></code>、<code class="xref py py-func docutils literal notranslate"><span class="pre">c_char_p()</span></code> (等同于 <span class="c-expr sig sig-inline c"><span class="kt">char</span><span class="p">*</span></span>) 等等。与Python的类型不同，C版本都是可变的；你可以分配给它们的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code> 属性来更改包装的值。Python整数和字符串将自动转换为相应的C类型，但对于其他类型，你必须调用正确的类型构造器。（我是说 <em>必须</em>；弄错了通常会导致解释器崩溃，出现段错误。）</p>
<p class="translated">当C函数将修改内存区域时，你不应该使用 <code class="xref py py-func docutils literal notranslate"><span class="pre">c_char_p()</span></code> 与Python字符串，因为Python字符串应该是不可变的；违反这一规则会导致令人困惑的bug。当你需要一个可修改的内存区域时，请使用 <code class="xref py py-func docutils literal notranslate"><span class="pre">create_string_buffer()</span></code>:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;this is a string&quot;</span>
<span class="n">buf</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">create_string_buffer</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">libc</span><span class="o">.</span><span class="n">strfry</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">C函数默认返回整数，但你可以设置函数对象的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> 属性来更改这一点:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">atof</span><span class="p">(</span><span class="s1">&#39;2.71828&#39;</span><span class="p">)</span>
<span class="go">-1783957616</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">atof</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">atof</span><span class="p">(</span><span class="s1">&#39;2.71828&#39;</span><span class="p">)</span>
<span class="go">2.71828</span>
</pre></div>
</div>
<p class="translated"><a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 还为Python的C API提供了一个包装器，即 <code class="docutils literal notranslate"><span class="pre">ctypes.pythonapi</span></code> 对象。这个对象在调用函数之前 <em>不</em> 释放全局解释器锁，因为调用解释器代码时必须持有该锁。还有一个 <a class="reference internal" href="../library/ctypes.html#ctypes.py_object" title="ctypes.py_object"><code class="xref py py-class docutils literal notranslate"><span class="pre">py_object</span></code></a> 类型构造器，它将创建一个 <span class="c-expr sig sig-inline c"><a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span> 指针。一个简单的用法:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">ctypes</span>

<span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">ctypes</span><span class="o">.</span><span class="n">pythonapi</span><span class="o">.</span><span class="n">PyObject_SetItem</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">py_object</span><span class="p">(</span><span class="n">d</span><span class="p">),</span>
          <span class="n">ctypes</span><span class="o">.</span><span class="n">py_object</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">),</span>  <span class="n">ctypes</span><span class="o">.</span><span class="n">py_object</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="c1"># d 现在是 {&#39;abc&#39;, 1}。</span>
</pre></div>
</div>
<p class="translated">不要忘记使用 <a class="reference internal" href="../library/ctypes.html#ctypes.py_object" title="ctypes.py_object"><code class="xref py py-func docutils literal notranslate"><span class="pre">py_object()</span></code></a>；如果省略它，你最终会遇到段错误。</p>
<p class="translated"><a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 已经存在一段时间了，但人们仍然编写和分发手工编码的扩展模块，因为你不能依赖 <a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 的存在。也许开发者现在会开始编写通过 <a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 访问库的 Python 包装器，而不是扩展模块，因为 <a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 已包含在核心 Python 中。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><a class="reference external" href="https://web.archive.org/web/20180410025338/http://starship.python.net/crew/theller/ctypes/">https://web.archive.org/web/20180410025338/http://starship.python.net/crew/theller/ctypes/</a></dt><dd><p class="translated">预标准库 ctypes 的网页，包含教程、参考和常见问题解答。</p>
</dd>
</dl>
<p class="translated"><a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 模块的文档。</p>
</div>
</section>
<section id="the-elementtree-package">
<span id="module-etree"></span><h3 class="translated">ElementTree 包<a class="headerlink" href="#the-elementtree-package" title="Link to this heading">¶</a></h3>
<p class="translated">Fredrik Lundh 的 ElementTree 库用于处理 XML 的一个子集已被添加到标准库中，作为 <code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree</span></code>。可用的模块有 <code class="xref py py-mod docutils literal notranslate"><span class="pre">ElementTree</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">ElementPath</span></code> 和来自 ElementTree 1.2.6 的 <code class="xref py py-mod docutils literal notranslate"><span class="pre">ElementInclude</span></code>。<code class="xref py py-mod docutils literal notranslate"><span class="pre">cElementTree</span></code> 加速模块也包括在内。</p>
<p class="translated">本节的剩余部分将提供使用 ElementTree 的简要说明。 要获取 ElementTree 的完整文档可访问 <a class="reference external" href="https://web.archive.org/web/20201124024954/http://effbot.org/zone/element-index.htm">https://web.archive.org/web/20201124024954/http://effbot.org/zone/element-index.htm</a>。</p>
<p class="translated">ElementTree 将 XML 文档表示为元素节点的树。文档的文本内容存储为 (这是 ElementTree 和文档对象模型之间的主要区别之一；在 DOM 中有许多不同类型的节点，包括 <code class="xref py py-class docutils literal notranslate"><span class="pre">TextNode</span></code>。) 的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">text</span></code> 和 <code class="xref py py-attr docutils literal notranslate"><span class="pre">tail</span></code> 属性。</p>
<p class="translated">最常用的解析函数是 <code class="xref py py-func docutils literal notranslate"><span class="pre">parse()</span></code>，它接受一个字符串（假设包含文件名）或文件类对象，并返回一个 <code class="xref py py-class docutils literal notranslate"><span class="pre">ElementTree</span></code> 实例:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">xml.etree</span><span class="w"> </span><span class="kn">import</span> <span class="n">ElementTree</span> <span class="k">as</span> <span class="n">ET</span>

<span class="n">tree</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;ex-1.xml&#39;</span><span class="p">)</span>

<span class="n">feed</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span>
          <span class="s1">&#39;http://planet.python.org/rss10.xml&#39;</span><span class="p">)</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">feed</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">一旦你有一个 <code class="xref py py-class docutils literal notranslate"><span class="pre">ElementTree</span></code> 实例，你可以调用它的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">getroot()</span></code> 方法来获取根 <code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code> 节点。</p>
<p class="translated">还有一个 <code class="xref py py-func docutils literal notranslate"><span class="pre">XML()</span></code> 函数，它接受一个字符串字面量并返回一个 <code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code> 节点（而不是一个 <code class="xref py py-class docutils literal notranslate"><span class="pre">ElementTree</span></code>）。这个函数提供了一种整洁的方式来嵌入 XML 片段，接近于 XML 字面量的便利性：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">svg</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">XML</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;&lt;svg width=&quot;10px&quot; version=&quot;1.0&quot;&gt;</span>
<span class="s2">             &lt;/svg&gt;&quot;&quot;&quot;</span><span class="p">)</span>
<span class="n">svg</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="s1">&#39;320px&#39;</span><span class="p">)</span>
<span class="n">svg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem1</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">每个 XML 元素都支持一些类似字典和类似列表的访问方法。类似字典的操作用于访问属性值，而类似列表的操作用于访问子节点。</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p class="translated">运算</p></th>
<th class="head"><p class="translated">结果：</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">elem[n]</span></code></p></td>
<td><p class="translated">返回第n个子元素。</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">elem[m:n]</span></code></p></td>
<td><p class="translated">返回第m至第n个子元素的列表。</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">len(elem)</span></code></p></td>
<td><p class="translated">返回子元素的个数。</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">list(elem)</span></code></p></td>
<td><p class="translated">返回子元素的列表。</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">elem.append(elem2)</span></code></p></td>
<td><p class="translated">将 <em>elem2</em> 添加为子级。</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">elem.insert(index,</span> <span class="pre">elem2)</span></code></p></td>
<td><p class="translated">在指定位置插入 <em>elem2</em> 。</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">elem[n]</span></code></p></td>
<td><p class="translated">删除第n个子元素。</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">elem.keys()</span></code></p></td>
<td><p class="translated">返回属性名称的列表。</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">elem.get(name)</span></code></p></td>
<td><p class="translated">返回 <em>name</em> 属性的值。</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">elem.set(name,</span> <span class="pre">value)</span></code></p></td>
<td><p class="translated">为 <em>name</em> 属性设置新值。</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">elem.attrib</span></code></p></td>
<td><p class="translated">检索包含属性的字典。</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">del</span> <span class="pre">elem.attrib[name]</span></code></p></td>
<td><p class="translated">删除 元素 <em>name</em> 的属性。</p></td>
</tr>
</tbody>
</table>
<p class="translated">注释和处理指令也以 <code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code> 节点的形式表示。要检查一个节点是否是注释或处理指令：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">elem</span><span class="o">.</span><span class="n">tag</span> <span class="ow">is</span> <span class="n">ET</span><span class="o">.</span><span class="n">Comment</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">elif</span> <span class="n">elem</span><span class="o">.</span><span class="n">tag</span> <span class="ow">is</span> <span class="n">ET</span><span class="o">.</span><span class="n">ProcessingInstruction</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated">要生成 XML 输出，应调用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">ElementTree.write()</span></code> 方法。与 <code class="xref py py-func docutils literal notranslate"><span class="pre">parse()</span></code> 类似，它既可以接受一个字符串，也可以接受一个类似文件的对象：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 编码为 US-ASCII</span>
<span class="n">tree</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;output.xml&#39;</span><span class="p">)</span>

<span class="c1"># 编码为 UTF-8</span>
<span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;output.xml&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="n">tree</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">（注意：输出的默认编码是 ASCII。对于一般的 XML 工作，其中元素的名称可能包含任意的 Unicode 字符，ASCII 不是一个非常有用的编码，因为它会在元素名称包含任何值大于 127 的字符时引发异常。因此，最好指定一个不同的编码，如 UTF-8，它可以处理任何 Unicode 字符。）</p>
<p class="translated">本节仅对 ElementTree 接口进行了部分描述。请阅读包的官方文档以获取更多详细信息。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><a class="reference external" href="https://web.archive.org/web/20201124024954/http://effbot.org/zone/element-index.htm">https://web.archive.org/web/20201124024954/http://effbot.org/zone/element-index.htm</a></dt><dd><p class="translated">ElementTree 的官方文档。</p>
</dd>
</dl>
</div>
</section>
<section id="the-hashlib-package">
<span id="module-hashlib"></span><h3 class="translated">hashlib 包<a class="headerlink" href="#the-hashlib-package" title="Link to this heading">¶</a></h3>
<p class="translated">由 Gregory P. Smith 编写的一个新的 <a class="reference internal" href="../library/hashlib.html#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code class="xref py py-mod docutils literal notranslate"><span class="pre">hashlib</span></code></a> 模块已被添加，以替换 <code class="xref py py-mod docutils literal notranslate"><span class="pre">md5</span></code> 和 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sha</span></code> 模块。<a class="reference internal" href="../library/hashlib.html#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code class="xref py py-mod docutils literal notranslate"><span class="pre">hashlib</span></code></a> 增加了对额外安全哈希（SHA-224、SHA-256、SHA-384 和 SHA-512）的支持。在可用的情况下，该模块使用 OpenSSL 以实现快速的平台优化算法实现。</p>
<p class="translated">旧的 <code class="xref py py-mod docutils literal notranslate"><span class="pre">md5</span></code> 和 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sha</span></code> 模块仍然存在，作为 hashlib 的包装器以保持向后兼容性。新模块的接口与旧模块非常接近，但不完全相同。最显著的区别是用于创建新哈希对象的构造函数命名不同。:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 旧版本</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">md5</span><span class="o">.</span><span class="n">md5</span><span class="p">()</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">md5</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>

<span class="c1"># 新版本</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">()</span>

<span class="c1"># 旧版本</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">sha</span><span class="o">.</span><span class="n">sha</span><span class="p">()</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">sha</span><span class="o">.</span><span class="n">new</span><span class="p">()</span>

<span class="c1"># 新版本</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha1</span><span class="p">()</span>

<span class="c1"># 之前不可用的哈希</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha224</span><span class="p">()</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha256</span><span class="p">()</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha384</span><span class="p">()</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha512</span><span class="p">()</span>

<span class="c1"># 备选形式</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;md5&#39;</span><span class="p">)</span>          <span class="c1"># 以字符串形式提供算法</span>
</pre></div>
</div>
<p class="translated">一旦创建了哈希对象，其方法与之前相同：<code class="docutils literal notranslate"><span class="pre">update(string)</span></code> 将指定的字符串哈希到当前摘要状态中，<code class="xref py py-meth docutils literal notranslate"><span class="pre">digest()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">hexdigest()</span></code> 分别返回二进制字符串或十六进制数字字符串的摘要值，<a class="reference internal" href="../library/copy.html#module-copy" title="copy: Shallow and deep copy operations."><code class="xref py py-meth docutils literal notranslate"><span class="pre">copy()</span></code></a> 返回具有相同摘要状态的新哈希对象。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p class="translated"><a class="reference internal" href="../library/hashlib.html#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code class="xref py py-mod docutils literal notranslate"><span class="pre">hashlib</span></code></a> 模块的文档。</p>
</div>
</section>
<section id="the-sqlite3-package">
<span id="module-sqlite"></span><h3 class="translated">sqlite3 包<a class="headerlink" href="#the-sqlite3-package" title="Link to this heading">¶</a></h3>
<p class="translated">pysqlite 模块（<a class="reference external" href="https://www.pysqlite.org">https://www.pysqlite.org</a>），作为 SQLite 嵌入式数据库的包装器，已被添加到标准库中，包名为 <a class="reference internal" href="../library/sqlite3.html#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a>。</p>
<p class="translated">SQLite 是一个C语言库，它可以提供一种轻量级的基于磁盘的数据库，这种数据库不需要独立的服务器进程，也允许需要使用一种非标准的 SQL 查询语言来访问它。一些应用程序可以使用 SQLite 作为内部数据存储。可以用它来创建一个应用程序原型，然后再迁移到更大的数据库，比如 PostgreSQL 或 Oracle。</p>
<p class="translated">pysqlite 由 Gerhard Häßing 编写，提供了一个符合 <span class="target" id="index-86"></span><a class="pep reference external" href="https://peps.python.org/pep-0249/"><strong>PEP 249</strong></a> 描述的 DB-API 2.0 规范的 SQL 接口。</p>
<p class="translated">如果你自己编译 Python 源代码，请注意源代码树不包含 SQLite 代码，只包含封装模块。在编译 Python 之前，你需要安装 SQLite 库和头文件，当必要的头文件可用时，编译过程将编译模块。</p>
<p class="translated">要使用该模块，你必须首先创建一个表示数据库的 <code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code> 对象。这里数据将存储在 <code class="file docutils literal notranslate"><span class="pre">/tmp/example</span></code> 文件中:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;/tmp/example&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">你也可以使用 <code class="docutils literal notranslate"><span class="pre">:memory:</span></code> 来创建一个内存中的数据库。</p>
<p class="translated">一旦你有了 <code class="xref py py-class docutils literal notranslate"><span class="pre">Connection</span></code>，你可以创建一个 <code class="xref py py-class docutils literal notranslate"><span class="pre">Cursor</span></code> 对象并调用其 <code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code> 方法来执行 SQL 命令:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>

<span class="c1"># 创建表</span>
<span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;create table stocks</span>
<span class="s1">(date text, trans text, symbol text,</span>
<span class="s1"> qty real, price real)&#39;&#39;&#39;</span><span class="p">)</span>

<span class="c1"># 插入一行数据</span>
<span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;insert into stocks</span>
<span class="s2">          values (&#39;2006-01-05&#39;,&#39;BUY&#39;,&#39;RHAT&#39;,100,35.14)&quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">通常，你的 SQL 操作需要使用来自 Python 变量的值。  你不应该使用 Python 的字符串操作来组装你的查询，因为这样做是不安全的，它会使你的程序容易受到 SQL 注入攻击。</p>
<p class="translated">相反，使用 DB-API 的参数替换。在需要使用值的任何位置放置 <code class="docutils literal notranslate"><span class="pre">?</span></code> 作为占位符，然后将值的元组作为第二个参数传递给游标的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code> 方法。（其他数据库模块可能使用不同的占位符，例如 <code class="docutils literal notranslate"><span class="pre">%s</span></code> 或 <code class="docutils literal notranslate"><span class="pre">:1</span></code>。）例如：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 千万不要这样做 -- 不安全！</span>
<span class="n">symbol</span> <span class="o">=</span> <span class="s1">&#39;IBM&#39;</span>
<span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;... where symbol = &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">symbol</span><span class="p">)</span>

<span class="c1"># 应该这样做</span>
<span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">symbol</span><span class="p">,)</span>
<span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;select * from stocks where symbol=?&#39;</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>

<span class="c1"># 更大的示例</span>
<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">((</span><span class="s1">&#39;2006-03-28&#39;</span><span class="p">,</span> <span class="s1">&#39;BUY&#39;</span><span class="p">,</span> <span class="s1">&#39;IBM&#39;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mf">45.00</span><span class="p">),</span>
          <span class="p">(</span><span class="s1">&#39;2006-04-05&#39;</span><span class="p">,</span> <span class="s1">&#39;BUY&#39;</span><span class="p">,</span> <span class="s1">&#39;MSOFT&#39;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mf">72.00</span><span class="p">),</span>
          <span class="p">(</span><span class="s1">&#39;2006-04-06&#39;</span><span class="p">,</span> <span class="s1">&#39;SELL&#39;</span><span class="p">,</span> <span class="s1">&#39;IBM&#39;</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mf">53.00</span><span class="p">),</span>
         <span class="p">):</span>
    <span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;insert into stocks values (?,?,?,?,?)&#39;</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">在执行 SELECT 语句后检索数据，可以将游标视为迭代器，调用游标的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">fetchone()</span></code> 方法检索单个匹配行，或者调用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">fetchall()</span></code> 获取匹配行的列表。</p>
<p class="translated">下面是一个使用迭代器形式的例子：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;select * from stocks order by price&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
<span class="gp">... </span>   <span class="nb">print</span> <span class="n">row</span>
<span class="gp">...</span>
<span class="go">(u&#39;2006-01-05&#39;, u&#39;BUY&#39;, u&#39;RHAT&#39;, 100, 35.140000000000001)</span>
<span class="go">(u&#39;2006-03-28&#39;, u&#39;BUY&#39;, u&#39;IBM&#39;, 1000, 45.0)</span>
<span class="go">(u&#39;2006-04-06&#39;, u&#39;SELL&#39;, u&#39;IBM&#39;, 500, 53.0)</span>
<span class="go">(u&#39;2006-04-05&#39;, u&#39;BUY&#39;, u&#39;MSOFT&#39;, 1000, 72.0)</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">有关 SQLite 所支持的 SQL 方法的更多信息，请参阅 <a class="reference external" href="https://www.sqlite.org">https://www.sqlite.org</a>。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><a class="reference external" href="https://www.pysqlite.org">https://www.pysqlite.org</a></dt><dd><p class="translated">pysqlite 的主页。</p>
</dd>
<dt class="translated"><a class="reference external" href="https://www.sqlite.org">https://www.sqlite.org</a></dt><dd><p class="translated">SQLite的主页；它的文档详细描述了它所支持的 SQL 方言的语法和可用的数据类型。</p>
</dd>
</dl>
<p class="translated"><a class="reference internal" href="../library/sqlite3.html#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> 模块的文档。</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-87"></span><a class="pep reference external" href="https://peps.python.org/pep-0249/"><strong>PEP 249</strong></a> - DB-API 2.0 规范</dt><dd><p class="translated">PEP 由 Marc-André Lemburg 撰写。</p>
</dd>
</dl>
</div>
</section>
<section id="the-wsgiref-package">
<span id="module-wsgiref"></span><h3 class="translated">wsgiref 包<a class="headerlink" href="#the-wsgiref-package" title="Link to this heading">¶</a></h3>
<p class="translated">Web 服务器网关接口 (WSGI) v1.0 定义了 Web 服务器和 Python Web 应用程序之间的标准接口，并在 <span class="target" id="index-88"></span><a class="pep reference external" href="https://peps.python.org/pep-0333/"><strong>PEP 333</strong></a> 中进行了描述。<a class="reference internal" href="../library/wsgiref.html#module-wsgiref" title="wsgiref: WSGI Utilities and Reference Implementation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">wsgiref</span></code></a> 包是 WSGI 规范的参考实现。</p>
<p class="translated">该软件包包含一个基本 HTTP 服务器，可运行 WSGI 应用程序；该服务器可用于调试，但不打算用于生产环境。设置服务器只需几行代码：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">wsgiref</span><span class="w"> </span><span class="kn">import</span> <span class="n">simple_server</span>

<span class="n">wsgi_app</span> <span class="o">=</span> <span class="o">...</span>

<span class="n">host</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
<span class="n">port</span> <span class="o">=</span> <span class="mi">8000</span>
<span class="n">httpd</span> <span class="o">=</span> <span class="n">simple_server</span><span class="o">.</span><span class="n">make_server</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">wsgi_app</span><span class="p">)</span>
<span class="n">httpd</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><a class="reference external" href="https://web.archive.org/web/20160331090247/http://wsgi.readthedocs.org/en/latest/">https://web.archive.org/web/20160331090247/http://wsgi.readthedocs.org/en/latest/</a></dt><dd><p class="translated">WSGI相关资源的核心网站。</p>
</dd>
<dt class="translated"><span class="target" id="index-89"></span><a class="pep reference external" href="https://peps.python.org/pep-0333/"><strong>PEP 333</strong></a> - Python Web服务器网关接口 v1.0</dt><dd><p class="translated">PEP 由 Phillip J. Eby 撰写。</p>
</dd>
</dl>
</div>
</section>
</section>
<section id="build-and-c-api-changes">
<span id="build-api"></span><h2 class="translated">构建和 C API 的变更<a class="headerlink" href="#build-and-c-api-changes" title="Link to this heading">¶</a></h2>
<p class="translated">针对 Python 构建过程和 C API 的变更包括:</p>
<ul>
<li><p class="translated">Python 源代码树从 CVS 转换为 Subversion，这一复杂的迁移过程由 Martin von Löwis 监督并完美执行。该过程按 <span class="target" id="index-90"></span><a class="pep reference external" href="https://peps.python.org/pep-0347/"><strong>PEP 347</strong></a> 进行了开发。</p></li>
<li><p class="translated">Coverity 公司，一家销售名为 Prevent 的源代码分析工具的公司，提供了他们对 Python 源代码的检查结果。分析发现了大约 60 个错误，这些错误很快被修复。许多错误是引用计数问题，通常出现在错误处理代码中。详见 <a class="reference external" href="https://scan.coverity.com">https://scan.coverity.com</a> 了解统计数据。</p></li>
<li><p class="translated">C API 最大的变化来自 <span class="target" id="index-91"></span><a class="pep reference external" href="https://peps.python.org/pep-0353/"><strong>PEP 353</strong></a>，该提案修改了解释器，使其使用 <a class="reference internal" href="../c-api/intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a> 类型定义而不是 <span class="c-expr sig sig-inline c"><span class="kt">int</span></span>。详见前文 <a class="reference internal" href="#pep-353"><span class="std std-ref">PEP 353: 使用ssize_t作为索引类型</span></a> 部分对此变化的讨论。</p></li>
<li><p class="translated">字节码编译器的设计发生了很大变化，不再通过遍历解析树生成字节码。相反，解析树被转换为抽象语法树（AST），然后遍历抽象语法树来生成字节码。</p>
<p class="translated">Python 代码可以通过使用内置的 <a class="reference internal" href="../library/functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 函数并指定 <code class="docutils literal notranslate"><span class="pre">_ast.PyCF_ONLY_AST</span></code> 作为 <em>flags</em> 参数的值来获取 AST 对象:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">_ast</span><span class="w"> </span><span class="kn">import</span> <span class="n">PyCF_ONLY_AST</span>
<span class="n">ast</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;a=0</span>
<span class="s2">for i in range(10):</span>
<span class="s2">    a += i</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;string&gt;&quot;</span><span class="p">,</span> <span class="s1">&#39;exec&#39;</span><span class="p">,</span> <span class="n">PyCF_ONLY_AST</span><span class="p">)</span>

<span class="n">assignment</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">for_loop</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p class="translated">目前还没有为 AST 代码编写官方文档，但 <span class="target" id="index-92"></span><a class="pep reference external" href="https://peps.python.org/pep-0339/"><strong>PEP 339</strong></a> 讨论了其设计。要开始了解这部分代码，请阅读 <code class="file docutils literal notranslate"><span class="pre">Parser/Python.asdl</span></code> 中各种 AST 节点的定义。一个 Python 脚本读取此文件，并在 <code class="file docutils literal notranslate"><span class="pre">Include/Python-ast.h</span></code> 中生成一组 C 结构定义。在 <code class="file docutils literal notranslate"><span class="pre">Include/pythonrun.h</span></code> 中定义的 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyParser_ASTFromString()</span></code> 和 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyParser_ASTFromFile()</span></code> 函数以 Python 源代码作为输入，返回表示内容的 AST 的根节点。这个 AST 可以通过 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyAST_Compile()</span></code> 转换为代码对象。更多信息请阅读源代码，并在 python-dev 上提问。</p>
<p class="translated">AST 代码在 Jeremy Hylton 的管理下开发，并由以下人员（按字母顺序）实现：Brett Cannon、Nick Coghlan、Grant Edwards、John Ehresman、Kurt Kaiser、Neal Norwitz、Tim Peters、Armin Rigo 和 Neil Schemenauer，以及参与 PyCon 等会议中多次 AST 短暂开发活动的参与者。</p>
</li>
<li><p class="translated">Evan Jones 提出的 obmalloc 补丁，最初在 PyCon DC 2005 的一次演讲中描述，已被应用。Python 2.4 在 256K 大小的区域中分配小对象，但不释放这些区域。有了这个补丁，Python 将在区域为空时释放它们。净效果是，在某些平台上，当你分配许多对象时，删除这些对象后 Python 的内存使用可能会实际减少，并且内存可能会返回给操作系统。（由 Evan Jones 实现，并由 Tim Peters 重构。）</p>
<p class="translated">请注意，这一变化意味着扩展模块在分配内存时必须更加小心。Python 的 API 有许多不同的内存分配函数，它们被分组到不同的家族中。例如，<a class="reference internal" href="../c-api/memory.html#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Malloc()</span></code></a>、<a class="reference internal" href="../c-api/memory.html#c.PyMem_Realloc" title="PyMem_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Realloc()</span></code></a> 和 <a class="reference internal" href="../c-api/memory.html#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Free()</span></code></a> 是一个用于分配原始内存的家族，而 <a class="reference internal" href="../c-api/memory.html#c.PyObject_Malloc" title="PyObject_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Malloc()</span></code></a>、<a class="reference internal" href="../c-api/memory.html#c.PyObject_Realloc" title="PyObject_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Realloc()</span></code></a> 和 <a class="reference internal" href="../c-api/memory.html#c.PyObject_Free" title="PyObject_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Free()</span></code></a> 是另一个用于创建 Python 对象的家族。</p>
<p class="translated">以前，这些不同的家族最终都归结为平台的 <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> 和 <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code> 函数。这意味着如果你搞错了，用 <code class="docutils literal notranslate"><span class="pre">PyMem</span></code> 函数分配内存却用 <code class="docutils literal notranslate"><span class="pre">PyObject</span></code> 函数释放它，也不会有问题。但随着 2.5 版对 obmalloc 的更改，这些家族现在执行不同的操作，不匹配可能会导致段错误。你应该仔细测试你的 C 扩展模块与 Python 2.5 的兼容性。</p>
</li>
<li><p class="translated">内置集合类型现在拥有官方的C API。调用 <a class="reference internal" href="../c-api/set.html#c.PySet_New" title="PySet_New"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySet_New()</span></code></a> 和 <a class="reference internal" href="../c-api/set.html#c.PyFrozenSet_New" title="PyFrozenSet_New"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFrozenSet_New()</span></code></a> 创建新集合，使用 <a class="reference internal" href="../c-api/set.html#c.PySet_Add" title="PySet_Add"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySet_Add()</span></code></a> 和 <a class="reference internal" href="../c-api/set.html#c.PySet_Discard" title="PySet_Discard"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySet_Discard()</span></code></a> 添加和移除元素，以及使用 <a class="reference internal" href="../c-api/set.html#c.PySet_Contains" title="PySet_Contains"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySet_Contains()</span></code></a> 和 <a class="reference internal" href="../c-api/set.html#c.PySet_Size" title="PySet_Size"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySet_Size()</span></code></a> 检查集合的状态。（由 Raymond Hettinger 贡献。）</p></li>
<li><p class="translated">C代码现在可以通过调用 <a class="reference internal" href="../c-api/init.html#c.Py_GetBuildInfo" title="Py_GetBuildInfo"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_GetBuildInfo()</span></code></a> 函数获取Python解释器的确切修订信息，该函数返回一个包含构建信息的字符串，例如：<code class="docutils literal notranslate"><span class="pre">&quot;trunk:45355:45356M,</span> <span class="pre">Apr</span> <span class="pre">13</span> <span class="pre">2006,</span> <span class="pre">07:42:19&quot;</span></code>。（由 Barry Warsaw 贡献。）</p></li>
<li><p class="translated">新增两个宏用于指示当前文件所属的局部 C 函数以便能够使用更快速的调用约定。 <a class="reference internal" href="../c-api/intro.html#c.Py_LOCAL" title="Py_LOCAL"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_LOCAL</span></code></a> 声明函数将返回指定 <em>type</em> 的值并使用快速调用限定符。 <a class="reference internal" href="../c-api/intro.html#c.Py_LOCAL_INLINE" title="Py_LOCAL_INLINE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_LOCAL_INLINE</span></code></a> 执行相同的操作并还将请求函数是内联的。 如果在包括 <code class="file docutils literal notranslate"><span class="pre">python.h</span></code> 之前 <code class="xref c c-macro docutils literal notranslate"><span class="pre">PY_LOCAL_AGGRESSIVE</span></code> 已被定义，则会为模块启用一组更激进的优化；你应当对结果进行基准测试以确定这些优化是否确实能使代码运行更快速。 （由 Fredrik Lundh 在 NeedForSpeed sprint 中贡献。）</p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">PyErr_NewException(name,</span> <span class="pre">base,</span> <span class="pre">dict)</span></code> 现在可以接受一个基类元组作为其 <em>base</em> 参数。（由 Georg Brandl 贡献。）</p></li>
<li><p class="translated">用于发出警告的 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyErr_Warn()</span></code> 函数现在已弃用，推荐使用 <code class="docutils literal notranslate"><span class="pre">PyErr_WarnEx(category,</span> <span class="pre">message,</span> <span class="pre">stacklevel)</span></code>，它允许你指定此函数与调用者之间的堆栈帧数。<em>stacklevel</em> 为1是调用 <a class="reference internal" href="../c-api/exceptions.html#c.PyErr_WarnEx" title="PyErr_WarnEx"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyErr_WarnEx()</span></code></a> 的函数，2是之上的函数，依此类推。（由 Neal Norwitz 添加。）</p></li>
<li><p class="translated">CPython解释器仍然用C语言编写，但现在代码可以用C++编译器编译而不会出错。（由 Anthony Baxter、Martin von Löwis、Skip Montanaro 实现。）</p></li>
<li><p class="translated"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyRange_New()</span></code> 函数已被移除。该函数从未被文档化，从未在核心代码中使用，并且具有危险的宽松错误检查。在极少数情况下，如果你的扩展使用了它，你可以用类似以下代码替换：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">range</span> <span class="o">=</span> <span class="n">PyObject_CallFunction</span><span class="p">((</span><span class="n">PyObject</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">PyRange_Type</span><span class="p">,</span> <span class="s2">&quot;lll&quot;</span><span class="p">,</span>
                              <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
<section id="port-specific-changes">
<span id="ports"></span><h3 class="translated">移植专属的改变<a class="headerlink" href="#port-specific-changes" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p class="translated">MacOS X (10.3 及更高版本): 模块的动态加载现在会使用 <code class="xref c c-func docutils literal notranslate"><span class="pre">dlopen()</span></code> 函数而不是 MacOS 专属的函数。</p></li>
<li><p class="translated">MacOS X：在 <strong class="program">configure</strong> 脚本中添加了 <code class="xref std std-option docutils literal notranslate"><span class="pre">--enable-universalsdk</span></code> 开关，用于将解释器编译为通用二进制文件，能够在 PowerPC 和 Intel 处理器上运行。（由 Ronald Oussoren 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2573">bpo-2573</a>。）</p></li>
<li><p class="translated">Windows：<code class="file docutils literal notranslate"><span class="pre">.dll</span></code> 已不再作为扩展模块的文件名扩展名支持。现在只搜索 <code class="file docutils literal notranslate"><span class="pre">.pyd</span></code> 作为文件名扩展名。</p></li>
</ul>
</section>
</section>
<section id="porting-to-python-2-5">
<span id="porting"></span><h2 class="translated">移植到Python 2.5<a class="headerlink" href="#porting-to-python-2-5" title="Link to this heading">¶</a></h2>
<p class="translated">本节列出了先前描述的可能需要修改你的代码的改变：</p>
<ul class="simple">
<li><p class="translated">ASCII 现在是模块的默认编码。如果一个模块包含带有 8 位字符的字符串字面量但没有编码声明，现在会引发语法错误。在 Python 2.4 中，这会触发警告，而不是语法错误。</p></li>
<li><p class="translated">之前，生成器的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">gi_frame</span></code> 属性始终是一个帧对象。由于 <span class="target" id="index-93"></span><a class="pep reference external" href="https://peps.python.org/pep-0342/"><strong>PEP 342</strong></a> 中描述的更改（见 <a class="reference internal" href="#pep-342"><span class="std std-ref">PEP 342: 生成器的新特性</span></a> 部分），现在 <code class="xref py py-attr docutils literal notranslate"><span class="pre">gi_frame</span></code> 可能是 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p></li>
<li><p class="translated">新增警告 <a class="reference internal" href="../library/exceptions.html#UnicodeWarning" title="UnicodeWarning"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnicodeWarning</span></code></a>，当尝试比较一个 Unicode 字符串和一个无法使用默认 ASCII 编码转换为 Unicode 的 8 位字符串时触发。之前此类比较会引发 <a class="reference internal" href="../library/exceptions.html#UnicodeDecodeError" title="UnicodeDecodeError"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnicodeDecodeError</span></code></a> 异常。</p></li>
<li><p class="translated">库：<a class="reference internal" href="../library/csv.html#module-csv" title="csv: Write and read tabular data to and from delimited files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">csv</span></code></a> 模块现在对多行引用字段更为严格。如果你的文件中包含嵌入字段中的换行符，输入应按保留换行符的方式拆分为行。</p></li>
<li><p class="translated">库：<a class="reference internal" href="../library/locale.html#module-locale" title="locale: Internationalization services."><code class="xref py py-mod docutils literal notranslate"><span class="pre">locale</span></code></a> 模块的 <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> 函数之前会接受任何字符串，只要不超过一个 %char 指定符。在 Python 2.5 中，参数必须正好是一个 %char 指定符，且周围没有文本。</p></li>
<li><p class="translated">库：<a class="reference internal" href="../library/pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 和 <code class="xref py py-mod docutils literal notranslate"><span class="pre">cPickle</span></code> 模块不再接受 <a class="reference internal" href="../library/pickle.html#object.__reduce__" title="object.__reduce__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code></a> 方法返回值为 <code class="docutils literal notranslate"><span class="pre">None</span></code>；该方法必须返回一个参数元组。模块也不再接受已弃用的 <em>bin</em> 关键字参数。</p></li>
<li><p class="translated">库：<a class="reference internal" href="../library/xmlrpc.server.html#module-xmlrpc.server" title="xmlrpc.server: Basic XML-RPC server implementations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">SimpleXMLRPCServer</span></code></a> 和 <a class="reference internal" href="../library/xmlrpc.server.html#module-xmlrpc.server" title="xmlrpc.server: Basic XML-RPC server implementations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">DocXMLRPCServer</span></code></a> 类现在有一个 <code class="xref py py-attr docutils literal notranslate"><span class="pre">rpc_paths</span></code> 属性，该属性将 XML-RPC 操作限制在有限的 URL 路径集中；默认只允许 <code class="docutils literal notranslate"><span class="pre">'/'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">'/RPC2'</span></code>。将 <code class="xref py py-attr docutils literal notranslate"><span class="pre">rpc_paths</span></code> 设置为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 或一个空元组将禁用此路径检查。</p></li>
<li><p class="translated">C API：许多函数现在使用 <a class="reference internal" href="../c-api/intro.html#c.Py_ssize_t" title="Py_ssize_t"><code class="xref c c-type docutils literal notranslate"><span class="pre">Py_ssize_t</span></code></a> 而不是 <span class="c-expr sig sig-inline c"><span class="kt">int</span></span>，以允许在 64 位机器上处理更多数据。扩展代码可能需要做出相同的更改，以避免警告并支持 64 位机器。有关此更改的讨论，请参阅前面的章节 <a class="reference internal" href="#pep-353"><span class="std std-ref">PEP 353: 使用ssize_t作为索引类型</span></a>。</p></li>
<li><p class="translated">C API：obmalloc 的更改意味着你必须小心，不要混合使用 <code class="docutils literal notranslate"><span class="pre">PyMem_*</span></code> 和 <code class="docutils literal notranslate"><span class="pre">PyObject_*</span></code> 系列函数。使用一个系列的 <code class="docutils literal notranslate"><span class="pre">*_Malloc</span></code> 分配的内存必须使用相应系列的 <code class="docutils literal notranslate"><span class="pre">*_Free</span></code> 函数释放。</p></li>
</ul>
</section>
<section id="acknowledgements">
<h2 class="translated">致谢<a class="headerlink" href="#acknowledgements" title="Link to this heading">¶</a></h2>
<p class="translated">作者感谢以下人员对本文各种草稿给予的建议、更正和协助： Georg Brandl、Nick Coghlan、Phillip J. Eby、Lars Gustäbel、Raymond Hettinger、Ralf W. Grosse-Kunstleve、Kent Johnson、Iain Lowe、Martin von Löwis、Fredrik Lundh、Andrew McNamara、Skip Montanaro、Gustavo Niemeyer、Paul Prescod、James Pryor、Mike Rovner、Scott Weikart、Barry Warsaw、Thomas Wouters。</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#">Python 2.5 有什么新变化</a><ul>
<li><a class="reference internal" href="#pep-308-conditional-expressions">PEP 308: 条件表达式</a></li>
<li><a class="reference internal" href="#pep-309-partial-function-application">PEP 309: 部分功能应用</a></li>
<li><a class="reference internal" href="#pep-314-metadata-for-python-software-packages-v1-1">PEP 314: Python软件包的元数据 v1.1</a></li>
<li><a class="reference internal" href="#pep-328-absolute-and-relative-imports">PEP 328: 绝对导入和相对导入</a></li>
<li><a class="reference internal" href="#pep-338-executing-modules-as-scripts">PEP 338: 将模块作为脚本执行</a></li>
<li><a class="reference internal" href="#pep-341-unified-try-except-finally">PEP 341: 统一 try/except/finally</a></li>
<li><a class="reference internal" href="#pep-342-new-generator-features">PEP 342: 生成器的新特性</a></li>
<li><a class="reference internal" href="#pep-343-the-with-statement">PEP 343: &quot;with&quot; 语句</a><ul>
<li><a class="reference internal" href="#writing-context-managers">编写上下文管理器</a></li>
<li><a class="reference internal" href="#the-contextlib-module">contextlib 模块</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pep-352-exceptions-as-new-style-classes">PEP 352: 异常作为新型的类</a></li>
<li><a class="reference internal" href="#pep-353-using-ssize-t-as-the-index-type">PEP 353: 使用ssize_t作为索引类型</a></li>
<li><a class="reference internal" href="#pep-357-the-index-method">PEP 357: '__index__' 方法</a></li>
<li><a class="reference internal" href="#other-language-changes">其他语言特性修改</a><ul>
<li><a class="reference internal" href="#interactive-interpreter-changes">交互解释器变更</a></li>
<li><a class="reference internal" href="#optimizations">性能优化</a></li>
</ul>
</li>
<li><a class="reference internal" href="#new-improved-and-removed-modules">新增，改进和删除的模块</a><ul>
<li><a class="reference internal" href="#the-ctypes-package">ctypes 包</a></li>
<li><a class="reference internal" href="#the-elementtree-package">ElementTree 包</a></li>
<li><a class="reference internal" href="#the-hashlib-package">hashlib 包</a></li>
<li><a class="reference internal" href="#the-sqlite3-package">sqlite3 包</a></li>
<li><a class="reference internal" href="#the-wsgiref-package">wsgiref 包</a></li>
</ul>
</li>
<li><a class="reference internal" href="#build-and-c-api-changes">构建和 C API 的变更</a><ul>
<li><a class="reference internal" href="#port-specific-changes">移植专属的改变</a></li>
</ul>
</li>
<li><a class="reference internal" href="#porting-to-python-2-5">移植到Python 2.5</a></li>
<li><a class="reference internal" href="#acknowledgements">致谢</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一主题</h4>
    <p class="topless"><a href="2.6.html"
                          title="上一章">Python 2.6 有什么新变化</a></p>
  </div>
  <div>
    <h4>下一主题</h4>
    <p class="topless"><a href="2.4.html"
                          title="下一章">Python 2.4 有什么新变化</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">报告代码错误</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/whatsnew/2.5.rst?plain=1"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="折叠边栏">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="2.4.html" title="Python 2.4 有什么新变化"
             >下一页</a> |</li>
        <li class="right" >
          <a href="2.6.html" title="Python 2.6 有什么新变化"
             >上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.14.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python的新变化</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Python 2.5 有什么新变化</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q" id="search-box">
          <input type="submit" value="转到">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    主题
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>自动</option>
        <option value="light">明亮</option>
        <option value="dark">黑暗</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版权</a> 2001 Python Software Foundation.
    <br>
    本页面采用 Python 软件基金会许可证第 2 版授权。
    <br>
    文档中的示例、代码片段及其他代码内容额外采用零条款 BSD 许可证授权。
    <br>
    
      更多信息请参阅《<a href="/license.html"> 历史与许可 </a>》。<br>
    
    
    <br>

    Python 软件基金会是一家非营利性公司。
<a href="https://www.python.org/psf/donations/">请进行捐赠。</a>
<br>
    <br>
      最后更新于11月 25, 2025 (07:24 UTC) 。
    
      <a href="/bugs.html">发现了错误</a>？
    
    <br>

    使用<a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3 创建。
    </div>

  </body>
</html>
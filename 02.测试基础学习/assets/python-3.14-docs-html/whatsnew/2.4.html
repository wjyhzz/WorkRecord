<!DOCTYPE html>

<html lang="zh-CN" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="Python 2.4 有什么新变化" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/whatsnew/2.4.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="作者, A.M. Kuchling,. 本文介绍了2005年3月30日发布的 Python 2.4.1 的新功能。 Python 2.4 是一个中等规模的发布版。 它引入的变化没有激进的 Python 2.2 那么多，但比保守的 2.3 发布版引入了更多的特性。 最主要的新语言特性是函数装饰器和生成器表达式；其他大部分改动都是针对标准库。 根据 CVS 变更日志，Python 2.3 和 2..." />
<meta property="og:image:width" content="1146" />
<meta property="og:image:height" content="600" />
<meta property="og:image" content="https://docs.python.org/3.14/zh-cn/_images/social_previews/summary_whatsnew_2.4_fe5a9329.png" />
<meta property="og:image:alt" content="作者, A.M. Kuchling,. 本文介绍了2005年3月30日发布的 Python 2.4.1 的新功能。 Python 2.4 是一个中等规模的发布版。 它引入的变化没有激进的 Python 2.2 那么多，但比保守的 2.3 发布版引入了更多的特性。 最主要的新语言特性是函数装饰器和生成器表达式；其他大部分改动都是针对标准库。 根据 CVS 变更日志，Python 2.3 和 2..." />
<meta name="description" content="作者, A.M. Kuchling,. 本文介绍了2005年3月30日发布的 Python 2.4.1 的新功能。 Python 2.4 是一个中等规模的发布版。 它引入的变化没有激进的 Python 2.2 那么多，但比保守的 2.3 发布版引入了更多的特性。 最主要的新语言特性是函数装饰器和生成器表达式；其他大部分改动都是针对标准库。 根据 CVS 变更日志，Python 2.3 和 2..." />
<meta name="twitter:card" content="summary_large_image" />
<meta name="theme-color" content="#3776ab">

    <title>Python 2.4 有什么新变化 &#8212; Python 3.14.0 文档</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=234b1a7c" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=8cd84f99" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=5349f25f" />
    
    <script src="../_static/documentation_options.js?v=a595ec0e"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=beaddf03"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.14.0 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于此文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权" href="../copyright.html" />
    <link rel="next" title="Python 2.3 有什么新变化" href="2.3.html" />
    <link rel="prev" title="Python 2.5 有什么新变化" href="2.5.html" />
    
      
      <script defer file-types="bz2,epub,zip" data-domain="docs.python.org" src="https://analytics.python.org/js/script.file-downloads.outbound-links.js"></script>
      
      <link rel="canonical" href="https://docs.python.org/3/whatsnew/2.4.html">
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg">
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="菜单">
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo">
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q">
                <input type="submit" value="转到">
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    主题
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>自动</option>
        <option value="light">明亮</option>
        <option value="dark">黑暗</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#">Python 2.4 有什么新变化</a><ul>
<li><a class="reference internal" href="#pep-218-built-in-set-objects">PEP 218: 内置集合对象</a></li>
<li><a class="reference internal" href="#pep-237-unifying-long-integers-and-integers">PEP 237: 统一长整数和整数</a></li>
<li><a class="reference internal" href="#pep-289-generator-expressions">PEP 289: 生成器表达式</a></li>
<li><a class="reference internal" href="#pep-292-simpler-string-substitutions">PEP 292: 更简单的字符串替换</a></li>
<li><a class="reference internal" href="#pep-318-decorators-for-functions-and-methods">PEP 318: 函数和方法的装饰器</a></li>
<li><a class="reference internal" href="#pep-322-reverse-iteration">PEP 322: 反向迭代</a></li>
<li><a class="reference internal" href="#pep-324-new-subprocess-module">PEP 324: 新的子进程模块</a></li>
<li><a class="reference internal" href="#pep-327-decimal-data-type">PEP 327: 十进制数据类型</a><ul>
<li><a class="reference internal" href="#why-is-decimal-needed">为什么需要十进制？</a></li>
<li><a class="reference internal" href="#the-decimal-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code> 类型</a></li>
<li><a class="reference internal" href="#the-context-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code> 类型</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pep-328-multi-line-imports">PEP 328: 多行导入</a></li>
<li><a class="reference internal" href="#pep-331-locale-independent-float-string-conversions">PEP 331: 与区域设置无关的浮点数/字符串转换</a></li>
<li><a class="reference internal" href="#other-language-changes">其他语言特性修改</a><ul>
<li><a class="reference internal" href="#optimizations">性能优化</a></li>
</ul>
</li>
<li><a class="reference internal" href="#new-improved-and-deprecated-modules">新增，改进和弃用的模块</a><ul>
<li><a class="reference internal" href="#cookielib">cookielib</a></li>
<li><a class="reference internal" href="#doctest">doctest</a></li>
</ul>
</li>
<li><a class="reference internal" href="#build-and-c-api-changes">构建和 C API 的改变</a><ul>
<li><a class="reference internal" href="#port-specific-changes">移植专属的改变</a></li>
</ul>
</li>
<li><a class="reference internal" href="#porting-to-python-2-4">移植到 Python 2.4</a></li>
<li><a class="reference internal" href="#acknowledgements">致谢</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一主题</h4>
    <p class="topless"><a href="2.5.html"
                          title="上一章">Python 2.5 有什么新变化</a></p>
  </div>
  <div>
    <h4>下一主题</h4>
    <p class="topless"><a href="2.3.html"
                          title="下一章">Python 2.3 有什么新变化</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">报告代码错误</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/whatsnew/2.4.rst?plain=1"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="2.3.html" title="Python 2.3 有什么新变化"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="2.5.html" title="Python 2.5 有什么新变化"
             accesskey="P">上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.14.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python的新变化</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Python 2.4 有什么新变化</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q" id="search-box">
          <input type="submit" value="转到">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    主题
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>自动</option>
        <option value="light">明亮</option>
        <option value="dark">黑暗</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="what-s-new-in-python-2-4">
<h1 class="translated">Python 2.4 有什么新变化<a class="headerlink" href="#what-s-new-in-python-2-4" title="Link to this heading">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd translated">作者<span class="colon">:</span></dt>
<dd class="field-odd translated"><p class="translated">A.M. Kuchling</p>
</dd>
</dl>
<p class="translated">本文介绍了2005年3月30日发布的 Python 2.4.1 的新功能。</p>
<p class="translated">Python 2.4 是一个中等规模的发布版。 它引入的变化没有激进的 Python 2.2 那么多，但比保守的 2.3 发布版引入了更多的特性。 最主要的新语言特性是函数装饰器和生成器表达式；其他大部分改动都是针对标准库。</p>
<p class="translated">根据 CVS 变更日志，Python 2.3 和 2.4 之间共应用了 481 个补丁并修复了 502 个错误。 这两个数字可能都被低估了。</p>
<p class="translated">本文并不试图提供每一个新特性的完整规范说明，而是对每个特性进行简要的介绍。 要了解完整细节，你应该参考 Python 2.4 的文档，如 Python 库参考和 Python 参考手册等。 通常你需要参阅特定新特性的 PEP 以了解有关具体实现和设计原理的说明。</p>
<section id="pep-218-built-in-set-objects">
<h2 class="translated">PEP 218: 内置集合对象<a class="headerlink" href="#pep-218-built-in-set-objects" title="Link to this heading">¶</a></h2>
<p class="translated">Python 2.3 引入了 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sets</span></code> 模块。 现在集合数据类型的 C 语言实现作为两个新的内置类型 <code class="docutils literal notranslate"><span class="pre">set(iterable)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">frozenset(iterable)</span></code> 被添加到 Python 内核中。 它们为成员测试、消除序列中的重复数据以及并集、交集、差集和对称差集等数学运算提供了高速操作。</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="s1">&#39;abracadabra&#39;</span><span class="p">)</span>              <span class="c1"># 从字符串形成集合</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;z&#39;</span> <span class="ow">in</span> <span class="n">a</span>                            <span class="c1"># 快速成员测试</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>                                   <span class="c1"># a中的唯一字母</span>
<span class="go">set([&#39;a&#39;, &#39;r&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>                          <span class="c1"># 转换回字符串</span>
<span class="go">&#39;arbcd&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="s1">&#39;alacazam&#39;</span><span class="p">)</span>                 <span class="c1"># 形成第二个集合</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span>                               <span class="c1"># 在a中但不在b中的字母</span>
<span class="go">set([&#39;r&#39;, &#39;d&#39;, &#39;b&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">|</span> <span class="n">b</span>                               <span class="c1"># 在a或b中的字母</span>
<span class="go">set([&#39;a&#39;, &#39;c&#39;, &#39;r&#39;, &#39;d&#39;, &#39;b&#39;, &#39;m&#39;, &#39;z&#39;, &#39;l&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span>                               <span class="c1"># 在a和b中的字母</span>
<span class="go">set([&#39;a&#39;, &#39;c&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">^</span> <span class="n">b</span>                               <span class="c1"># 在a或b中但不在两者中的字母</span>
<span class="go">set([&#39;r&#39;, &#39;d&#39;, &#39;b&#39;, &#39;m&#39;, &#39;z&#39;, &#39;l&#39;])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>                          <span class="c1"># 添加新元素</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="s1">&#39;wxy&#39;</span><span class="p">)</span>                     <span class="c1"># 添加多个新元素</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">set([&#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;d&#39;, &#39;r&#39;, &#39;w&#39;, &#39;y&#39;, &#39;x&#39;, &#39;z&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>                       <span class="c1"># 移除一个元素</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">set([&#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;d&#39;, &#39;r&#39;, &#39;w&#39;, &#39;y&#39;, &#39;z&#39;])</span>
</pre></div>
</div>
<p class="translated"><a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-func docutils literal notranslate"><span class="pre">frozenset()</span></code></a> 类型是 <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-func docutils literal notranslate"><span class="pre">set()</span></code></a> 的不可变版本。 由于它是不可变且不可哈希的对象，因而可被用作字典的键或另一个集合的成员。</p>
<p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sets</span></code> 模块仍被保留在标准库中，如果你想要子类化 <code class="xref py py-class docutils literal notranslate"><span class="pre">Set</span></code> 或 <code class="xref py py-class docutils literal notranslate"><span class="pre">ImmutableSet</span></code> 类时会很有用处。 目前还没有弃用该模块的计划。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-37"></span><a class="pep reference external" href="https://peps.python.org/pep-0218/"><strong>PEP 218</strong></a> - 添加内置Set对象类型</dt><dd><p class="translated">最初由 Greg Wilson 提出，由 Raymond Hettinger 最终实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-237-unifying-long-integers-and-integers">
<h2 class="translated">PEP 237: 统一长整数和整数<a class="headerlink" href="#pep-237-unifying-long-integers-and-integers" title="Link to this heading">¶</a></h2>
<p class="translated">这个PEP的漫长过渡过程始于Python 2.2，在Python 2.4中又向前迈出了一步。在2.3中，某些在int/long统一后行为不同的整数操作会触发 <a class="reference internal" href="../library/exceptions.html#FutureWarning" title="FutureWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FutureWarning</span></code></a> 警告，并返回限于32位或64位（取决于您的平台）的值。在2.4中，这些表达式不再产生警告，而是产生一个通常为长整数的不同结果。</p>
<p class="translated">问题表达式主要是左移和长十六进制和八进制常量。例如，<code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">&lt;&lt;</span> <span class="pre">32</span></code> 在2.3中会引发警告，在32位平台上评估为0。在Python 2.4中，这个表达式现在返回正确答案，8589934592。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-38"></span><a class="pep reference external" href="https://peps.python.org/pep-0237/"><strong>PEP 237</strong></a> - 统一长整数和整数</dt><dd><p class="translated">原始PEP由 Moshe Zadka 和 GvR 撰写，2.4 的变更由 Kalle Svensson 实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-289-generator-expressions">
<h2 class="translated">PEP 289: 生成器表达式<a class="headerlink" href="#pep-289-generator-expressions" title="Link to this heading">¶</a></h2>
<p class="translated">Python 2.2中引入的迭代器特性和 <a class="reference internal" href="../library/itertools.html#module-itertools" title="itertools: Functions creating iterators for efficient looping."><code class="xref py py-mod docutils literal notranslate"><span class="pre">itertools</span></code></a> 模块使得编写循环遍历大数据集的程序变得更加容易，而无需将整个数据集一次性加载到内存中。列表推导式并不很适合这种场景，因为它们会产生一个包含所有项的Python列表对象。这不可避免地将所有对象拉入内存，如果数据集非常大，这可能会成为问题。当尝试编写函数式风格的程序时，自然会写出类似以下代码：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">links</span> <span class="o">=</span> <span class="p">[</span><span class="n">link</span> <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">get_all_links</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">link</span><span class="o">.</span><span class="n">followed</span><span class="p">]</span>
<span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated">代替：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">get_all_links</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">link</span><span class="o">.</span><span class="n">followed</span><span class="p">:</span>
        <span class="k">continue</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated">第一种形式更简洁，可能也更易读，但如果你正在处理大量的链接对象，为了避免同时将所有链接对象加载到内存中，你将不得不编写第二种形式。</p>
<p class="translated">生成器表达式的工作方式类似于列表推导式，但不生成整个列表；相反，它们创建一个生成器，逐个返回元素。上述示例可以改写为：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">links</span> <span class="o">=</span> <span class="p">(</span><span class="n">link</span> <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">get_all_links</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">link</span><span class="o">.</span><span class="n">followed</span><span class="p">)</span>
<span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated">生成器表达式必须像上述示例那样写在括号内。函数调用所用的括号也算在内，因此如果你想要创建一个将立即传递给函数的迭代器，可以写成：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span> <span class="nb">sum</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">count</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">list_all_objects</span><span class="p">())</span>
</pre></div>
</div>
<p class="translated">生成器表达式与列表推导式在各方面有细微的不同。最显著的是，循环变量（上述示例中的*obj*）在生成器表达式外部是不可访问的。列表推导式会将变量赋值为最后一个值；Python的未来版本将改变这一点，使列表推导式在这方面与生成器表达式一致。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-39"></span><a class="pep reference external" href="https://peps.python.org/pep-0289/"><strong>PEP 289</strong></a> - 生成器表达式</dt><dd><p class="translated">由Raymond Hettinger提出，Jiwon Seo实现，Hye-Shik Chang在早期进行了指导。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-292-simpler-string-substitutions">
<h2 class="translated">PEP 292: 更简单的字符串替换<a class="headerlink" href="#pep-292-simpler-string-substitutions" title="Link to this heading">¶</a></h2>
<p class="translated">标准库中的一些新类提供了将变量替换到字符串中的替代机制；这种替换风格可能更适合那些未经训练的用户需要编辑模板的应用程序。</p>
<p class="translated">按名称替换变量的常用方式是 <code class="docutils literal notranslate"><span class="pre">%</span></code> 运算符:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">%(page)i</span><span class="s1">: </span><span class="si">%(title)s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;page&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="s1">&#39;The Best of Times&#39;</span><span class="p">}</span>
<span class="go">&#39;2: The Best of Times&#39;</span>
</pre></div>
</div>
<p class="translated">在编写模板字符串时，很容易忘记在闭合括号后加上 <code class="docutils literal notranslate"><span class="pre">i</span></code> 或 <code class="docutils literal notranslate"><span class="pre">s</span></code>。如果模板在 Python 模块中，这并不是一个大问题，因为你可以运行代码，得到一个“不支持的格式字符” <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>，然后修复这个问题。然而，考虑像 Mailman 这样的应用程序，其中模板字符串或翻译是由不了解 Python 语言的用户编辑的。向这些用户解释格式字符串的语法是很复杂的，如果他们犯了错误，很难向他们提供有用的反馈。</p>
<p class="translated">PEP 292 给 <a class="reference internal" href="../library/string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code></a> 模块增加了一个 <code class="xref py py-class docutils literal notranslate"><span class="pre">Template</span></code>，它使用 <code class="docutils literal notranslate"><span class="pre">$</span></code> 来表示替换:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">string</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">Template</span><span class="p">(</span><span class="s1">&#39;$page: $title&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">substitute</span><span class="p">({</span><span class="s1">&#39;page&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="s1">&#39;The Best of Times&#39;</span><span class="p">})</span>
<span class="go">&#39;2: The Best of Times&#39;</span>
</pre></div>
</div>
<p class="translated">如果某个键在字典中找不到，<code class="xref py py-meth docutils literal notranslate"><span class="pre">substitute()</span></code> 方法将引发 <a class="reference internal" href="../library/exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a>。 还有一个 <code class="xref py py-meth docutils literal notranslate"><span class="pre">safe_substitute()</span></code> 方法则会忽略找不到的键:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">Template</span><span class="p">(</span><span class="s1">&#39;$page: $title&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">({</span><span class="s1">&#39;page&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">})</span>
<span class="go">&#39;3: $title&#39;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-40"></span><a class="pep reference external" href="https://peps.python.org/pep-0292/"><strong>PEP 292</strong></a> - 更简单的字符串替换</dt><dd><p class="translated">由 Barry Warsaw 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-318-decorators-for-functions-and-methods">
<h2 class="translated">PEP 318: 函数和方法的装饰器<a class="headerlink" href="#pep-318-decorators-for-functions-and-methods" title="Link to this heading">¶</a></h2>
<p class="translated">Python 2.2 通过添加静态方法和类方法扩展了 Python 的对象模型，但它并没有扩展 Python 的语法来提供任何定义静态方法或类方法的新方式。相反，你必须以通常的方式编写一个 <a class="reference internal" href="../reference/compound_stmts.html#def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">def</span></code></a> 语句，并将生成的函数传递给一个 <a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a> 或 <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a> 函数，该函数会将函数包装成新类型的方法。你的代码会像这样:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="p">:</span>
   <span class="k">def</span><span class="w"> </span><span class="nf">meth</span> <span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
       <span class="o">...</span>

   <span class="n">meth</span> <span class="o">=</span> <span class="nb">classmethod</span><span class="p">(</span><span class="n">meth</span><span class="p">)</span>   <span class="c1"># 将名称重新绑定到包装后的类方法</span>
</pre></div>
</div>
<p class="translated">如果方法非常长，很容易错过或忘记在函数体后调用 <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a>。</p>
<p class="translated">初衷一直是添加一些语法来使这样的定义更易读，但在 2.2 发布时，一个好的语法并不明显。今天，一个好的语法 <em>仍然</em> 不明显，但用户希望更方便地访问这个特性；为了满足这一需求，添加了一个新的语法特性。</p>
<p class="translated">这个新特性被称为“函数装饰器”。这个名字源于 <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">classmethod()</span></code></a>、<a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-func docutils literal notranslate"><span class="pre">staticmethod()</span></code></a> 及其同类函数在函数对象上存储额外信息的想法；它们在用更多细节 <em>装饰</em> 函数。</p>
<p class="translated">这种表示法借鉴了 Java，并使用 <code class="docutils literal notranslate"><span class="pre">'&#64;'</span></code> 字符作为指示符。使用新语法，上面的例子会写成:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="p">:</span>

   <span class="nd">@classmethod</span>
   <span class="k">def</span><span class="w"> </span><span class="nf">meth</span> <span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
       <span class="o">...</span>
</pre></div>
</div>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">&#64;classmethod</span></code> 是 <code class="docutils literal notranslate"><span class="pre">meth=classmethod(meth)</span></code> 赋值的简写。更一般地，如果你有以下代码：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@A</span>
<span class="nd">@B</span>
<span class="nd">@C</span>
<span class="k">def</span><span class="w"> </span><span class="nf">f</span> <span class="p">():</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated">它等价于以下无装饰器的代码:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">():</span> <span class="o">...</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="n">B</span><span class="p">(</span><span class="n">C</span><span class="p">(</span><span class="n">f</span><span class="p">)))</span>
</pre></div>
</div>
<p class="translated">装饰器必须放在函数定义的前一行，每行一个装饰器，不能与 def 语句在同一行，这意味着 <code class="docutils literal notranslate"><span class="pre">&#64;A</span> <span class="pre">def</span> <span class="pre">f():</span> <span class="pre">...</span></code> 是非法的。你只能装饰模块级别或类内部的函数定义；不能装饰类定义。</p>
<p class="translated">装饰器只是一个函数，它接受要装饰的函数作为参数，并返回相同的函数或某个新对象。装饰器的返回值不一定是可调用的（尽管通常是这样），除非将进一步应用装饰器到结果上。编写自己的装饰器很容易。以下简单示例只是在函数对象上设置一个属性：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">deco</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="gp">... </span>   <span class="n">func</span><span class="o">.</span><span class="n">attr</span> <span class="o">=</span> <span class="s1">&#39;decorated&#39;</span>
<span class="gp">... </span>   <span class="k">return</span> <span class="n">func</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@deco</span>
<span class="gp">... </span><span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">():</span> <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span>
<span class="go">&lt;function f at 0x402ef0d4&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">attr</span>
<span class="go">&#39;decorated&#39;</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">作为一个稍微更现实的例子，以下装饰器检查提供的参数是否为整数：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">require_int</span> <span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">wrapper</span> <span class="p">(</span><span class="n">arg</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper</span>

<span class="nd">@require_int</span>
<span class="k">def</span><span class="w"> </span><span class="nf">p1</span> <span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="nb">print</span> <span class="n">arg</span>

<span class="nd">@require_int</span>
<span class="k">def</span><span class="w"> </span><span class="nf">p2</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="nb">print</span> <span class="n">arg</span><span class="o">*</span><span class="mi">2</span>
</pre></div>
</div>
<p class="translated">在 <span class="target" id="index-41"></span><a class="pep reference external" href="https://peps.python.org/pep-0318/"><strong>PEP 318</strong></a> 中的一个示例包含了一个更复杂的版本，它允许你同时指定所需类型并检查返回类型。</p>
<p class="translated">装饰器函数可以接受参数。如果提供了参数，你的装饰器函数仅用这些参数调用，并且必须返回一个新的装饰器函数；这个函数必须接受单个函数并返回一个函数，如前所述。换句话说，<code class="docutils literal notranslate"><span class="pre">&#64;A</span> <span class="pre">&#64;B</span> <span class="pre">&#64;C(args)</span></code> 变为：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">():</span> <span class="o">...</span>
<span class="n">_deco</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="n">B</span><span class="p">(</span><span class="n">_deco</span><span class="p">(</span><span class="n">f</span><span class="p">)))</span>
</pre></div>
</div>
<p class="translated">理解这一点可能有点费脑筋，但并不太困难。</p>
<p class="translated">一个小相关的更改使得函数的 <a class="reference internal" href="../reference/datamodel.html#function.__name__" title="function.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">func_name</span></code></a> 属性可写。此属性用于在跟踪信息中显示函数名称，因此装饰器应更改任何新构造并返回的函数的名称。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-42"></span><a class="pep reference external" href="https://peps.python.org/pep-0318/"><strong>PEP 318</strong></a> - 函数、方法和类的装饰器</dt><dd><p class="translated">由 Kevin D. Smith、Jim Jewett 和 Skip Montanaro 编写。有几个人编写了实现函数装饰器的补丁，但实际被合并的是补丁 #979728，由 Mark Russell 编写。</p>
</dd>
<dt class="translated"><a class="reference external" href="https://wiki.python.org/moin/PythonDecoratorLibrary">https://wiki.python.org/moin/PythonDecoratorLibrary</a></dt><dd><p class="translated">该Wiki页面包含几个装饰器示例。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-322-reverse-iteration">
<h2 class="translated">PEP 322: 反向迭代<a class="headerlink" href="#pep-322-reverse-iteration" title="Link to this heading">¶</a></h2>
<p class="translated">一个新的内置函数 <code class="docutils literal notranslate"><span class="pre">reversed(seq)</span></code>，接受一个序列并返回一个以相反顺序遍历序列元素的迭代器。</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)):</span>
<span class="gp">... </span>   <span class="nb">print</span> <span class="n">i</span>
<span class="gp">...</span>
<span class="go">3</span>
<span class="go">2</span>
<span class="go">1</span>
</pre></div>
</div>
<p class="translated">与扩展切片（如 <code class="docutils literal notranslate"><span class="pre">range(1,4)[::-1]</span></code>）相比，<a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a> 更易读，运行更快，且显著减少内存使用。</p>
<p class="translated">请注意，<a class="reference internal" href="../library/functions.html#reversed" title="reversed"><code class="xref py py-func docutils literal notranslate"><span class="pre">reversed()</span></code></a> 只接受序列，不接受任意迭代器。如果你想反转一个迭代器，首先使用 <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-func docutils literal notranslate"><span class="pre">list()</span></code></a> 将其转换为列表。</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">input</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/etc/passwd&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">input</span><span class="p">)):</span>
<span class="gp">... </span>  <span class="nb">print</span> <span class="n">line</span>
<span class="gp">...</span>
<span class="go">root:*:0:0:System Administrator:/var/root:/bin/tcsh</span>
<span class="go">  ...</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-43"></span><a class="pep reference external" href="https://peps.python.org/pep-0322/"><strong>PEP 322</strong></a> - 反向迭代</dt><dd><p class="translated">由 Raymond Hettinger 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-324-new-subprocess-module">
<h2 class="translated">PEP 324: 新的子进程模块<a class="headerlink" href="#pep-324-new-subprocess-module" title="Link to this heading">¶</a></h2>
<p class="translated">标准库提供了多种执行子进程的方式，提供不同的功能和不同的复杂度。<code class="docutils literal notranslate"><span class="pre">os.system(command)</span></code> 使用简单，但速度慢（它运行一个 shell 进程来执行命令）且存在风险（你必须小心处理 shell 的元字符转义）。<code class="xref py py-mod docutils literal notranslate"><span class="pre">popen2</span></code> 模块提供可以捕获子进程标准输出和标准错误的类，但命名令人困惑。<a class="reference internal" href="../library/subprocess.html#module-subprocess" title="subprocess: Subprocess management."><code class="xref py py-mod docutils literal notranslate"><span class="pre">subprocess</span></code></a> 模块对此进行了清理，提供了一个统一的接口，提供了你可能需要的所有功能。</p>
<p class="translated">与 <code class="xref py py-mod docutils literal notranslate"><span class="pre">popen2</span></code> 的一系列类不同，<a class="reference internal" href="../library/subprocess.html#module-subprocess" title="subprocess: Subprocess management."><code class="xref py py-mod docutils literal notranslate"><span class="pre">subprocess</span></code></a> 包含一个名为 <a class="reference internal" href="../library/subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a> 的单一类，其构造函数支持多种不同的关键字参数。</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Popen</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">bufsize</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">executable</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">stdin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">preexec_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">close_fds</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">cwd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">universal_newlines</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">startupinfo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">creationflags</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
</pre></div>
</div>
<p class="translated"><em>args</em> 通常是一个字符串序列，用作子进程要执行的程序的参数。 (如果 <em>shell</em> 参数为真，<em>args</em> 可以是一个字符串，然后会传递给 shell 进行解释，就像 <a class="reference internal" href="../library/os.html#os.system" title="os.system"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.system()</span></code></a> 所做的那样。)</p>
<p class="translated"><em>stdin</em>、<em>stdout</em> 和 <em>stderr</em> 指定子进程的输入、输出和错误流将会是什么。 你可以提供一个文件对象或文件描述符，或者你可以使用常量 <code class="docutils literal notranslate"><span class="pre">subprocess.PIPE</span></code> 来在子进程和父进程之间创建一个管道。</p>
<p class="translated" id="index-7">此构造器有几个方便的选项:</p>
<ul class="simple">
<li><p class="translated"><em>close_fds</em> 将在运行子进程之前请求关闭所有文件描述符。</p></li>
<li><p class="translated"><em>cwd</em> 指定执行子进程将使用的工作目录（默认为父进程的工作目录）。</p></li>
<li><p class="translated"><em>env</em> 是一个指定环境变量的字典。</p></li>
<li><p class="translated"><em>preexec_fn</em> 是将在子进程启动之前被调用的函数。</p></li>
<li><p class="translated"><em>universal_newlines</em> 使用 Python 的 <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a> 特性打开子进程的输入和输出。</p></li>
</ul>
<p class="translated">一旦你创建了 <code class="xref py py-class docutils literal notranslate"><span class="pre">Popen</span></code> 实例，你可以调用它的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code> 方法来暂停直到子进程退出，<code class="xref py py-meth docutils literal notranslate"><span class="pre">poll()</span></code> 来检查它是否已退出而不暂停，或者 <code class="docutils literal notranslate"><span class="pre">communicate(data)</span></code> 来将字符串 <em>data</em> 发送到子进程的标准输入。 <code class="docutils literal notranslate"><span class="pre">communicate(data)</span></code> 然后读取子进程发送到其标准输出或标准错误的任何数据，返回一个元组 <code class="docutils literal notranslate"><span class="pre">(stdout_data,</span> <span class="pre">stderr_data)</span></code>。</p>
<p class="translated"><code class="xref py py-func docutils literal notranslate"><span class="pre">call()</span></code> 是一个快捷方式，它将其参数传递给 <code class="xref py py-class docutils literal notranslate"><span class="pre">Popen</span></code> 构造函数，等待命令完成，并返回子进程的状态码。 它可以作为 <a class="reference internal" href="../library/os.html#os.system" title="os.system"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.system()</span></code></a> 的更安全替代:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">sts</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">([</span><span class="s1">&#39;dpkg&#39;</span><span class="p">,</span> <span class="s1">&#39;-i&#39;</span><span class="p">,</span> <span class="s1">&#39;/tmp/new-package.deb&#39;</span><span class="p">])</span>
<span class="k">if</span> <span class="n">sts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="c1"># 成功</span>
    <span class="o">...</span>
<span class="k">else</span><span class="p">:</span>
    <span class="c1"># dpkg 返回错误</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated">命令在不使用 shell 的情况下被调用。 如果你确实想使用 shell，你可以添加 <code class="docutils literal notranslate"><span class="pre">shell=True</span></code> 作为关键字参数，并提供一个字符串而不是序列:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">sts</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="s1">&#39;dpkg -i /tmp/new-package.deb&#39;</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">PEP 提供了各种 shell 和 Python 代码示例，并展示了它们如何被翻译成使用 <a class="reference internal" href="../library/subprocess.html#module-subprocess" title="subprocess: Subprocess management."><code class="xref py py-mod docutils literal notranslate"><span class="pre">subprocess</span></code></a> 的 Python 代码。强烈建议阅读 PEP 的这一部分。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-44"></span><a class="pep reference external" href="https://peps.python.org/pep-0324/"><strong>PEP 324</strong></a> - 子进程 - 新的进程模块</dt><dd><p class="translated">由 Peter Åstrand 在 Fredrik Lundh 等人的协助下撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-327-decimal-data-type">
<h2 class="translated">PEP 327: 十进制数据类型<a class="headerlink" href="#pep-327-decimal-data-type" title="Link to this heading">¶</a></h2>
<p class="translated">Python 一直支持基于底层 C 语言 <span class="c-expr sig sig-inline c"><span class="kt">double</span></span> 类型的浮点数（FP）作为数据类型。然而，尽管大多数编程语言提供了浮点数类型，但许多人（甚至程序员）并不知道浮点数不能准确表示某些十进制分数。新的 <code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code> 类型可以准确表示这些分数，直至用户指定的精度限制。</p>
<section id="why-is-decimal-needed">
<h3 class="translated">为什么需要十进制？<a class="headerlink" href="#why-is-decimal-needed" title="Link to this heading">¶</a></h3>
<p class="translated">这些限制源于浮点数的表示方式。FP 数由三个部分组成：</p>
<ul class="simple">
<li><p class="translated">符号，可以是正或负。</p></li>
<li><p class="translated">尾数，是一个单数字的二进制数后跟一个小数部分。例如，二进制表示的 <code class="docutils literal notranslate"><span class="pre">1.01</span></code> 是 <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">0/2</span> <span class="pre">+</span> <span class="pre">1/4</span></code>，即十进制表示的 1.25。</p></li>
<li><p class="translated">指数，指示数字表示中十进制点的位置。</p></li>
</ul>
<p class="translated">例如，数字 1.25 具有正符号，尾数值为 1.01（二进制），指数为 0（十进制点不需要移动）。数字 5 具有相同的符号和尾数，但指数为 2，因为尾数乘以 4（2 的指数 2 次方）；1.25 * 4 等于 5。</p>
<p class="translated">现代系统通常提供符合IEEE 754标准的浮点支持。C语言的 <span class="c-expr sig sig-inline c"><span class="kt">double</span></span> 类型通常被实现为64位的IEEE 754数字，其中使用52位空间来存储尾数。这意味着数字只能精确到52位。如果你试图表示那些展开后会无限重复的数字，其展开会在52位后截断。不幸的是，大多数软件需要以十进制输出，而十进制中的常见分数在二进制中往往是无限循环小数。例如，十进制的1.1在二进制中是``1.0001100110011 ...``；0.1 = 1/16 + 1/32 + 1/256加上无限多个额外项。IEEE 754必须在52位后截断这个无限重复的小数，因此表示略有误差。</p>
<p class="translated">有时在打印数字时可以看到这种不准确性：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">1.1</span>
<span class="go">1.1000000000000001</span>
</pre></div>
</div>
<p class="translated">这种不准确性在打印数字时不总是可见，因为浮点数到十进制字符串的转换由C库提供，大多数C库会尝试生成合理的输出。即使没有显示出来，不准确性仍然存在，后续操作可能会放大这个误差。</p>
<p class="translated">对于许多应用来说，这并不重要。如果我在绘制点并在显示器上显示它们，1.1和1.1000000000000001之间的差异太小，无法察觉。报告通常限制输出到一定的小数位数，如果你将数字四舍五入到两位、三位甚至八位小数，误差永远不会显现。然而，对于确实重要的应用，实现自己的自定义算术例程是一项大量工作。</p>
<p class="translated">因此，创建了 <code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code> 类型。</p>
</section>
<section id="the-decimal-type">
<h3 class="translated"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code> 类型<a class="headerlink" href="#the-decimal-type" title="Link to this heading">¶</a></h3>
<p class="translated">Python标准库中添加了一个新模块 <a class="reference internal" href="../library/decimal.html#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic Specification."><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code></a> 。它包含两个类，<code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code> 和 <code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code>。<code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code> 实例表示数字，而 <code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code> 实例用于封装各种设置，例如精度和默认舍入模式。</p>
<p class="translated"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code> 实例是不可变的，就像常规的 Python 整数和浮点数一样；一旦创建，就无法更改实例所表示的值。<code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code> 实例可以从整数或字符串创建：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">decimal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1972</span><span class="p">)</span>
<span class="go">Decimal(&quot;1972&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="s2">&quot;1.1&quot;</span><span class="p">)</span>
<span class="go">Decimal(&quot;1.1&quot;)</span>
</pre></div>
</div>
<p class="translated">你也可以提供包含符号、以十进制数字元组表示的尾数和指数的元组：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span>
<span class="go">Decimal(&quot;-14.75&quot;)</span>
</pre></div>
</div>
<p class="translated">注意事项：符号位是一个布尔值，所以 0 表示正数，1 表示负数。</p>
<p class="translated">从浮点数转换会带来一些问题：表示 1.1 的浮点数应该转换为精确的 1.1 的十进制数，还是 1.1 加上引入的任何不准确度？决定是回避这个问题，不将此类转换包含在 API 中。相反，你应该将浮点数转换为字符串，使用所需的精度，并将字符串传递给 <code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code> 构造函数：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="mf">1.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
<span class="go">Decimal(&quot;1.1&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%.12f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">f</span><span class="p">)</span>
<span class="go">Decimal(&quot;1.100000000000&quot;)</span>
</pre></div>
</div>
<p class="translated">一旦你有了 <code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code> 实例，你可以在它们上执行常规的数学运算。一个限制：指数运算需要整数指数：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;35.72&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;1.73&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">+</span><span class="n">b</span>
<span class="go">Decimal(&quot;37.45&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">-</span><span class="n">b</span>
<span class="go">Decimal(&quot;33.99&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">*</span><span class="n">b</span>
<span class="go">Decimal(&quot;61.7956&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">/</span><span class="n">b</span>
<span class="go">Decimal(&quot;20.64739884393063583815028902&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">**</span> <span class="mi">2</span>
<span class="go">Decimal(&quot;1275.9184&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">**</span><span class="n">b</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">decimal.InvalidOperation</span>: <span class="n">x ** (非整数)</span>
</pre></div>
</div>
<p class="translated">你可以将 <code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code> 实例与整数组合，但不能与浮点数组合：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+</span> <span class="mi">4</span>
<span class="go">Decimal(&quot;39.72&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">+</span> <span class="mf">4.5</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">你只能用 int, long 或 Decimal 数据类型与 Decimal 交互。</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code> 数字可以与 <a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> 和 <a class="reference internal" href="../library/cmath.html#module-cmath" title="cmath: Mathematical functions for complex numbers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmath</span></code></a> 模块一起使用，但请注意，在进行操作之前，它们会立即转换为浮点数，这可能导致精度和准确性的损失。你也会得到一个普通的浮点数，而不是 <code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code>。</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">math</span><span class="o">,</span><span class="w"> </span><span class="nn">cmath</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;123456789012.345&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">351364.18288201344</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cmath</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">d</span><span class="p">)</span>
<span class="go">351364.18288201344j</span>
</pre></div>
</div>
<p class="translated"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code> 实例有一个 <code class="xref py py-meth docutils literal notranslate"><span class="pre">sqrt()</span></code> 方法，返回一个 <code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code>，但如果你需要其他函数，比如三角函数，你将不得不自己实现它们。</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>
<span class="go">Decimal(&quot;351364.1828820134592177245001&quot;)</span>
</pre></div>
</div>
</section>
<section id="the-context-type">
<h3 class="translated"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code> 类型<a class="headerlink" href="#the-context-type" title="Link to this heading">¶</a></h3>
<p class="translated"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code> 类的实例封装了小数操作的几种设置：</p>
<ul class="simple">
<li><p class="translated"><code class="xref py py-attr docutils literal notranslate"><span class="pre">prec</span></code> 是精度，即小数点后的位数。</p></li>
<li><p class="translated"><code class="xref py py-attr docutils literal notranslate"><span class="pre">rounding</span></code> 指定舍入模式。<a class="reference internal" href="../library/decimal.html#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic Specification."><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code></a> 模块为各种可能性提供了常量：<code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_DOWN</span></code>、<code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_CEILING</span></code>、<code class="xref py py-const docutils literal notranslate"><span class="pre">ROUND_HALF_EVEN</span></code> 以及其他几种。</p></li>
<li><p class="translated"><code class="xref py py-attr docutils literal notranslate"><span class="pre">traps</span></code> 是一个字典，指定在遇到某些错误条件时会发生什么：要么抛出异常，要么返回一个值。一些错误条件的例子包括除以零、精度损失和溢出。</p></li>
</ul>
<p class="translated">通过调用 <code class="xref py py-func docutils literal notranslate"><span class="pre">getcontext()</span></code> 可以获得线程本地的默认上下文；你可以更改此上下文的属性来改变默认的精度、舍入或错误处理。以下示例显示了更改默认上下文精度的效果:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">decimal</span><span class="o">.</span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span>
<span class="go">28</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal(&quot;0.1428571428571428571428571429&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decimal</span><span class="o">.</span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">Decimal(&quot;0.142857143&quot;)</span>
</pre></div>
</div>
<p class="translated">错误条件的默认行为是可选择的；模块可以返回特殊值，如无穷大或非数字，或者可以抛出异常:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">decimal.DivisionByZero</span>: <span class="n">x / 0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decimal</span><span class="o">.</span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">traps</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">DivisionByZero</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Decimal(&quot;Infinity&quot;)</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code> 实例还包含多种用于格式化数字的方法，例如 <code class="xref py py-meth docutils literal notranslate"><span class="pre">to_eng_string()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">to_sci_string()</span></code>。</p>
<p class="translated">更多信息请参阅 <a class="reference internal" href="../library/decimal.html#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic Specification."><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code></a> 模块的文档，其中包含快速入门教程和参考手册。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-45"></span><a class="pep reference external" href="https://peps.python.org/pep-0327/"><strong>PEP 327</strong></a> - 十进数据类型</dt><dd><p class="translated">由 Facundo Batista 撰写，由Facundo Batista, Eric Price, Raymond Hettinger, Aahz 和 Tim Peters 实现。</p>
</dd>
<dt class="translated"><a class="reference external" href="https://web.archive.org/web/20230604072523/http://www.lahey.com/float.htm">http://www.lahey.com/float.htm</a></dt><dd><p class="translated">该文章使用 Fortran 代码演示了浮点精度问题可能导致的许多问题。</p>
</dd>
<dt class="translated"><a class="reference external" href="https://speleotrove.com/decimal/">https://speleotrove.com/decimal/</a></dt><dd><p class="translated">描述了一种基于十进制的表示法。这种表示法已被提议作为标准，并且是新的 Python decimal 类型的基础。大部分内容由 Rexx 语言的设计者 Mike Cowlishaw 撰写。</p>
</dd>
</dl>
</div>
</section>
</section>
<section id="pep-328-multi-line-imports">
<h2 class="translated">PEP 328: 多行导入<a class="headerlink" href="#pep-328-multi-line-imports" title="Link to this heading">¶</a></h2>
<p class="translated">一个语言改动是针对从模块中导入多个名称的小语法调整。在 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">names</span></code> 语句中，<em>names</em> 是由逗号分隔的名称序列。如果序列非常长，您可以要么从同一模块多次导入，要么使用反斜杠转义行尾，如下所示:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">SimpleXMLRPCServer</span><span class="w"> </span><span class="kn">import</span> <span class="n">SimpleXMLRPCServer</span><span class="p">,</span>\
            <span class="n">SimpleXMLRPCRequestHandler</span><span class="p">,</span>\
            <span class="n">CGIXMLRPCRequestHandler</span><span class="p">,</span>\
            <span class="n">resolve_dotted_attribute</span>
</pre></div>
</div>
<p class="translated">Python 2.4 中的语法改动允许将名称放在括号内。Python 忽略括号表达式中的换行符，因此不再需要反斜杠:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">SimpleXMLRPCServer</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span><span class="n">SimpleXMLRPCServer</span><span class="p">,</span>
                                <span class="n">SimpleXMLRPCRequestHandler</span><span class="p">,</span>
                                <span class="n">CGIXMLRPCRequestHandler</span><span class="p">,</span>
                                <span class="n">resolve_dotted_attribute</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">PEP还提议所有 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句应为绝对导入，使用前导的 <code class="docutils literal notranslate"><span class="pre">.</span></code> 字符表示相对导入。这部分PEP在Python 2.4中未实现，但在Python 2.5中完成了。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-46"></span><a class="pep reference external" href="https://peps.python.org/pep-0328/"><strong>PEP 328</strong></a> - 导入：多行和绝对/相对导入</dt><dd><p class="translated">由 Aahz 撰写，多行导入由 Dima Dorfman 实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-331-locale-independent-float-string-conversions">
<h2 class="translated">PEP 331: 与区域设置无关的浮点数/字符串转换<a class="headerlink" href="#pep-331-locale-independent-float-string-conversions" title="Link to this heading">¶</a></h2>
<p class="translated"><a class="reference internal" href="../library/locale.html#module-locale" title="locale: Internationalization services."><code class="xref py py-mod docutils literal notranslate"><span class="pre">locale</span></code></a> 模块让Python软件选择针对特定国家或语言的多种转换和显示约定。然而，该模块小心翼翼地不更改数字区域设置，因为Python实现中的各种函数要求数字区域设置保持为 <code class="docutils literal notranslate"><span class="pre">'C'</span></code> 区域。这通常是因为代码使用了C库的 <code class="xref c c-func docutils literal notranslate"><span class="pre">atof()</span></code> 函数。</p>
<p class="translated">不设置数字区域设置给使用第三方C库的扩展带来了麻烦，因为它们不会有正确的区域设置。动机示例是GTK+，其用户界面小部件未在当前区域显示数字。</p>
<p class="translated">PEP中描述的解决方案是在Python API中添加三个新函数，执行仅ASCII的转换，忽略区域设置：</p>
<ul class="simple">
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">PyOS_ascii_strtod(str,</span> <span class="pre">ptr)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">PyOS_ascii_atof(str,</span> <span class="pre">ptr)</span></code> 都将字符串转换为C <span class="c-expr sig sig-inline c"><span class="kt">double</span></span>。</p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">PyOS_ascii_formatd(buffer,</span> <span class="pre">buf_len,</span> <span class="pre">format,</span> <span class="pre">d)</span></code> 将 <span class="c-expr sig sig-inline c"><span class="kt">double</span></span> 转换为ASCII字符串。</p></li>
</ul>
<p class="translated">这些函数的代码来自GLib库（<a class="reference external" href="http://web.archive.org/web/20210306104320/https://developer.gnome.org/glib/2.26/">https://developer-old.gnome.org/glib/2.26/</a>），其开发者友好地重新许可了相关函数并捐赠给Python软件基金会。<a class="reference internal" href="../library/locale.html#module-locale" title="locale: Internationalization services."><code class="xref py py-mod docutils literal notranslate"><span class="pre">locale</span></code></a> 模块现在可以更改数字区域设置，让诸如GTK+之类的扩展产生正确的结果。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-47"></span><a class="pep reference external" href="https://peps.python.org/pep-0331/"><strong>PEP 331</strong></a> - 与区域设置无关的浮点数/字符串转换</dt><dd><p class="translated">由Christian R. Reis撰写，由 Gustavo Carneiro 实现。</p>
</dd>
</dl>
</div>
</section>
<section id="other-language-changes">
<h2 class="translated">其他语言特性修改<a class="headerlink" href="#other-language-changes" title="Link to this heading">¶</a></h2>
<p class="translated">以下是 Python 2.4 针对核心 Python 语言的所有改变。</p>
<ul>
<li><p class="translated">增加了用于函数和方法的装饰器 (<span class="target" id="index-48"></span><a class="pep reference external" href="https://peps.python.org/pep-0318/"><strong>PEP 318</strong></a>)。</p></li>
<li><p class="translated">内置的 <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-func docutils literal notranslate"><span class="pre">set()</span></code></a> 和 <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-func docutils literal notranslate"><span class="pre">frozenset()</span></code></a> 类型被添加（<span class="target" id="index-49"></span><a class="pep reference external" href="https://peps.python.org/pep-0218/"><strong>PEP 218</strong></a>）。其他新内置函数包括 <code class="docutils literal notranslate"><span class="pre">reversed(seq)</span></code> 函数（<span class="target" id="index-50"></span><a class="pep reference external" href="https://peps.python.org/pep-0322/"><strong>PEP 322</strong></a>）。</p></li>
<li><p class="translated">增加了生成器表达式 (<span class="target" id="index-51"></span><a class="pep reference external" href="https://peps.python.org/pep-0289/"><strong>PEP 289</strong></a>)。</p></li>
<li><p class="translated">某些数值表达式不再返回限于32位或64位的结果 (<span class="target" id="index-52"></span><a class="pep reference external" href="https://peps.python.org/pep-0237/"><strong>PEP 237</strong></a>)。</p></li>
<li><p class="translated">现在可以在 <cite>from module import names</cite> 语句中的名称列表周围加上括号 (<span class="target" id="index-53"></span><a class="pep reference external" href="https://peps.python.org/pep-0328/"><strong>PEP 328</strong></a>)。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/stdtypes.html#dict.update" title="dict.update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.update()</span></code></a> 方法现在接受与 <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> 构造函数相同的参数形式。这包括任何映射、任何键/值对的迭代器以及关键字参数。（由 Raymond Hettinger 贡献。）</p></li>
<li><p class="translated">字符串方法 <code class="xref py py-meth docutils literal notranslate"><span class="pre">ljust()</span></code>、<code class="xref py py-meth docutils literal notranslate"><span class="pre">rjust()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">center()</span></code> 现在接受一个可选参数，用于指定除空格以外的填充字符。（由 Raymond Hettinger 贡献。）</p></li>
<li><p class="translated">字符串还增加了一个 <code class="xref py py-meth docutils literal notranslate"><span class="pre">rsplit()</span></code> 方法，其工作方式类似于 <code class="xref py py-meth docutils literal notranslate"><span class="pre">split()</span></code> 方法，但从字符串末尾开始分割。（由 Sean Reifschneider 贡献。）</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;www.python.org&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[&#39;www&#39;, &#39;python.org&#39;]</span>
<span class="go">&#39;www.python.org&#39;.rsplit(&#39;.&#39;, 1)</span>
<span class="go">[&#39;www.python&#39;, &#39;org&#39;]</span>
</pre></div>
</div>
</li>
<li><p class="translated">列表的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">sort()</span></code> 方法增加了三个关键字参数：<em>cmp</em>、<em>key</em> 和 <em>reverse</em>。这些参数使一些常见的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">sort()</span></code> 用法变得更简单。所有这些参数都是可选的。</p>
<p class="translated">对于 <em>cmp</em> 参数，其值应为一个比较函数，该函数接受两个参数，根据参数的比较结果返回 -1、0 或 +1。然后使用此函数对列表进行排序。以前这是唯一可以提供给 <code class="xref py py-meth docutils literal notranslate"><span class="pre">sort()</span></code> 的参数。</p>
<p class="translated"><em>key</em> 应该是一个单参数函数，该函数接受一个列表元素并返回该元素的比较键。然后使用比较键对列表进行排序。以下示例按不区分大小写的方式对列表进行排序:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>                 <span class="c1"># 区分大小写的排序</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span>
<span class="go">[&#39;A&#39;, &#39;D&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 使用 &#39;key&#39; 参数对列表进行排序</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span>
<span class="go">[&#39;A&#39;, &#39;b&#39;, &#39;c&#39;, &#39;D&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 旧式方法</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">cmp</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">cmp</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">lower</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span>
<span class="go">[&#39;A&#39;, &#39;b&#39;, &#39;c&#39;, &#39;D&#39;]</span>
</pre></div>
</div>
<p class="translated">最后一个示例使用了 <em>cmp</em> 参数，这是旧方法来进行不区分大小写的排序。它可以工作，但比使用 <em>key</em> 参数慢。使用 <em>key</em> 参数会对列表中的每个元素调用一次 <code class="xref py py-meth docutils literal notranslate"><span class="pre">lower()</span></code> 方法，而使用 <em>cmp</em> 参数则会在每次比较时调用两次，因此使用 <em>key</em> 参数可以减少对 <code class="xref py py-meth docutils literal notranslate"><span class="pre">lower()</span></code> 方法的调用。</p>
<p class="translated">对于简单的键函数和比较函数，通常可以通过使用未绑定方法来避免使用 <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> 表达式。例如，上述不区分大小写的排序最好写成：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="o">.</span><span class="n">lower</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span>
<span class="go">[&#39;A&#39;, &#39;b&#39;, &#39;c&#39;, &#39;D&#39;]</span>
</pre></div>
</div>
<p class="translated">最后，<em>reverse</em> 参数接受一个布尔值。如果值为真，列表将按逆序排序。现在你可以用 <code class="docutils literal notranslate"><span class="pre">L.sort(reverse=True)</span></code> 替代 <code class="docutils literal notranslate"><span class="pre">L.sort();</span> <span class="pre">L.reverse()</span></code>。</p>
<p class="translated">排序结果现在保证是稳定的。这意味着具有相同键的两个条目将按照它们输入的顺序返回。例如，你可以先按名字对人员列表进行排序，然后再按年龄排序，结果是一个按年龄排序的列表，其中同年龄的人员按名字排序。</p>
<p class="translated">（所有对 <code class="xref py py-meth docutils literal notranslate"><span class="pre">sort()</span></code> 方法的更改由 Raymond Hettinger 贡献。）</p>
</li>
<li><p class="translated">有一个新的内置函数 <code class="docutils literal notranslate"><span class="pre">sorted(iterable)</span></code>，它类似于原地 <a class="reference internal" href="../library/stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a> 方法，但可以在表达式中使用。区别在于：</p></li>
<li><p class="translated">输入可以是任意可迭代对象;</p></li>
<li><p class="translated">新生成的副本被排序，原始列表保持不变；以及</p></li>
<li><p class="translated">表达式返回新的已排序副本</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="mi">10</span><span class="o">+</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">L</span><span class="p">)]</span>       <span class="c1"># 可用于列表推导</span>
<span class="go">[11, 12, 13, 14, 15, 16, 17, 18, 19]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span>                               <span class="c1"># 原列表保持不变</span>
<span class="go">[9,7,8,3,2,4,1,6,5]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="s1">&#39;Monty Python&#39;</span><span class="p">)</span>          <span class="c1"># 任何可迭代对象都可以作为输入</span>
<span class="go">[&#39; &#39;, &#39;M&#39;, &#39;P&#39;, &#39;h&#39;, &#39;n&#39;, &#39;n&#39;, &#39;o&#39;, &#39;o&#39;, &#39;t&#39;, &#39;t&#39;, &#39;y&#39;, &#39;y&#39;]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 按键值排序并列出字典内容</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">colormap</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">red</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">blue</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">green</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">black</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">yellow</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">colormap</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()):</span>
<span class="gp">... </span>    <span class="nb">print</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span>
<span class="gp">...</span>
<span class="go">black 4</span>
<span class="go">blue 2</span>
<span class="go">green 3</span>
<span class="go">red 1</span>
<span class="go">yellow 5</span>
</pre></div>
</div>
<p class="translated">（由 Raymond Hettinger 贡献。）</p>
</li>
<li><p class="translated">整数运算将不再触发 <code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowWarning</span></code>。<code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowWarning</span></code> 警告将在 Python 2.5 中消失。</p></li>
<li><p class="translated">解释器新增了一个开关 <a class="reference internal" href="../using/cmdline.html#cmdoption-m"><code class="xref std std-option docutils literal notranslate"><span class="pre">-m</span></code></a>，它接受一个名称，在 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> 上搜索相应的模块，并将该模块作为脚本运行。例如，你现在可以使用 <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-m</span> <span class="pre">profile</span></code> 运行 Python 分析器。（由 Nick Coghlan 贡献。）</p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">eval(expr,</span> <span class="pre">globals,</span> <span class="pre">locals)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">execfile(filename,</span> <span class="pre">globals,</span> <span class="pre">locals)</span></code> 函数以及 <code class="docutils literal notranslate"><span class="pre">exec</span></code> 语句现在接受任何映射类型作为 <em>locals</em> 参数。以前这必须是一个普通的 Python 字典。（由 Raymond Hettinger 贡献。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/functions.html#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> 内置函数和 <code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.izip()</span></code> 现在在无参数调用时返回一个空列表。以前它们会引发 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 异常。这使得它们更适合用于可变长度参数列表:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">transpose</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
<span class="gp">... </span>   <span class="k">return</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">array</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transpose</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">)])</span>
<span class="go">[(1, 4), (2, 5), (3, 6)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transpose</span><span class="p">([])</span>
<span class="go">[]</span>
</pre></div>
</div>
<p class="translated">（由 Raymond Hettinger 贡献。）</p>
</li>
<li><p class="translated">在导入模块时遇到失败将不再在 <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code> 中留下部分初始化的模块对象。留下的不完整模块对象会导致后续导入同一模块时误以为成功，进而引发混淆的错误。（由 Tim Peters 修复。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 现在是一个常量；将一个新值绑定到名称 <code class="docutils literal notranslate"><span class="pre">None</span></code> 的代码现在会造成语法错误。 （由 Raymond Hettinger 贡献。）</p></li>
</ul>
<section id="optimizations">
<h3 class="translated">性能优化<a class="headerlink" href="#optimizations" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p class="translated">列表和元组切片的内部循环经过优化，现在运行速度大约提高了三分之一。字典的内部循环也进行了优化，使得 <code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code>、<code class="xref py py-meth docutils literal notranslate"><span class="pre">values()</span></code>、<code class="xref py py-meth docutils literal notranslate"><span class="pre">items()</span></code>、<code class="xref py py-meth docutils literal notranslate"><span class="pre">iterkeys()</span></code>、<code class="xref py py-meth docutils literal notranslate"><span class="pre">itervalues()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">iteritems()</span></code> 的性能得到提升。（由 Raymond Hettinger 贡献。）</p></li>
<li><p class="translated">用于列表增长和缩小的机制进行了速度和空间效率的优化。由于更高效的代码路径和更少地使用底层系统 <code class="xref c c-func docutils literal notranslate"><span class="pre">realloc()</span></code>，向列表追加和弹出元素现在运行得更快。列表推导也从中受益。<a class="reference internal" href="../library/stdtypes.html#list.extend" title="list.extend"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.extend()</span></code></a> 也进行了优化，不再将其参数转换为临时列表后再扩展基础列表。（由 Raymond Hettinger 贡献。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-func docutils literal notranslate"><span class="pre">list()</span></code></a>、<a class="reference internal" href="../library/stdtypes.html#tuple" title="tuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">tuple()</span></code></a>、<a class="reference internal" href="../library/functions.html#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a>、<a class="reference internal" href="../library/functions.html#filter" title="filter"><code class="xref py py-func docutils literal notranslate"><span class="pre">filter()</span></code></a> 和 <a class="reference internal" href="../library/functions.html#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> 在使用提供 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__len__()</span></code> 方法的非序列参数时，现在运行速度提高了数倍。（由 Raymond Hettinger 贡献。）</p></li>
<li><p class="translated"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.__getitem__()</span></code>、<code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.__getitem__()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">dict.__contains__()</span></code> 方法现在实现为 <code class="xref py py-class docutils literal notranslate"><span class="pre">method_descriptor</span></code> 对象，而不是 <code class="xref py py-class docutils literal notranslate"><span class="pre">wrapper_descriptor</span></code> 对象。这种访问形式使它们的性能翻倍，更适合作为函数式编程的参数使用：<code class="docutils literal notranslate"><span class="pre">map(mydict.__getitem__,</span> <span class="pre">keylist)</span></code>。（由 Raymond Hettinger 贡献。）</p></li>
<li><p class="translated">添加了一个新的操作码 <code class="docutils literal notranslate"><span class="pre">LIST_APPEND</span></code>，简化了列表推导生成的字节码，并使其速度提高了大约三分之一。（由 Raymond Hettinger 贡献。）</p></li>
<li><p class="translated">窥孔字节码优化器得到了改进，能够生成更短、更快的字节码；值得注意的是，生成的字节码更易读。（由 Raymond Hettinger 增强。）</p></li>
<li><p class="translated">在形式为 <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">s</span> <span class="pre">+</span> <span class="pre">&quot;abc&quot;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">+=</span> <span class="pre">&quot;abc&quot;</span></code> 的语句中，字符串连接现在在某些情况下会更高效地执行。这种优化不会出现在其他Python实现中，例如Jython，因此你不应依赖它；当你需要高效地连接大量字符串时，仍然推荐使用字符串的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code> 方法。（由Armin Rigo贡献。）</p></li>
</ul>
<p class="translated">2.4版本优化的净结果是，Python 2.4运行pystone基准测试比Python 2.3快约5%，比Python 2.2快35%。（pystone并不是一个特别好的基准测试，但它是衡量Python性能最常用的方法。你的应用程序可能从Python 2.4中获得更大或更小的收益。）</p>
</section>
</section>
<section id="new-improved-and-deprecated-modules">
<h2 class="translated">新增，改进和弃用的模块<a class="headerlink" href="#new-improved-and-deprecated-modules" title="Link to this heading">¶</a></h2>
<p class="translated">一如既往，Python的标准库获得了一些增强和错误修复。以下是一些最显著变化的部分列表，按模块名称字母顺序排序。请查阅源树中的 <code class="file docutils literal notranslate"><span class="pre">Misc/NEWS</span></code> 文件以获取更完整的变化列表，或通过CVS日志查看所有细节。</p>
<ul>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncore</span></code> 模块的 <code class="xref py py-func docutils literal notranslate"><span class="pre">loop()</span></code> 函数现在有一个 <em>count</em> 参数，允许你执行有限次数的轮询循环。默认情况下仍然是无限循环。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/base64.html#module-base64" title="base64: RFC 4648: Base16, Base32, Base64 Data Encodings; Base85 and Ascii85"><code class="xref py py-mod docutils literal notranslate"><span class="pre">base64</span></code></a> 模块现在更完整地支持 <span class="target" id="index-54"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3548.html"><strong>RFC 3548</strong></a> 中的Base64、Base32和Base16编码和解码，包括可选的大小写折叠和可选的替代字母表。（由Barry Warsaw贡献。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/bisect.html#module-bisect" title="bisect: Array bisection algorithms for binary searching."><code class="xref py py-mod docutils literal notranslate"><span class="pre">bisect</span></code></a> 模块现在有底层的C实现，以提升性能。（由Dmitry Vasiliev贡献。）</p></li>
<li><p class="translated">由 Hye-Shik Chang 维护的东亚编解码器的 CJKCodecs 集合已集成到 2.4 中。新的编码为：</p></li>
<li><p class="translated">汉语（大陆）: gb2312, gbk, gb18030, big5hkscs, hz</p></li>
<li><p class="translated">汉语（台湾）: big5, cp950</p></li>
<li><dl class="simple">
<dt class="translated">日语: cp932, euc-jis-2004, euc-jp, euc-jisx0213, iso-2022-jp,</dt><dd><p class="translated">iso-2022-jp-1, iso-2022-jp-2, iso-2022-jp-3, iso-2022-jp-ext, iso-2022-jp-2004,
shift-jis, shift-jisx0213, shift-jis-2004</p>
</dd>
</dl>
</li>
<li><p class="translated">韩语: cp949, euc-kr, johab, iso-2022-kr</p></li>
<li><p class="translated">添加了其他一些新的编码：HP Roman8、 ISO_8859-11、 ISO_8859-16、 PCTP-154 和 TIS-620。</p></li>
<li><p class="translated">UTF-8和UTF-16编解码器现在更好地处理接收部分输入的情况。以前，<code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code> 类会尝试读取更多数据，使得无法从流中恢复解码。<code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> 方法现在将返回尽可能多的数据，后续调用将从之前停止的地方恢复解码。（由Walter Dörwald实现。）</p></li>
<li><p class="translated">有一个新的 <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 模块，用于各种专业化的集合数据类型。目前它只包含一种类型，<code class="xref py py-class docutils literal notranslate"><span class="pre">deque</span></code>，这是一个双端队列，支持高效地从两端添加和移除元素:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(</span><span class="s1">&#39;ghi&#39;</span><span class="p">)</span>        <span class="c1"># 创建一个新的包含三个项目的 deque</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;j&#39;</span><span class="p">)</span>           <span class="c1"># 在右侧添加一个新的条目</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>       <span class="c1"># 在左侧添加一个新的条目</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>                       <span class="c1"># 显示 deque 的表示</span>
<span class="go">deque([&#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>                 <span class="c1"># 返回并移除最右侧的条目</span>
<span class="go">&#39;j&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>             <span class="c1"># 返回并移除最左侧的条目</span>
<span class="go">&#39;f&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>                 <span class="c1"># 列出 deque 的内容</span>
<span class="go">[&#39;g&#39;, &#39;h&#39;, &#39;i&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;h&#39;</span> <span class="ow">in</span> <span class="n">d</span>                <span class="c1"># 搜索 deque</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="translated">多个模块，如 <code class="xref py py-mod docutils literal notranslate"><span class="pre">Queue</span></code> 和 <a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> 模块，现在利用 <a class="reference internal" href="../library/collections.html#collections.deque" title="collections.deque"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.deque</span></code></a> 来提高性能。（由 Raymond Hettinger 贡献。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/configparser.html#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ConfigParser</span></code></a> 类略有增强。<a class="reference internal" href="../library/configparser.html#configparser.ConfigParser.read" title="configparser.ConfigParser.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a> 方法现在返回成功解析的文件列表，如果传递给 <a class="reference internal" href="../library/configparser.html#configparser.ConfigParser.set" title="configparser.ConfigParser.set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set()</span></code></a> 方法的 <em>value</em> 参数不是字符串，则会引发 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。（由 John Belmonte 和 David Goodger 贡献。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/curses.html#module-curses" title="curses: An interface to the curses library, providing portable terminal handling. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">curses</span></code></a> 模块现在支持 ncurses 扩展 <code class="xref py py-func docutils literal notranslate"><span class="pre">use_default_colors()</span></code>。在终端支持透明度的平台上，这使得使用透明背景成为可能。（由 Jörg Lehmann 贡献。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/difflib.html#module-difflib" title="difflib: Helpers for computing differences between objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">difflib</span></code></a> 模块现在包含一个 <code class="xref py py-class docutils literal notranslate"><span class="pre">HtmlDiff</span></code> 类，该类创建一个 HTML 表格，显示两个文本版本的并列比较。（由 Dan Gass 贡献。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code></a> 包已更新至 3.0 版本，该版本移除了多种已弃用的 API，并取消了对于 Python 2.3 之前版本的支持。3.0 版本的包使用了一个新的增量解析器来处理 MIME 消息，该解析器位于 <code class="xref py py-mod docutils literal notranslate"><span class="pre">email.FeedParser</span></code> 模块中。新解析器不需要将整个消息读入内存，且在消息格式不正确时不会抛出异常；相反，它会将任何问题记录在消息的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">defect</span></code> 属性中。（由 Anthony Baxter、Barry Warsaw、Thomas Wouters 等人开发。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/heapq.html#module-heapq" title="heapq: Heap queue algorithm (a.k.a. priority queue)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">heapq</span></code></a> 模块已被转换为 C 语言实现。由此带来的速度提升达十倍，使得该模块适合处理大量数据。此外，该模块新增了两个函数 <code class="xref py py-func docutils literal notranslate"><span class="pre">nlargest()</span></code> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">nsmallest()</span></code>，它们使用堆来查找数据集中的 N 个最大或最小值，而无需进行完整的排序。（由 Raymond Hettinger 贡献。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/http.html#module-http" title="http: HTTP status codes and messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">httplib</span></code></a> 模块现在包含了在多个与 HTTP 相关的 RFC 文档中定义的 HTTP 状态码常量。常量名称如 <code class="xref py py-const docutils literal notranslate"><span class="pre">OK</span></code>、<code class="xref py py-const docutils literal notranslate"><span class="pre">CREATED</span></code>、<code class="xref py py-const docutils literal notranslate"><span class="pre">CONTINUE</span></code> 和 <code class="xref py py-const docutils literal notranslate"><span class="pre">MOVED_PERMANENTLY</span></code>；使用 pydoc 可获取完整列表。（由 Andrew Eland 贡献。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/imaplib.html#module-imaplib" title="imaplib: IMAP4 protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">imaplib</span></code></a> 模块现在支持 IMAP 的 THREAD 命令（由 Yves Dionne 贡献）以及新的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">deleteacl()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">myrights()</span></code> 方法（由 Arnaud Mazin 贡献）。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/itertools.html#module-itertools" title="itertools: Functions creating iterators for efficient looping."><code class="xref py py-mod docutils literal notranslate"><span class="pre">itertools</span></code></a> 模块新增了 <code class="docutils literal notranslate"><span class="pre">groupby(iterable[,</span> <span class="pre">*func*])</span></code> 函数。<em>iterable</em> 是可以迭代以返回元素流的对象，可选的 <em>func</em> 参数是一个函数，它接受一个元素并返回一个键值；如果省略，键即为元素本身。<code class="xref py py-func docutils literal notranslate"><span class="pre">groupby()</span></code> 然后将元素分组为具有匹配键值的子序列，并返回一系列包含键值和子序列迭代器的 2 元组。</p>
<p class="translated">以下是一个示例，以便更清晰地说明这一点。<em>key</em> 函数 simply 返回一个数字是奇数还是偶数，因此 <code class="xref py py-func docutils literal notranslate"><span class="pre">groupby()</span></code> 的结果就是返回连续的奇数或偶数序列。:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">key_val</span><span class="p">,</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span><span class="p">):</span>
<span class="gp">... </span>   <span class="nb">print</span> <span class="n">key_val</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">0 [2, 4, 6]</span>
<span class="go">1 [7]</span>
<span class="go">0 [8]</span>
<span class="go">1 [9, 11]</span>
<span class="go">0 [12, 14]</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated"><code class="xref py py-func docutils literal notranslate"><span class="pre">groupby()</span></code> 通常用于处理已排序的输入。<code class="xref py py-func docutils literal notranslate"><span class="pre">groupby()</span></code> 的逻辑类似于 Unix 的 <code class="docutils literal notranslate"><span class="pre">uniq</span></code> 过滤器，这使得它非常适合用于消除、计数或识别重复元素:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">word</span> <span class="o">=</span> <span class="s1">&#39;abracadabra&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">letters</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>   <span class="c1"># 将字符串转换为按字母排序的列表</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">letters</span>
<span class="go">[&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;r&#39;, &#39;r&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">letters</span><span class="p">):</span>
<span class="gp">... </span>   <span class="nb">print</span> <span class="n">k</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">a [&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;]</span>
<span class="go">b [&#39;b&#39;, &#39;b&#39;]</span>
<span class="go">c [&#39;c&#39;]</span>
<span class="go">d [&#39;d&#39;]</span>
<span class="go">r [&#39;r&#39;, &#39;r&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 列出唯一字母</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">(</span><span class="n">letters</span><span class="p">)]</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;r&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 计算字母出现次数</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="p">)))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">(</span><span class="n">letters</span><span class="p">)]</span>
<span class="go">[(&#39;a&#39;, 5), (&#39;b&#39;, 2), (&#39;c&#39;, 1), (&#39;d&#39;, 1), (&#39;r&#39;, 2)]</span>
</pre></div>
</div>
<p class="translated">（由 Hye-Shik Chang 贡献。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/itertools.html#module-itertools" title="itertools: Functions creating iterators for efficient looping."><code class="xref py py-mod docutils literal notranslate"><span class="pre">itertools</span></code></a> 还增加了一个名为 <code class="docutils literal notranslate"><span class="pre">tee(iterator,</span> <span class="pre">N)</span></code> 的函数，它返回 <em>N</em> 个独立迭代器，这些迭代器复制 <em>iterator</em>。如果省略 <em>N</em>，默认值为 2。:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">tee</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i1</span><span class="p">,</span><span class="n">i2</span>
<span class="go">(&lt;itertools.tee object at 0x402c2080&gt;, &lt;itertools.tee object at 0x402c2090&gt;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">i1</span><span class="p">)</span>               <span class="c1"># 运行第一个迭代器直到耗尽</span>
<span class="go">[1, 2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">i2</span><span class="p">)</span>               <span class="c1"># 运行第二个迭代器直到耗尽</span>
<span class="go">[1, 2, 3]</span>
</pre></div>
</div>
<p class="translated">请注意，<code class="xref py py-func docutils literal notranslate"><span class="pre">tee()</span></code> 需要保留由迭代器返回的值的副本；在最坏的情况下，它可能需要保留所有这些值。因此，如果领先迭代器在长输入流中远远领先于滞后迭代器，应谨慎使用此功能。如果分离较大，那么您可能还不如使用 <a class="reference internal" href="../library/stdtypes.html#list" title="list"><code class="xref py py-func docutils literal notranslate"><span class="pre">list()</span></code></a>。当迭代器彼此紧密跟踪时，<code class="xref py py-func docutils literal notranslate"><span class="pre">tee()</span></code> 是理想的。可能的用例包括书签、窗口化或前瞻迭代器。（由 Raymond Hettinger 贡献。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/locale.html#module-locale" title="locale: Internationalization services."><code class="xref py py-mod docutils literal notranslate"><span class="pre">locale</span></code></a> 模块添加了一些函数，例如 <code class="xref py py-func docutils literal notranslate"><span class="pre">bind_textdomain_codeset()</span></code> 用于指定特定编码，以及一系列 <code class="xref py py-func docutils literal notranslate"><span class="pre">l*gettext()</span></code> 函数，这些函数返回所选编码中的消息。（由 Gustavo Niemeyer 贡献。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> 包的 <code class="xref py py-func docutils literal notranslate"><span class="pre">basicConfig()</span></code> 函数添加了一些关键字参数，以简化日志配置。默认行为是将消息记录到标准错误，但可以指定各种关键字参数以将日志记录到特定文件、更改日志格式或设置日志级别。例如：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;/var/log/application.log&#39;</span><span class="p">,</span>
    <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>  <span class="c1"># 记录所有消息</span>
    <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;%(levelname):%(process):%(thread):%(message)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated"><a class="reference internal" href="../library/logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> 包的其他添加内容包括一个 <code class="docutils literal notranslate"><span class="pre">log(level,</span> <span class="pre">msg)</span></code> 便捷方法，以及一个 <code class="xref py py-class docutils literal notranslate"><span class="pre">TimedRotatingFileHandler</span></code> 类，该类在定时间隔旋转其日志文件。模块已经有一个 <code class="xref py py-class docutils literal notranslate"><span class="pre">RotatingFileHandler</span></code>，它在文件超过特定大小时旋转日志。这两个类都派生自一个新的 <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseRotatingHandler</span></code> 类，该类可用于实现其他旋转处理程序。</p>
<p class="translated">（更改由 Vinay Sajip 实现。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">marshal</span></code></a> 模块现在在解包数据结构时共享内部字符串。这可能会缩小某些 pickle 字符串的大小，但主要效果是使 <code class="file docutils literal notranslate"><span class="pre">.pyc</span></code> 文件显著变小。（由 Martin von Löwis 贡献。）</p></li>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nntplib</span></code> 模块的 <code class="xref py py-class docutils literal notranslate"><span class="pre">NNTP</span></code> 类新增了 <code class="xref py py-meth docutils literal notranslate"><span class="pre">description()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">descriptions()</span></code> 方法，用于检索单个新闻组或一系列新闻组的描述。（由 Jürgen A. Erhard 贡献。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/operator.html#module-operator" title="operator: Functions corresponding to the standard operators."><code class="xref py py-mod docutils literal notranslate"><span class="pre">operator</span></code></a> 模块新增了两个函数，<code class="docutils literal notranslate"><span class="pre">attrgetter(attr)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">itemgetter(index)</span></code>。这两个函数都返回一个接受单个参数并返回相应属性或项的可调用对象；这些可调用对象在与 <a class="reference internal" href="../library/functions.html#map" title="map"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a> 或 <a class="reference internal" href="../library/functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a> 一起使用时，是非常优秀的数据提取器。例如：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">map</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">L</span><span class="p">)</span>
<span class="go">[&#39;c&#39;, &#39;d&#39;, &#39;a&#39;, &#39;b&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">map</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">L</span><span class="p">)</span>
<span class="go">[2, 1, 4, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># 按元组的第二个项对列表进行排序</span>
<span class="go">[(&#39;d&#39;, 1), (&#39;c&#39;, 2), (&#39;b&#39;, 3), (&#39;a&#39;, 4)]</span>
</pre></div>
</div>
<p class="translated">（由 Raymond Hettinger 贡献。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/optparse.html#module-optparse" title="optparse: Command-line option parsing library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">optparse</span></code></a> 模块进行了多项更新。该模块现在通过 <a class="reference internal" href="../library/gettext.html#gettext.gettext" title="gettext.gettext"><code class="xref py py-func docutils literal notranslate"><span class="pre">gettext.gettext()</span></code></a> 传递其消息，使得可以国际化 Optik 的帮助和错误消息。选项的帮助消息现在可以包含字符串 <code class="docutils literal notranslate"><span class="pre">'%default'</span></code>，该字符串将被选项的默认值替换。（由 Greg Ward 贡献。）</p></li>
<li><p class="translated">长期计划是在未来的某个 Python 版本中弃用 <code class="xref py py-mod docutils literal notranslate"><span class="pre">rfc822</span></code> 模块，转而使用 <a class="reference internal" href="../library/email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code></a> 包。为此，<a class="reference internal" href="../library/email.utils.html#email.utils.formatdate" title="email.utils.formatdate"><code class="xref py py-func docutils literal notranslate"><span class="pre">email.Utils.formatdate</span></code></a> 函数已被修改，使其可以作为 <code class="xref py py-func docutils literal notranslate"><span class="pre">rfc822.formatdate()</span></code> 的替代。您在编写新的电子邮件处理代码时可能需要考虑这一点。（由 Anthony Baxter 实施。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os</span></code></a> 模块新增了 <code class="docutils literal notranslate"><span class="pre">urandom(n)</span></code> 函数，返回一个包含 <em>n</em> 字节随机数据的字符串。该函数提供了对平台特定随机源（如 Linux 上的 <code class="file docutils literal notranslate"><span class="pre">/dev/urandom</span></code> 或 Windows CryptoAPI）的访问。（由 Trevor Perrin 贡献。）</p></li>
<li><p class="translated">另一个新函数：<code class="docutils literal notranslate"><span class="pre">os.path.lexists(path)</span></code> 如果指定的文件存在（无论是否为符号链接）则返回 true。这与现有的 <code class="docutils literal notranslate"><span class="pre">os.path.exists(path)</span></code> 函数不同，后者在 <em>path</em> 是指向不存在目标的符号链接时返回 false。（由 Beni Cherniavsky 贡献。）</p></li>
<li><p class="translated">在 <a class="reference internal" href="../library/os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os</span></code></a> 之下 <a class="reference internal" href="../library/posix.html#module-posix" title="posix: The most common POSIX system calls (normally used via module os). (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">posix</span></code></a> 模块中新增了一个 <code class="xref py py-func docutils literal notranslate"><span class="pre">getsid()</span></code> 函数。 （由 J. Raynor 贡献。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/poplib.html#module-poplib" title="poplib: POP3 protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">poplib</span></code></a> 模块现在已支持 SSL 上的 POP。 （由 Hector Urtubia 贡献。）</p></li>
<li><p class="translated">现在 <a class="reference internal" href="../library/profile.html#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a> 模块将可对 C 扩展函数执行性能分析。 （由 Nick Bastin 贡献。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/random.html#module-random" title="random: Generate pseudo-random numbers with various common distributions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">random</span></code></a> 模块有一个新方法 <code class="docutils literal notranslate"><span class="pre">getrandbits(N)</span></code>，返回一个长度为 <em>N</em> 位的长整数。现有的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">randrange()</span></code> 方法现在在适当的情况下使用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">getrandbits()</span></code>，使得生成任意大的随机数更加高效。（由 Raymond Hettinger 贡献。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 模块接受的正则表达式语言扩展了简单的条件表达式，写作 <code class="docutils literal notranslate"><span class="pre">(?(group)A|B)</span></code>。<em>group</em> 可以是数字组 ID 或用 <code class="docutils literal notranslate"><span class="pre">(?P&lt;group&gt;...)</span></code> 在表达式中提前定义的组名。如果指定的组匹配，正则表达式模式 <em>A</em> 将被用于测试字符串；如果组未匹配，则使用模式 <em>B</em>。（由 Gustavo Niemeyer 贡献。）</p></li>
<li><p class="translated">由于 Gustavo Niemeyer 大量工作，<a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 模块也不再是递归的。在递归正则表达式引擎中，某些模式会导致大量 C 栈空间被消耗，甚至可能溢出栈。例如，如果你将一个 30000 字节的 <code class="docutils literal notranslate"><span class="pre">a</span></code> 字符串与表达式 <code class="docutils literal notranslate"><span class="pre">(a|b)+</span></code> 匹配，每个字符会消耗一个栈帧。Python 2.3 试图检查栈溢出并抛出 <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> 异常，但某些模式可以绕过检查，如果你运气不好，Python 可能会段错误。Python 2.4 的正则表达式引擎可以无问题地匹配此模式。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/signal.html#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal notranslate"><span class="pre">signal</span></code></a> 模块现在对 <a class="reference internal" href="../library/signal.html#signal.signal" title="signal.signal"><code class="xref py py-func docutils literal notranslate"><span class="pre">signal.signal()</span></code></a> 函数的参数进行更严格的错误检查。例如，你不能在 <code class="xref py py-const docutils literal notranslate"><span class="pre">SIGKILL</span></code> 信号上设置处理程序；之前的 Python 版本会默默接受这一点，但 2.4 版本将引发一个 <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> 异常。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> 模块新增了两个函数。<code class="xref py py-func docutils literal notranslate"><span class="pre">socketpair()</span></code> 返回一对已连接的套接字，而 <code class="docutils literal notranslate"><span class="pre">getservbyport(port)</span></code> 用于查找给定端口号的服务名称。（由 Dave Cole 和 Barry Warsaw 贡献。）</p></li>
<li><p class="translated"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exitfunc()</span></code> 函数已被弃用。代码应使用现有的 <a class="reference internal" href="../library/atexit.html#module-atexit" title="atexit: Register and execute cleanup functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">atexit</span></code></a> 模块，它能正确处理调用多个退出函数。最终 <code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exitfunc()</span></code> 将成为一个纯内部接口，仅由 <a class="reference internal" href="../library/atexit.html#module-atexit" title="atexit: Register and execute cleanup functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">atexit</span></code></a> 访问。</p></li>
<li><p class="translated">现在 <a class="reference internal" href="../library/tarfile.html#module-tarfile" title="tarfile: Read and write tar-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tarfile</span></code></a> 模块默认将生成 GNU 格式的 tar 文件。 （由 Lars Gustäbel 贡献。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> 模块现在有了一种优雅简洁的方式来支持线程本地数据。该模块包含一个 <code class="xref py py-class docutils literal notranslate"><span class="pre">local</span></code> 类，其属性值对不同线程是本地的。:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">threading</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">local</span><span class="p">()</span>
<span class="n">data</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="mi">42</span>
<span class="n">data</span><span class="o">.</span><span class="n">url</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;www.python.org&#39;</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">其他线程可以为 <code class="xref py py-attr docutils literal notranslate"><span class="pre">number</span></code> 和 <code class="xref py py-attr docutils literal notranslate"><span class="pre">url</span></code> 属性分配和检索它们自己的值。你可以子类化 <code class="xref py py-class docutils literal notranslate"><span class="pre">local</span></code> 来初始化属性或添加方法。（由 Jim Fulton 贡献。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/timeit.html#module-timeit" title="timeit: Measure the execution time of small code snippets."><code class="xref py py-mod docutils literal notranslate"><span class="pre">timeit</span></code></a> 模块现在在计时循环中自动禁用周期性垃圾收集。这一改变使得连续计时更具可比性。（由 Raymond Hettinger 贡献。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/weakref.html#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal notranslate"><span class="pre">weakref</span></code></a> 模块现在支持更多种类的对象，包括 Python 函数、类实例、集合、冻结集合、双端队列、数组、文件、套接字和正则表达式模式对象。（由 Raymond Hettinger 贡献。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/xmlrpc.client.html#module-xmlrpc.client" title="xmlrpc.client: XML-RPC client access."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xmlrpclib</span></code></a> 模块现在支持多调用扩展，用于在单个 HTTP 操作中传输多个 XML-RPC 调用。（由 Brian Quinlan 贡献。）</p></li>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mpz</span></code>, <code class="xref py py-mod docutils literal notranslate"><span class="pre">rotor</span></code> 和 <code class="xref py py-mod docutils literal notranslate"><span class="pre">xreadlines</span></code> 模块已被移除。</p></li>
</ul>
<section id="cookielib">
<h3 class="translated">cookielib<a class="headerlink" href="#cookielib" title="Link to this heading">¶</a></h3>
<p class="translated"><a class="reference internal" href="../library/http.cookiejar.html#module-http.cookiejar" title="http.cookiejar: Classes for automatic handling of HTTP cookies."><code class="xref py py-mod docutils literal notranslate"><span class="pre">cookielib</span></code></a> 库支持客户端处理 HTTP Cookie，与 <a class="reference internal" href="../library/http.cookies.html#module-http.cookies" title="http.cookies: Support for HTTP state management (cookies)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">Cookie</span></code></a> 模块的服務器端 Cookie 支持相呼应。Cookie 存储在 Cookie 罐中；该库透明地将网页服务器提供的 Cookie 存储在 Cookie 罐中，并在连接到服务器时从罐中提取 Cookie。与网页浏览器一样，策略对象控制是否接受 Cookie。</p>
<p class="translated">为了跨会话存储 Cookie，提供了两种 Cookie 罐的实现：一种以 Netscape 格式存储 Cookie，以便应用程序可以使用 Mozilla 或 Lynx 的 Cookie 文件，另一种以与 Perl libwww 库相同的格式存储 Cookie。</p>
<p class="translated"><a class="reference internal" href="../library/urllib.request.html#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib2</span></code></a> 已更改以与 <a class="reference internal" href="../library/http.cookiejar.html#module-http.cookiejar" title="http.cookiejar: Classes for automatic handling of HTTP cookies."><code class="xref py py-mod docutils literal notranslate"><span class="pre">cookielib</span></code></a> 交互：<code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPCookieProcessor</span></code> 管理一个在访问 URL 时使用的 Cookie 罐。</p>
<p class="translated">该模块由  John J. Lee 贡献。</p>
</section>
<section id="doctest">
<h3 class="translated">doctest<a class="headerlink" href="#doctest" title="Link to this heading">¶</a></h3>
<p class="translated">由于 Edward Loper 和 Tim Peters 的贡献，<a class="reference internal" href="../library/doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> 模块进行了大量重构。测试仍然可以简单到只需运行 <a class="reference internal" href="../library/doctest.html#doctest.testmod" title="doctest.testmod"><code class="xref py py-func docutils literal notranslate"><span class="pre">doctest.testmod()</span></code></a>，但重构允许以各种方式自定义模块的操作。</p>
<p class="translated">新的 <code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestFinder</span></code> 类从给定对象的文档字符串中提取测试：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">f</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;&gt;&gt;&gt; f(2,2)</span>
<span class="sd">4</span>
<span class="sd">&gt;&gt;&gt; f(3,2)</span>
<span class="sd">6</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span>

<span class="n">finder</span> <span class="o">=</span> <span class="n">doctest</span><span class="o">.</span><span class="n">DocTestFinder</span><span class="p">()</span>

<span class="c1"># 获取 DocTest 实例列表</span>
<span class="n">tests</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">新的 <code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestRunner</span></code> 类然后运行单个测试并可以生成结果摘要：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">runner</span> <span class="o">=</span> <span class="n">doctest</span><span class="o">.</span><span class="n">DocTestRunner</span><span class="p">()</span>
<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tests</span><span class="p">:</span>
    <span class="n">tried</span><span class="p">,</span> <span class="n">failed</span> <span class="o">=</span> <span class="n">runner</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

<span class="n">runner</span><span class="o">.</span><span class="n">summarize</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">上述示例生成以下输出：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span> <span class="n">items</span> <span class="n">passed</span> <span class="nb">all</span> <span class="n">tests</span><span class="p">:</span>
   <span class="mi">2</span> <span class="n">tests</span> <span class="ow">in</span> <span class="n">f</span>
<span class="mi">2</span> <span class="n">tests</span> <span class="ow">in</span> <span class="mi">1</span> <span class="n">items</span><span class="o">.</span>
<span class="mi">2</span> <span class="n">passed</span> <span class="ow">and</span> <span class="mi">0</span> <span class="n">failed</span><span class="o">.</span>
<span class="n">Test</span> <span class="n">passed</span><span class="o">.</span>
</pre></div>
</div>
<p class="translated"><code class="xref py py-class docutils literal notranslate"><span class="pre">DocTestRunner</span></code> 使用一个 <code class="xref py py-class docutils literal notranslate"><span class="pre">OutputChecker</span></code> 类的实例来比较预期输出和实际输出。这个类接受多个不同的标志来定制其行为；有野心的用户也可以编写一个全新的 <code class="xref py py-class docutils literal notranslate"><span class="pre">OutputChecker</span></code> 子类。</p>
<p class="translated">默认的输出检查器提供了一些方便的功能。例如，使用 <a class="reference internal" href="../library/doctest.html#doctest.ELLIPSIS" title="doctest.ELLIPSIS"><code class="xref py py-const docutils literal notranslate"><span class="pre">doctest.ELLIPSIS</span></code></a> 选项标志，预期输出中的省略号（<code class="docutils literal notranslate"><span class="pre">...</span></code>）可以匹配任何子字符串，这使得更容易适应在细小方面有所变化的输出:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">o</span> <span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;&gt;&gt;&gt; o(1)</span>
<span class="sd">&lt;__main__.C instance at 0x...&gt;</span>
<span class="sd">&gt;&gt;&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p class="translated">另一个特殊字符串，<code class="docutils literal notranslate"><span class="pre">&lt;BLANKLINE&gt;</span></code>, 匹配一个空行:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">p</span> <span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;&gt;&gt;&gt; p(1)</span>
<span class="sd">&lt;BLANKLINE&gt;</span>
<span class="sd">&gt;&gt;&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p class="translated">另一个新功能是通过指定 <a class="reference internal" href="../library/doctest.html#doctest.REPORT_UDIFF" title="doctest.REPORT_UDIFF"><code class="xref py py-const docutils literal notranslate"><span class="pre">doctest.REPORT_UDIFF</span></code></a> (统一差异) 、<a class="reference internal" href="../library/doctest.html#doctest.REPORT_CDIFF" title="doctest.REPORT_CDIFF"><code class="xref py py-const docutils literal notranslate"><span class="pre">doctest.REPORT_CDIFF</span></code></a> (上下文差异) 或 <a class="reference internal" href="../library/doctest.html#doctest.REPORT_NDIFF" title="doctest.REPORT_NDIFF"><code class="xref py py-const docutils literal notranslate"><span class="pre">doctest.REPORT_NDIFF</span></code></a> (增量式差异) 选项标志，生成输出差异风格的显示。例如:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">g</span> <span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;&gt;&gt;&gt; g(4)</span>
<span class="sd">here</span>
<span class="sd">is</span>
<span class="sd">a</span>
<span class="sd">lengthy</span>
<span class="sd">&gt;&gt;&gt;&quot;&quot;&quot;</span>
    <span class="n">L</span> <span class="o">=</span> <span class="s1">&#39;here is a rather lengthy list of words&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">L</span><span class="p">[:</span><span class="n">n</span><span class="p">]:</span>
        <span class="nb">print</span> <span class="n">word</span>
</pre></div>
</div>
<p class="translated">在指定 <a class="reference internal" href="../library/doctest.html#doctest.REPORT_UDIFF" title="doctest.REPORT_UDIFF"><code class="xref py py-const docutils literal notranslate"><span class="pre">doctest.REPORT_UDIFF</span></code></a> 的情况下运行上述函数的测试，你会得到以下输出：</p>
<div class="translated highlight-none notranslate"><div class="highlight"><pre><span></span>**********************************************************************
File &quot;t.py&quot;, line 15, in g
Failed example:
    g(4)
Differences (unified diff with -expected +actual):
    @@ -2,3 +2,3 @@
     is
     a
    -lengthy
    +rather
**********************************************************************
</pre></div>
</div>
</section>
</section>
<section id="build-and-c-api-changes">
<h2 class="translated">构建和 C API 的改变<a class="headerlink" href="#build-and-c-api-changes" title="Link to this heading">¶</a></h2>
<p class="translated">对于 Python 构建过程和 C API 的一些修改:</p>
<ul class="simple">
<li><p class="translated">为常见扩展函数返回值添加了三个新的便利宏：<a class="reference internal" href="../c-api/none.html#c.Py_RETURN_NONE" title="Py_RETURN_NONE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_RETURN_NONE</span></code></a>、<a class="reference internal" href="../c-api/bool.html#c.Py_RETURN_TRUE" title="Py_RETURN_TRUE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_RETURN_TRUE</span></code></a> 和 <a class="reference internal" href="../c-api/bool.html#c.Py_RETURN_FALSE" title="Py_RETURN_FALSE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_RETURN_FALSE</span></code></a>。（由 Brett Cannon 贡献。）</p></li>
<li><p class="translated">另一个新宏，<a class="reference internal" href="../c-api/refcounting.html#c.Py_CLEAR" title="Py_CLEAR"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_CLEAR</span></code></a>，减少 <em>obj</em> 的引用计数并将 <em>obj</em> 设置为空指针。（由 Jim Fulton 贡献。)</p></li>
<li><p class="translated">一个新的函数 <code class="docutils literal notranslate"><span class="pre">PyTuple_Pack(N,</span> <span class="pre">obj1,</span> <span class="pre">obj2,</span> <span class="pre">...,</span> <span class="pre">objN)</span></code>，可以从一个可变长度的Python对象参数列表中构造元组。（由Raymond Hettinger贡献。）</p></li>
<li><p class="translated">一个新的函数 <code class="docutils literal notranslate"><span class="pre">PyDict_Contains(d,</span> <span class="pre">k)</span></code>，实现了快速的字典查找，而不会掩盖查找过程中引发的异常。（由Raymond Hettinger贡献。）</p></li>
<li><p class="translated">宏 <span class="c-expr sig sig-inline c"><a class="reference internal" href="../c-api/float.html#c.Py_IS_NAN" title="Py_IS_NAN"><span class="n">Py_IS_NAN</span></a><span class="p">(</span><span class="n">X</span><span class="p">)</span></span> 如果其浮点或双精度参数 <em>X</em> 是NaN，则返回1。（由Tim Peters贡献。）</p></li>
<li><p class="translated">C代码可以通过使用新的 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_ThreadsInitialized()</span></code> 函数来避免不必要的锁定，以判断是否进行了任何线程操作。如果此函数返回false，则不需要锁定操作。（由Nick Coghlan贡献。）</p></li>
<li><p class="translated">一个新的函数 <a class="reference internal" href="../c-api/arg.html#c.PyArg_VaParseTupleAndKeywords" title="PyArg_VaParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_VaParseTupleAndKeywords()</span></code></a>，与 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTupleAndKeywords" title="PyArg_ParseTupleAndKeywords"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTupleAndKeywords()</span></code></a> 相同，但接受一个 <code class="xref c c-type docutils literal notranslate"><span class="pre">va_list</span></code> 而不是参数数量。（由Greg Chapman贡献。）</p></li>
<li><p class="translated">一个新的方法标志 <a class="reference internal" href="../c-api/structures.html#c.METH_COEXIST" title="METH_COEXIST"><code class="xref c c-macro docutils literal notranslate"><span class="pre">METH_COEXIST</span></code></a>，允许在槽中定义的函数与具有相同名称的 <a class="reference internal" href="../c-api/structures.html#c.PyCFunction" title="PyCFunction"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyCFunction</span></code></a> 共存。这可以将诸如 <code class="xref py py-meth docutils literal notranslate"><span class="pre">set.__contains__()</span></code> 这样的方法的访问时间减半。（由Raymond Hettinger贡献。）</p></li>
<li><p class="translated">Python现在可以内置对解释器本身的额外分析功能，旨在帮助开发Python核心的人员。向 <strong class="program">configure</strong> 脚本提供 <code class="xref std std-option docutils literal notranslate"><span class="pre">--enable-profiling</span></code> 选项将允许您使用 <strong class="program">gprof</strong> 对解释器进行分析，提供 <code class="xref std std-option docutils literal notranslate"><span class="pre">--with-tsc</span></code> 开关则启用使用Pentium的时间戳计数器寄存器进行分析。请注意，<code class="xref std std-option docutils literal notranslate"><span class="pre">--with-tsc</span></code> 开关命名略有不当，因为该分析功能在PowerPC平台上也能工作，尽管该处理器架构不将该寄存器称为“TSC寄存器”。（由Jeremy Hylton贡献。）</p></li>
<li><p class="translated"><code class="xref c c-type docutils literal notranslate"><span class="pre">tracebackobject</span></code> 类型已被重命名为 <code class="xref c c-type docutils literal notranslate"><span class="pre">PyTracebackObject</span></code>。</p></li>
</ul>
<section id="port-specific-changes">
<h3 class="translated">移植专属的改变<a class="headerlink" href="#port-specific-changes" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p class="translated">Windows端口现在可以在MSVC++ 7.1以及版本6下构建。（由Martin von Löwis贡献。）</p></li>
</ul>
</section>
</section>
<section id="porting-to-python-2-4">
<h2 class="translated">移植到 Python 2.4<a class="headerlink" href="#porting-to-python-2-4" title="Link to this heading">¶</a></h2>
<p class="translated">本节列出了先前描述的可能需要修改你的代码的改变：</p>
<ul class="simple">
<li><p class="translated">左移操作和过大的十六进制/八进制常量不再触发 <a class="reference internal" href="../library/exceptions.html#FutureWarning" title="FutureWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FutureWarning</span></code></a>，并且返回一个限制在32或64位的值；相反，它们返回一个长整数。</p></li>
<li><p class="translated">整数运算将不再触发 <code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowWarning</span></code>。<code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowWarning</span></code> 警告将在 Python 2.5 中消失。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/functions.html#zip" title="zip"><code class="xref py py-func docutils literal notranslate"><span class="pre">zip()</span></code></a> 内置函数和 <code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.izip()</span></code> 现在在无参数调用时返回一个空列表，而不是抛出 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 异常。</p></li>
<li><p class="translated">您不能再比较由 <a class="reference internal" href="../library/datetime.html#module-datetime" title="datetime: Basic date and time types."><code class="xref py py-mod docutils literal notranslate"><span class="pre">datetime</span></code></a> 模块提供的 <code class="xref py py-class docutils literal notranslate"><span class="pre">date</span></code> 和 <a class="reference internal" href="../library/datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime</span></code></a> 实例。不同类的两个实例现在将始终不相等，并且相对比较（<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>，<code class="docutils literal notranslate"><span class="pre">&gt;</span></code>）将抛出 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p></li>
<li><p class="translated"><code class="xref py py-func docutils literal notranslate"><span class="pre">dircache.listdir()</span></code> 现在将异常传递给调用者，而不是返回空列表。</p></li>
<li><p class="translated"><code class="xref py py-func docutils literal notranslate"><span class="pre">LexicalHandler.startDTD()</span></code> 过去接收公共和系统 ID 的顺序错误。这已被纠正；依赖错误顺序的应用程序需要修复。</p></li>
<li><p class="translated">现在 <a class="reference internal" href="../library/fcntl.html#fcntl.ioctl" title="fcntl.ioctl"><code class="xref py py-func docutils literal notranslate"><span class="pre">fcntl.ioctl()</span></code></a> 会在 <em>mutate</em> 参数被省略并且将造成影响时发出警告。</p></li>
<li><p class="translated">现在 <a class="reference internal" href="../library/tarfile.html#module-tarfile" title="tarfile: Read and write tar-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tarfile</span></code></a> 模块默认将生成 GNU 格式的 tar 文件。</p></li>
<li><p class="translated">在导入模块时遭遇失败不会再将部分初始化的模块对象留在 <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code> 中。</p></li>
<li><p class="translated">现在 <a class="reference internal" href="../library/constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> 是一个常量；将一个新值绑定到 <code class="docutils literal notranslate"><span class="pre">None</span></code> 将导致语法错误。</p></li>
<li><p class="translated">现在对于某些非法的值 <code class="xref py py-func docutils literal notranslate"><span class="pre">signals.signal()</span></code> 函数将引发 <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> 异常；在之前版本中这些错误会静默地放过。 例如，你将不能在 <code class="xref py py-const docutils literal notranslate"><span class="pre">SIGKILL</span></code> 信号上设置处理器。</p></li>
</ul>
</section>
<section id="acknowledgements">
<span id="acks"></span><h2 class="translated">致谢<a class="headerlink" href="#acknowledgements" title="Link to this heading">¶</a></h2>
<p class="translated">作者感谢以下人员对本文各种草稿给予的建议、更正和协助：Koray Can、Hye-Shik Chang、Michael Dyck、Raymond Hettinger、Brian Hurt、Hamish Lawson、Fredrik Lundh、Sean Reifschneider、Sadruddin Rejeb。</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#">Python 2.4 有什么新变化</a><ul>
<li><a class="reference internal" href="#pep-218-built-in-set-objects">PEP 218: 内置集合对象</a></li>
<li><a class="reference internal" href="#pep-237-unifying-long-integers-and-integers">PEP 237: 统一长整数和整数</a></li>
<li><a class="reference internal" href="#pep-289-generator-expressions">PEP 289: 生成器表达式</a></li>
<li><a class="reference internal" href="#pep-292-simpler-string-substitutions">PEP 292: 更简单的字符串替换</a></li>
<li><a class="reference internal" href="#pep-318-decorators-for-functions-and-methods">PEP 318: 函数和方法的装饰器</a></li>
<li><a class="reference internal" href="#pep-322-reverse-iteration">PEP 322: 反向迭代</a></li>
<li><a class="reference internal" href="#pep-324-new-subprocess-module">PEP 324: 新的子进程模块</a></li>
<li><a class="reference internal" href="#pep-327-decimal-data-type">PEP 327: 十进制数据类型</a><ul>
<li><a class="reference internal" href="#why-is-decimal-needed">为什么需要十进制？</a></li>
<li><a class="reference internal" href="#the-decimal-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code> 类型</a></li>
<li><a class="reference internal" href="#the-context-type"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code> 类型</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pep-328-multi-line-imports">PEP 328: 多行导入</a></li>
<li><a class="reference internal" href="#pep-331-locale-independent-float-string-conversions">PEP 331: 与区域设置无关的浮点数/字符串转换</a></li>
<li><a class="reference internal" href="#other-language-changes">其他语言特性修改</a><ul>
<li><a class="reference internal" href="#optimizations">性能优化</a></li>
</ul>
</li>
<li><a class="reference internal" href="#new-improved-and-deprecated-modules">新增，改进和弃用的模块</a><ul>
<li><a class="reference internal" href="#cookielib">cookielib</a></li>
<li><a class="reference internal" href="#doctest">doctest</a></li>
</ul>
</li>
<li><a class="reference internal" href="#build-and-c-api-changes">构建和 C API 的改变</a><ul>
<li><a class="reference internal" href="#port-specific-changes">移植专属的改变</a></li>
</ul>
</li>
<li><a class="reference internal" href="#porting-to-python-2-4">移植到 Python 2.4</a></li>
<li><a class="reference internal" href="#acknowledgements">致谢</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一主题</h4>
    <p class="topless"><a href="2.5.html"
                          title="上一章">Python 2.5 有什么新变化</a></p>
  </div>
  <div>
    <h4>下一主题</h4>
    <p class="topless"><a href="2.3.html"
                          title="下一章">Python 2.3 有什么新变化</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">报告代码错误</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/whatsnew/2.4.rst?plain=1"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="折叠边栏">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="2.3.html" title="Python 2.3 有什么新变化"
             >下一页</a> |</li>
        <li class="right" >
          <a href="2.5.html" title="Python 2.5 有什么新变化"
             >上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.14.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python的新变化</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Python 2.4 有什么新变化</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q" id="search-box">
          <input type="submit" value="转到">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    主题
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>自动</option>
        <option value="light">明亮</option>
        <option value="dark">黑暗</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版权</a> 2001 Python Software Foundation.
    <br>
    本页面采用 Python 软件基金会许可证第 2 版授权。
    <br>
    文档中的示例、代码片段及其他代码内容额外采用零条款 BSD 许可证授权。
    <br>
    
      更多信息请参阅《<a href="/license.html"> 历史与许可 </a>》。<br>
    
    
    <br>

    Python 软件基金会是一家非营利性公司。
<a href="https://www.python.org/psf/donations/">请进行捐赠。</a>
<br>
    <br>
      最后更新于11月 25, 2025 (07:24 UTC) 。
    
      <a href="/bugs.html">发现了错误</a>？
    
    <br>

    使用<a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3 创建。
    </div>

  </body>
</html>
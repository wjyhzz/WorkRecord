<!DOCTYPE html>

<html lang="zh-CN" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="Python 2.7 有什么新变化" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/whatsnew/2.7.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="作者, A.M. Kuchling (amk at amk.ca),. 本文介绍了Python 2.7 的新功能。 Python 2.7 于2010年7月3日发布。 数字处理在许多方面得到了改进，包括浮点数和 Decimal 类。标准库中有一些有用的补充，例如大大增强的 unittest 模块，用于解析命令行选项的 argparse 模块，在 collections 模块中方便的 Order..." />
<meta property="og:image:width" content="1146" />
<meta property="og:image:height" content="600" />
<meta property="og:image" content="https://docs.python.org/3.14/zh-cn/_images/social_previews/summary_whatsnew_2.7_3299bd73.png" />
<meta property="og:image:alt" content="作者, A.M. Kuchling (amk at amk.ca),. 本文介绍了Python 2.7 的新功能。 Python 2.7 于2010年7月3日发布。 数字处理在许多方面得到了改进，包括浮点数和 Decimal 类。标准库中有一些有用的补充，例如大大增强的 unittest 模块，用于解析命令行选项的 argparse 模块，在 collections 模块中方便的 Order..." />
<meta name="description" content="作者, A.M. Kuchling (amk at amk.ca),. 本文介绍了Python 2.7 的新功能。 Python 2.7 于2010年7月3日发布。 数字处理在许多方面得到了改进，包括浮点数和 Decimal 类。标准库中有一些有用的补充，例如大大增强的 unittest 模块，用于解析命令行选项的 argparse 模块，在 collections 模块中方便的 Order..." />
<meta name="twitter:card" content="summary_large_image" />
<meta name="theme-color" content="#3776ab">

    <title>Python 2.7 有什么新变化 &#8212; Python 3.14.0 文档</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=234b1a7c" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=8cd84f99" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=5349f25f" />
    
    <script src="../_static/documentation_options.js?v=a595ec0e"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=beaddf03"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.14.0 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于此文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权" href="../copyright.html" />
    <link rel="next" title="Python 2.6 有什么新变化" href="2.6.html" />
    <link rel="prev" title="Python 3.0 有什么新变化" href="3.0.html" />
    
      
      <script defer file-types="bz2,epub,zip" data-domain="docs.python.org" src="https://analytics.python.org/js/script.file-downloads.outbound-links.js"></script>
      
      <link rel="canonical" href="https://docs.python.org/3/whatsnew/2.7.html">
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg">
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="菜单">
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo">
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q">
                <input type="submit" value="转到">
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    主题
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>自动</option>
        <option value="light">明亮</option>
        <option value="dark">黑暗</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#">Python 2.7 有什么新变化</a><ul>
<li><a class="reference internal" href="#the-future-for-python-2-x">Python 2.x的未来</a></li>
<li><a class="reference internal" href="#changes-to-the-handling-of-deprecation-warnings">对于弃用警告处理方式的改变</a></li>
<li><a class="reference internal" href="#python-3-1-features">Python 3.1 特性</a></li>
<li><a class="reference internal" href="#pep-372-adding-an-ordered-dictionary-to-collections">PEP 372：将有序字典 添加到收藏集</a></li>
<li><a class="reference internal" href="#pep-378-format-specifier-for-thousands-separator">PEP 378: 千位分隔符的格式说明符</a></li>
<li><a class="reference internal" href="#pep-389-the-argparse-module-for-parsing-command-lines">PEP 389：用于解析命令行的 argparse 模块</a></li>
<li><a class="reference internal" href="#pep-391-dictionary-based-configuration-for-logging">PEP 391: 基于字典的日志配置</a></li>
<li><a class="reference internal" href="#pep-3106-dictionary-views">PEP 3106: 字典视图</a></li>
<li><a class="reference internal" href="#pep-3137-the-memoryview-object">PEP 3137: memoryview 对象</a></li>
<li><a class="reference internal" href="#other-language-changes">其他语言特性修改</a><ul>
<li><a class="reference internal" href="#interpreter-changes">解释器改动</a></li>
<li><a class="reference internal" href="#optimizations">性能优化</a></li>
</ul>
</li>
<li><a class="reference internal" href="#new-and-improved-modules">新增和改进的模块</a><ul>
<li><a class="reference internal" href="#new-module-importlib">新增模块：importlib</a></li>
<li><a class="reference internal" href="#new-module-sysconfig">新增模块：sysconfig</a></li>
<li><a class="reference internal" href="#ttk-themed-widgets-for-tk">ttk：Tk 主题组件</a></li>
<li><a class="reference internal" href="#updated-module-unittest">更新的模块：unittest</a></li>
<li><a class="reference internal" href="#updated-module-elementtree-1-3">更新的模块：ElementTree 1.3</a></li>
</ul>
</li>
<li><a class="reference internal" href="#build-and-c-api-changes">构建和 C API 的变更</a><ul>
<li><a class="reference internal" href="#capsules">Capsule 对象</a></li>
<li><a class="reference internal" href="#port-specific-changes-windows">特定于 Windows 的更改：</a></li>
<li><a class="reference internal" href="#port-specific-changes-mac-os-x">特定于 Mac OS X 的更改：</a></li>
<li><a class="reference internal" href="#port-specific-changes-freebsd">特定于 FreeBSD 的更改：</a></li>
</ul>
</li>
<li><a class="reference internal" href="#other-changes-and-fixes">其他的变更和修正</a></li>
<li><a class="reference internal" href="#porting-to-python-2-7">移植到 Python 2.7</a></li>
<li><a class="reference internal" href="#new-features-added-to-python-2-7-maintenance-releases">Python 2.7 维护版本中添加的新特性</a><ul>
<li><a class="reference internal" href="#two-new-environment-variables-for-debug-mode">调试模式的两个新环境变量</a></li>
<li><a class="reference internal" href="#pep-434-idle-enhancement-exception-for-all-branches">PEP 434：针对所有分支的 IDLE 增强功能豁免提案</a></li>
<li><a class="reference internal" href="#pep-466-network-security-enhancements-for-python-2-7">PEP 466: 针对 Python 2.7 的网络安全加固</a></li>
<li><a class="reference internal" href="#pep-477-backport-ensurepip-pep-453-to-python-2-7">PEP 477: 将 ensurepip (PEP 453) 向下移植到 Python 2.7</a><ul>
<li><a class="reference internal" href="#bootstrapping-pip-by-default">默认对 pip 进行初始配置</a></li>
<li><a class="reference internal" href="#documentation-changes">文档更改</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pep-476-enabling-certificate-verification-by-default-for-stdlib-http-clients">PEP 476: 默认为 stdlib http 客户端启用证书验证</a></li>
<li><a class="reference internal" href="#pep-493-https-verification-migration-tools-for-python-2-7">PEP 493：适用于Python 2.7 的 HTTPS 验证迁移工具</a></li>
<li><a class="reference internal" href="#new-make-regen-all-build-target">新增 <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">regen-all</span></code> 构建目标</a></li>
<li><a class="reference internal" href="#removal-of-make-touch-build-target">移除了 <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">touch</span></code> 构建目标</a></li>
</ul>
</li>
<li><a class="reference internal" href="#acknowledgements">致谢</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一主题</h4>
    <p class="topless"><a href="3.0.html"
                          title="上一章">Python 3.0 有什么新变化</a></p>
  </div>
  <div>
    <h4>下一主题</h4>
    <p class="topless"><a href="2.6.html"
                          title="下一章">Python 2.6 有什么新变化</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">报告代码错误</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/whatsnew/2.7.rst?plain=1"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="2.6.html" title="Python 2.6 有什么新变化"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="3.0.html" title="Python 3.0 有什么新变化"
             accesskey="P">上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.14.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python的新变化</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Python 2.7 有什么新变化</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q" id="search-box">
          <input type="submit" value="转到">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    主题
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>自动</option>
        <option value="light">明亮</option>
        <option value="dark">黑暗</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="what-s-new-in-python-2-7">
<h1 class="translated">Python 2.7 有什么新变化<a class="headerlink" href="#what-s-new-in-python-2-7" title="Link to this heading">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd translated">作者<span class="colon">:</span></dt>
<dd class="field-odd translated"><p class="translated">A.M. Kuchling (amk at amk.ca)</p>
</dd>
</dl>
<p class="translated">本文介绍了Python 2.7 的新功能。 Python 2.7 于2010年7月3日发布。</p>
<p class="translated">数字处理在许多方面得到了改进，包括浮点数和 <a class="reference internal" href="../library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 类。标准库中有一些有用的补充，例如大大增强的 <a class="reference internal" href="../library/unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 模块，用于解析命令行选项的 <a class="reference internal" href="../library/argparse.html#module-argparse" title="argparse: Command-line option and argument parsing library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">argparse</span></code></a> 模块，在 <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 模块中方便的 <a class="reference internal" href="../library/collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">OrderedDict</span></code></a> 和 <a class="reference internal" href="../library/collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Counter</span></code></a> 类，以及许多其他改进。</p>
<p class="translated">Python 2.7计划成为2.x版本的最后一个发布版本，因此我们努力使其成为长期支持的好版本。为了帮助迁移到Python 3，我们在2.7中包含了几个来自Python 3.x系列的新特性。</p>
<p class="translated">本文并不试图提供新特性的完整规范说明，而是提供一个方便的概览。要了解完整的细节，请参阅Python 2.7的文档。如果你想了解有关设计和实现的具体考量，请参阅特定新特性的PEP或在https://bugs.python.org上讨论更改的问题。在可能的情况下，“What's New in Python”链接到每个更改的错误修正/补丁项。</p>
<section id="the-future-for-python-2-x">
<span id="whatsnew27-python31"></span><h2 class="translated">Python 2.x的未来<a class="headerlink" href="#the-future-for-python-2-x" title="Link to this heading">¶</a></h2>
<p class="translated">Python 2.7 是 2.x 系列中的最后一个主版本，因为Python 维护人员已将新功能开发工作的重点转移到了 Python 3.x 系列中。这意味着，尽管 Python 2 会继续修复bug并更新，以便在新的硬件和支持操作系统版本上正确构建，但不会有新的功能发布。</p>
<p class="translated">然而，尽管在 Python 2.7 和 Python 3 之间有一个很大的公共子集，并且迁移到该公共子集或直接迁移到 Python 3 所涉及的许多更改可以安全地自动化完成。但是一些其他更改（特别是那些与Unicode处理相关的更改）可能需要仔细考虑，并且最好用自动化回归测试套件进行健壮性测试，以便有效地迁移。</p>
<p class="translated">这意味着 Python2.7 将长期保留，为尚未移植到 Python 3 的生产系统提供一个稳定且受支持的基础平台。Python 2.7系列的预期完整生命周期在 <span class="target" id="index-52"></span><a class="pep reference external" href="https://peps.python.org/pep-0373/"><strong>PEP 373</strong></a> 中有详细介绍。</p>
<p class="translated">长期保留 2.7 版的的一些关键后果：</p>
<ul class="simple">
<li><p class="translated">如上所述，与早期的2.x版本相比，2.7版本的维护时间更长。目前，预计核心开发团队将继续支持Python 2.7（接收安全更新和其他错误修复），直到至少2020年（首次发布后10年，相比之下，通常的支持期为18--24个月）。</p></li>
<li><p class="translated">随着 Python 2.7 标准库的老化，有效地利用 Python 包索引（直接或通过重新分发者）对 Python 2 用户来说变得更加重要。除了各种任务的第三方包之外，可用的包还包括与 Python 2 兼容的 Python 3 标准库中的新模块和功能的后端移植，以及各种工具和库，这些工具和库可以让用户更容易迁移到 Python 3。 <a class="reference external" href="https://packaging.python.org">Python 包用户指南</a> 提供了从 Python 包索引的下载和安装软件的指导。</p></li>
<li><p class="translated">虽然现在增强 Python 2 的首选方法是在Python包索引上发布新包，但这种方法不一定适用于所有情况，尤其是与网络安全相关的情况。在一些特殊情况下，如果在PyPI上发布新的或更新的包无法得到充分的处理，则可以使用Python增强建议过程来提出直接在Python 2标准库中添加新功能。任何此类添加及其添加的维护版本将在下面的 <a class="reference internal" href="#py27-maintenance-enhancements"><span class="std std-ref">Python 2.7 维护版本中添加的新特性</span></a> 部分中注明。</p></li>
</ul>
<p class="translated">对于希望从 Python2 迁移到 Python3 的项目，或者对于希望同时支持 Python2 和 Python3 用户的库和框架开发人员，可以使用各种工具和指南来帮助决定合适的方法并管理所涉及的一些技术细节。建议从 <a class="reference internal" href="../howto/pyporting.html#pyporting-howto"><span class="std std-ref">如何将 Python 2 代码移植到 Python 3</span></a> 操作指南开始。</p>
</section>
<section id="changes-to-the-handling-of-deprecation-warnings">
<h2 class="translated">对于弃用警告处理方式的改变<a class="headerlink" href="#changes-to-the-handling-of-deprecation-warnings" title="Link to this heading">¶</a></h2>
<p class="translated">对于 Python 2.7，一个策略决定是默认情况下禁止只对开发人员有兴趣的警告。 现在，除非另有要求，否则将忽略 <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a> 及其子类，以防止用户看到应用程序触发的警告。 这个更改也在成为Python 3.2 的分歧点上进行了。 （在 stdlib-sig 上进行了讨论，并在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7319">bpo-7319</a> 中执行。）</p>
<p class="translated">在以前的版本中，默认情况下启用了 <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a> 消息，为 Python 开发人员提供了一个明确的指示，说明他们的代码可能在未来的 Python 主要版本中出现问题。</p>
<p class="translated">然而，越来越多基于 Python 的应用程序的用户并不直接参与这些应用程序的开发。 <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a> 消息与这些用户无关，这让他们担心应用能否真正正常工作，并让应用开发人员承担起回应这些担忧的负担。</p>
<p class="translated">显示通过使用 <a class="reference internal" href="../using/cmdline.html#cmdoption-W"><code class="xref std std-option docutils literal notranslate"><span class="pre">-Wdefault</span></code></a> (简写: <a class="reference internal" href="../using/cmdline.html#cmdoption-W"><code class="xref std std-option docutils literal notranslate"><span class="pre">-Wd</span></code></a>) 开关运行 Python，或者在运行 Python 之前将 <span class="target" id="index-53"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONWARNINGS"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONWARNINGS</span></code></a> 环境变量设置为 <code class="docutils literal notranslate"><span class="pre">&quot;default&quot;</span></code> (或 <code class="docutils literal notranslate"><span class="pre">&quot;d&quot;</span></code>)，可以重新启用 <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a> 消息。 Python 代码也可以通过调用 <code class="docutils literal notranslate"><span class="pre">warnings.simplefilter('default')</span></code> 重新启用它们。</p>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">unittest</span></code> 模块还会在运行测试时自动重新启用弃用警告。</p>
</section>
<section id="python-3-1-features">
<h2 class="translated">Python 3.1 特性<a class="headerlink" href="#python-3-1-features" title="Link to this heading">¶</a></h2>
<p class="translated">就像 Python2.6 集成了 Python3.0 的特性一样，2.7版也集成了 Python3.1 中的一些新特性。2.x 系列继续提供迁移到3.x系列的工具。</p>
<p class="translated">3.1 功能的部分列表，这些功能已反向移植到 2.7：</p>
<ul class="simple">
<li><p class="translated">用于集合字面值的语法 (<code class="docutils literal notranslate"><span class="pre">{1,2,3}</span></code> 是一个可变集合)。</p></li>
<li><p class="translated">字典与集合推导式 (<code class="docutils literal notranslate"><span class="pre">{i:</span> <span class="pre">i*2</span> <span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">range(3)}</span></code>)。</p></li>
<li><p class="translated">单个 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 语句中使用多个上下文管理器。</p></li>
<li><p class="translated">一个 <a class="reference internal" href="../library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a> 库的新版本，用 C 重写以提升性能。</p></li>
<li><p class="translated"><a class="reference internal" href="#pep-0372"><span class="std std-ref">PEP 372：将有序字典 添加到收藏集</span></a> 所描述的有序字典类型。</p></li>
<li><p class="translated"><a class="reference internal" href="#pep-0378"><span class="std std-ref">PEP 378: 千位分隔符的格式说明符</span></a> 所描述的新的 <code class="docutils literal notranslate"><span class="pre">&quot;,&quot;</span></code> 格式说明符。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> 对象。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a> 模块的一个较小子集，<a class="reference external" href="#importlib-section">described below</a>。</p></li>
<li><p class="translated">在很多情况下，浮点数 <code class="docutils literal notranslate"><span class="pre">x</span></code> 的 <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 更短：现在它基于最短的十进制字符串 ，保证四舍五入到 <code class="docutils literal notranslate"><span class="pre">x</span></code>。  与 Python 以前的版本一样，保证 <code class="docutils literal notranslate"><span class="pre">float(repr(x))</span></code> 能恢复到 <code class="docutils literal notranslate"><span class="pre">x</span></code>。</p></li>
<li><p class="translated">浮点数到字符串和字符串到浮点数的转换已正确舍入。 <a class="reference internal" href="../library/functions.html#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a> 函数现在也能正确舍入。</p></li>
<li><p class="translated"><a class="reference internal" href="../c-api/capsule.html#c.PyCapsule" title="PyCapsule"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyCapsule</span></code></a> 类型，用于为扩展模块提供 C API 。</p></li>
<li><p class="translated"><a class="reference internal" href="../c-api/long.html#c.PyLong_AsLongAndOverflow" title="PyLong_AsLongAndOverflow"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyLong_AsLongAndOverflow()</span></code></a> C API 函数 。</p></li>
</ul>
<p class="translated">其他新的 Python3 模式警告包括：</p>
<ul class="simple">
<li><p class="translated"><code class="xref py py-func docutils literal notranslate"><span class="pre">operator.isCallable()</span></code> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">operator.sequenceIncludes()</span></code> 在 3.x 中不支持，现在会触发警告。</p></li>
<li><p class="translated"><code class="xref std std-option docutils literal notranslate"><span class="pre">-3</span></code> 开关现在会自动启用 <code class="xref std std-option docutils literal notranslate"><span class="pre">-Qwarn</span></code> 开关，该开关会在使用经典整除法处理整数和长整数时发出警告。</p></li>
</ul>
</section>
<section id="pep-372-adding-an-ordered-dictionary-to-collections">
<span id="pep-0372"></span><h2 class="translated">PEP 372：将有序字典 添加到收藏集<a class="headerlink" href="#pep-372-adding-an-ordered-dictionary-to-collections" title="Link to this heading">¶</a></h2>
<p class="translated">常规 Python 字典以任意顺序遍历键/值对。 多年来，许多作者编写了替代实现，以记住键最初插入的顺序。 基于这些实现的经验，2.7 在 <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 模块中引入了一个新的 <a class="reference internal" href="../library/collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">OrderedDict</span></code></a> 类。</p>
<p class="translated"><a class="reference internal" href="../library/collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">OrderedDict</span></code></a> API 提供与普通字典相同的接口 ，但会根据键首次插入的时间，按一定顺序遍历键和值：：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span>                 <span class="p">(</span><span class="s1">&#39;second&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
<span class="gp">... </span>                 <span class="p">(</span><span class="s1">&#39;third&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
<span class="go">[(&#39;first&#39;, 1), (&#39;second&#39;, 2), (&#39;third&#39;, 3)]</span>
</pre></div>
</div>
<p class="translated">如果新条目覆盖了现有条目，则原插入位置保持不变</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;second&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
<span class="go">[(&#39;first&#39;, 1), (&#39;second&#39;, 4), (&#39;third&#39;, 3)]</span>
</pre></div>
</div>
<p class="translated">删除条目并重新插入会将其移至末尾</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;second&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;second&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
<span class="go">[(&#39;first&#39;, 1), (&#39;third&#39;, 3), (&#39;second&#39;, 5)]</span>
</pre></div>
</div>
<p class="translated"><a class="reference internal" href="../library/collections.html#collections.OrderedDict.popitem" title="collections.OrderedDict.popitem"><code class="xref py py-meth docutils literal notranslate"><span class="pre">popitem()</span></code></a> 方法有一个可选 <em>last</em> 参数 ，默认为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 。如果 <em>last</em> 为 true ，则返回并删除最近添加的密钥；如果为 false ，则选择最旧的密钥:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">od</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">od</span><span class="o">.</span><span class="n">popitem</span><span class="p">()</span>
<span class="go">(19, 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">od</span><span class="o">.</span><span class="n">popitem</span><span class="p">()</span>
<span class="go">(18, 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">od</span><span class="o">.</span><span class="n">popitem</span><span class="p">(</span><span class="n">last</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">(0, 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">od</span><span class="o">.</span><span class="n">popitem</span><span class="p">(</span><span class="n">last</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">(1, 0)</span>
</pre></div>
</div>
<p class="translated">比较两个有序字典会同时检查键和值，并要求插入顺序相同</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">od1</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span>                   <span class="p">(</span><span class="s1">&#39;second&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
<span class="gp">... </span>                   <span class="p">(</span><span class="s1">&#39;third&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">od2</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="s1">&#39;third&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
<span class="gp">... </span>                   <span class="p">(</span><span class="s1">&#39;first&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span>                   <span class="p">(</span><span class="s1">&#39;second&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">od1</span> <span class="o">==</span> <span class="n">od2</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 将 &#39;third&#39; 键移动到末尾</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">od2</span><span class="p">[</span><span class="s1">&#39;third&#39;</span><span class="p">];</span> <span class="n">od2</span><span class="p">[</span><span class="s1">&#39;third&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">od1</span> <span class="o">==</span> <span class="n">od2</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="translated">将 <a class="reference internal" href="../library/collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">OrderedDict</span></code></a> 与普通字典进行比较时，会忽略插入顺序，只比较键和值。</p>
<p class="translated"><a class="reference internal" href="../library/collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">OrderedDict</span></code></a> 是如何工作的？它维护一个键的双链路列表，在插入新键时将其添加到列表中。二级字典 将键映射到其对应的列表节点 ，因此删除时不必遍历整个链接列表，从而保持 <em>O</em>(1)。</p>
<p class="translated">现在，标准库支持在多个模块 中使用有序字典。</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="../library/configparser.html#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ConfigParser</span></code></a> 模块默认使用它们，这意味着现在可以按照原来的顺序读取、修改和写回配置文件。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-func docutils literal notranslate"><span class="pre">collections.namedtuple()</span></code></a> 的 <a class="reference internal" href="../library/collections.html#collections.somenamedtuple._asdict" title="collections.somenamedtuple._asdict"><code class="xref py py-meth docutils literal notranslate"><span class="pre">_asdict()</span></code></a> 方法现在返回一个有序字典，其中的值按照底层元组索引的顺序出现。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/json.html#module-json" title="json: Encode and decode the JSON format."><code class="xref py py-mod docutils literal notranslate"><span class="pre">json</span></code></a> 模块的 <a class="reference internal" href="../library/json.html#json.JSONDecoder" title="json.JSONDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">JSONDecoder</span></code></a> 类构造器扩展了一个 <em>object_pairs_hook</em> 形参 ，允许解码器构建 <code class="xref py py-class docutils literal notranslate"><span class="pre">OrderedDict</span></code> 实例。此外，还添加了对第三方工具的支持，如 <a class="reference external" href="https://pyyaml.org/">PyYAML</a> 。</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-54"></span><a class="pep reference external" href="https://peps.python.org/pep-0372/"><strong>PEP 372</strong></a> - 将有序词典添加到集合中</dt><dd><p class="translated">PEP 由 Armin Ronacher 和 Raymond Hettinger 撰写，由 Raymond Hettinger 实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-378-format-specifier-for-thousands-separator">
<span id="pep-0378"></span><h2 class="translated">PEP 378: 千位分隔符的格式说明符<a class="headerlink" href="#pep-378-format-specifier-for-thousands-separator" title="Link to this heading">¶</a></h2>
<p class="translated">为了使程序输出更易读，可以在大数字上添加分隔符，将其显示为 18,446,744,073,709,551,616 而不是 18446744073709551616。</p>
<p class="translated">完全通用的解决方案是 <a class="reference internal" href="../library/locale.html#module-locale" title="locale: Internationalization services."><code class="xref py py-mod docutils literal notranslate"><span class="pre">locale</span></code></a> 模块 ，它可以使用不同的分隔符（北美为&quot;,&quot;，欧洲为&quot;.&quot;）和不同的分组大小，但 <a class="reference internal" href="../library/locale.html#module-locale" title="locale: Internationalization services."><code class="xref py py-mod docutils literal notranslate"><span class="pre">locale</span></code></a> 使用起来比较复杂，而且不适合多线程应用程序，因为不同的线程会为不同的本地生成输出。</p>
<p class="translated">因此，在 <a class="reference internal" href="../library/stdtypes.html#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a> 方法使用的迷你语言中添加了一个简单的逗号分组机制。 在格式化浮点数时，只需在宽度和精度之间加上逗号</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">{:20,.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mf">18446744073709551616.0</span><span class="p">)</span>
<span class="go">&#39;18,446,744,073,709,551,616.00&#39;</span>
</pre></div>
</div>
<p class="translated">格式化整数时，在宽度后面加上逗号：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">{:20,d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">18446744073709551616</span><span class="p">)</span>
<span class="go">&#39;18,446,744,073,709,551,616&#39;</span>
</pre></div>
</div>
<p class="translated">这种机制完全没有适应性；逗号总是用作分隔符，分组总是以三位数为一组。 逗号格式机制不如 <a class="reference internal" href="../library/locale.html#module-locale" title="locale: Internationalization services."><code class="xref py py-mod docutils literal notranslate"><span class="pre">locale</span></code></a> 模块通用，但使用起来更方便。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-55"></span><a class="pep reference external" href="https://peps.python.org/pep-0378/"><strong>PEP 378</strong></a> - 千位分隔符的格式说明符</dt><dd><p class="translated">PEP 由 Raymond Hettinger 撰写，由 Eric Smith 实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-389-the-argparse-module-for-parsing-command-lines">
<h2 class="translated">PEP 389：用于解析命令行的 argparse 模块<a class="headerlink" href="#pep-389-the-argparse-module-for-parsing-command-lines" title="Link to this heading">¶</a></h2>
<p class="translated">用于解析命令-line参数的 <a class="reference internal" href="../library/argparse.html#module-argparse" title="argparse: Command-line option and argument parsing library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">argparse</span></code></a> 模块是作为 <a class="reference internal" href="../library/optparse.html#module-optparse" title="optparse: Command-line option parsing library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">optparse</span></code></a> 模块更强大的替代功能而添加的。</p>
<p class="translated">这意味着 Python 现在支持三个不同的用来解析命令行参数的模块: <a class="reference internal" href="../library/getopt.html#module-getopt" title="getopt: Portable parser for command line options; support both short and long option names."><code class="xref py py-mod docutils literal notranslate"><span class="pre">getopt</span></code></a>, <a class="reference internal" href="../library/optparse.html#module-optparse" title="optparse: Command-line option parsing library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">optparse</span></code></a> 和 <a class="reference internal" href="../library/argparse.html#module-argparse" title="argparse: Command-line option and argument parsing library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">argparse</span></code></a>。 <a class="reference internal" href="../library/getopt.html#module-getopt" title="getopt: Portable parser for command line options; support both short and long option names."><code class="xref py py-mod docutils literal notranslate"><span class="pre">getopt</span></code></a> 模块非常接近 C 库的 <code class="xref c c-func docutils literal notranslate"><span class="pre">getopt()</span></code> 函数，因此它在你编写最终要用 C 来重新编写的 Python 原型代码时很有用处。 <a class="reference internal" href="../library/optparse.html#module-optparse" title="optparse: Command-line option parsing library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">optparse</span></code></a> 已经变得冗余，但并没有移除它的计划因为许多脚本仍然在使用它，并且也没有自动化更新这些脚本的方式。 （让 <a class="reference internal" href="../library/argparse.html#module-argparse" title="argparse: Command-line option and argument parsing library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">argparse</span></code></a> API 与 <a class="reference internal" href="../library/optparse.html#module-optparse" title="optparse: Command-line option parsing library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">optparse</span></code></a> 的接口保持一致的提议曾被讨论但因过于繁琐和困难而被拒绝。）</p>
<p class="translated">简而言之，如果你是在编写新脚本并且不需要担心与 Python 较早版本的兼容性，请使用 <a class="reference internal" href="../library/argparse.html#module-argparse" title="argparse: Command-line option and argument parsing library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">argparse</span></code></a> 而不是 <a class="reference internal" href="../library/optparse.html#module-optparse" title="optparse: Command-line option parsing library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">optparse</span></code></a>。</p>
<p class="translated">以下是为示例代码:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">argparse</span>

<span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s1">&#39;命令行示例。&#39;</span><span class="p">)</span>

<span class="c1"># 添加可选开关</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-v&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_true&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;is_verbose&#39;</span><span class="p">,</span>
                    <span class="n">help</span><span class="o">=</span><span class="s1">&#39;生成详细输出&#39;</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-o&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;output&#39;</span><span class="p">,</span>
                    <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;FILE&#39;</span><span class="p">,</span>
                    <span class="n">help</span><span class="o">=</span><span class="s1">&#39;将输出重定向到 FILE 而不是 stdout&#39;</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-C&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;context&#39;</span><span class="p">,</span>
                    <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;NUM&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">help</span><span class="o">=</span><span class="s1">&#39;显示 NUM 行的附加上下文&#39;</span><span class="p">)</span>

<span class="c1"># 允许任意数量的附加参数。</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="n">nargs</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;inputs&#39;</span><span class="p">,</span>
                    <span class="n">help</span><span class="o">=</span><span class="s1">&#39;输入文件名（默认为 stdin）&#39;</span><span class="p">)</span>

<span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
<span class="nb">print</span> <span class="n">args</span><span class="o">.</span><span class="vm">__dict__</span>
</pre></div>
</div>
<p class="translated">除非你覆盖它，否则会自动添加 <code class="xref std std-option docutils literal notranslate"><span class="pre">-h</span></code> 和 <code class="xref std std-option docutils literal notranslate"><span class="pre">--help</span></code> 开关，并产生格式化良好的输出:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">-&gt;</span> <span class="o">./</span><span class="n">python</span><span class="o">.</span><span class="n">exe</span> <span class="n">argparse</span><span class="o">-</span><span class="n">example</span><span class="o">.</span><span class="n">py</span> <span class="o">--</span><span class="n">help</span>
<span class="n">usage</span><span class="p">:</span> <span class="n">argparse</span><span class="o">-</span><span class="n">example</span><span class="o">.</span><span class="n">py</span> <span class="p">[</span><span class="o">-</span><span class="n">h</span><span class="p">]</span> <span class="p">[</span><span class="o">-</span><span class="n">v</span><span class="p">]</span> <span class="p">[</span><span class="o">-</span><span class="n">o</span> <span class="n">FILE</span><span class="p">]</span> <span class="p">[</span><span class="o">-</span><span class="n">C</span> <span class="n">NUM</span><span class="p">]</span> <span class="p">[</span><span class="n">inputs</span> <span class="p">[</span><span class="n">inputs</span> <span class="o">...</span><span class="p">]]</span>

<span class="n">Command</span><span class="o">-</span><span class="n">line</span> <span class="n">example</span><span class="o">.</span>

<span class="n">positional</span> <span class="n">arguments</span><span class="p">:</span>
  <span class="n">inputs</span>      <span class="nb">input</span> <span class="n">filenames</span> <span class="p">(</span><span class="n">default</span> <span class="ow">is</span> <span class="n">stdin</span><span class="p">)</span>

<span class="n">optional</span> <span class="n">arguments</span><span class="p">:</span>
  <span class="o">-</span><span class="n">h</span><span class="p">,</span> <span class="o">--</span><span class="n">help</span>  <span class="n">show</span> <span class="n">this</span> <span class="n">help</span> <span class="n">message</span> <span class="ow">and</span> <span class="n">exit</span>
  <span class="o">-</span><span class="n">v</span>          <span class="n">produce</span> <span class="n">verbose</span> <span class="n">output</span>
  <span class="o">-</span><span class="n">o</span> <span class="n">FILE</span>     <span class="n">direct</span> <span class="n">output</span> <span class="n">to</span> <span class="n">FILE</span> <span class="n">instead</span> <span class="n">of</span> <span class="n">stdout</span>
  <span class="o">-</span><span class="n">C</span> <span class="n">NUM</span>      <span class="n">display</span> <span class="n">NUM</span> <span class="n">lines</span> <span class="n">of</span> <span class="n">added</span> <span class="n">context</span>
</pre></div>
</div>
<p class="translated">与 <a class="reference internal" href="../library/optparse.html#module-optparse" title="optparse: Command-line option parsing library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">optparse</span></code></a> 一样，命令行开关和参数将返回为一个具有通过 <em>dest</em> 形参所指定的属性的对象:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">-&gt;</span> <span class="o">./</span><span class="n">python</span><span class="o">.</span><span class="n">exe</span> <span class="n">argparse</span><span class="o">-</span><span class="n">example</span><span class="o">.</span><span class="n">py</span> <span class="o">-</span><span class="n">v</span>
<span class="p">{</span><span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
 <span class="s1">&#39;is_verbose&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
 <span class="s1">&#39;context&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
 <span class="s1">&#39;inputs&#39;</span><span class="p">:</span> <span class="p">[]}</span>

<span class="o">-&gt;</span> <span class="o">./</span><span class="n">python</span><span class="o">.</span><span class="n">exe</span> <span class="n">argparse</span><span class="o">-</span><span class="n">example</span><span class="o">.</span><span class="n">py</span> <span class="o">-</span><span class="n">v</span> <span class="o">-</span><span class="n">o</span> <span class="o">/</span><span class="n">tmp</span><span class="o">/</span><span class="n">output</span> <span class="o">-</span><span class="n">C</span> <span class="mi">4</span> <span class="n">file1</span> <span class="n">file2</span>
<span class="p">{</span><span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="s1">&#39;/tmp/output&#39;</span><span class="p">,</span>
 <span class="s1">&#39;is_verbose&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
 <span class="s1">&#39;context&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
 <span class="s1">&#39;inputs&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;file1&#39;</span><span class="p">,</span> <span class="s1">&#39;file2&#39;</span><span class="p">]}</span>
</pre></div>
</div>
<p class="translated"><a class="reference internal" href="../library/argparse.html#module-argparse" title="argparse: Command-line option and argument parsing library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">argparse</span></code></a> 模块提供了比 <a class="reference internal" href="../library/optparse.html#module-optparse" title="optparse: Command-line option parsing library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">optparse</span></code></a> 更强大的参数验证功能：你可以通过指定整数来要求精确数量的参数，使用 <code class="docutils literal notranslate"><span class="pre">'*'</span></code> 表示接受零个或多个参数，使用 <code class="docutils literal notranslate"><span class="pre">'+'</span></code> 表示接受一个或多个参数，或者使用 <code class="docutils literal notranslate"><span class="pre">'?'</span></code> 表示可选参数。顶层解析器还可以包含子解析器，用于定义具有不同开关选项集的子命令（例如 <code class="docutils literal notranslate"><span class="pre">svn</span> <span class="pre">commit</span></code>、<code class="docutils literal notranslate"><span class="pre">svn</span> <span class="pre">checkout</span></code> 等）。此外，你可以将参数类型指定为 <a class="reference internal" href="../library/argparse.html#argparse.FileType" title="argparse.FileType"><code class="xref py py-class docutils literal notranslate"><span class="pre">FileType</span></code></a>，该类型会自动为你打开文件，并理解 <code class="docutils literal notranslate"><span class="pre">'-'</span></code> 表示标准输入或输出。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><a class="reference internal" href="../library/argparse.html#module-argparse" title="argparse: Command-line option and argument parsing library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">argparse</span></code></a> 文档</dt><dd><p class="translated">argparse 模块的文档页面。</p>
</dd>
<dt class="translated"><a class="reference internal" href="../howto/argparse-optparse.html#upgrading-optparse-code"><span class="std std-ref">将 optparse 代码迁移至 argparse</span></a></dt><dd><p class="translated">Python 文档的一部分，描述如何转换使用了 <a class="reference internal" href="../library/optparse.html#module-optparse" title="optparse: Command-line option parsing library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">optparse</span></code></a> 的代码。</p>
</dd>
<dt class="translated"><span class="target" id="index-56"></span><a class="pep reference external" href="https://peps.python.org/pep-0389/"><strong>PEP 389</strong></a> - argparse - 新的命令行解析模块</dt><dd><p class="translated">PEP 由 Steven Bethard 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-391-dictionary-based-configuration-for-logging">
<h2 class="translated">PEP 391: 基于字典的日志配置<a class="headerlink" href="#pep-391-dictionary-based-configuration-for-logging" title="Link to this heading">¶</a></h2>
<p class="translated"><a class="reference internal" href="../library/logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> 模块非常灵活；应用程序可以定义一个日志子系统树，树中的每个记录器可以过滤掉某些消息，以不同的方式格式化它们，并将消息定向到不同数量的处理器。</p>
<p class="translated">所有这些灵活性可能需要大量的配置。你可以编写Python语句来创建对象并设置它们的属性，但复杂的设置需要冗长但乏味的代码。<a class="reference internal" href="../library/logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> 还支持一个 <a class="reference internal" href="../library/logging.config.html#logging.config.fileConfig" title="logging.config.fileConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">fileConfig()</span></code></a> 函数，该函数解析一个文件，但文件格式不支持配置过滤器，并且通过程序生成会更混乱。</p>
<p class="translated">Python 2.7 添加了一个 <a class="reference internal" href="../library/logging.config.html#logging.config.dictConfig" title="logging.config.dictConfig"><code class="xref py py-func docutils literal notranslate"><span class="pre">dictConfig()</span></code></a> 函数，该函数使用字典来配置日志记录。有多种方法可以从不同来源生成字典：使用代码构造一个；解析包含 JSON 的文件；或者如果安装了 YAML 解析库，则使用该库。更多信息请参见 <a class="reference internal" href="../library/logging.config.html#logging-config-api"><span class="std std-ref">配置函数</span></a>。</p>
<p class="translated">以下示例配置了两个日志记录器，根日志记录器和一个名为 &quot;network&quot; 的日志记录器。发送到根日志记录器的消息将使用 syslog 协议发送到系统日志，而发送到 &quot;network&quot; 日志记录器的消息将写入一个 <code class="file docutils literal notranslate"><span class="pre">network.log</span></code> 文件，当日志达到 1MB 时将进行轮转。</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging.config</span>

<span class="n">configdict</span> <span class="o">=</span> <span class="p">{</span>
 <span class="s1">&#39;version&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>    <span class="c1"># 使用的配置模式；目前必须是 1</span>
 <span class="s1">&#39;formatters&#39;</span><span class="p">:</span> <span class="p">{</span>
     <span class="s1">&#39;standard&#39;</span><span class="p">:</span> <span class="p">{</span>
         <span class="s1">&#39;format&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">%(asctime)s</span><span class="s1"> </span><span class="si">%(name)-15s</span><span class="s1"> &#39;</span>
                    <span class="s1">&#39;</span><span class="si">%(levelname)-8s</span><span class="s1"> </span><span class="si">%(message)s</span><span class="s1">&#39;</span><span class="p">)}},</span>

 <span class="s1">&#39;handlers&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;netlog&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;backupCount&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
                     <span class="s1">&#39;class&#39;</span><span class="p">:</span> <span class="s1">&#39;logging.handlers.RotatingFileHandler&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;filename&#39;</span><span class="p">:</span> <span class="s1">&#39;/logs/network.log&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;formatter&#39;</span><span class="p">:</span> <span class="s1">&#39;standard&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;level&#39;</span><span class="p">:</span> <span class="s1">&#39;INFO&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;maxBytes&#39;</span><span class="p">:</span> <span class="mi">1000000</span><span class="p">},</span>
              <span class="s1">&#39;syslog&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;class&#39;</span><span class="p">:</span> <span class="s1">&#39;logging.handlers.SysLogHandler&#39;</span><span class="p">,</span>
                         <span class="s1">&#39;formatter&#39;</span><span class="p">:</span> <span class="s1">&#39;standard&#39;</span><span class="p">,</span>
                         <span class="s1">&#39;level&#39;</span><span class="p">:</span> <span class="s1">&#39;ERROR&#39;</span><span class="p">}},</span>

 <span class="c1"># 指定所有子日志记录器</span>
 <span class="s1">&#39;loggers&#39;</span><span class="p">:</span> <span class="p">{</span>
             <span class="s1">&#39;network&#39;</span><span class="p">:</span> <span class="p">{</span>
                         <span class="s1">&#39;handlers&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;netlog&#39;</span><span class="p">]</span>
             <span class="p">}</span>
 <span class="p">},</span>
 <span class="c1"># 指定根日志记录器的属性</span>
 <span class="s1">&#39;root&#39;</span><span class="p">:</span> <span class="p">{</span>
          <span class="s1">&#39;handlers&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;syslog&#39;</span><span class="p">]</span>
 <span class="p">},</span>
<span class="p">}</span>

<span class="c1"># 设置配置</span>
<span class="n">logging</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">dictConfig</span><span class="p">(</span><span class="n">configdict</span><span class="p">)</span>

<span class="c1"># 作为示例，记录两个错误消息</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;数据库未找到&#39;</span><span class="p">)</span>

<span class="n">netlogger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;network&#39;</span><span class="p">)</span>
<span class="n">netlogger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;连接失败&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">Vinay Sajip 实现的对 <a class="reference internal" href="../library/logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> 模块的三项较小增强是：</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="../library/logging.handlers.html#logging.handlers.SysLogHandler" title="logging.handlers.SysLogHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">SysLogHandler</span></code></a> 类现在支持通过 TCP 进行系统日志记录。构造函数有一个 <em>socktype</em> 参数，用于指定要使用的套接字类型，可以是 <a class="reference internal" href="../library/socket.html#socket.SOCK_DGRAM" title="socket.SOCK_DGRAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">socket.SOCK_DGRAM</span></code></a> 用于 UDP 或 <a class="reference internal" href="../library/socket.html#socket.SOCK_STREAM" title="socket.SOCK_STREAM"><code class="xref py py-const docutils literal notranslate"><span class="pre">socket.SOCK_STREAM</span></code></a> 用于 TCP。默认协议仍然是 UDP。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/logging.html#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> 实例新增了一个 <a class="reference internal" href="../library/logging.html#logging.Logger.getChild" title="logging.Logger.getChild"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getChild()</span></code></a> 方法，用于通过相对路径检索子日志记录器。例如，一旦通过 <code class="docutils literal notranslate"><span class="pre">log</span> <span class="pre">=</span> <span class="pre">getLogger('app')</span></code> 获取日志记录器，调用 <code class="docutils literal notranslate"><span class="pre">log.getChild('network.listen')</span></code> 等同于 <code class="docutils literal notranslate"><span class="pre">getLogger('app.network.listen')</span></code>。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/logging.html#logging.LoggerAdapter" title="logging.LoggerAdapter"><code class="xref py py-class docutils literal notranslate"><span class="pre">LoggerAdapter</span></code></a> 类新增了一个 <a class="reference internal" href="../library/logging.html#logging.Logger.isEnabledFor" title="logging.Logger.isEnabledFor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isEnabledFor()</span></code></a> 方法，该方法接受一个 <em>level</em> 参数，并返回底层日志记录器是否会处理该级别重要性的消息。</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-57"></span><a class="pep reference external" href="https://peps.python.org/pep-0391/"><strong>PEP 391</strong></a> - 基于字典的日志配置</dt><dd><p class="translated">PEP 由 Vinay Sajip 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-3106-dictionary-views">
<h2 class="translated">PEP 3106: 字典视图<a class="headerlink" href="#pep-3106-dictionary-views" title="Link to this heading">¶</a></h2>
<p class="translated">字典方法 <a class="reference internal" href="../library/stdtypes.html#dict.keys" title="dict.keys"><code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code></a>、 <a class="reference internal" href="../library/stdtypes.html#dict.values" title="dict.values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">values()</span></code></a> 和 <a class="reference internal" href="../library/stdtypes.html#dict.items" title="dict.items"><code class="xref py py-meth docutils literal notranslate"><span class="pre">items()</span></code></a> 在 Python 3.x 有所不同。 它们将返回名为 <em class="dfn">view</em> 的对象而不是完整的列表。</p>
<p class="translated">在 Python 2.7 中不可能改变 <a class="reference internal" href="../library/stdtypes.html#dict.keys" title="dict.keys"><code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code></a>、 <a class="reference internal" href="../library/stdtypes.html#dict.values" title="dict.values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">values()</span></code></a> 和 <a class="reference internal" href="../library/stdtypes.html#dict.items" title="dict.items"><code class="xref py py-meth docutils literal notranslate"><span class="pre">items()</span></code></a> 的返回值因为那会破坏大量已有代码。 作为替代 3.x 版本是以新名称 <code class="xref py py-meth docutils literal notranslate"><span class="pre">viewkeys()</span></code>、 <code class="xref py py-meth docutils literal notranslate"><span class="pre">viewvalues()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">viewitems()</span></code> 添加的。</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">i</span><span class="o">*</span><span class="mi">10</span><span class="p">,</span> <span class="nb">chr</span><span class="p">(</span><span class="mi">65</span><span class="o">+</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">26</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">{0: &#39;A&#39;, 130: &#39;N&#39;, 10: &#39;B&#39;, 140: &#39;O&#39;, 20: ..., 250: &#39;Z&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">viewkeys</span><span class="p">()</span>
<span class="go">dict_keys([0, 130, 10, 140, 20, 150, 30, ..., 250])</span>
</pre></div>
</div>
<p class="translated">视图可以被迭代，但键和条目视图的行为也很像是集合。 <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> 运算符执行交集运算，<code class="docutils literal notranslate"><span class="pre">|</span></code> 执行并集运算:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d1</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">i</span><span class="o">*</span><span class="mi">10</span><span class="p">,</span> <span class="nb">chr</span><span class="p">(</span><span class="mi">65</span><span class="o">+</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">26</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d2</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">i</span><span class="o">**</span><span class="mf">.5</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d1</span><span class="o">.</span><span class="n">viewkeys</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">d2</span><span class="o">.</span><span class="n">viewkeys</span><span class="p">()</span>
<span class="go">set([0.0, 10.0, 20.0, 30.0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d1</span><span class="o">.</span><span class="n">viewkeys</span><span class="p">()</span> <span class="o">|</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
<span class="go">set([0, 1, 130, 3, 4, 5, 6, ..., 120, 250])</span>
</pre></div>
</div>
<p class="translated">视图会追踪字典及字典被修改时的内容变化:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vk</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">viewkeys</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vk</span>
<span class="go">dict_keys([0, 130, 10, ..., 250])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="mi">260</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;&amp;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vk</span>
<span class="go">dict_keys([0, 130, 260, 10, ..., 250])</span>
</pre></div>
</div>
<p class="translated">但是，请注意在对视图进行迭代时你是不能添加或移除键的:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">vk</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
<span class="gp">...</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">RuntimeError</span>: <span class="n">dictionary changed size during iteration</span>
</pre></div>
</div>
<p class="translated">你可以在 Python 2.x 代码中使用视图方法，2to3 转换器会将它们更改为标准的 <a class="reference internal" href="../library/stdtypes.html#dict.keys" title="dict.keys"><code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code></a>、<a class="reference internal" href="../library/stdtypes.html#dict.values" title="dict.values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">values()</span></code></a> 和 <a class="reference internal" href="../library/stdtypes.html#dict.items" title="dict.items"><code class="xref py py-meth docutils literal notranslate"><span class="pre">items()</span></code></a> 方法。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-58"></span><a class="pep reference external" href="https://peps.python.org/pep-3106/"><strong>PEP 3106</strong></a> - 改造 dict.keys()、 .values() 和 .items()</dt><dd><p class="translated">PEP 由 Guido van Rossum 撰写。 由 Alexandre Vassalotti 反向移植到 2.7；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1967">bpo-1967</a>。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-3137-the-memoryview-object">
<h2 class="translated">PEP 3137: memoryview 对象<a class="headerlink" href="#pep-3137-the-memoryview-object" title="Link to this heading">¶</a></h2>
<p class="translated"><a class="reference internal" href="../library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> 对象提供与 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 类型的接口相匹配的另一个对象的内存内容的视图。</p>
<div class="translated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">string</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">letters</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">&lt;memory at 0x37f850&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>           <span class="c1"># 返回底层对象的长度</span>
<span class="go">52</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">25</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">26</span><span class="p">]</span>   <span class="c1"># 索引返回一个字节</span>
<span class="go">(&#39;a&#39;, &#39;z&#39;, &#39;A&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">26</span><span class="p">]</span>         <span class="c1"># 切片返回另一个 memoryview</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span>
<span class="go">&lt;memory at 0x37f080&gt;</span>
</pre></div>
</div>
<p class="translated">视图的内容可被转换为一个字节串或整数列表：</p>
<div class="translated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="go">&#39;abcdefghijklmnopqrstuvwxyz&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="go">[97, 98, 99, 100, 101, 102, 103, ... 121, 122]</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated"><a class="reference internal" href="../library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> 对象允许对属于可变对象的下层对象进行修改。</p>
<div class="translated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">75</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">cannot modify read-only memory</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">letters</span><span class="p">)</span>  <span class="c1"># 创建一个可变对象</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">bytearray(b&#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mb</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;*&#39;</span>         <span class="c1"># 通过视图赋值，改变字节序列。</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>              <span class="c1"># 字节序列已被改变。</span>
<span class="go">bytearray(b&#39;*bcde&#39;)</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-59"></span><a class="pep reference external" href="https://peps.python.org/pep-3137/"><strong>PEP 3137</strong></a> - 不变字节和可变缓冲区</dt><dd><p class="translated">PEP 由 Guido van Rossum 撰写。 由 Travis Oliphant、 Antoine Pitrou 等人实现。 由 Antoine Pitrou 向下移植到 2.7; 参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2396">bpo-2396</a>。</p>
</dd>
</dl>
</div>
</section>
<section id="other-language-changes">
<h2 class="translated">其他语言特性修改<a class="headerlink" href="#other-language-changes" title="Link to this heading">¶</a></h2>
<p class="translated">对Python 语言核心进行的小改动：</p>
<ul>
<li><p class="translated">已从 Python 3.x 向下移植了集合字面值语法。 使用花括号来标记可变集合的内容；集合与字典的区别在于它不包含冒号及映射的值。 <code class="docutils literal notranslate"><span class="pre">{}</span></code> 仍然表示空字典；请使用 <code class="docutils literal notranslate"><span class="pre">set()</span></code> 来表示空集合。</p>
<div class="translated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
<span class="go">set([1, 2, 3, 4, 5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">set</span><span class="p">()</span> <span class="c1"># 空集合</span>
<span class="go">set([])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">{}</span>    <span class="c1"># 空字典</span>
<span class="go">{}</span>
</pre></div>
</div>
<p class="translated">由 Alexandre Vassalotti 向下移植;参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2335">bpo-2335</a>。</p>
</li>
<li><p class="translated">字典与集合推导式是另一个从 3.x 向下移植的特性，对列表/生成器推导式进行泛化以针对集合与字典使用字面值语法。</p>
<div class="translated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)}</span>
<span class="go">{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">{(</span><span class="s1">&#39;a&#39;</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)}</span>
<span class="go">set([&#39;&#39;, &#39;a&#39;, &#39;aa&#39;, &#39;aaa&#39;, &#39;aaaa&#39;, &#39;aaaaa&#39;])</span>
</pre></div>
</div>
<p class="translated">由 Alexandre Vassalotti 向下移植;参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2333">bpo-2333</a>。</p>
</li>
<li><p class="translated">现在 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 语句可以在一个语句中使用多个上下文管理器。 上下文管理器将按从左到右的顺序处理并且每个都会被视为开始一个新的 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code> 语句。 这意味着:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">A</span><span class="p">()</span> <span class="k">as</span> <span class="n">a</span><span class="p">,</span> <span class="n">B</span><span class="p">()</span> <span class="k">as</span> <span class="n">b</span><span class="p">:</span>
    <span class="o">...</span> <span class="n">一系列语句</span> <span class="o">...</span>
</pre></div>
</div>
<p class="translated">相当于:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">A</span><span class="p">()</span> <span class="k">as</span> <span class="n">a</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">B</span><span class="p">()</span> <span class="k">as</span> <span class="n">b</span><span class="p">:</span>
        <span class="o">...</span> <span class="n">一系列语句</span> <span class="o">...</span>
</pre></div>
</div>
<p class="translated"><code class="xref py py-func docutils literal notranslate"><span class="pre">contextlib.nested()</span></code> 函数提供了非常类似的功能，因此它不再必要并已被弃用。</p>
<p class="translated">（提议于 <a class="reference external" href="https://codereview.appspot.com/53094">https://codereview.appspot.com/53094</a>；由 Georg Brandl 实现。）</p>
</li>
<li><p class="translated">在大多数平台上，浮点数和字符串之间的转换现在正确地四舍五入。这些转换发生在许多不同的地方：对浮点数和复数的 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a>；<a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> 和 <a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a> 构造函数；数值格式化；使用 <a class="reference internal" href="../library/marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">marshal</span></code></a>、<a class="reference internal" href="../library/pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 和 <a class="reference internal" href="../library/json.html#module-json" title="json: Encode and decode the JSON format."><code class="xref py py-mod docutils literal notranslate"><span class="pre">json</span></code></a> 模块序列化和反序列化浮点数和复数；在 Python 代码中解析浮点数和虚数字面量；以及 <a class="reference internal" href="../library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 到浮点数的转换。</p>
<p class="translated">与此相关，浮点数 <em>x</em> 的 <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 现在返回基于最短十进制字符串的结果，该字符串保证在正确四舍五入（采用四舍六入五成双模式）的情况下能返回到 <em>x</em>。之前它给出的是基于将 x 四舍五入到 17 位小数的字符串。</p>
<p class="translated">负责此改进的舍入库在Windows和Unix平台上使用gcc、icc或suncc编译器工作。可能有一些平台无法保证此代码的正确运行，因此在这些系统上不使用此代码。你可以通过检查 <a class="reference internal" href="../library/sys.html#sys.float_repr_style" title="sys.float_repr_style"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.float_repr_style</span></code></a> 来了解正在使用的代码，如果使用新代码则为``short``，未使用则为``legacy``。</p>
<p class="translated">由Eric Smith和Mark Dickinson实现，使用David Gay的 <code class="file docutils literal notranslate"><span class="pre">dtoa.c</span></code> 库；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7117">bpo-7117</a>。</p>
</li>
<li><p class="translated">从长整数和普通整数转换为浮点数现在有不同的舍入方式，返回最接近该数的浮点数。对于可以精确转换的小整数，这无关紧要，但对于不可避免会丢失精度的大数，Python 2.7现在更接近真实值。例如，Python 2.6计算如下：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">295147905179352891391</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">2.9514790517935283e+20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">-</span> <span class="n">long</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="go">65535L</span>
</pre></div>
</div>
<p class="translated">Python 2.7的浮点结果更大，但更接近真实值：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">295147905179352891391</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">2.9514790517935289e+20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">-</span> <span class="n">long</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="go">-1L</span>
</pre></div>
</div>
<p class="translated">（由Mark Dickinson实现；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=3166">bpo-3166</a>。）</p>
<p class="translated">整数除法在舍入行为上也更准确。（也由Mark Dickinson实现；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1811">bpo-1811</a>。）</p>
</li>
<li><p class="translated">已移除复数的隐式强制转换；解释器将不再尝试调用复数对象上的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__coerce__()</span></code> 方法。（由Meador Inge和Mark Dickinson移除；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5211">bpo-5211</a>。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/stdtypes.html#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a> 方法现在支持替换字段的自动编号。这使得使用 <a class="reference internal" href="../library/stdtypes.html#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a> 更类似于使用``%s``格式化：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">:</span><span class="si">{}</span><span class="s1">:</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">2009</span><span class="p">,</span> <span class="mi">04</span><span class="p">,</span> <span class="s1">&#39;Sunday&#39;</span><span class="p">)</span>
<span class="go">&#39;2009:4:Sunday&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">:</span><span class="si">{}</span><span class="s1">:</span><span class="si">{day}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">2009</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="s1">&#39;Sunday&#39;</span><span class="p">)</span>
<span class="go">&#39;2009:4:Sunday&#39;</span>
</pre></div>
</div>
<p class="translated">自动编号从左到右获取字段，因此第一个 <code class="docutils literal notranslate"><span class="pre">{...}</span></code> 指定符将使用 <a class="reference internal" href="../library/stdtypes.html#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a> 的第一个参数，下一个指定符将使用下一个参数，依此类推。不能混合使用自动编号和显式编号——要么为所有指定符字段编号，要么不编号——但可以混合使用自动编号和命名字段，如上第二个示例所示。（由 Eric Smith 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5237">bpo-5237</a>。）</p>
<p class="translated">复数现在正确支持与 <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> 的使用，并默认右对齐。指定精度或逗号分隔适用于数字的实部和虚部，但指定的字段宽度和对齐应用于整个 <code class="docutils literal notranslate"><span class="pre">1.5+3j</span></code> 输出。（由 Eric Smith 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1588">bpo-1588</a> 和 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7988">bpo-7988</a>。）</p>
<p class="translated">“F”格式代码现在总是使用大写字符格式化其输出，因此它现在将产生“INF”和“NAN”。（由 Eric Smith 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=3382">bpo-3382</a>。）</p>
<p class="translated">一个底层修改：<a class="reference internal" href="../reference/datamodel.html#object.__format__" title="object.__format__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__format__()</span></code></a> 方法现在在传递格式字符串时触发 <a class="reference internal" href="../library/exceptions.html#PendingDeprecationWarning" title="PendingDeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PendingDeprecationWarning</span></code></a>，因为 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__format__()</span></code> 方法对于 <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 将对象转换为字符串表示并进行格式化。以前该方法静默地应用格式字符串到字符串表示，但这可能会隐藏 Python 代码中的错误。如果你提供格式化信息，如对齐或精度，你可能期望以某种对象特定的方式进行格式化。（由 Eric Smith 修复；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7994">bpo-7994</a>。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">long()</span></code> 类型获得了一个 <code class="docutils literal notranslate"><span class="pre">bit_length</span></code> 方法，该方法返回表示其参数所需的二进制位数：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">37</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="go">&#39;0b100101&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span>
<span class="go">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">123</span><span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span>
<span class="go">123</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span>
<span class="go">124</span>
</pre></div>
</div>
<p class="translated">（由 Fredrik Johansson 和 Victor Stinner 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=3439">bpo-3439</a>。）</p>
</li>
<li><p class="translated">如果相对导入（例如 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">.os</span> <span class="pre">import</span> <span class="pre">sep</span></code>）失败，<a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句将不再尝试绝对导入。这修复了一个错误，但可能会破坏某些仅凭偶然才工作的 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code> 语句。（由 Meador Inge 修复；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7902">bpo-7902</a>。）</p></li>
<li><p class="translated">现在，内置 <code class="xref py py-class docutils literal notranslate"><span class="pre">unicode</span></code> 类型的子类可以重写 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__unicode__()</span></code> 方法。（由 Victor Stinner 实现；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1583863">bpo-1583863</a>。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 类型的 <a class="reference internal" href="../library/stdtypes.html#bytearray.translate" title="bytearray.translate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">translate()</span></code></a> 方法现在接受 <code class="docutils literal notranslate"><span class="pre">None</span></code> 作为其第一个参数。（由 Georg Brandl 修复；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4759">bpo-4759</a>。）</p>
</li>
<li><p class="translated">当使用 <a class="reference internal" href="../library/functions.html#classmethod" title="classmethod"><code class="xref py py-deco docutils literal notranslate"><span class="pre">&#64;classmethod</span></code></a> 和 <a class="reference internal" href="../library/functions.html#staticmethod" title="staticmethod"><code class="xref py py-deco docutils literal notranslate"><span class="pre">&#64;staticmethod</span></code></a> 将方法包装为类方法或静态方法时，包装器对象现在会将其包装的函数公开为它们的 <a class="reference internal" href="../reference/datamodel.html#method.__func__" title="method.__func__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code></a> 属性。 （由 Amaury Forgeot d'Arc 贡献，基于 George Sakkis 的建议; <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5982">bpo-5982</a>。）</p></li>
<li><p class="translated">当使用 <code class="docutils literal notranslate"><span class="pre">__slots__</span></code> 设置一组受限属性时，删除未设置的属性不会像预期那样引发 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>。（由 Benjamin Peterson 修复；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7604">bpo-7604</a>。）</p></li>
<li><p class="translated">现在支持两种新的编码：&quot;cp720&quot;，主要用于阿拉伯文本；以及 &quot;cp858&quot;，是 CP 850 的变体，增加了欧元符号。（CP720 由 Alexander Belchenko 和 Amaury Forgeot d'Arc 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1616979">bpo-1616979</a> 中贡献；CP858 由 Tim Hatch 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=8016">bpo-8016</a> 中贡献。）</p></li>
<li><p class="translated"><code class="xref py py-class docutils literal notranslate"><span class="pre">file</span></code> 对象现在在 POSIX 平台上尝试打开目录时会在 <a class="reference internal" href="../library/exceptions.html#IOError" title="IOError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IOError</span></code></a> 异常上设置 <code class="xref py py-attr docutils literal notranslate"><span class="pre">filename</span></code> 属性（由 Jan Kaliszewski 指出；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4764">bpo-4764</a>），并且现在明确检查并禁止对只读文件对象进行写入，而不是依赖 C 库来捕获和报告错误（由 Stefan Krah 修复；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5677">bpo-5677</a>）。</p></li>
<li><p class="translated">Python 词法分析器现在会自行处理行尾符，因此内置函数 <a class="reference internal" href="../library/functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 现在可以接受采用任意行尾约定（如 Windows 的 CRLF、Unix 的 LF 或旧版 Mac 的 CR）的代码。此外，该函数不再强制要求代码必须以换行符结尾。</p></li>
<li><p class="translated">在Python 3.x中，函数定义中的额外括号是非法的，这意味着你会从``def f((x)): pass``中得到一个语法错误。在Python3警告模式下，Python 2.7现在会警告这种奇怪的用法。（由James Lingard指出；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7362">bpo-7362</a>。）</p></li>
<li><p class="translated">现在可以创建对旧式类对象的弱引用。新式类始终可以弱引用。（由 Antoine Pitrou 修复；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=8268">bpo-8268</a>。）</p></li>
<li><p class="translated">当一个模块对象被垃圾回收时，该模块的字典现在只有在没有其他引用时才会被清除（参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7140">bpo-7140</a>）。</p></li>
</ul>
<section id="interpreter-changes">
<span id="new-27-interpreter"></span><h3 class="translated">解释器改动<a class="headerlink" href="#interpreter-changes" title="Link to this heading">¶</a></h3>
<p class="translated">一个新的环境变量，<span class="target" id="index-60"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONWARNINGS"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONWARNINGS</span></code></a>，允许控制警告。它应设置为包含警告设置的字符串，等同于使用 <a class="reference internal" href="../using/cmdline.html#cmdoption-W"><code class="xref std std-option docutils literal notranslate"><span class="pre">-W</span></code></a> 开关的设置，用逗号分隔。（由 Brian Curtin 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7301">bpo-7301</a>。）</p>
<p class="translated">例如，以下设置将在每次出现警告时打印它们，但将来自 <a class="reference internal" href="../library/http.cookies.html#module-http.cookies" title="http.cookies: Support for HTTP state management (cookies)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">Cookie</span></code></a> 模块的警告转换为错误。（设置环境变量的确切语法因操作系统和shell而异。）</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">export</span> <span class="n">PYTHONWARNINGS</span><span class="o">=</span><span class="nb">all</span><span class="p">,</span><span class="n">error</span><span class="p">:::</span><span class="n">Cookie</span><span class="p">:</span><span class="mi">0</span>
</pre></div>
</div>
</section>
<section id="optimizations">
<h3 class="translated">性能优化<a class="headerlink" href="#optimizations" title="Link to this heading">¶</a></h3>
<p class="translated">已添加多项性能优化改进：</p>
<ul>
<li><p class="translated">添加了一个新的操作码，用于执行 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 语句的初始设置，查找 <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> 和 <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 方法。（由 Benjamin Peterson 贡献。）</p></li>
<li><p class="translated">垃圾回收器现在对一种常见使用模式表现更好：当大量对象被分配而没有释放任何对象时。此前，垃圾回收需要二次方时间，但现在随着堆中对象数量的增长，完整垃圾回收的次数减少了。新逻辑仅在中间代被收集10次且中间代幸存对象数量超过最老代对象数量的10%时，才执行一次完整的垃圾回收。 （由 Martin von Löwis 建议，Antoine Pitrou 实现；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4074">bpo-4074</a>。）</p></li>
<li><p class="translated">垃圾回收器会尽量避免追踪那些不可能形成循环引用的简单容器对象。在 Python 2.7 中，对于仅包含原子类型（如整数、字符串等）的元组和字典，现在均符合这一特性。由此推及，包含原子类型元组的字典同样不会被追踪。这一优化通过减少垃圾回收器需要处理和遍历的对象数量，有效降低了每次垃圾回收的开销。（由 Antoine Pitrou 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4688">bpo-4688</a>。）</p></li>
<li><p class="translated">长整型数值现在在内部存储时采用 <code class="docutils literal notranslate"><span class="pre">2**15</span></code> 或 <code class="docutils literal notranslate"><span class="pre">2**30</span></code> 作为基数，具体采用哪种基数在构建（编译）时确定。此前，长整型数值始终采用 <code class="docutils literal notranslate"><span class="pre">2**15</span></code> 作为存储基数。使用 <code class="docutils literal notranslate"><span class="pre">2**30</span></code> 作为基数能在 64 位机器上带来显著的性能提升，但在 32 位机器上的基准测试结果则好坏参半。因此，默认情况下，在 64 位机器上使用 <code class="docutils literal notranslate"><span class="pre">2**30</span></code> 作为基数，在 32 位机器上使用 <code class="docutils literal notranslate"><span class="pre">2**15</span></code> 作为基数；在 Unix 系统上，新增了一个配置选项 <cite>--enable-big-digits`（对应选项标记为 :option:</cite>!--enable-big-digits`），可用于覆盖这一默认设置。</p>
<p class="translated">除了性能改进外，这一变化对最终用户应该是不可见的，有一个例外：为了测试和调试目的，新增了一个structseq <code class="xref py py-data docutils literal notranslate"><span class="pre">sys.long_info</span></code>，它提供了有关内部格式的信息，包括每个数字的位数和用于存储每个数字的C类型的大小（以字节为单位）：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sys</span><span class="o">.</span><span class="n">long_info</span>
<span class="go">sys.long_info(bits_per_digit=30, sizeof_digit=4)</span>
</pre></div>
</div>
<p class="translated">（由 Mark Dickinson在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4258">bpo-4258</a> 贡献）</p>
<p class="translated">另一组更改使长对象缩小了几字节：在32位系统上缩小了2字节，在64位系统上缩小了6字节。（由Mark Dickinson贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5260">bpo-5260</a>。）</p>
</li>
<li><p class="translated">通过收紧内循环、进行位移而不是乘法以及修复不必要的额外迭代，长整数的除法算法已经变得更快。各种基准测试显示，长整数除法和取模操作的加速在50%到150%之间。（由Mark Dickinson贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5512">bpo-5512</a>。）位运算也显著更快（初始补丁由Gregory Smith提供；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1087418">bpo-1087418</a>）。</p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">%</span></code> 的实现检查左侧操作数是否为 Python 字符串并进行特殊处理；这使频繁使用 <code class="docutils literal notranslate"><span class="pre">%</span></code> 与字符串的应用程序（如模板库）的性能提高了 1% 到 3%。（由 Collin Winter 实现；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5176">bpo-5176</a>。）</p></li>
<li><p class="translated">带有``if``条件的列表推导被编译成更快的字节码。（由Antoine Pitrou提供补丁，Jeffrey Yasskin向下移植到2.7；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4715">bpo-4715</a>。）</p></li>
<li><p class="translated">通过特殊处理基数10而不是使用支持任意基数的通用转换函数，将整数或长整数转换为十进制字符串的速度得到了提升。（由Gawain Bolton提供补丁；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=6713">bpo-6713</a>。）</p></li>
<li><p class="translated">字符串型类型（字符串、Unicode字符串和 <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 对象）的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">split()</span></code>、<code class="xref py py-meth docutils literal notranslate"><span class="pre">replace()</span></code>、<code class="xref py py-meth docutils literal notranslate"><span class="pre">rindex()</span></code>、<code class="xref py py-meth docutils literal notranslate"><span class="pre">rpartition()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">rsplit()</span></code> 方法现在使用快速的逆向搜索算法，而不是逐字符扫描。这在某些情况下可以快10倍。（由 Florent Xicluna 添加；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7462">bpo-7462</a> 和 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7622">bpo-7622</a>。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 和 <code class="xref py py-mod docutils literal notranslate"><span class="pre">cPickle</span></code> 模块现在自动内联用于属性名称的字符串，减少了反序列化生成的对象的内存使用。（由 Jake McGuire 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5084">bpo-5084</a>。）</p></li>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cPickle</span></code> 模块现在对字典进行了特殊处理，将序列化它们所需的时间几乎减半。（由 Collin Winter 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5670">bpo-5670</a>。）</p></li>
</ul>
</section>
</section>
<section id="new-and-improved-modules">
<h2 class="translated">新增和改进的模块<a class="headerlink" href="#new-and-improved-modules" title="Link to this heading">¶</a></h2>
<p class="translated">与每个版本一样，Python 的标准库收到了许多增强和 bug 修复。以下是一些最显著变化的的部分列表，按模块名称字母顺序排序。查阅源树中的 <code class="file docutils literal notranslate"><span class="pre">Misc/NEWS</span></code> 文件以获取更完整的变化列表，或通过 Subversion 日志查看所有详细信息。</p>
<ul>
<li><p class="translated"><a class="reference internal" href="../library/bdb.html#module-bdb" title="bdb: Debugger framework."><code class="xref py py-mod docutils literal notranslate"><span class="pre">bdb</span></code></a> 模块的基调试类 <a class="reference internal" href="../library/bdb.html#bdb.Bdb" title="bdb.Bdb"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bdb</span></code></a> 增加了一个跳过模块的功能。构造函数现在接受一个包含 glob 风格模式（如 <code class="docutils literal notranslate"><span class="pre">django.*</span></code>）的可迭代对象；调试器将不会进入与这些模式之一匹配的模块的堆栈帧。（由 Maru Newby 在 Senthil Kumaran 的建议后贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5142">bpo-5142</a>。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/binascii.html#module-binascii" title="binascii: Tools for converting between binary and various ASCII-encoded binary representations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">binascii</span></code></a> 模块现在支持缓冲区 API，因此可以与 <a class="reference internal" href="../library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> 实例和其他类似的缓冲区对象一起使用。（由 Florent Xicluna 从 3.x 向下移植；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7703">bpo-7703</a>。）</p></li>
<li><p class="translated">更新模块：<code class="xref py py-mod docutils literal notranslate"><span class="pre">bsddb</span></code> 模块已从 4.7.2devel9 更新到 <a class="reference external" href="https://www.jcea.es/programacion/pybsddb.htm">pybsddb 包</a> 的 4.8.4 版本。新版本具有更好的 Python 3.x 兼容性，各种 bug 修复，并添加了几个新的 BerkeleyDB 标志和方法。（由 Jesú Cea Avión 更新；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=8156">bpo-8156</a>。pybsddb 的更改日志可以在 <a class="reference external" href="https://hg.jcea.es/pybsddb/file/tip/ChangeLog">https://hg.jcea.es/pybsddb/file/tip/ChangeLog</a> 查看。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/bz2.html#module-bz2" title="bz2: Interfaces for bzip2 compression and decompression."><code class="xref py py-mod docutils literal notranslate"><span class="pre">bz2</span></code></a> 模块的 <a class="reference internal" href="../library/bz2.html#bz2.BZ2File" title="bz2.BZ2File"><code class="xref py py-class docutils literal notranslate"><span class="pre">BZ2File</span></code></a> 现在支持上下文管理协议，因此你可以编写 <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">bz2.BZ2File(...)</span> <span class="pre">as</span> <span class="pre">f:</span></code>。（由 Hagen Fürstenau 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=3860">bpo-3860</a>。）</p></li>
<li><p class="translated">新增类：<a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 模块中的 <a class="reference internal" href="../library/collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Counter</span></code></a> 类适用于统计数据。<a class="reference internal" href="../library/collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Counter</span></code></a> 实例的行为大多类似于字典，但对于缺失的键返回零而不是引发 <a class="reference internal" href="../library/exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a>：</p>
<div class="translated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">Counter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="s1">&#39;here is a sample of english text&#39;</span><span class="p">:</span>
<span class="gp">... </span>  <span class="n">c</span><span class="p">[</span><span class="n">letter</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">Counter({&#39; &#39;: 6, &#39;e&#39;: 5, &#39;s&#39;: 3, &#39;a&#39;: 2, &#39;i&#39;: 2, &#39;h&#39;: 2,</span>
<span class="go">&#39;l&#39;: 2, &#39;t&#39;: 2, &#39;g&#39;: 1, &#39;f&#39;: 1, &#39;m&#39;: 1, &#39;o&#39;: 1, &#39;n&#39;: 1,</span>
<span class="go">&#39;p&#39;: 1, &#39;r&#39;: 1, &#39;x&#39;: 1})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">]</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span>
<span class="go">0</span>
</pre></div>
</div>
<p class="translated">有三个额外的 <a class="reference internal" href="../library/collections.html#collections.Counter" title="collections.Counter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Counter</span></code></a> 方法。<a class="reference internal" href="../library/collections.html#collections.Counter.most_common" title="collections.Counter.most_common"><code class="xref py py-meth docutils literal notranslate"><span class="pre">most_common()</span></code></a> 返回最常见的 N 个元素及其计数。<a class="reference internal" href="../library/collections.html#collections.Counter.elements" title="collections.Counter.elements"><code class="xref py py-meth docutils literal notranslate"><span class="pre">elements()</span></code></a> 返回一个迭代器，遍历包含的元素，每个元素重复的次数与其计数相同。<a class="reference internal" href="../library/collections.html#collections.Counter.subtract" title="collections.Counter.subtract"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subtract()</span></code></a> 接受一个可迭代对象，并为每个元素减一而不是加一；如果参数是字典或另一个 <code class="xref py py-class docutils literal notranslate"><span class="pre">Counter</span></code>，则减去相应的计数。:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">most_common</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">[(&#39; &#39;, 6), (&#39;e&#39;, 5), (&#39;s&#39;, 3), (&#39;a&#39;, 2), (&#39;i&#39;, 2)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">elements</span><span class="p">()</span> <span class="o">-&gt;</span>
<span class="go">   &#39;a&#39;, &#39;a&#39;, &#39; &#39;, &#39; &#39;, &#39; &#39;, &#39; &#39;, &#39; &#39;, &#39; &#39;,</span>
<span class="go">   &#39;e&#39;, &#39;e&#39;, &#39;e&#39;, &#39;e&#39;, &#39;e&#39;, &#39;g&#39;, &#39;f&#39;, &#39;i&#39;, &#39;i&#39;,</span>
<span class="go">   &#39;h&#39;, &#39;h&#39;, &#39;m&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;n&#39;, &#39;p&#39;, &#39;s&#39;,</span>
<span class="go">   &#39;s&#39;, &#39;s&#39;, &#39;r&#39;, &#39;t&#39;, &#39;t&#39;, &#39;x&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">]</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="s1">&#39;very heavy on the letter e&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">]</span>    <span class="c1"># Count 现在降低了</span>
<span class="go">-1</span>
</pre></div>
</div>
<p class="translated">由 Raymond Hettinger 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1696199">bpo-1696199</a>。</p>
<p class="translated">新增类：<a class="reference internal" href="../library/collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">OrderedDict</span></code></a> 在之前的章节 <a class="reference internal" href="#pep-0372"><span class="std std-ref">PEP 372：将有序字典 添加到收藏集</span></a> 中有描述。</p>
<p class="translated">新方法：<a class="reference internal" href="../library/collections.html#collections.deque" title="collections.deque"><code class="xref py py-class docutils literal notranslate"><span class="pre">deque</span></code></a> 数据类型现在有一个 <a class="reference internal" href="../library/collections.html#collections.deque.count" title="collections.deque.count"><code class="xref py py-meth docutils literal notranslate"><span class="pre">count()</span></code></a> 方法，返回等于提供的参数 <em>x</em> 的元素数量，以及一个 <a class="reference internal" href="../library/collections.html#collections.deque.reverse" title="collections.deque.reverse"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reverse()</span></code></a> 方法，原地反转 deque 中的元素。<a class="reference internal" href="../library/collections.html#collections.deque" title="collections.deque"><code class="xref py py-class docutils literal notranslate"><span class="pre">deque</span></code></a> 还将其最大长度暴露为只读的 <a class="reference internal" href="../library/collections.html#collections.deque.maxlen" title="collections.deque.maxlen"><code class="xref py py-attr docutils literal notranslate"><span class="pre">maxlen</span></code></a> 属性。（这两个特性均由 Raymond Hettinger 添加。)</p>
<p class="translated"><a class="reference internal" href="../library/collections.html#collections.namedtuple" title="collections.namedtuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">namedtuple</span></code></a> 类现在有一个可选的 <em>rename</em> 参数。如果 <em>rename</em> 为真，则由于重复或不是合法的 Python 标识符而无效的字段名将被重命名为基于字段在字段列表中的位置的合法名称：</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">namedtuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;field1&#39;</span><span class="p">,</span> <span class="s1">&#39;$illegal&#39;</span><span class="p">,</span> <span class="s1">&#39;for&#39;</span><span class="p">,</span> <span class="s1">&#39;field2&#39;</span><span class="p">],</span> <span class="n">rename</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span><span class="o">.</span><span class="n">_fields</span>
<span class="go">(&#39;field1&#39;, &#39;_1&#39;, &#39;_2&#39;, &#39;field2&#39;)</span>
</pre></div>
</div>
<p class="translated">（由 Raymond Hettinger 添加；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1818">bpo-1818</a>。）</p>
<p class="translated">最后，<a class="reference internal" href="../library/collections.abc.html#collections.abc.Mapping" title="collections.abc.Mapping"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapping</span></code></a> 抽象基类在将一个映射对象与非 <code class="xref py py-class docutils literal notranslate"><span class="pre">Mapping</span></code> 类型的其他类型进行比较时，现在会返回 <a class="reference internal" href="../library/constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a>。（该问题由 Daniel Stutzbach 修复；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=8729">bpo-8729</a>。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/configparser.html#module-configparser" title="configparser: Configuration file parser."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ConfigParser</span></code></a> 模块中的解析类构造函数现在接受一个 <em>allow_no_value</em> 参数，默认为假；如果为真，将允许没有值的选项。例如：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">ConfigParser</span><span class="o">,</span><span class="w"> </span><span class="nn">StringIO</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample_config</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="gp">... </span><span class="s2">[mysqld]</span>
<span class="gp">... </span><span class="s2">user = mysql</span>
<span class="gp">... </span><span class="s2">pid-file = /var/run/mysqld/mysqld.pid</span>
<span class="gp">... </span><span class="s2">skip-bdb</span>
<span class="gp">... </span><span class="s2">&quot;&quot;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span> <span class="o">=</span> <span class="n">ConfigParser</span><span class="o">.</span><span class="n">RawConfigParser</span><span class="p">(</span><span class="n">allow_no_value</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="o">.</span><span class="n">readfp</span><span class="p">(</span><span class="n">StringIO</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="n">sample_config</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mysqld&#39;</span><span class="p">,</span> <span class="s1">&#39;user&#39;</span><span class="p">)</span>
<span class="go">&#39;mysql&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mysqld&#39;</span><span class="p">,</span> <span class="s1">&#39;skip-bdb&#39;</span><span class="p">)</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mysqld&#39;</span><span class="p">,</span> <span class="s1">&#39;unknown&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">NoOptionError</span>: <span class="n">No option &#39;unknown&#39; in section: &#39;mysqld&#39;</span>
</pre></div>
</div>
<p class="translated">（由 Mats Kindahl 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7005">bpo-7005</a>。）</p>
</li>
<li><p class="translated">已弃用的函数：<code class="xref py py-func docutils literal notranslate"><span class="pre">contextlib.nested()</span></code>，它允许使用单个 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 语句处理多个上下文管理器，已被弃用，因为 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code> 语句现在支持多个上下文管理器。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/http.cookiejar.html#module-http.cookiejar" title="http.cookiejar: Classes for automatic handling of HTTP cookies."><code class="xref py py-mod docutils literal notranslate"><span class="pre">cookielib</span></code></a> 模块现在忽略具有无效版本字段的 cookie，即不包含整数值的版本字段。（由 John J. Lee 修复；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=3924">bpo-3924</a>。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/copy.html#module-copy" title="copy: Shallow and deep copy operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">copy</span></code></a> 模块的 <a class="reference internal" href="../library/copy.html#copy.deepcopy" title="copy.deepcopy"><code class="xref py py-func docutils literal notranslate"><span class="pre">deepcopy()</span></code></a> 函数现在将正确复制绑定的实例方法。（由 Robert Collins 实现；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1515">bpo-1515</a>。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 模块现在总是将 <code class="docutils literal notranslate"><span class="pre">None</span></code> 转换为 C 的 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针，用于声明为指针的参数。（由 Thomas Heller 改动；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4606">bpo-4606</a>。）底层的 <a class="reference external" href="https://sourceware.org/libffi/">libffi 库</a> 已更新至版本 3.0.9，包含对不同平台的多项修复。（由 Matthias Klose 更新；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=8142">bpo-8142</a>。）</p></li>
<li><p class="translated">新方法：<a class="reference internal" href="../library/datetime.html#module-datetime" title="datetime: Basic date and time types."><code class="xref py py-mod docutils literal notranslate"><span class="pre">datetime</span></code></a> 模块的 <a class="reference internal" href="../library/datetime.html#datetime.timedelta" title="datetime.timedelta"><code class="xref py py-class docutils literal notranslate"><span class="pre">timedelta</span></code></a> 类增加了一个 <a class="reference internal" href="../library/datetime.html#datetime.timedelta.total_seconds" title="datetime.timedelta.total_seconds"><code class="xref py py-meth docutils literal notranslate"><span class="pre">total_seconds()</span></code></a> 方法，返回持续时间中的秒数。（由 Brian Quinlan 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5788">bpo-5788</a>。）</p></li>
<li><p class="translated">新方法：<a class="reference internal" href="../library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 类增加了一个 <a class="reference internal" href="../library/decimal.html#decimal.Decimal.from_float" title="decimal.Decimal.from_float"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_float()</span></code></a> 类方法，用于将浮点数精确转换为 <code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code>。这种精确转换力求最接近浮点表示值的十进制近似值；因此，结果十进制值仍会包含任何不准确的部分。例如，<code class="docutils literal notranslate"><span class="pre">Decimal.from_float(0.1)</span></code> 返回 <code class="docutils literal notranslate"><span class="pre">Decimal('0.1000000000000000055511151231257827021181583404541015625')</span></code>。（由 Raymond Hettinger 实现；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4796">bpo-4796</a>。）</p>
<p class="translated">现在，将 <a class="reference internal" href="../library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 实例与浮点数进行比较，会根据操作数的数值产生合理的结果。以前，此类比较会回退到 Python 的默认对象比较规则，这会根据它们的类型产生任意结果。请注意，你仍然不能在其他操作（如加法）中组合 <code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code> 和浮点数，因为你应该明确选择如何在浮点数和 <code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code> 之间进行转换。（由 Mark Dickinson 修复；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2531">bpo-2531</a>。）</p>
<p class="translated"><a class="reference internal" href="../library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 的构造函数现在接受浮点数（由 Raymond Hettinger 添加；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=8257">bpo-8257</a>）和非欧洲 Unicode 字符，如阿拉伯-印度数字（由 Mark Dickinson 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=6595">bpo-6595</a>）。</p>
<p class="translated"><a class="reference internal" href="../library/decimal.html#decimal.Context" title="decimal.Context"><code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code></a> 类的大多数方法现在既接受整数也接受 <a class="reference internal" href="../library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 实例；唯一的例外是 <a class="reference internal" href="../library/decimal.html#decimal.Context.canonical" title="decimal.Context.canonical"><code class="xref py py-meth docutils literal notranslate"><span class="pre">canonical()</span></code></a> 和 <a class="reference internal" href="../library/decimal.html#decimal.Context.is_canonical" title="decimal.Context.is_canonical"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_canonical()</span></code></a> 方法。 (由 Juan José Conti 提交补丁；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7633">bpo-7633</a>)</p>
<p class="translated">当使用 <a class="reference internal" href="../library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 实例与字符串的 <a class="reference internal" href="../library/stdtypes.html#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">format()</span></code></a> 方法时，之前的默认对齐方式是左对齐。这已被更改为右对齐，这对于数值类型更为合理。 (由 Mark Dickinson 更改；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=6857">bpo-6857</a>)</p>
<p class="translated">涉及信号 NaN 值（或 <code class="docutils literal notranslate"><span class="pre">sNAN</span></code>）的比较现在会触发 <a class="reference internal" href="../library/decimal.html#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-const docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a>，而不是根据比较运算符静默地返回真或假值。静默 NaN 值（或 <code class="docutils literal notranslate"><span class="pre">NaN</span></code>）现在可以被哈希。 (由 Mark Dickinson 修复；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7279">bpo-7279</a>)</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/difflib.html#module-difflib" title="difflib: Helpers for computing differences between objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">difflib</span></code></a> 模块现在通过一个小改动，使其输出与现代 <strong class="command">diff</strong>/<strong class="command">patch</strong> 工具更加兼容，即在头部给出文件名时使用制表符而不是空格作为分隔符。 (由 Anatoly Techtonik 修复；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7585">bpo-7585</a>)</p></li>
<li><p class="translated">Distutils 的 <code class="docutils literal notranslate"><span class="pre">sdist</span></code> 命令现在总是重新生成 <code class="file docutils literal notranslate"><span class="pre">MANIFEST</span></code> 文件，因为即使 <code class="file docutils literal notranslate"><span class="pre">MANIFEST.in</span></code> 或 <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code> 文件没有被修改，用户也可能创建了一些应该包含的新文件。 (由 Tarek Ziadé 修复；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=8688">bpo-8688</a>)</p></li>
<li><p class="translated"><a class="reference internal" href="../library/doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> 模块的 <a class="reference internal" href="../library/doctest.html#doctest.IGNORE_EXCEPTION_DETAIL" title="doctest.IGNORE_EXCEPTION_DETAIL"><code class="xref py py-const docutils literal notranslate"><span class="pre">IGNORE_EXCEPTION_DETAIL</span></code></a> 标志现在将忽略包含被测试异常的模块名称。 (由 Lennart Regebro 提交补丁；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7490">bpo-7490</a>)</p></li>
<li><p class="translated"><a class="reference internal" href="../library/email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code></a> 模块的 <a class="reference internal" href="../library/email.compat32-message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> 类现在将接受一个 Unicode 值的有效负载，并自动将有效负载转换为 <code class="xref py py-attr docutils literal notranslate"><span class="pre">output_charset</span></code> 指定的编码。 (由 R. David Murray 添加；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1368247">bpo-1368247</a>)</p></li>
<li><p class="translated"><a class="reference internal" href="../library/fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Fraction</span></code></a> 类现在接受单个浮点数或 <a class="reference internal" href="../library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 实例，或两个有理数作为其构造函数的参数。（由 Mark Dickinson 实现；有理数在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5812">bpo-5812</a> 中添加，浮点数/小数在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=8294">bpo-8294</a> 中添加。）</p>
<p class="translated">分数和复数之间的排序比较（<code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>）现在会引发 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。这一改进修复了一处疏漏，使得 <a class="reference internal" href="../library/fractions.html#fractions.Fraction" title="fractions.Fraction"><code class="xref py py-class docutils literal notranslate"><span class="pre">Fraction</span></code></a> 类型的行为与其他数值类型保持一致。</p>
</li>
<li><p class="translated">新增类：<a class="reference internal" href="../library/ftplib.html#module-ftplib" title="ftplib: FTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ftplib</span></code></a> 模块中的 <a class="reference internal" href="../library/ftplib.html#ftplib.FTP_TLS" title="ftplib.FTP_TLS"><code class="xref py py-class docutils literal notranslate"><span class="pre">FTP_TLS</span></code></a> 类提供使用 TLS 封装的认证以及后续控制和数据传输的安全 FTP 连接。（由 Giampaolo Rodola 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2054">bpo-2054</a>。）</p>
<p class="translated"><a class="reference internal" href="../library/ftplib.html#ftplib.FTP.storbinary" title="ftplib.FTP.storbinary"><code class="xref py py-meth docutils literal notranslate"><span class="pre">storbinary()</span></code></a> 方法用于二进制上传，现在可以通过新增的 <em>rest</em> 参数重新启动上传（由 Pablo Mouzo 提交补丁；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=6845">bpo-6845</a>。）</p>
</li>
<li><p class="translated">新的类装饰器：<a class="reference internal" href="../library/functools.html#module-functools" title="functools: Higher-order functions and operations on callable objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">functools</span></code></a> 模块中的 <a class="reference internal" href="../library/functools.html#functools.total_ordering" title="functools.total_ordering"><code class="xref py py-func docutils literal notranslate"><span class="pre">total_ordering()</span></code></a> 接受一个定义了 <a class="reference internal" href="../reference/datamodel.html#object.__eq__" title="object.__eq__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code></a> 方法和 <a class="reference internal" href="../reference/datamodel.html#object.__lt__" title="object.__lt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__lt__()</span></code></a>、 <a class="reference internal" href="../reference/datamodel.html#object.__le__" title="object.__le__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__le__()</span></code></a>、 <a class="reference internal" href="../reference/datamodel.html#object.__gt__" title="object.__gt__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__gt__()</span></code></a> 或 <a class="reference internal" href="../reference/datamodel.html#object.__ge__" title="object.__ge__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__ge__()</span></code></a> 中之一的类，并生成缺失的比较方法。由于 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__cmp__()</span></code> 方法在 Python 3.x 中已被弃用，此装饰器使得定义有序类更为简便。（由 Raymond Hettinger 添加；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5479">bpo-5479</a>。）</p>
<p class="translated">新增函数：<a class="reference internal" href="../library/functools.html#functools.cmp_to_key" title="functools.cmp_to_key"><code class="xref py py-func docutils literal notranslate"><span class="pre">cmp_to_key()</span></code></a> 将接受一个期望两个参数的旧式比较函数，并返回一个新的可调用对象，该对象可以用作 <a class="reference internal" href="../library/functions.html#sorted" title="sorted"><code class="xref py py-func docutils literal notranslate"><span class="pre">sorted()</span></code></a>、 <a class="reference internal" href="../library/functions.html#min" title="min"><code class="xref py py-func docutils literal notranslate"><span class="pre">min()</span></code></a> 和 <a class="reference internal" href="../library/functions.html#max" title="max"><code class="xref py py-func docutils literal notranslate"><span class="pre">max()</span></code></a> 等函数的 <em>key</em> 参数。其主要用途是帮助代码兼容 Python 3.x。（由 Raymond Hettinger 添加。）</p>
</li>
<li><p class="translated">新增函数：<a class="reference internal" href="../library/gc.html#module-gc" title="gc: Interface to the cycle-detecting garbage collector."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gc</span></code></a> 模块的 <a class="reference internal" href="../library/gc.html#gc.is_tracked" title="gc.is_tracked"><code class="xref py py-func docutils literal notranslate"><span class="pre">is_tracked()</span></code></a> 在给定实例被垃圾回收器跟踪时返回 true，否则返回 false。（由 Antoine Pitrou 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4688">bpo-4688</a>。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/gzip.html#module-gzip" title="gzip: Interfaces for gzip compression and decompression using file objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gzip</span></code></a> 模块的 <a class="reference internal" href="../library/gzip.html#gzip.GzipFile" title="gzip.GzipFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">GzipFile</span></code></a> 现在支持上下文管理协议，因此你可以写 <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">gzip.GzipFile(...)</span> <span class="pre">as</span> <span class="pre">f:</span></code> (由 Hagen Fürstenau 贡献;参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=3860">bpo-3860</a>) ，并且它现在实现了 <a class="reference internal" href="../library/io.html#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BufferedIOBase</span></code></a> ABC，因此你可以用 <a class="reference internal" href="../library/io.html#io.BufferedReader" title="io.BufferedReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BufferedReader</span></code></a> 包装它以加快处理速度（由 Nir Aides 贡献;参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7471">bpo-7471</a>）。现在还可以通过在构造函数中提供可选的时间戳来覆盖 gzip 文件中记录的修改时间。（由 Jacques Frechet 贡献;参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4272">bpo-4272</a>。）</p>
<p class="translated">gzip 格式的文件可以用尾随零字节填充；<a class="reference internal" href="../library/gzip.html#module-gzip" title="gzip: Interfaces for gzip compression and decompression using file objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gzip</span></code></a> 模块现在将消耗这些尾随字节。（由 Tadek Pietraszek 和 Brian Curtin 修复;参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2846">bpo-2846</a>。）</p>
</li>
<li><p class="translated">新属性：<a class="reference internal" href="../library/hashlib.html#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code class="xref py py-mod docutils literal notranslate"><span class="pre">hashlib</span></code></a> 模块现在有一个 <code class="xref py py-attr docutils literal notranslate"><span class="pre">algorithms</span></code> 属性，包含一个命名支持算法的元组。在 Python 2.7 中，<code class="docutils literal notranslate"><span class="pre">hashlib.algorithms</span></code> 包含 <code class="docutils literal notranslate"><span class="pre">('md5',</span> <span class="pre">'sha1',</span> <span class="pre">'sha224',</span> <span class="pre">'sha256',</span> <span class="pre">'sha384',</span> <span class="pre">'sha512')</span></code>。（由 Carl Chenet 贡献;参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7418">bpo-7418</a>。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/http.html#module-http" title="http: HTTP status codes and messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">httplib</span></code></a> 模块使用的默认 <a class="reference internal" href="../library/http.client.html#http.client.HTTPResponse" title="http.client.HTTPResponse"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPResponse</span></code></a> 类现在支持缓冲，从而大大加快了 HTTP 响应的读取速度。（由 Kristján Valur Jónsson 贡献;参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4879">bpo-4879</a>。）</p>
<p class="translated"><a class="reference internal" href="../library/http.client.html#http.client.HTTPConnection" title="http.client.HTTPConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPConnection</span></code></a> 和 <a class="reference internal" href="../library/http.client.html#http.client.HTTPSConnection" title="http.client.HTTPSConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPSConnection</span></code></a> 类现在支持一个 <em>source_address</em> 参数，这是一个 <code class="docutils literal notranslate"><span class="pre">(host,</span> <span class="pre">port)</span></code> 2元组，给出了将用于连接的源地址。（由 Eldon Ziegler 贡献;参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=3972">bpo-3972</a>。）</p>
</li>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ihooks</span></code> 模块现在支持相对导入。请注意，<code class="xref py py-mod docutils literal notranslate"><span class="pre">ihooks</span></code> 是一个用于自定义导入的较旧模块，已被 Python 2.0 中添加的 <code class="xref py py-mod docutils literal notranslate"><span class="pre">imputil</span></code> 模块取代。（相对导入支持由 Neil Schemenauer 添加。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/imaplib.html#module-imaplib" title="imaplib: IMAP4 protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">imaplib</span></code></a> 模块现在支持 IPv6 地址。（由 Derek Morr 贡献;参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1655">bpo-1655</a>。）</p></li>
<li><p class="translated">新功能：<a class="reference internal" href="../library/inspect.html#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect</span></code></a> 模块的 <a class="reference internal" href="../library/inspect.html#inspect.getcallargs" title="inspect.getcallargs"><code class="xref py py-func docutils literal notranslate"><span class="pre">getcallargs()</span></code></a> 函数接受一个可调用对象及其位置和关键字参数，并确定该可调用对象的哪些参数将接收每个参数，返回一个将参数名映射到其值的字典。例如：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">inspect</span><span class="w"> </span><span class="kn">import</span> <span class="n">getcallargs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="o">**</span><span class="n">named</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcallargs</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">{&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;pos&#39;: (3,), &#39;named&#39;: {}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcallargs</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">{&#39;a&#39;: 2, &#39;b&#39;: 1, &#39;pos&#39;: (), &#39;named&#39;: {&#39;x&#39;: 4}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getcallargs</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">f() takes at least 1 argument (0 given)</span>
</pre></div>
</div>
<p class="translated">由 Georg Sakkis 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=3135">bpo-3135</a> 中贡献。</p>
</li>
<li><p class="translated">更新模块：<a class="reference internal" href="../library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a> 库已升级到随 Python 3.1 一起发布的版本。对于 3.1，I/O 库完全用 C 语言重写，根据执行的任务不同，速度提高了 2 到 20 倍。原始的 Python 版本被重命名为 <code class="xref py py-mod docutils literal notranslate"><span class="pre">_pyio</span></code> 模块。</p>
<p class="translated">一个小的变化：<a class="reference internal" href="../library/io.html#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.TextIOBase</span></code></a> 类现在有一个 <a class="reference internal" href="../library/io.html#io.TextIOBase.errors" title="io.TextIOBase.errors"><code class="xref py py-attr docutils literal notranslate"><span class="pre">errors</span></code></a> 属性，用于给出编码和解码错误使用的错误设置（<code class="docutils literal notranslate"><span class="pre">'strict'</span></code>、<code class="docutils literal notranslate"><span class="pre">'replace'</span></code>、<code class="docutils literal notranslate"><span class="pre">'ignore'</span></code> 之一）。</p>
<p class="translated"><a class="reference internal" href="../library/io.html#io.FileIO" title="io.FileIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.FileIO</span></code></a> 类在传递无效文件描述符时现在会引发 <a class="reference internal" href="../library/exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>。(由 Benjamin Peterson 实现；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4991">bpo-4991</a>。) <a class="reference internal" href="../library/io.html#io.IOBase.truncate" title="io.IOBase.truncate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">truncate()</span></code></a> 方法现在保留文件位置；之前它会将文件位置更改为新文件的末尾。(由 Pascal Chambon 修复；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=6939">bpo-6939</a>。)</p>
</li>
<li><p class="translated">新增函数：<code class="docutils literal notranslate"><span class="pre">itertools.compress(data,</span> <span class="pre">selectors)</span></code> 接受两个迭代器。如果 <em>selectors</em> 中对应的值为真，则返回 <em>data</em> 中的元素：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">itertools</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="s1">&#39;ABCDEF&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">=&gt;</span>
  <span class="n">A</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">F</span>
</pre></div>
</div>
<p class="translated">新增函数：<code class="docutils literal notranslate"><span class="pre">itertools.combinations_with_replacement(iter,</span> <span class="pre">r)</span></code> 返回可迭代对象 <em>iter</em> 中所有可能的 <em>r</em> 长度组合。与 <a class="reference internal" href="../library/itertools.html#itertools.combinations" title="itertools.combinations"><code class="xref py py-func docutils literal notranslate"><span class="pre">combinations()</span></code></a> 不同，生成组合中的单个元素可以重复：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations_with_replacement</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">=&gt;</span>
  <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">),</span>
  <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">请注意，元素被视为唯一是根据它们在输入中的位置，而不是它们的实际值。</p>
<p class="translated"><a class="reference internal" href="../library/itertools.html#itertools.count" title="itertools.count"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.count()</span></code></a> 函数现在有一个 <em>step</em> 参数，允许以非1的值递增。<a class="reference internal" href="../library/itertools.html#itertools.count" title="itertools.count"><code class="xref py py-func docutils literal notranslate"><span class="pre">count()</span></code></a> 也现在允许关键字参数，并使用非整数值，例如浮点数或 <a class="reference internal" href="../library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 实例。（由 Raymond Hettinger 实现；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5032">bpo-5032</a>。）</p>
<p class="translated"><a class="reference internal" href="../library/itertools.html#itertools.combinations" title="itertools.combinations"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.combinations()</span></code></a> 和 <a class="reference internal" href="../library/itertools.html#itertools.product" title="itertools.product"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.product()</span></code></a> 函数此前在参数 <em>r</em> 的值大于输入可迭代对象长度时会引发 <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 异常。经认定这是规范定义上的错误，因此现在当出现这种情况时，这两个函数会返回一个空迭代器。（由 Raymond Hettinger 修复；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4816">bpo-4816</a>。）</p>
</li>
<li><p class="translated">更新模块：<a class="reference internal" href="../library/json.html#module-json" title="json: Encode and decode the JSON format."><code class="xref py py-mod docutils literal notranslate"><span class="pre">json</span></code></a> 模块已升级到 simplejson 包的 2.0.9 版本，该版本包括一个 C 扩展，使编码和解码更快。（由 Bob Ippolito 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4136">bpo-4136</a>。）</p>
<p class="translated">为了支持新的 <a class="reference internal" href="../library/collections.html#collections.OrderedDict" title="collections.OrderedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.OrderedDict</span></code></a> 类型，<a class="reference internal" href="../library/json.html#json.load" title="json.load"><code class="xref py py-func docutils literal notranslate"><span class="pre">json.load()</span></code></a> 现在有一个可选的 <em>object_pairs_hook</em> 参数，它将用任何解码为对列表的对象字面量调用。（由 Raymond Hettinger 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5381">bpo-5381</a>。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/mailbox.html#module-mailbox" title="mailbox: Manipulate mailboxes in various formats"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mailbox</span></code></a> 模块的 <a class="reference internal" href="../library/mailbox.html#mailbox.Maildir" title="mailbox.Maildir"><code class="xref py py-class docutils literal notranslate"><span class="pre">Maildir</span></code></a> 类现在记录它读取的目录的时间戳，并且只有在修改时间随后发生变化时才重新读取它们。这通过避免不必要的目录扫描来提高性能。（由 A.M. Kuchling 和 Antoine Pitrou 修复；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1607951">bpo-1607951</a>、 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=6896">bpo-6896</a>。）</p></li>
<li><p class="translated">新增函数：<a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> 模块新增了 <a class="reference internal" href="../library/math.html#math.erf" title="math.erf"><code class="xref py py-func docutils literal notranslate"><span class="pre">erf()</span></code></a> 和 <a class="reference internal" href="../library/math.html#math.erfc" title="math.erfc"><code class="xref py py-func docutils literal notranslate"><span class="pre">erfc()</span></code></a> 用于计算误差函数和互补误差函数，<a class="reference internal" href="../library/math.html#math.expm1" title="math.expm1"><code class="xref py py-func docutils literal notranslate"><span class="pre">expm1()</span></code></a> 用于更精确地计算 <code class="docutils literal notranslate"><span class="pre">e**x</span> <span class="pre">-</span> <span class="pre">1</span></code> 而不是使用 <a class="reference internal" href="../library/math.html#math.exp" title="math.exp"><code class="xref py py-func docutils literal notranslate"><span class="pre">exp()</span></code></a> 并减去 1，<a class="reference internal" href="../library/math.html#math.gamma" title="math.gamma"><code class="xref py py-func docutils literal notranslate"><span class="pre">gamma()</span></code></a> 用于计算伽马函数，以及 <a class="reference internal" href="../library/math.html#math.lgamma" title="math.lgamma"><code class="xref py py-func docutils literal notranslate"><span class="pre">lgamma()</span></code></a> 用于计算伽马函数的自然对数。（由 Mark Dickinson 和 nirinA raseliarison 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=3366">bpo-3366</a>。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> 模块的 <code class="xref py py-class docutils literal notranslate"><span class="pre">Manager*</span></code> 类现在可以传递一个可调用对象，该对象将在子进程启动时被调用，同时还可以传递一组将传递给该可调用对象的参数。（由 lekma 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5585">bpo-5585</a>。）</p>
<p class="translated">控制工作进程池的 <a class="reference internal" href="../library/multiprocessing.html#multiprocessing.pool.Pool" title="multiprocessing.pool.Pool"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pool</span></code></a> 类现在有一个可选的 <em>maxtasksperchild</em> 参数。工作进程将执行指定数量的任务后退出，导致 <code class="xref py py-class docutils literal notranslate"><span class="pre">Pool</span></code> 启动新的工作进程。这在任务可能泄漏内存或其他资源，或者某些任务会使工作进程变得非常大时非常有用。（由 Charles Cazabon 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=6963">bpo-6963</a>。）</p>
</li>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">nntplib</span></code> 模块现在支持 IPv6 地址。（由 Derek Morr 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1664">bpo-1664</a>。）</p></li>
<li><p class="translated">新增函数：<a class="reference internal" href="../library/os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os</span></code></a> 模块封装了以下 POSIX 系统调用：<a class="reference internal" href="../library/os.html#os.getresgid" title="os.getresgid"><code class="xref py py-func docutils literal notranslate"><span class="pre">getresgid()</span></code></a> 和 <a class="reference internal" href="../library/os.html#os.getresuid" title="os.getresuid"><code class="xref py py-func docutils literal notranslate"><span class="pre">getresuid()</span></code></a>，它们返回实际、有效和保存的 GID 和 UID；<a class="reference internal" href="../library/os.html#os.setresgid" title="os.setresgid"><code class="xref py py-func docutils literal notranslate"><span class="pre">setresgid()</span></code></a> 和 <a class="reference internal" href="../library/os.html#os.setresuid" title="os.setresuid"><code class="xref py py-func docutils literal notranslate"><span class="pre">setresuid()</span></code></a>，它们将实际、有效和保存的 GID 和 UID 设置为新值；<a class="reference internal" href="../library/os.html#os.initgroups" title="os.initgroups"><code class="xref py py-func docutils literal notranslate"><span class="pre">initgroups()</span></code></a>，用于初始化当前进程的组访问列表。（GID/UID 函数由 Travis H. 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=6508">bpo-6508</a>。initgroups 支持由 Jean-Paul Calderone 添加；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7333">bpo-7333</a>。）</p>
<p class="translated"><a class="reference internal" href="../library/os.html#os.fork" title="os.fork"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fork()</span></code></a> 函数现在在子进程中重新初始化导入锁；这解决了在 Solaris 上从线程中调用 <a class="reference internal" href="../library/os.html#os.fork" title="os.fork"><code class="xref py py-func docutils literal notranslate"><span class="pre">fork()</span></code></a> 时的问题。（由 Zsolt Cserna 修复；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7242">bpo-7242</a>。）</p>
</li>
<li><p class="translated">在 <a class="reference internal" href="../library/os.path.html#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os.path</span></code></a> 模块中，<a class="reference internal" href="../library/os.path.html#os.path.normpath" title="os.path.normpath"><code class="xref py py-func docutils literal notranslate"><span class="pre">normpath()</span></code></a> 和 <a class="reference internal" href="../library/os.path.html#os.path.abspath" title="os.path.abspath"><code class="xref py py-func docutils literal notranslate"><span class="pre">abspath()</span></code></a> 函数现在可以保留 Unicode；如果它们的输入路径是 Unicode 字符串，返回值也是 Unicode 字符串。(<a class="reference internal" href="../library/os.path.html#os.path.normpath" title="os.path.normpath"><code class="xref py py-meth docutils literal notranslate"><span class="pre">normpath()</span></code></a> 由 Matt Giuca 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5827">bpo-5827</a> 中修复；<a class="reference internal" href="../library/os.path.html#os.path.abspath" title="os.path.abspath"><code class="xref py py-meth docutils literal notranslate"><span class="pre">abspath()</span></code></a> 由 Ezio Melotti 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=3426">bpo-3426</a> 修复。)</p></li>
<li><p class="translated"><a class="reference internal" href="../library/pydoc.html#module-pydoc" title="pydoc: Documentation generator and online help system."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydoc</span></code></a> 模块现在提供了 Python 使用的各种符号的帮助信息。例如，你现在可以执行 <code class="docutils literal notranslate"><span class="pre">help('&lt;&lt;')</span></code> 或 <code class="docutils literal notranslate"><span class="pre">help('&#64;')</span></code>。（由 David Laban 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4739">bpo-4739</a>）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 模块的 <a class="reference internal" href="../library/re.html#re.split" title="re.split"><code class="xref py py-func docutils literal notranslate"><span class="pre">split()</span></code></a>、<a class="reference internal" href="../library/re.html#re.sub" title="re.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub()</span></code></a> 和 <a class="reference internal" href="../library/re.html#re.subn" title="re.subn"><code class="xref py py-func docutils literal notranslate"><span class="pre">subn()</span></code></a> 现在接受一个可选的 <em>flags</em> 参数，以便与其他模块中的函数保持一致。（由 Gregory P. Smith 添加）</p></li>
<li><p class="translated">新增函数：<a class="reference internal" href="../library/runpy.html#module-runpy" title="runpy: Locate and run Python modules without importing them first."><code class="xref py py-mod docutils literal notranslate"><span class="pre">runpy</span></code></a> 模块中的 <a class="reference internal" href="../library/runpy.html#runpy.run_path" title="runpy.run_path"><code class="xref py py-func docutils literal notranslate"><span class="pre">run_path()</span></code></a> 将执行提供的 <em>path</em> 参数中的代码。<em>path</em> 可以是 Python 源文件路径 (<code class="file docutils literal notranslate"><span class="pre">example.py</span></code>)、编译的字节码文件路径 (<code class="file docutils literal notranslate"><span class="pre">example.pyc</span></code>)、目录 (<code class="file docutils literal notranslate"><span class="pre">./package/</span></code>) 或 zip 归档文件路径 (<code class="file docutils literal notranslate"><span class="pre">example.zip</span></code>)。如果提供的是目录或 zip 路径，它将被添加到 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> 的前面，并导入模块 <a class="reference internal" href="../library/__main__.html#module-__main__" title="__main__: The environment where top-level code is run. Covers command-line interfaces, import-time behavior, and ``__name__ == '__main__'``."><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code></a>。预期目录或 zip 包含一个 <code class="file docutils literal notranslate"><span class="pre">__main__.py</span></code>；如果没有，可能会从 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> 中后面的位置导入其他 <code class="file docutils literal notranslate"><span class="pre">__main__.py</span></code>。这使得脚本能够利用 <a class="reference internal" href="../library/runpy.html#module-runpy" title="runpy: Locate and run Python modules without importing them first."><code class="xref py py-mod docutils literal notranslate"><span class="pre">runpy</span></code></a> 模块的更多机制，从而模拟 Python 命令行处理显式路径名称的方式。（由 Nick Coghlan 添加；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=6816">bpo-6816</a>）</p></li>
<li><p class="translated">新增函数：在 <a class="reference internal" href="../library/shutil.html#module-shutil" title="shutil: High-level file operations, including copying."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shutil</span></code></a> 模块中，<a class="reference internal" href="../library/shutil.html#shutil.make_archive" title="shutil.make_archive"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_archive()</span></code></a> 接受一个文件名、归档类型（zip 或 tar 格式）和目录路径，并创建一个包含目录内容的归档文件。（由 Tarek Ziadé 添加）</p>
<p class="translated"><a class="reference internal" href="../library/shutil.html#module-shutil" title="shutil: High-level file operations, including copying."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shutil</span></code></a> 模块的 <a class="reference internal" href="../library/shutil.html#shutil.copyfile" title="shutil.copyfile"><code class="xref py py-func docutils literal notranslate"><span class="pre">copyfile()</span></code></a> 和 <a class="reference internal" href="../library/shutil.html#shutil.copytree" title="shutil.copytree"><code class="xref py py-func docutils literal notranslate"><span class="pre">copytree()</span></code></a> 函数现在在尝试复制命名管道时将引发 <a class="reference internal" href="../library/shutil.html#shutil.SpecialFileError" title="shutil.SpecialFileError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SpecialFileError</span></code></a> 异常。此前代码会将命名管道视为普通文件并尝试打开它们进行读取，这会导致无限阻塞。（由 Antoine Pitrou 修复；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=3002">bpo-3002</a>。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/signal.html#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal notranslate"><span class="pre">signal</span></code></a> 模块现在不再重新安装信号处理程序，除非确实必要，这修复了一个可能导致无法稳健捕获 EINTR 信号的错误。（由 Charles-Francois Natali 修复；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=8354">bpo-8354</a>。）</p></li>
<li><p class="translated">新增函数：在 <a class="reference internal" href="../library/site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code></a> 模块中，新增了三个函数返回各种站点和用户特定的路径。<a class="reference internal" href="../library/site.html#site.getsitepackages" title="site.getsitepackages"><code class="xref py py-func docutils literal notranslate"><span class="pre">getsitepackages()</span></code></a> 返回包含所有全局 site-packages 目录的列表，<a class="reference internal" href="../library/site.html#site.getusersitepackages" title="site.getusersitepackages"><code class="xref py py-func docutils literal notranslate"><span class="pre">getusersitepackages()</span></code></a> 返回用户 site-packages 目录的路径，<a class="reference internal" href="../library/site.html#site.getuserbase" title="site.getuserbase"><code class="xref py py-func docutils literal notranslate"><span class="pre">getuserbase()</span></code></a> 返回 <a class="reference internal" href="../library/site.html#site.USER_BASE" title="site.USER_BASE"><code class="xref py py-data docutils literal notranslate"><span class="pre">USER_BASE</span></code></a> 环境变量的值，给出可用于存储数据的目录路径。（由 Tarek Ziadé 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=6693">bpo-6693</a>。）</p>
<p class="translated"><a class="reference internal" href="../library/site.html#module-site" title="site: Module responsible for site-specific configuration."><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code></a> 模块现在会报告在导入 <a class="reference internal" href="../library/site.html#module-sitecustomize" title="sitecustomize"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sitecustomize</span></code></a> 模块时发生的异常，并且不再捕获并吞掉 <a class="reference internal" href="../library/exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> 异常。（由 Victor Stinner 修复；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=3137">bpo-3137</a>。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/socket.html#socket.create_connection" title="socket.create_connection"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_connection()</span></code></a> 函数新增了一个 <em>source_address</em> 参数，这是一个 <code class="docutils literal notranslate"><span class="pre">(host,</span> <span class="pre">port)</span></code> 2元组，指定用于连接的源地址。（由 Eldon Ziegler 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=3972">bpo-3972</a>。）</p>
<p class="translated"><a class="reference internal" href="../library/socket.html#socket.socket.recv_into" title="socket.socket.recv_into"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recv_into()</span></code></a> 和 <a class="reference internal" href="../library/socket.html#socket.socket.recvfrom_into" title="socket.socket.recvfrom_into"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recvfrom_into()</span></code></a> 方法现在支持将接收的数据写入实现了缓冲区 API 的对象，最常用的是 <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 和 <a class="reference internal" href="../library/stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> 对象。（由 Antoine Pitrou 实现；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=8104">bpo-8104</a>。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/socketserver.html#module-socketserver" title="socketserver: A framework for network servers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">SocketServer</span></code></a> 模块的 <a class="reference internal" href="../library/socketserver.html#socketserver.TCPServer" title="socketserver.TCPServer"><code class="xref py py-class docutils literal notranslate"><span class="pre">TCPServer</span></code></a> 类现在支持套接字超时和禁用 Nagle 算法。<code class="xref py py-attr docutils literal notranslate"><span class="pre">disable_nagle_algorithm</span></code> 类属性默认为 <code class="docutils literal notranslate"><span class="pre">False</span></code>；如果覆盖为 true，新的请求连接将设置 TCP_NODELAY 选项，以防止将多个小发送包缓冲到单个 TCP 数据包中。<a class="reference internal" href="../library/socketserver.html#socketserver.BaseServer.timeout" title="socketserver.BaseServer.timeout"><code class="xref py py-attr docutils literal notranslate"><span class="pre">timeout</span></code></a> 类属性可以包含一个以秒为单位的超时时间，该时间将应用于请求套接字；如果在规定时间内未收到请求，将调用 <a class="reference internal" href="../library/socketserver.html#socketserver.BaseServer.handle_timeout" title="socketserver.BaseServer.handle_timeout"><code class="xref py py-meth docutils literal notranslate"><span class="pre">handle_timeout()</span></code></a>，并且 <a class="reference internal" href="../library/socketserver.html#socketserver.BaseServer.handle_request" title="socketserver.BaseServer.handle_request"><code class="xref py py-meth docutils literal notranslate"><span class="pre">handle_request()</span></code></a> 将返回。（由 Kristján Valur Jónsson 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=6192">bpo-6192</a> 和 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=6267">bpo-6267</a>。）</p></li>
<li><p class="translated">更新模块：<a class="reference internal" href="../library/sqlite3.html#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> 模块已更新到 <a class="reference external" href="https://github.com/ghaering/pysqlite">pysqlite 包</a> 的 2.6.0 版本。2.6.0 版本包括多项 bug 修复，并增加了从共享库加载 SQLite 扩展的能力。调用 <code class="docutils literal notranslate"><span class="pre">enable_load_extension(True)</span></code> 方法以启用扩展，然后调用 <a class="reference internal" href="../library/sqlite3.html#sqlite3.Connection.load_extension" title="sqlite3.Connection.load_extension"><code class="xref py py-meth docutils literal notranslate"><span class="pre">load_extension()</span></code></a> 以加载特定的共享库。（由 Gerhard Häring 更新。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/ssl.html#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> 模块的 <a class="reference internal" href="../library/ssl.html#ssl.SSLSocket" title="ssl.SSLSocket"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> 对象现在支持缓冲区 API，这修复了测试套件失败的问题（由 Antoine Pitrou 修复；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7133">bpo-7133</a>），并自动设置 OpenSSL 的 <code class="xref c c-macro docutils literal notranslate"><span class="pre">SSL_MODE_AUTO_RETRY</span></code>，这将防止从触发 SSL 重新协商的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">recv()</span></code> 操作返回错误代码（由 Antoine Pitrou 修复；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=8222">bpo-8222</a>）。</p>
<p class="translated"><a class="reference internal" href="../library/ssl.html#ssl.SSLContext.wrap_socket" title="ssl.SSLContext.wrap_socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a> 构造函数现在接受一个 <em>ciphers</em> 参数，该参数是一个列出允许的加密算法的字符串；字符串的格式在 <a class="reference external" href="https://docs.openssl.org/1.0.2/man1/ciphers/">OpenSSL 文档</a> 中描述。（由 Antoine Pitrou 添加；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=8322">bpo-8322</a>。）</p>
<p class="translated">另一项更改使扩展加载了所有OpenSSL的加密算法和摘要算法，以便它们全部可用。一些SSL证书无法验证，会报告“未知算法”错误。（由Beda Kosata报告，Antoine Pitrou修复；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=8484">bpo-8484</a>。）</p>
<p class="translated">当前使用的OpenSSL版本现在可以作为模块属性 <a class="reference internal" href="../library/ssl.html#ssl.OPENSSL_VERSION" title="ssl.OPENSSL_VERSION"><code class="xref py py-const docutils literal notranslate"><span class="pre">ssl.OPENSSL_VERSION</span></code></a> (一个字符串) 、<a class="reference internal" href="../library/ssl.html#ssl.OPENSSL_VERSION_INFO" title="ssl.OPENSSL_VERSION_INFO"><code class="xref py py-const docutils literal notranslate"><span class="pre">ssl.OPENSSL_VERSION_INFO</span></code></a> (一个5元组) 和 <a class="reference internal" href="../library/ssl.html#ssl.OPENSSL_VERSION_NUMBER" title="ssl.OPENSSL_VERSION_NUMBER"><code class="xref py py-const docutils literal notranslate"><span class="pre">ssl.OPENSSL_VERSION_NUMBER</span></code></a> (一个整数) 使用。（由Antoine Pitrou添加；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=8321">bpo-8321</a>。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> 模块将不再在值对于特定整数格式代码（<code class="docutils literal notranslate"><span class="pre">bBhHiIlLqQ</span></code> 之一）过大时静默忽略溢出错误；它现在总是引发 <a class="reference internal" href="../library/struct.html#struct.error" title="struct.error"><code class="xref py py-exc docutils literal notranslate"><span class="pre">struct.error</span></code></a> 异常。(由 Mark Dickinson 更改；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1523">bpo-1523</a>。) <a class="reference internal" href="../library/struct.html#struct.pack" title="struct.pack"><code class="xref py py-func docutils literal notranslate"><span class="pre">pack()</span></code></a> 函数也将尝试使用 <a class="reference internal" href="../reference/datamodel.html#object.__index__" title="object.__index__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code></a> 来转换并打包非整数，然后再尝试 <a class="reference internal" href="../reference/datamodel.html#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code></a> 方法或报告错误。(由 Mark Dickinson 更改；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=8300">bpo-8300</a>。)</p></li>
<li><p class="translated">新增函数：<a class="reference internal" href="../library/subprocess.html#module-subprocess" title="subprocess: Subprocess management."><code class="xref py py-mod docutils literal notranslate"><span class="pre">subprocess</span></code></a> 模块的 <a class="reference internal" href="../library/subprocess.html#subprocess.check_output" title="subprocess.check_output"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_output()</span></code></a> 运行一个带有指定参数集的命令，并在命令无错误运行时返回命令的输出作为字符串，否则引发 <a class="reference internal" href="../library/subprocess.html#subprocess.CalledProcessError" title="subprocess.CalledProcessError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">CalledProcessError</span></code></a> 异常。</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">subprocess</span><span class="o">.</span><span class="n">check_output</span><span class="p">([</span><span class="s1">&#39;df&#39;</span><span class="p">,</span> <span class="s1">&#39;-h&#39;</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">])</span>
<span class="go">&#39;Filesystem     Size   Used  Avail Capacity  Mounted on\n</span>
<span class="go">/dev/disk0s2    52G    49G   3.0G    94%    /\n&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">subprocess</span><span class="o">.</span><span class="n">check_output</span><span class="p">([</span><span class="s1">&#39;df&#39;</span><span class="p">,</span> <span class="s1">&#39;-h&#39;</span><span class="p">,</span> <span class="s1">&#39;/bogus&#39;</span><span class="p">])</span>
<span class="go">  ...</span>
<span class="go">subprocess.CalledProcessError: Command &#39;[&#39;df&#39;, &#39;-h&#39;, &#39;/bogus&#39;]&#39; returned non-zero exit status 1</span>
</pre></div>
</div>
<p class="translated">（由 Gregory P. Smith 贡献）</p>
<p class="translated"><a class="reference internal" href="../library/subprocess.html#module-subprocess" title="subprocess: Subprocess management."><code class="xref py py-mod docutils literal notranslate"><span class="pre">subprocess</span></code></a> 模块现在在接收到 <a class="reference internal" href="../library/errno.html#errno.EINTR" title="errno.EINTR"><code class="xref py py-const docutils literal notranslate"><span class="pre">EINTR</span></code></a> 信号时会重试其内部系统调用。（由多人报告；最终补丁由 Gregory P. Smith 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1068268">bpo-1068268</a> 中提供。）</p>
</li>
<li><p class="translated">新增函数：在 <a class="reference internal" href="../library/symtable.html#module-symtable" title="symtable: Interface to the compiler's internal symbol tables."><code class="xref py py-mod docutils literal notranslate"><span class="pre">symtable</span></code></a> 模块中的 <a class="reference internal" href="../library/symtable.html#symtable.Symbol.is_declared_global" title="symtable.Symbol.is_declared_global"><code class="xref py py-func docutils literal notranslate"><span class="pre">is_declared_global()</span></code></a> 函数，对于明确声明为全局变量的变量返回 true，对于隐式全局变量返回 false。（由 Jeremy Hylton 贡献。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/syslog.html#module-syslog" title="syslog: An interface to the Unix syslog library routines. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">syslog</span></code></a> 模块现在将使用 <code class="docutils literal notranslate"><span class="pre">sys.argv[0]</span></code> 的值作为标识符，而不是之前的默认值 <code class="docutils literal notranslate"><span class="pre">'python'</span></code>。（由 Sean Reifschneider 更改；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=8451">bpo-8451</a>。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/sys.html#sys.version_info" title="sys.version_info"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.version_info</span></code></a> 的值现在是一个具名元组，其属性名为 <code class="xref py py-attr docutils literal notranslate"><span class="pre">major</span></code>、<code class="xref py py-attr docutils literal notranslate"><span class="pre">minor</span></code>、<code class="xref py py-attr docutils literal notranslate"><span class="pre">micro</span></code>、<code class="xref py py-attr docutils literal notranslate"><span class="pre">releaselevel</span></code> 和 <code class="xref py py-attr docutils literal notranslate"><span class="pre">serial</span></code>。（由 Ross Light 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4285">bpo-4285</a>。）</p>
<p class="translated"><a class="reference internal" href="../library/sys.html#sys.getwindowsversion" title="sys.getwindowsversion"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getwindowsversion()</span></code></a> 也返回一个具名元组，其属性名为 <code class="xref py py-attr docutils literal notranslate"><span class="pre">major</span></code>、<code class="xref py py-attr docutils literal notranslate"><span class="pre">minor</span></code>、<code class="xref py py-attr docutils literal notranslate"><span class="pre">build</span></code>、<code class="xref py py-attr docutils literal notranslate"><span class="pre">platform</span></code>、<code class="xref py py-attr docutils literal notranslate"><span class="pre">service_pack</span></code>、<code class="xref py py-attr docutils literal notranslate"><span class="pre">service_pack_major</span></code>、<code class="xref py py-attr docutils literal notranslate"><span class="pre">service_pack_minor</span></code>、<code class="xref py py-attr docutils literal notranslate"><span class="pre">suite_mask</span></code> 和 <code class="xref py py-attr docutils literal notranslate"><span class="pre">product_type</span></code>。（由 Brian Curtin 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7766">bpo-7766</a>。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/tarfile.html#module-tarfile" title="tarfile: Read and write tar-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tarfile</span></code></a> 模块的默认错误处理已更改，不再抑制致命错误。之前的默认错误级别为 0，这意味着错误只会导致一条消息被写入调试日志，但由于调试日志默认不激活，这些错误会被忽略。现在的默认错误级别为 1，如果出现错误会引发异常。（由 Lars Gustäbel 改变；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7357">bpo-7357</a>。）</p>
<p class="translated"><a class="reference internal" href="../library/tarfile.html#module-tarfile" title="tarfile: Read and write tar-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tarfile</span></code></a> 现在支持过滤添加到 tar 文件中的 <a class="reference internal" href="../library/tarfile.html#tarfile.TarInfo" title="tarfile.TarInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarInfo</span></code></a> 对象。当你调用 <a class="reference internal" href="../library/tarfile.html#tarfile.TarFile.add" title="tarfile.TarFile.add"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add()</span></code></a> 时，可以提供一个可选的 <em>filter</em> 参数，该参数是一个可调用的函数。<em>filter</em> 可调用函数将为每个被添加的文件传递 <a class="reference internal" href="../library/tarfile.html#tarfile.TarInfo" title="tarfile.TarInfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarInfo</span></code></a>，并可以修改并返回它。如果可调用函数返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>，该文件将被排除在最终归档之外。这比现有的 <em>exclude</em> 参数更强大，因此 <em>exclude</em> 参数已被弃用。(由 Lars Gustäbel 添加；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=6856">bpo-6856</a>。) <a class="reference internal" href="../library/tarfile.html#tarfile.TarFile" title="tarfile.TarFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">TarFile</span></code></a> 类现在也支持上下文管理协议。（由 Lars Gustäbel 添加；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7232">bpo-7232</a>。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/threading.html#threading.Event" title="threading.Event"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Event</span></code></a> 类的 <a class="reference internal" href="../library/threading.html#threading.Event.wait" title="threading.Event.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> 方法现在在退出时返回内部标志。这意味着该方法通常会返回 true，因为 <a class="reference internal" href="../library/threading.html#threading.Event.wait" title="threading.Event.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> 应该阻塞直到内部标志变为 true。只有在提供了超时并且操作超时时，返回值才会是 false。（由 Tim Lesher 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1674032">bpo-1674032</a>。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/unicodedata.html#module-unicodedata" title="unicodedata: Access the Unicode Database."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unicodedata</span></code></a> 模块提供的 Unicode 数据库现在用于内部确定哪些字符是数字、空格或表示换行。该数据库还包括来自 <code class="file docutils literal notranslate"><span class="pre">Unihan.txt</span></code> 数据文件的信息（由 Anders Chrigström 和 Amaury Forgeot d'Arc 提交的补丁；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1571184">bpo-1571184</a>），并已更新到版本 5.2.0（由 Florent Xicluna 更新；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=8024">bpo-8024</a>。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/urllib.parse.html#module-urllib.parse" title="urllib.parse: Parse URLs into or assemble them from components."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urlparse</span></code></a> 模块的 <a class="reference internal" href="../library/urllib.parse.html#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlsplit()</span></code></a> 现在以一种符合 <span class="target" id="index-61"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3986.html"><strong>RFC 3986</strong></a> 的方式处理未知的 URL 方案：如果 URL 形如 <code class="docutils literal notranslate"><span class="pre">&quot;&lt;something&gt;://...&quot;</span></code>，则 <code class="docutils literal notranslate"><span class="pre">://</span></code> 之前的文本被视为方案，即使它是一个模块不知道的自定义方案。这一更改可能会破坏针对旧行为进行工作的代码。例如，Python 2.6.4 或 2.5 将返回以下内容：</p>
<div class="translated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">urlparse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urlparse</span><span class="o">.</span><span class="n">urlsplit</span><span class="p">(</span><span class="s1">&#39;invented://host/filename?query&#39;</span><span class="p">)</span>
<span class="go">(&#39;invented&#39;, &#39;&#39;, &#39;//host/filename?query&#39;, &#39;&#39;, &#39;&#39;)</span>
</pre></div>
</div>
<p class="translated">Python 2.7（以及Python 2.6.5）将返回：</p>
<div class="translated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">urlparse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urlparse</span><span class="o">.</span><span class="n">urlsplit</span><span class="p">(</span><span class="s1">&#39;invented://host/filename?query&#39;</span><span class="p">)</span>
<span class="go">(&#39;invented&#39;, &#39;host&#39;, &#39;/filename?query&#39;, &#39;&#39;, &#39;&#39;)</span>
</pre></div>
</div>
<p class="translated">（Python 2.7实际上产生的输出略有不同，因为它返回的是一个具名元组而不是标准元组。）</p>
<p class="translated"><a class="reference internal" href="../library/urllib.parse.html#module-urllib.parse" title="urllib.parse: Parse URLs into or assemble them from components."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urlparse</span></code></a> 模块还支持由 <span class="target" id="index-62"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2732.html"><strong>RFC 2732</strong></a> 定义的IPv6文字地址（由Senthil Kumaran贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2987">bpo-2987</a>）。</p>
<div class="translated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">urlparse</span><span class="o">.</span><span class="n">urlparse</span><span class="p">(</span><span class="s1">&#39;http://[1080::8:800:200C:417A]/foo&#39;</span><span class="p">)</span>
<span class="go">ParseResult(scheme=&#39;http&#39;, netloc=&#39;[1080::8:800:200C:417A]&#39;,</span>
<span class="go">            path=&#39;/foo&#39;, params=&#39;&#39;, query=&#39;&#39;, fragment=&#39;&#39;)</span>
</pre></div>
</div>
</li>
<li><p class="translated">新增类：<a class="reference internal" href="../library/weakref.html#module-weakref" title="weakref: Support for weak references and weak dictionaries."><code class="xref py py-mod docutils literal notranslate"><span class="pre">weakref</span></code></a> 模块中的 <a class="reference internal" href="../library/weakref.html#weakref.WeakSet" title="weakref.WeakSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">WeakSet</span></code></a> 类是一个集合，它只对其元素保持弱引用；一旦没有引用指向这些元素，它们将被移除。（最初由 Raymond Hettinger 在 Python 3.x 中实现，并由 Michael Foord 向下移植到2.7。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/xml.etree.elementtree.html#module-xml.etree.ElementTree" title="xml.etree.ElementTree: Implementation of the ElementTree API."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.ElementTree</span></code></a> 库在输出XML处理指令（看起来像``&lt;?xml-stylesheet href=&quot;#style1&quot;?&gt;``）或注释（看起来像``&lt;!-- comment --&gt;``）时，不再转义与符号“&amp;”和尖括号“&lt;&gt;”。（由Neil Muller修补；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2746">bpo-2746</a>。）</p></li>
<li><p class="translated">由 <a class="reference internal" href="../library/xmlrpc.client.html#module-xmlrpc.client" title="xmlrpc.client: XML-RPC client access."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xmlrpclib</span></code></a> 和 <a class="reference internal" href="../library/xmlrpc.server.html#module-xmlrpc.server" title="xmlrpc.server: Basic XML-RPC server implementations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">SimpleXMLRPCServer</span></code></a> 模块提供的XML-RPC客户端和服务器，通过支持HTTP/1.1保持连接和可选使用gzip编码压缩交换的XML，提高了性能。gzip压缩由 <a class="reference internal" href="../library/xmlrpc.server.html#xmlrpc.server.SimpleXMLRPCRequestHandler" title="xmlrpc.server.SimpleXMLRPCRequestHandler"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimpleXMLRPCRequestHandler</span></code></a> 的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">encode_threshold</span></code> 属性控制，该属性包含一个字节大小；大于此大小的响应将被压缩。（由Kristján Valur Jónsson贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=6267">bpo-6267</a>。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/zipfile.html#module-zipfile" title="zipfile: Read and write ZIP-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipfile</span></code></a> 模块的 <a class="reference internal" href="../library/zipfile.html#zipfile.ZipFile" title="zipfile.ZipFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">ZipFile</span></code></a> 现在支持上下文管理协议，因此你可以写 <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">zipfile.ZipFile(...)</span> <span class="pre">as</span> <span class="pre">f:</span></code>。（由 Brian Curtin 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5511">bpo-5511</a>。）</p>
<p class="translated"><a class="reference internal" href="../library/zipfile.html#module-zipfile" title="zipfile: Read and write ZIP-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipfile</span></code></a> 现在也支持归档空目录并正确提取它们。（由 Kuba Wieczorek 修复；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4710">bpo-4710</a>。）从归档中读取文件更快，交替使用 <a class="reference internal" href="../library/io.html#io.BufferedIOBase.read" title="io.BufferedIOBase.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a> 和 <a class="reference internal" href="../library/io.html#io.IOBase.readline" title="io.IOBase.readline"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code></a> 现在也能正确工作。（由 Nir Aides 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7610">bpo-7610</a>。）</p>
<p class="translated"><a class="reference internal" href="../library/zipfile.html#zipfile.is_zipfile" title="zipfile.is_zipfile"><code class="xref py py-func docutils literal notranslate"><span class="pre">is_zipfile()</span></code></a> 函数现在接受文件对象，除了早期版本中接受的路径名。（由 Gabriel Genellina 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4756">bpo-4756</a>。）</p>
<p class="translated"><a class="reference internal" href="../library/zipfile.html#zipfile.ZipFile.writestr" title="zipfile.ZipFile.writestr"><code class="xref py py-meth docutils literal notranslate"><span class="pre">writestr()</span></code></a> 方法现在有一个可选的 <em>compress_type</em> 参数，允许你覆盖在 <a class="reference internal" href="../library/zipfile.html#zipfile.ZipFile" title="zipfile.ZipFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">ZipFile</span></code></a> 构造函数中指定的默认压缩方法。（由 Ronald Oussoren 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=6003">bpo-6003</a>。）</p>
</li>
</ul>
<section id="new-module-importlib">
<span id="importlib-section"></span><h3 class="translated">新增模块：importlib<a class="headerlink" href="#new-module-importlib" title="Link to this heading">¶</a></h3>
<p class="translated">Python 3.1 包含 <a class="reference internal" href="../library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a> 包，这是对 Python 的 <a class="reference internal" href="../reference/simple_stmts.html#import"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">import</span></code></a> 语句背后逻辑的重新实现。<a class="reference internal" href="../library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a> 对 Python 解释器的实现者和希望编写新导入器以参与导入过程的用户很有用。Python 2.7 不包含完整的 <a class="reference internal" href="../library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a> 包，而是有一个小型的子集，其中包含一个单一函数，<a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code></a>。</p>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">import_module(name,</span> <span class="pre">package=None)</span></code> 导入一个模块。<em>name</em> 是一个包含模块或包名称的字符串。可以通过提供一个以 <code class="docutils literal notranslate"><span class="pre">.</span></code> 字符开头的字符串来进行相对导入，例如 <code class="docutils literal notranslate"><span class="pre">..utils.errors</span></code>。对于相对导入，必须提供 <em>package</em> 参数，它是将用作相对导入锚点的包名称。<a class="reference internal" href="../library/importlib.html#importlib.import_module" title="importlib.import_module"><code class="xref py py-func docutils literal notranslate"><span class="pre">import_module()</span></code></a> 既将导入的模块插入到 <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code> 中，也返回模块对象。</p>
<p class="translated">这是一些例子:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">importlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">import_module</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">anydbm</span> <span class="o">=</span> <span class="n">import_module</span><span class="p">(</span><span class="s1">&#39;anydbm&#39;</span><span class="p">)</span>  <span class="c1"># 标准的绝对导入</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">anydbm</span>
<span class="go">&lt;module &#39;anydbm&#39; from &#39;/p/python/Lib/anydbm.py&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 相对导入</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">file_util</span> <span class="o">=</span> <span class="n">import_module</span><span class="p">(</span><span class="s1">&#39;..file_util&#39;</span><span class="p">,</span> <span class="s1">&#39;distutils.command&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">file_util</span>
<span class="go">&lt;module &#39;distutils.file_util&#39; from &#39;/python/Lib/distutils/file_util.pyc&#39;&gt;</span>
</pre></div>
</div>
<p class="translated"><a class="reference internal" href="../library/importlib.html#module-importlib" title="importlib: The implementation of the import machinery."><code class="xref py py-mod docutils literal notranslate"><span class="pre">importlib</span></code></a> 由 Brett Cannon 实现，并在 Python 3.1 中引入。</p>
</section>
<section id="new-module-sysconfig">
<h3 class="translated">新增模块：sysconfig<a class="headerlink" href="#new-module-sysconfig" title="Link to this heading">¶</a></h3>
<p class="translated"><a class="reference internal" href="../library/sysconfig.html#module-sysconfig" title="sysconfig: Python's configuration information"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sysconfig</span></code></a> 模块已从 Distutils 包中提取出来，成为一个新的顶级模块。<a class="reference internal" href="../library/sysconfig.html#module-sysconfig" title="sysconfig: Python's configuration information"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sysconfig</span></code></a> 提供了用于获取有关 Python 构建过程信息的函数：编译器开关、安装路径、平台名称以及 Python 是否从其源目录运行。</p>
<p class="translated">该模块中的部分函数:</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="../library/sysconfig.html#sysconfig.get_config_var" title="sysconfig.get_config_var"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_config_var()</span></code></a> 返回来自 Python 的 Makefile 和 <code class="file docutils literal notranslate"><span class="pre">pyconfig.h</span></code> 文件的变量。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/sysconfig.html#sysconfig.get_config_vars" title="sysconfig.get_config_vars"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_config_vars()</span></code></a> 返回一个包含所有配置变量的字典。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/sysconfig.html#sysconfig.get_path" title="sysconfig.get_path"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_path()</span></code></a> 返回特定模块类型的配置路径：标准库、站点专属模块、平台专属模块等等。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/sysconfig.html#sysconfig.is_python_build" title="sysconfig.is_python_build"><code class="xref py py-func docutils literal notranslate"><span class="pre">is_python_build()</span></code></a> 会在你从 Python 源码树运行二进制可执行文件时返回真值，而在其他情况下返回假值。</p></li>
</ul>
<p class="translated">请参阅 <a class="reference internal" href="../library/sysconfig.html#module-sysconfig" title="sysconfig: Python's configuration information"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sysconfig</span></code></a> 文档以获取更多详细信息以及完整的函数列表。</p>
<p class="translated">Distutils 包和 <a class="reference internal" href="../library/sysconfig.html#module-sysconfig" title="sysconfig: Python's configuration information"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sysconfig</span></code></a> 现由 Tarek Ziadé 维护，他还启动了一个 Distutils2 包（源代码仓库位于 <a class="reference external" href="https://hg.python.org/distutils2/">https://hg.python.org/distutils2/</a>），用于开发 Distutils 的下一代版本。</p>
</section>
<section id="ttk-themed-widgets-for-tk">
<h3 class="translated">ttk：Tk 主题组件<a class="headerlink" href="#ttk-themed-widgets-for-tk" title="Link to this heading">¶</a></h3>
<p class="translated">Tcl/Tk 8.5 包含一组主题化的小部件，这些小部件重新实现了基本的 Tk 小部件，但具有更可定制的外观，因此可以更接近本地平台的小部件。这个小部件集最初称为 Tile，但在添加到 Tcl/Tk 8.5 版本时被重命名为 Ttk（意为“主题化 Tk”）。</p>
<p class="translated">要了解更多信息，请阅读 <a class="reference internal" href="../library/tkinter.ttk.html#module-tkinter.ttk" title="tkinter.ttk: Tk themed widget set"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ttk</span></code></a> 模块文档。你可能还希望阅读 Tcl/Tk 手册页，其中描述了 Ttk 主题引擎，位于 <a class="reference external" href="https://www.tcl.tk/man/tcl8.5/TkCmd/ttk_intro.html">https://www.tcl.tk/man/tcl8.5/TkCmd/ttk_intro.html</a>。一些 Python/Ttk 代码的截图可在 <a class="reference external" href="https://code.google.com/archive/p/python-ttk/wikis/Screenshots.wiki">https://code.google.com/archive/p/python-ttk/wikis/Screenshots.wiki</a> 查看。</p>
<p class="translated"><a class="reference internal" href="../library/tkinter.ttk.html#module-tkinter.ttk" title="tkinter.ttk: Tk themed widget set"><code class="xref py py-mod docutils literal notranslate"><span class="pre">tkinter.ttk</span></code></a> 模块由 Guilherme Polo 编写，并在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2983">bpo-2983</a> 中添加。另一个版本名为 <code class="docutils literal notranslate"><span class="pre">Tile.py</span></code>，由 Martin Franklin 编写并由 Kevin Walzer 维护，曾在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2618">bpo-2618</a> 中提议纳入，但作者们认为 Guilherme Polo 的工作更为全面。</p>
</section>
<section id="updated-module-unittest">
<span id="unittest-section"></span><h3 class="translated">更新的模块：unittest<a class="headerlink" href="#updated-module-unittest" title="Link to this heading">¶</a></h3>
<p class="translated"><a class="reference internal" href="../library/unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 模块得到了大幅增强；添加了许多新功能。这些功能大多由 Michael Foord 实现，除非另有说明。该模块的增强版本可以单独下载，用于 Python 2.4 至 2.6 版本，打包为 <code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest2</span></code> 包，可从 <a class="extlink-pypi reference external" href="https://pypi.org/project/unittest2/">unittest2</a> 获取。</p>
<p class="translated">当从命令行使用时，该模块可以自动发现测试。它不如 <a class="reference external" href="https://pytest.org">py.test</a> 或 <a class="reference external" href="https://nose.readthedocs.io/">nose</a> 那么花哨，但提供了一种简单的方式来运行保存在一组包目录中的测试。例如，以下命令将搜索 <code class="file docutils literal notranslate"><span class="pre">test/</span></code> 子目录中名为 <code class="docutils literal notranslate"><span class="pre">test*.py</span></code> 的任何可导入测试文件：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">unittest</span> <span class="n">discover</span> <span class="o">-</span><span class="n">s</span> <span class="n">test</span>
</pre></div>
</div>
<p class="translated">更多详细信息，请参阅 <a class="reference internal" href="../library/unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 模块文档。（开发于 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=6001">bpo-6001</a>。）</p>
<p class="translated"><a class="reference internal" href="../library/unittest.html#unittest.main" title="unittest.main"><code class="xref py py-func docutils literal notranslate"><span class="pre">main()</span></code></a> 函数支持一些其他新选项：</p>
<ul>
<li><p class="translated"><a class="reference internal" href="../library/unittest.html#cmdoption-unittest-b"><code class="xref std std-option docutils literal notranslate"><span class="pre">-b</span></code></a> 或 <code class="xref std std-option docutils literal notranslate"><span class="pre">--buffer</span></code> 将在每个测试期间缓冲标准输出和标准错误流。如果测试通过，任何生成的输出将被丢弃；如果失败，缓冲的输出将被显示。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/unittest.html#cmdoption-unittest-c"><code class="xref std std-option docutils literal notranslate"><span class="pre">-c</span></code></a> 或 <code class="xref std std-option docutils literal notranslate"><span class="pre">--catch</span></code> 将使 control-C 中断处理得更为优雅。而不是立即中断测试进程，当前运行的测试将被完成，然后报告中断前的部分结果。如果你不耐烦，再次按下 control-C 将导致立即中断。</p>
<p class="translated">此 Control-C 处理程序尝试避免在测试的代码或运行的测试已定义了自己的信号处理程序时引发问题，通过检测到已设置信号处理程序并调用它来实现。如果这对你不起作用，可以使用 <a class="reference internal" href="../library/unittest.html#unittest.removeHandler" title="unittest.removeHandler"><code class="xref py py-func docutils literal notranslate"><span class="pre">removeHandler()</span></code></a> 装饰器来标记应禁用 Control-C 处理的测试。</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/unittest.html#cmdoption-unittest-f"><code class="xref std std-option docutils literal notranslate"><span class="pre">-f</span></code></a> 或 <code class="xref std std-option docutils literal notranslate"><span class="pre">--failfast</span></code> 选项使测试执行在测试失败时立即停止，而不是继续执行后续测试。（由 Cliff Dyer 建议，Michael Foord 实现；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=8074">bpo-8074</a>。）</p></li>
</ul>
<p class="translated">在详细模式下运行时，进度消息现在会用 'x' 表示预期失败，用 'u' 表示意外成功。（由 Benjamin Peterson 贡献。）</p>
<p class="translated">测试用例可以引发 <a class="reference internal" href="../library/unittest.html#unittest.SkipTest" title="unittest.SkipTest"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SkipTest</span></code></a> 异常来跳过测试（参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1034053">bpo-1034053</a>）。</p>
<p class="translated"><a class="reference internal" href="../library/unittest.html#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a>、<a class="reference internal" href="../library/unittest.html#unittest.TestCase.assertTrue" title="unittest.TestCase.assertTrue"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertTrue()</span></code></a> 和 <a class="reference internal" href="../library/unittest.html#unittest.TestCase.assertFalse" title="unittest.TestCase.assertFalse"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertFalse()</span></code></a> 失败的错误消息现在提供更多信息。如果你将 <a class="reference internal" href="../library/unittest.html#unittest.TestCase.longMessage" title="unittest.TestCase.longMessage"><code class="xref py py-attr docutils literal notranslate"><span class="pre">longMessage</span></code></a> 属性在你的 <a class="reference internal" href="../library/unittest.html#unittest.TestCase" title="unittest.TestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></a> 类中设置为 true，那么标准错误消息和你提供的任何附加消息都将在失败时打印出来。（由 Michael Foord 添加；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5663">bpo-5663</a>。）</p>
<p class="translated"><a class="reference internal" href="../library/unittest.html#unittest.TestCase.assertRaises" title="unittest.TestCase.assertRaises"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaises()</span></code></a> 方法在调用时如果不提供可调用对象来运行，现在返回一个上下文处理程序。例如，你可以这样写：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="ne">KeyError</span><span class="p">):</span>
    <span class="p">{}[</span><span class="s1">&#39;foo&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p class="translated">（由 Antoine Pitrou 实现；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4444">bpo-4444</a>。）</p>
<p class="translated">现在支持模块级和类级的初始化（setup）与清理（teardown）夹具（fixture）。模块中可以包含 <a class="reference internal" href="../library/unittest.html#unittest.setUpModule" title="unittest.setUpModule"><code class="xref py py-func docutils literal notranslate"><span class="pre">setUpModule()</span></code></a> 和 <a class="reference internal" href="../library/unittest.html#unittest.tearDownModule" title="unittest.tearDownModule"><code class="xref py py-func docutils literal notranslate"><span class="pre">tearDownModule()</span></code></a> 函数；类中可以定义 <a class="reference internal" href="../library/unittest.html#unittest.TestCase.setUpClass" title="unittest.TestCase.setUpClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUpClass()</span></code></a> 和 <a class="reference internal" href="../library/unittest.html#unittest.TestCase.tearDownClass" title="unittest.TestCase.tearDownClass"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDownClass()</span></code></a> 方法，这些方法必须声明为类方法（使用 <code class="docutils literal notranslate"><span class="pre">&#64;classmethod</span></code> 或等效方式）。当测试运行器切换到不同模块或类中的测试用例时，这些函数和方法会被调用。</p>
<p class="translated">添加了 <a class="reference internal" href="../library/unittest.html#unittest.TestCase.addCleanup" title="unittest.TestCase.addCleanup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addCleanup()</span></code></a> 和 <a class="reference internal" href="../library/unittest.html#unittest.TestCase.doCleanups" title="unittest.TestCase.doCleanups"><code class="xref py py-meth docutils literal notranslate"><span class="pre">doCleanups()</span></code></a> 方法。<a class="reference internal" href="../library/unittest.html#unittest.TestCase.addCleanup" title="unittest.TestCase.addCleanup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addCleanup()</span></code></a> 允许你添加清理函数，这些函数将无条件调用（如果 <a class="reference internal" href="../library/unittest.html#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> 失败，则在 <a class="reference internal" href="../library/unittest.html#unittest.TestCase.setUp" title="unittest.TestCase.setUp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setUp()</span></code></a> 之后调用，否则在 <a class="reference internal" href="../library/unittest.html#unittest.TestCase.tearDown" title="unittest.TestCase.tearDown"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tearDown()</span></code></a> 之后调用）。这大大简化了测试期间的资源分配和释放（参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5679">bpo-5679</a>）。</p>
<p class="translated">新增了多个提供更专业测试功能的方法。其中许多方法由谷歌工程师编写，用于他们内部的测试套件；Gregory P. Smith、Michael Foord 和 GvR 参与了将这些方法合并到 Python 版 <a class="reference internal" href="../library/unittest.html#module-unittest" title="unittest: Unit testing framework for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unittest</span></code></a> 模块的工作。</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="../library/unittest.html#unittest.TestCase.assertIsNone" title="unittest.TestCase.assertIsNone"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIsNone()</span></code></a> 和 <a class="reference internal" href="../library/unittest.html#unittest.TestCase.assertIsNotNone" title="unittest.TestCase.assertIsNotNone"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIsNotNone()</span></code></a> 接受一个表达式，并验证结果是否为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/unittest.html#unittest.TestCase.assertIs" title="unittest.TestCase.assertIs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIs()</span></code></a> 和 <a class="reference internal" href="../library/unittest.html#unittest.TestCase.assertIsNot" title="unittest.TestCase.assertIsNot"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIsNot()</span></code></a> 接受两个值，并检查这两个值是否评估为同一个对象。（由 Michael Foord 添加；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2578">bpo-2578</a>。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/unittest.html#unittest.TestCase.assertIsInstance" title="unittest.TestCase.assertIsInstance"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIsInstance()</span></code></a> 和 <a class="reference internal" href="../library/unittest.html#unittest.TestCase.assertNotIsInstance" title="unittest.TestCase.assertNotIsInstance"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotIsInstance()</span></code></a> 检查结果对象是否是特定类的实例，或是否是类元组中的一个类的实例。（由 Georg Brandl 添加；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7031">bpo-7031</a>。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/unittest.html#unittest.TestCase.assertGreater" title="unittest.TestCase.assertGreater"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertGreater()</span></code></a>、<a class="reference internal" href="../library/unittest.html#unittest.TestCase.assertGreaterEqual" title="unittest.TestCase.assertGreaterEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertGreaterEqual()</span></code></a>、<a class="reference internal" href="../library/unittest.html#unittest.TestCase.assertLess" title="unittest.TestCase.assertLess"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertLess()</span></code></a> 和 <a class="reference internal" href="../library/unittest.html#unittest.TestCase.assertLessEqual" title="unittest.TestCase.assertLessEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertLessEqual()</span></code></a> 比较两个数量。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/unittest.html#unittest.TestCase.assertMultiLineEqual" title="unittest.TestCase.assertMultiLineEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertMultiLineEqual()</span></code></a> 比较两个字符串，如果不相等，会显示一个有用的比较结果，突出显示两个字符串中的差异。这种比较现在默认用于比较 Unicode 字符串时与 <a class="reference internal" href="../library/unittest.html#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a>。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/unittest.html#unittest.TestCase.assertRegex" title="unittest.TestCase.assertRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRegexpMatches()</span></code></a> 和 <a class="reference internal" href="../library/unittest.html#unittest.TestCase.assertNotRegex" title="unittest.TestCase.assertNotRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotRegexpMatches()</span></code></a> 检查第一个参数是否为与第二个参数提供的正则表达式匹配或不匹配的字符串 (参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=8038">bpo-8038</a>)。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/unittest.html#unittest.TestCase.assertRaisesRegex" title="unittest.TestCase.assertRaisesRegex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertRaisesRegexp()</span></code></a> 检查是否引发了特定的异常，并进一步检查异常的字符串表示是否与提供的正则表达式匹配。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/unittest.html#unittest.TestCase.assertIn" title="unittest.TestCase.assertIn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertIn()</span></code></a> 和 <a class="reference internal" href="../library/unittest.html#unittest.TestCase.assertNotIn" title="unittest.TestCase.assertNotIn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotIn()</span></code></a> 测试 <em>first</em> 是否在 <em>second</em> 中。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/unittest.html#unittest.TestCase.assertCountEqual" title="unittest.TestCase.assertCountEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertItemsEqual()</span></code></a> 测试两个提供的序列是否包含相同的元素。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/unittest.html#unittest.TestCase.assertSetEqual" title="unittest.TestCase.assertSetEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertSetEqual()</span></code></a> 比较两个集合是否相等，在错误情况下仅报告集合之间的差异。</p></li>
<li><p class="translated">同样，<a class="reference internal" href="../library/unittest.html#unittest.TestCase.assertListEqual" title="unittest.TestCase.assertListEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertListEqual()</span></code></a> 和 <a class="reference internal" href="../library/unittest.html#unittest.TestCase.assertTupleEqual" title="unittest.TestCase.assertTupleEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertTupleEqual()</span></code></a> 比较指定的类型并解释任何差异，而不一定打印它们的完整值；这些方法现在默认用于使用 <a class="reference internal" href="../library/unittest.html#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a> 比较列表和元组。更一般地，<a class="reference internal" href="../library/unittest.html#unittest.TestCase.assertSequenceEqual" title="unittest.TestCase.assertSequenceEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertSequenceEqual()</span></code></a> 比较两个序列，并可以可选地检查两个序列是否为特定类型。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/unittest.html#unittest.TestCase.assertDictEqual" title="unittest.TestCase.assertDictEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertDictEqual()</span></code></a> 比较两个字典并报告差异；现在默认用于使用 <a class="reference internal" href="../library/unittest.html#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a> 比较两个字典。<code class="xref py py-meth docutils literal notranslate"><span class="pre">assertDictContainsSubset()</span></code> 检查 <em>first</em> 中的所有键/值对是否都在 <em>second</em> 中找到。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/unittest.html#unittest.TestCase.assertAlmostEqual" title="unittest.TestCase.assertAlmostEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertAlmostEqual()</span></code></a> 和 <a class="reference internal" href="../library/unittest.html#unittest.TestCase.assertNotAlmostEqual" title="unittest.TestCase.assertNotAlmostEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertNotAlmostEqual()</span></code></a> 测试 <em>first</em> 和 <em>second</em> 是否近似相等。此方法可以将其差异四舍五入到可选指定的 <em>places</em> 数（默认为 7）并与零比较，或者要求差异小于提供的 <em>delta</em> 值。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/unittest.html#unittest.TestLoader.loadTestsFromName" title="unittest.TestLoader.loadTestsFromName"><code class="xref py py-meth docutils literal notranslate"><span class="pre">loadTestsFromName()</span></code></a> 正确地尊重 <a class="reference internal" href="../library/unittest.html#unittest.TestLoader" title="unittest.TestLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestLoader</span></code></a> 的 <a class="reference internal" href="../library/unittest.html#unittest.TestLoader.suiteClass" title="unittest.TestLoader.suiteClass"><code class="xref py py-attr docutils literal notranslate"><span class="pre">suiteClass</span></code></a> 属性。（由 Mark Roddy 修复；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=6866">bpo-6866</a>。）</p></li>
<li><p class="translated">一个新的钩子允许你扩展 <a class="reference internal" href="../library/unittest.html#unittest.TestCase.assertEqual" title="unittest.TestCase.assertEqual"><code class="xref py py-meth docutils literal notranslate"><span class="pre">assertEqual()</span></code></a> 方法以处理新的数据类型。<a class="reference internal" href="../library/unittest.html#unittest.TestCase.addTypeEqualityFunc" title="unittest.TestCase.addTypeEqualityFunc"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addTypeEqualityFunc()</span></code></a> 方法接受一个类型对象和一个函数。当比较的两个对象都是指定类型时，将使用该函数。此函数应比较两个对象，并在它们不匹配时引发异常；建议该函数提供关于两个对象为什么不匹配的额外信息，就像新的序列比较方法一样。</p></li>
</ul>
<p class="translated"><a class="reference internal" href="../library/unittest.html#unittest.main" title="unittest.main"><code class="xref py py-func docutils literal notranslate"><span class="pre">unittest.main()</span></code></a> 现在接受一个可选的 <code class="docutils literal notranslate"><span class="pre">exit</span></code> 参数。如果为假，<a class="reference internal" href="../library/unittest.html#unittest.main" title="unittest.main"><code class="xref py py-func docutils literal notranslate"><span class="pre">main()</span></code></a> 不调用 <a class="reference internal" href="../library/sys.html#sys.exit" title="sys.exit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exit()</span></code></a>，允许从交互式解释器中使用 <a class="reference internal" href="../library/unittest.html#unittest.main" title="unittest.main"><code class="xref py py-func docutils literal notranslate"><span class="pre">main()</span></code></a>。（由 J. Pablo Fernández 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=3379">bpo-3379</a>。）</p>
<p class="translated"><a class="reference internal" href="../library/unittest.html#unittest.TestResult" title="unittest.TestResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">TestResult</span></code></a> 有新的 <a class="reference internal" href="../library/unittest.html#unittest.TestResult.startTestRun" title="unittest.TestResult.startTestRun"><code class="xref py py-meth docutils literal notranslate"><span class="pre">startTestRun()</span></code></a> 和 <a class="reference internal" href="../library/unittest.html#unittest.TestResult.stopTestRun" title="unittest.TestResult.stopTestRun"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stopTestRun()</span></code></a> 方法，它们分别在测试运行之前和之后立即被调用。（由 Robert Collins 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5728">bpo-5728</a>。）</p>
<p class="translated">随着所有这些更改，<code class="file docutils literal notranslate"><span class="pre">unittest.py</span></code> 变得异常庞大，因此该模块被转换为一个包，代码被分割成几个文件（由 Benjamin Peterson 完成）。这不会影响模块的导入或使用。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><a class="reference external" href="https://web.archive.org/web/20210619163128/http://www.voidspace.org.uk/python/articles/unittest2.shtml">https://web.archive.org/web/20210619163128/http://www.voidspace.org.uk/python/articles/unittest2.shtml</a></dt><dd><p class="translated">描述新特性、如何使用它们以及各种设计决策的合理性。（由 Michael Foord 撰写。）</p>
</dd>
</dl>
</div>
</section>
<section id="updated-module-elementtree-1-3">
<span id="elementtree-section"></span><h3 class="translated">更新的模块：ElementTree 1.3<a class="headerlink" href="#updated-module-elementtree-1-3" title="Link to this heading">¶</a></h3>
<p class="translated">Python自带的ElementTree库已更新至1.3版本。一些新特性包括：</p>
<ul>
<li><p class="translated">各种解析函数现在接受一个*parser*关键字参数，该参数提供一个 <a class="reference internal" href="../library/xml.etree.elementtree.html#xml.etree.ElementTree.XMLParser" title="xml.etree.ElementTree.XMLParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">XMLParser</span></code></a> 实例用于解析。这使得可以覆盖文件的内部编码：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">XMLParser</span><span class="p">(</span><span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">XML</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;&lt;root/&gt;&quot;&quot;&quot;</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">解析XML时的错误现在会引发一个 <a class="reference internal" href="../library/xml.etree.elementtree.html#xml.etree.ElementTree.ParseError" title="xml.etree.ElementTree.ParseError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ParseError</span></code></a> 异常，其实例具有一个 <code class="xref py py-attr docutils literal notranslate"><span class="pre">position</span></code> 属性，包含一个(<em>line</em>, <em>column</em>)元组，指示问题的位置。</p>
</li>
<li><p class="translated">ElementTree将树转换为字符串的代码已大幅重构，在许多情况下速度大约提高了一倍。<a class="reference internal" href="../library/xml.etree.elementtree.html#xml.etree.ElementTree.ElementTree.write" title="xml.etree.ElementTree.ElementTree.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ElementTree.write()</span></code></a> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Element.write()</span></code> 方法现在有一个 <em>method</em> 形参，可以是&quot;xml&quot;（默认）、&quot;html&quot;或&quot;text&quot;。HTML模式会将空元素输出为 <code class="docutils literal notranslate"><span class="pre">&lt;empty&gt;&lt;/empty&gt;</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">&lt;empty/&gt;</span></code>，文本模式将跳过元素仅输出文本块。如果将一个元素的 <a class="reference internal" href="../library/xml.etree.elementtree.html#xml.etree.ElementTree.Element.tag" title="xml.etree.ElementTree.Element.tag"><code class="xref py py-attr docutils literal notranslate"><span class="pre">tag</span></code></a> 属性设置为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 但其子元素仍在原位，则在写出树时该元素将被省略，因此无需进行更广泛的重新排列来移除单个元素。</p>
<p class="translated">命名空间处理也得到了改进。所有 <code class="docutils literal notranslate"><span class="pre">xmlns:&lt;whatever&gt;</span></code> 声明现在都输出在根元素上，而不是散布在生成的XML中。可以通过设置 <code class="xref py py-attr docutils literal notranslate"><span class="pre">default_namespace</span></code> 属性来设置树的默认命名空间，并可以使用 <a class="reference internal" href="../library/xml.etree.elementtree.html#xml.etree.ElementTree.register_namespace" title="xml.etree.ElementTree.register_namespace"><code class="xref py py-meth docutils literal notranslate"><span class="pre">register_namespace()</span></code></a> 注册新的前缀。在XML模式下，可以使用true/false的 <em>xml_declaration</em> 参数来抑制XML声明。</p>
</li>
<li><p class="translated">新的 <a class="reference internal" href="../library/xml.etree.elementtree.html#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 方法： <a class="reference internal" href="../library/xml.etree.elementtree.html#xml.etree.ElementTree.Element.extend" title="xml.etree.ElementTree.Element.extend"><code class="xref py py-meth docutils literal notranslate"><span class="pre">extend()</span></code></a> 将序列中的项追加到元素的子元素中。元素本身表现得像序列，因此可以轻松地将子元素从一个元素移动到另一个元素:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">xml.etree</span><span class="w"> </span><span class="kn">import</span> <span class="n">ElementTree</span> <span class="k">as</span> <span class="n">ET</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">XML</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;&lt;list&gt;</span>
<span class="s2">  &lt;item&gt;1&lt;/item&gt; &lt;item&gt;2&lt;/item&gt;  &lt;item&gt;3&lt;/item&gt;</span>
<span class="s2">&lt;/list&gt;&quot;&quot;&quot;</span><span class="p">)</span>
<span class="n">new</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">XML</span><span class="p">(</span><span class="s1">&#39;&lt;root/&gt;&#39;</span><span class="p">)</span>
<span class="n">new</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

<span class="c1"># 输出 &lt;root&gt;&lt;item&gt;1&lt;/item&gt;...&lt;/root&gt;</span>
<span class="nb">print</span> <span class="n">ET</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="translated">新增 <a class="reference internal" href="../library/xml.etree.elementtree.html#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 方法： <a class="reference internal" href="../library/xml.etree.elementtree.html#xml.etree.ElementTree.Element.iter" title="xml.etree.ElementTree.Element.iter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iter()</span></code></a> 以生成器的形式生成元素的子元素。也可以使用 <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">child</span> <span class="pre">in</span> <span class="pre">elem:</span></code> 来遍历元素的子元素。现有的方法 <code class="xref py py-meth docutils literal notranslate"><span class="pre">getiterator()</span></code> 现在已被弃用，同样 <code class="xref py py-meth docutils literal notranslate"><span class="pre">getchildren()</span></code> 也会被弃用，因为它构造并返回子元素的列表。</p></li>
<li><p class="translated">新增 <a class="reference internal" href="../library/xml.etree.elementtree.html#xml.etree.ElementTree.Element" title="xml.etree.ElementTree.Element"><code class="xref py py-class docutils literal notranslate"><span class="pre">Element</span></code></a> 方法： <a class="reference internal" href="../library/xml.etree.elementtree.html#xml.etree.ElementTree.Element.itertext" title="xml.etree.ElementTree.Element.itertext"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itertext()</span></code></a> 生成元素的所有后代文本块。例如:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">XML</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;&lt;list&gt;</span>
<span class="s2">  &lt;item&gt;1&lt;/item&gt; &lt;item&gt;2&lt;/item&gt;  &lt;item&gt;3&lt;/item&gt;</span>
<span class="s2">&lt;/list&gt;&quot;&quot;&quot;</span><span class="p">)</span>

<span class="c1"># 输出 [&#39;\n  &#39;, &#39;1&#39;, &#39; &#39;, &#39;2&#39;, &#39;  &#39;, &#39;3&#39;, &#39;\n&#39;]</span>
<span class="nb">print</span> <span class="nb">list</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">itertext</span><span class="p">())</span>
</pre></div>
</div>
</li>
<li><p class="translated">已弃用：使用元素作为布尔值（即 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">elem:</span></code>）如果元素有任何子元素则返回真，如果没有子元素则返回假。这种行为是令人困惑的——<code class="docutils literal notranslate"><span class="pre">None</span></code> 是假，但无子元素的元素也是假？——因此现在会触发 <a class="reference internal" href="../library/exceptions.html#FutureWarning" title="FutureWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FutureWarning</span></code></a>。在你的代码中，应该明确：如果你关心子元素的数量，写 <code class="docutils literal notranslate"><span class="pre">len(elem)</span> <span class="pre">!=</span> <span class="pre">0</span></code>；如果你想检查元素是否为空，写 <code class="docutils literal notranslate"><span class="pre">elem</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None</span></code>。</p></li>
</ul>
<p class="translated">Fredrik Lundh 开发了 ElementTree 并制作了 1.3 版本；你可以在 <a class="reference external" href="https://web.archive.org/web/20200703234532/http://effbot.org/zone/elementtree-13-intro.htm">https://web.archive.org/web/20200703234532/http://effbot.org/zone/elementtree-13-intro.htm</a> 阅读他描述 1.3 的文章。Florent Xicluna 在 python-dev 上的讨论和在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=6472">bpo-6472</a> 中更新了包含在 Python 中的版本。</p>
</section>
</section>
<section id="build-and-c-api-changes">
<h2 class="translated">构建和 C API 的变更<a class="headerlink" href="#build-and-c-api-changes" title="Link to this heading">¶</a></h2>
<p class="translated">针对 Python 构建过程和 C API 的变更包括:</p>
<ul>
<li><p class="translated">最新发布的GNU调试器GDB 7可以使用Python进行`脚本化 &lt;<a class="reference external" href="https://web.archive.org/web/20110715084810/http://sourceware.org/gdb/current/onlinedocs/gdb/Python.html">https://web.archive.org/web/20110715084810/http://sourceware.org/gdb/current/onlinedocs/gdb/Python.html</a>&gt;`__。当你开始调试可执行程序P时，GDB会查找名为``P-gdb.py``的文件并自动读取它。Dave Malcolm 贡献了一个 <code class="file docutils literal notranslate"><span class="pre">python-gdb.py</span></code>，该文件添加了许多在调试Python本身时非常有用的命令。例如，<code class="docutils literal notranslate"><span class="pre">py-up</span></code> 和 <code class="docutils literal notranslate"><span class="pre">py-down</span></code> 可以向上或向下移动一个 Python 堆栈帧，这通常对应于多个C堆栈帧。<code class="docutils literal notranslate"><span class="pre">py-print</span></code> 打印 Python 变量的值，而 <code class="docutils literal notranslate"><span class="pre">py-bt</span></code> 打印 Python 堆栈跟踪。（作为 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=8032">bpo-8032</a> 的结果添加。）</p></li>
<li><p class="translated">如果你使用Python提供的 <code class="file docutils literal notranslate"><span class="pre">.gdbinit</span></code> 文件，2.7版本中的 &quot;pyo&quot; 宏现在在调试的线程不持有GIL时也能正确工作；该宏现在在打印之前会获取GIL。（由 Victor Stinner 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=3632">bpo-3632</a>。）</p></li>
<li><p class="translated"><a class="reference internal" href="../c-api/init.html#c.Py_AddPendingCall" title="Py_AddPendingCall"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_AddPendingCall()</span></code></a> 现在线程安全，允许任何工作线程向主Python线程提交通知。这对于异步IO操作特别有用。（由 Kristján Valur Jónsson 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4293">bpo-4293</a>。）</p></li>
<li><p class="translated">新增函数：<a class="reference internal" href="../c-api/code.html#c.PyCode_NewEmpty" title="PyCode_NewEmpty"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyCode_NewEmpty()</span></code></a> 创建一个空代码对象；只需要文件名、函数名和首行号。这对于试图构建更有用的回溯堆栈的扩展模块非常有用。之前这样的扩展需要调用 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyCode_New()</span></code>，该函数有更多的参数。（由Jeffrey Yasskin添加。）</p></li>
<li><p class="translated">新增函数：<a class="reference internal" href="../c-api/exceptions.html#c.PyErr_NewExceptionWithDoc" title="PyErr_NewExceptionWithDoc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyErr_NewExceptionWithDoc()</span></code></a> 创建一个新的异常类，就像现有的 <a class="reference internal" href="../c-api/exceptions.html#c.PyErr_NewException" title="PyErr_NewException"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyErr_NewException()</span></code></a> 一样，但多了一个包含新异常类文档字符串的 <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code> 参数。（由 'lekma' 在Python错误跟踪器中添加；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7033">bpo-7033</a>。})</p></li>
<li><p class="translated">新增函数：<a class="reference internal" href="../c-api/frame.html#c.PyFrame_GetLineNumber" title="PyFrame_GetLineNumber"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFrame_GetLineNumber()</span></code></a> 接受一个帧对象，并返回该帧当前执行的行号。之前需要获取当前执行的字节码指令的索引，然后查找对应地址的行号。（由 Jeffrey Yasskin 添加。）</p></li>
<li><p class="translated">新增函数：<a class="reference internal" href="../c-api/long.html#c.PyLong_AsLongAndOverflow" title="PyLong_AsLongAndOverflow"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyLong_AsLongAndOverflow()</span></code></a> 和 <a class="reference internal" href="../c-api/long.html#c.PyLong_AsLongLongAndOverflow" title="PyLong_AsLongLongAndOverflow"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyLong_AsLongLongAndOverflow()</span></code></a> 可将 Python 长整型数值近似转换为 C 语言的 <span class="c-expr sig sig-inline c"><span class="kt">long</span></span> 或 <span class="c-expr sig sig-inline c"><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span> 类型。若数值过大而无法容纳于目标输出类型中，则会设置 <em>溢出</em> 标志位，并将该标志返回给调用者。（由 Case Van Horsen 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7528">bpo-7528</a> 和 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7767">bpo-7767</a>。）</p></li>
<li><p class="translated">新增函数：由于字符串到浮点数转换的重写，新增了 <a class="reference internal" href="../c-api/conversion.html#c.PyOS_string_to_double" title="PyOS_string_to_double"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyOS_string_to_double()</span></code></a> 函数。旧的 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyOS_ascii_strtod()</span></code> 和 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyOS_ascii_atof()</span></code> 函数现已弃用。</p></li>
<li><p class="translated">新增函数：<code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_SetArgvEx()</span></code> 设置 <code class="docutils literal notranslate"><span class="pre">sys.argv</span></code> 的值，并可根据 <em>updatepath</em> 参数的值，选择性地更新 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> 以包含包含由 <code class="docutils literal notranslate"><span class="pre">sys.argv[0]</span></code> 指定的脚本的目录。</p>
<p class="translated">添加此函数是为了关闭嵌入 Python 的应用程序的安全漏洞。旧的函数 <code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_SetArgv()</span></code> 总是更新 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>，有时还会添加当前目录。这意味着，如果你在受他人控制的目录中运行嵌入 Python 的应用程序，攻击者可以在该目录中放置一个木马模块（例如，一个名为 <code class="file docutils literal notranslate"><span class="pre">os.py</span></code> 的文件），你的应用程序将会导入并运行它。</p>
<p class="translated">如果你维护一个嵌入 Python 的 C/C++ 应用程序，请检查你是否调用了 <code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_SetArgv()</span></code>，并仔细考虑是否应该使用 <em>updatepath</em> 设置为 false 的 <code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_SetArgvEx()</span></code>。</p>
<p class="translated">安全问题报告为 <span class="target" id="index-63"></span><a class="cve reference external" href="https://www.cve.org/CVERecord?id=CVE-2008-5983"><strong>CVE 2008-5983</strong></a>；在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5753">bpo-5753</a> 中讨论，并由 Antoine Pitrou 修复。</p>
</li>
<li><p class="translated">新增的宏：Python 头文件现在定义了以下的宏: <a class="reference internal" href="../c-api/conversion.html#c.Py_ISALNUM" title="Py_ISALNUM"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_ISALNUM</span></code></a>, <a class="reference internal" href="../c-api/conversion.html#c.Py_ISALPHA" title="Py_ISALPHA"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_ISALPHA</span></code></a>, <a class="reference internal" href="../c-api/conversion.html#c.Py_ISDIGIT" title="Py_ISDIGIT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_ISDIGIT</span></code></a>, <a class="reference internal" href="../c-api/conversion.html#c.Py_ISLOWER" title="Py_ISLOWER"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_ISLOWER</span></code></a>, <a class="reference internal" href="../c-api/conversion.html#c.Py_ISSPACE" title="Py_ISSPACE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_ISSPACE</span></code></a>, <a class="reference internal" href="../c-api/conversion.html#c.Py_ISUPPER" title="Py_ISUPPER"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_ISUPPER</span></code></a>, <a class="reference internal" href="../c-api/conversion.html#c.Py_ISXDIGIT" title="Py_ISXDIGIT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_ISXDIGIT</span></code></a>, <a class="reference internal" href="../c-api/conversion.html#c.Py_TOLOWER" title="Py_TOLOWER"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TOLOWER</span></code></a> 和 <a class="reference internal" href="../c-api/conversion.html#c.Py_TOUPPER" title="Py_TOUPPER"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TOUPPER</span></code></a>。 所有这些函数都类似于用于对字符归类的 C 标准宏，但忽略当前语言区域设置，因为在一些场合下 Python 需要以语言区域无关的方式分析字符。 （由 Eric Smith 添加；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5793">bpo-5793</a>。）</p></li>
<li><p class="translated">移除函数：<code class="xref c c-func docutils literal notranslate"><span class="pre">PyEval_CallObject()</span></code> 现在仅作为宏可用。保留函数版本是为了保持 ABI 链接兼容性，但这已是 1997 年的事；现在可以删除了。（由 Antoine Pitrou 移除；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=8276">bpo-8276</a>。）</p></li>
<li><p class="translated">新增格式代码：<code class="xref c c-func docutils literal notranslate"><span class="pre">PyString_FromFormat()</span></code>、 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyString_FromFormatV()</span></code> 和 <a class="reference internal" href="../c-api/exceptions.html#c.PyErr_Format" title="PyErr_Format"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyErr_Format()</span></code></a> 函数现在接受 <code class="docutils literal notranslate"><span class="pre">%lld</span></code> 和 <code class="docutils literal notranslate"><span class="pre">%llu</span></code> 格式代码，用于显示 C 的 <span class="c-expr sig sig-inline c"><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span> 类型。（由 Mark Dickinson 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7228">bpo-7228</a>。）</p></li>
<li><p class="translated">线程和进程分叉之间的复杂交互已更改。之前，由 <a class="reference internal" href="../library/os.html#os.fork" title="os.fork"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fork()</span></code></a> 创建的子进程可能会失败，因为子进程仅有一个线程在运行，即执行 <a class="reference internal" href="../library/os.html#os.fork" title="os.fork"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fork()</span></code></a> 的线程。如果其他线程在执行分叉时持有锁（例如 Python 的导入锁），则该锁在新进程中仍会标记为“已持有”。但在子进程中，由于其他线程未复制，子进程将无法释放该锁，从而无法再执行导入。</p>
<p class="translated">Python 2.7 在执行 <a class="reference internal" href="../library/os.html#os.fork" title="os.fork"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.fork()</span></code></a> 之前获取导入锁，并清理使用 <a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> 模块创建的任何锁。具有内部锁的 C 扩展模块，或自行调用 <code class="xref c c-func docutils literal notranslate"><span class="pre">fork()</span></code> 的模块，将不会受益于这种清理。</p>
<p class="translated">（由 Thomas Wouters 修复；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1590864">bpo-1590864</a>。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../c-api/init.html#c.Py_Finalize" title="Py_Finalize"><code class="xref c c-func docutils literal notranslate"><span class="pre">Py_Finalize()</span></code></a> 函数现在调用内部的 <code class="xref py py-func docutils literal notranslate"><span class="pre">threading._shutdown()</span></code> 函数；这防止了解释器关闭时一些异常的抛出。（由 Adam Olsen 提交补丁；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1722344">bpo-1722344</a>。）</p></li>
<li><p class="translated">在使用 <a class="reference internal" href="../c-api/structures.html#c.PyMemberDef" title="PyMemberDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMemberDef</span></code></a> 结构体定义类型的属性时，Python 将不再允许你尝试删除或设置 <code class="xref c c-macro docutils literal notranslate"><span class="pre">T_STRING_INPLACE</span></code> 属性。</p>
</li>
<li><p class="translated">由 <a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 模块定义的全局符号现在以 <code class="docutils literal notranslate"><span class="pre">Py</span></code> 或 <code class="docutils literal notranslate"><span class="pre">_ctypes</span></code> 为前缀。（由 Thomas Heller 实现；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=3102">bpo-3102</a>。）</p></li>
<li><p class="translated">新增配置选项：<code class="xref std std-option docutils literal notranslate"><span class="pre">--with-system-expat</span></code> 开关允许构建 <a class="reference internal" href="../library/pyexpat.html#module-xml.parsers.expat" title="xml.parsers.expat: An interface to the Expat non-validating XML parser."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyexpat</span></code></a> 模块以使用系统 Expat 库。（由 Arfrever Frehtes Taifersar Arahesis 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7609">bpo-7609</a>。）</p></li>
<li><p class="translated">新增配置选项：<code class="xref std std-option docutils literal notranslate"><span class="pre">--with-valgrind</span></code> 选项现在将禁用 pymalloc 分配器，该分配器难以被 Valgrind 内存错误检测器正确分析。因此，Valgrind 将更好地检测内存泄漏和溢出。（由 James Henstridge 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2422">bpo-2422</a>。）</p></li>
<li><p class="translated">新增配置选项：你现在可以提供一个空字符串给 <code class="xref std std-option docutils literal notranslate"><span class="pre">--with-dbmliborder=</span></code> 以禁用所有各种 DBM 模块。（由 Arfrever Frehtes Taifersar Arahesis 添加；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=6491">bpo-6491</a>。）</p></li>
<li><p class="translated"><strong class="program">configure</strong> 脚本现在检查某些 32 位 Intel 芯片上的浮点舍入错误，并定义一个 <code class="xref c c-macro docutils literal notranslate"><span class="pre">X87_DOUBLE_ROUNDING</span></code> 预处理器定义。当前没有代码使用这个定义，但它是可用的，如果有人希望使用它。（由 Mark Dickinson 添加；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2937">bpo-2937</a>。）</p>
<p class="translated">现在 <strong class="program">configure</strong> 还设置了一个 <code class="xref std std-envvar docutils literal notranslate"><span class="pre">LDCXXSHARED</span></code> Makefile 变量以支持 C++ 链接。 （由 Arfrever Frehtes Taifersar Arahesis 贡献; <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1222585">bpo-1222585</a>。）</p>
</li>
<li><p class="translated">构建过程现在创建必要的文件以支持 pkg-config。（由 Clinton Roy 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=3585">bpo-3585</a>。）</p></li>
<li><p class="translated">构建过程现在支持 Subversion 1.7。（由 Arfrever Frehtes Taifersar Arahesis 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=6094">bpo-6094</a>。）</p></li>
</ul>
<section id="capsules">
<span id="whatsnew27-capsules"></span><h3 class="translated">Capsule 对象<a class="headerlink" href="#capsules" title="Link to this heading">¶</a></h3>
<p class="translated">Python 3.1 新增了一种 C 数据类型 <a class="reference internal" href="../c-api/capsule.html#c.PyCapsule" title="PyCapsule"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyCapsule</span></code></a>，用于为扩展模块提供 C 语言 API 接口。胶囊（capsule）本质上是 C 语言中 <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code> 指针的封装载体，并作为模块属性对外暴露；例如，<a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> 模块的 API 通过 <code class="docutils literal notranslate"><span class="pre">socket.CAPI</span></code> 暴露，而 <a class="reference internal" href="../library/unicodedata.html#module-unicodedata" title="unicodedata: Access the Unicode Database."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unicodedata</span></code></a> 模块则暴露了 <code class="docutils literal notranslate"><span class="pre">ucnhash_CAPI</span></code>。其他扩展模块可以导入该模块，访问其字典以获取胶囊对象，进而获取其中的 <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code> 指针——该指针通常指向一个指针数组，其中包含模块各类 API 函数的地址。</p>
<p class="translated">已经有一个用于此目的的现有数据类型，<code class="xref c c-type docutils literal notranslate"><span class="pre">PyCObject</span></code>，但它不提供类型安全。用纯 Python 编写的恶意代码可能会通过从模块 A 获取 <code class="xref c c-type docutils literal notranslate"><span class="pre">PyCObject</span></code> 并以某种方式将其替换为模块 B 中的 <code class="xref c c-type docutils literal notranslate"><span class="pre">PyCObject</span></code> 来导致段错误。胶囊知道它们自己的名称，获取指针需要提供名称：</p>
<div class="translated highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">vtable</span><span class="p">;</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">PyCapsule_IsValid</span><span class="p">(</span><span class="n">capsule</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;mymodule.CAPI&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_ValueError</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;argument type invalid&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">vtable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PyCapsule_GetPointer</span><span class="p">(</span><span class="n">capsule</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;mymodule.CAPI&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p class="translated">你可以确信 <code class="docutils literal notranslate"><span class="pre">vtable</span></code> 指向你所期望的内容。如果传递了不同的胶囊，<a class="reference internal" href="../c-api/capsule.html#c.PyCapsule_IsValid" title="PyCapsule_IsValid"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyCapsule_IsValid()</span></code></a> 会检测到不匹配的名称并返回 false。有关使用这些对象的更多信息，请参阅 <a class="reference internal" href="../extending/extending.html#using-capsules"><span class="std std-ref">给扩展模块提供C API</span></a>。</p>
<p class="translated">Python 2.7 现在内部使用胶囊来提供各种扩展模块 API，但 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyCObject_AsVoidPtr()</span></code> 已被修改以处理胶囊，保留了与 <code class="xref c c-type docutils literal notranslate"><span class="pre">PyCObject</span></code> 接口的编译时兼容性。使用 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyCObject_AsVoidPtr()</span></code> 将发出 <a class="reference internal" href="../library/exceptions.html#PendingDeprecationWarning" title="PendingDeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PendingDeprecationWarning</span></code></a>，默认情况下是静默的。</p>
<p class="translated">在 Python 3.1 中实现并向下移植到 2.7，由 Larry Hastings 完成；在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5630">bpo-5630</a> 中讨论。</p>
</section>
<section id="port-specific-changes-windows">
<h3 class="translated">特定于 Windows 的更改：<a class="headerlink" href="#port-specific-changes-windows" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="../library/msvcrt.html#module-msvcrt" title="msvcrt: Miscellaneous useful routines from the MS VC++ runtime. (Windows)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">msvcrt</span></code></a> 模块现在包含来自 <code class="file docutils literal notranslate"><span class="pre">crtassem.h</span></code> 头文件的一些常量：<a class="reference internal" href="../library/msvcrt.html#msvcrt.CRT_ASSEMBLY_VERSION" title="msvcrt.CRT_ASSEMBLY_VERSION"><code class="xref py py-data docutils literal notranslate"><span class="pre">CRT_ASSEMBLY_VERSION</span></code></a>、 <a class="reference internal" href="../library/msvcrt.html#msvcrt.VC_ASSEMBLY_PUBLICKEYTOKEN" title="msvcrt.VC_ASSEMBLY_PUBLICKEYTOKEN"><code class="xref py py-data docutils literal notranslate"><span class="pre">VC_ASSEMBLY_PUBLICKEYTOKEN</span></code></a> 和 <a class="reference internal" href="../library/msvcrt.html#msvcrt.LIBRARIES_ASSEMBLY_NAME_PREFIX" title="msvcrt.LIBRARIES_ASSEMBLY_NAME_PREFIX"><code class="xref py py-data docutils literal notranslate"><span class="pre">LIBRARIES_ASSEMBLY_NAME_PREFIX</span></code></a>。（由 David Cournapeau 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4365">bpo-4365</a>。）</p></li>
<li><p class="translated">用于访问注册表的 <a class="reference internal" href="../library/winreg.html#module-winreg" title="winreg: Routines and objects for manipulating the Windows registry. (Windows)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">_winreg</span></code></a> 模块现在实现了 <a class="reference internal" href="../library/winreg.html#winreg.CreateKeyEx" title="winreg.CreateKeyEx"><code class="xref py py-func docutils literal notranslate"><span class="pre">CreateKeyEx()</span></code></a> 和 <a class="reference internal" href="../library/winreg.html#winreg.DeleteKeyEx" title="winreg.DeleteKeyEx"><code class="xref py py-func docutils literal notranslate"><span class="pre">DeleteKeyEx()</span></code></a> 函数，这些是之前支持函数的扩展版本，它们接受几个额外的参数。<a class="reference internal" href="../library/winreg.html#winreg.DisableReflectionKey" title="winreg.DisableReflectionKey"><code class="xref py py-func docutils literal notranslate"><span class="pre">DisableReflectionKey()</span></code></a>、 <a class="reference internal" href="../library/winreg.html#winreg.EnableReflectionKey" title="winreg.EnableReflectionKey"><code class="xref py py-func docutils literal notranslate"><span class="pre">EnableReflectionKey()</span></code></a> 和 <a class="reference internal" href="../library/winreg.html#winreg.QueryReflectionKey" title="winreg.QueryReflectionKey"><code class="xref py py-func docutils literal notranslate"><span class="pre">QueryReflectionKey()</span></code></a> 也经过了测试和文档记录。（由 Brian Curtin 实现：<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7347">bpo-7347</a>。）</p></li>
<li><p class="translated">新的 <code class="xref c c-func docutils literal notranslate"><span class="pre">_beginthreadex()</span></code> API 用于启动线程，现在使用了本地线程局部存储函数。（由 Kristján Valur Jónsson 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=3582">bpo-3582</a>。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/os.html#os.kill" title="os.kill"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.kill()</span></code></a> 函数现在在 Windows 上工作。信号值可以是常量 <a class="reference internal" href="../library/signal.html#signal.CTRL_C_EVENT" title="signal.CTRL_C_EVENT"><code class="xref py py-const docutils literal notranslate"><span class="pre">CTRL_C_EVENT</span></code></a>、 <a class="reference internal" href="../library/signal.html#signal.CTRL_BREAK_EVENT" title="signal.CTRL_BREAK_EVENT"><code class="xref py py-const docutils literal notranslate"><span class="pre">CTRL_BREAK_EVENT</span></code></a> 或任何整数。前两个常量将向子进程发送 <kbd class="kbd docutils literal notranslate">Control</kbd>-<kbd class="kbd docutils literal notranslate">C</kbd> 和 <kbd class="kbd docutils literal notranslate">Control</kbd>-<kbd class="kbd docutils literal notranslate">Break</kbd> 键盘事件；任何其他值将使用 <code class="xref c c-func docutils literal notranslate"><span class="pre">TerminateProcess()</span></code> API。（由 Miki Tebeka 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1220212">bpo-1220212</a>。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/os.html#os.listdir" title="os.listdir"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.listdir()</span></code></a> 函数现在在空路径时正确地失败。（由 Hirokazu Yamamoto 修复；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5913">bpo-5913</a>。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/mimetypes.html#module-mimetypes" title="mimetypes: Mapping of filename extensions to MIME types."><code class="xref py py-mod docutils literal notranslate"><span class="pre">mimetypes</span></code></a> 模块在初始化时现在会从 Windows 注册表读取 MIME 数据库。（由 Gabriel Genellina 提供补丁；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4969">bpo-4969</a>。）</p></li>
</ul>
</section>
<section id="port-specific-changes-mac-os-x">
<h3 class="translated">特定于 Mac OS X 的更改：<a class="headerlink" href="#port-specific-changes-mac-os-x" title="Link to this heading">¶</a></h3>
<ul>
<li><p class="translated">路径 <code class="docutils literal notranslate"><span class="pre">/Library/Python/2.7/site-packages</span></code> 现在附加到 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>，以便在系统安装和用户安装的同一版本的副本之间共享添加的包。（由 Ronald Oussoren 更改；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=4865">bpo-4865</a>。）</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 2.7.13 版本发生变更: </span>自2.7.13版本起，这一变更已被移除。<code class="docutils literal notranslate"><span class="pre">/Library/Python/2.7/site-packages</span></code>，即Apple提供的系统Python 2.7所使用的site-packages目录，不再被追加到用户安装的Python（例如通过python.org安装器安装的Python）的 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> 中。自 macOS 10.12 起，Apple 更改了系统 site-packages 目录的配置方式，这可能导致安装pip组件（如setuptools）失败。为系统 Python 安装的包将不再与用户安装的 Python 共享。(参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=28440">bpo-28440</a>)</p>
</div>
</li>
</ul>
</section>
<section id="port-specific-changes-freebsd">
<h3 class="translated">特定于 FreeBSD 的更改：<a class="headerlink" href="#port-specific-changes-freebsd" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p class="translated">FreeBSD 7.1中的 <code class="xref py py-const docutils literal notranslate"><span class="pre">SO_SETFIB</span></code> 常量，用于与 <a class="reference internal" href="../library/socket.html#socket.socket" title="socket.socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket()</span></code></a> 方法的 <a class="reference internal" href="../library/socket.html#socket.socket.getsockopt" title="socket.socket.getsockopt"><code class="xref py py-func docutils literal notranslate"><span class="pre">getsockopt()</span></code></a>/<a class="reference internal" href="../library/socket.html#socket.socket.setsockopt" title="socket.socket.setsockopt"><code class="xref py py-func docutils literal notranslate"><span class="pre">setsockopt()</span></code></a> 一起选择备用路由表，现在已在 <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> 模块中提供。（由 Kyle VanderBeek 添加;参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=8235">bpo-8235</a>。）</p></li>
</ul>
</section>
</section>
<section id="other-changes-and-fixes">
<h2 class="translated">其他的变更和修正<a class="headerlink" href="#other-changes-and-fixes" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p class="translated">两个基准测试脚本，<code class="file docutils literal notranslate"><span class="pre">iobench</span></code> 和 <code class="file docutils literal notranslate"><span class="pre">ccbench</span></code>，已被添加到 <code class="file docutils literal notranslate"><span class="pre">Tools</span></code> 目录中。<code class="file docutils literal notranslate"><span class="pre">iobench</span></code> 用于测量内置文件I/O对象（由 <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 返回）在进行各种操作时的速度，而 <code class="file docutils literal notranslate"><span class="pre">ccbench</span></code> 是一个并发基准测试，旨在测量在使用不同数量线程执行多个任务时的计算吞吐量、线程切换延迟和IO处理带宽。</p></li>
<li><p class="translated"><code class="file docutils literal notranslate"><span class="pre">Tools/i18n/msgfmt.py</span></code> 脚本现在能够理解 <code class="file docutils literal notranslate"><span class="pre">.po</span></code> 文件中的复数形式。（由 Martin von Löwis 修复;参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5464">bpo-5464</a>。）</p></li>
<li><p class="translated">当从具有现有 <code class="file docutils literal notranslate"><span class="pre">.py</span></code> 对应文件的 <code class="file docutils literal notranslate"><span class="pre">.pyc</span></code> 或 <code class="file docutils literal notranslate"><span class="pre">.pyo</span></code> 文件导入模块时，如果原始文件名已过时，则生成的代码对象的 <a class="reference internal" href="../reference/datamodel.html#codeobject.co_filename" title="codeobject.co_filename"><code class="xref py py-attr docutils literal notranslate"><span class="pre">co_filename</span></code></a> 属性将被覆盖。这可能发生在文件被重命名、移动或通过不同路径访问时。（由 Ziga Seilnacht 和 Jean-Paul Calderone 提供补丁;参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1180193">bpo-1180193</a>。)</p></li>
<li><p class="translated"><code class="file docutils literal notranslate"><span class="pre">regrtest.py</span></code> 脚本现在接受一个 <code class="xref std std-option docutils literal notranslate"><span class="pre">--randseed=</span></code> 开关，该开关需要一个整数作为随机种子，用于 <code class="xref std std-option docutils literal notranslate"><span class="pre">-r</span></code> 选项以随机顺序执行测试。<code class="xref std std-option docutils literal notranslate"><span class="pre">-r</span></code> 选项还会报告所使用的种子（由 Collin Winter 添加）。</p></li>
<li><p class="translated">另一个 <code class="file docutils literal notranslate"><span class="pre">regrtest.py</span></code> 开关是 <code class="xref std std-option docutils literal notranslate"><span class="pre">-j</span></code>，它需要一个整数来指定并行运行的测试数量。这可以减少多核机器上的总运行时间。此选项与多个其他选项兼容，包括已知会产生长运行时间的 <code class="xref std std-option docutils literal notranslate"><span class="pre">-R</span></code> 开关（由 Antoine Pitrou 添加，参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=6152">bpo-6152</a>）。这也可以与新的 <code class="xref std std-option docutils literal notranslate"><span class="pre">-F</span></code> 开关一起使用，该开关会循环运行选定的测试，直到它们失败为止（由 Antoine Pitrou 添加；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7312">bpo-7312</a>）。</p></li>
<li><p class="translated">当作为脚本执行时，<code class="file docutils literal notranslate"><span class="pre">py_compile.py</span></code> 模块现在接受 <code class="docutils literal notranslate"><span class="pre">'-'</span></code> 作为参数，这将从标准输入读取要编译的文件名列表（由 Piotr Ożarowski 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=8233">bpo-8233</a>）。</p></li>
</ul>
</section>
<section id="porting-to-python-2-7">
<h2 class="translated">移植到 Python 2.7<a class="headerlink" href="#porting-to-python-2-7" title="Link to this heading">¶</a></h2>
<p class="translated">本节列出了先前描述的变更以及可能需要修改你的代码的其他问题修正:</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="../library/stdtypes.html#range" title="range"><code class="xref py py-func docutils literal notranslate"><span class="pre">range()</span></code></a> 函数现在更一致地处理其参数；它将调用 <a class="reference internal" href="../reference/datamodel.html#object.__int__" title="object.__int__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__int__()</span></code></a> 方法来处理提供给它的非浮点、非整数参数（由 Alexander Belopolsky 修复；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1533">bpo-1533</a>）。</p></li>
<li><p class="translated">字符串的 <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">format()</span></code></a> 方法将浮点数和复数的默认精度从 6 小数位改为 12 小数位，这与 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> 使用的精度一致（由 Eric Smith 更改；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5920">bpo-5920</a>）。</p></li>
<li><p class="translated">由于对 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 语句的优化，特殊方法 <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> 和 <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 必须属于对象的类型，不能直接附加到对象的实例上。这影响新式类（从 <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 派生）和 C 扩展类型（参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=6101">bpo-6101</a>）。</p></li>
<li><p class="translated">由于 Python 2.6 中的一个 bug，传递给 <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 方法的 <em>exc_value</em> 参数通常是异常的字符串表示，而不是实例。这在 2.7 中已修复，因此 <em>exc_value</em> 将如预期那样是一个实例。（由 Florent Xicluna 修复；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7853">bpo-7853</a>。）</p></li>
<li><p class="translated">当使用 <code class="docutils literal notranslate"><span class="pre">__slots__</span></code> 设置一组受限属性时，删除未设置的属性不会像预期那样引发 <a class="reference internal" href="../library/exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>。（由 Benjamin Peterson 修复；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7604">bpo-7604</a>。）</p></li>
</ul>
<p class="translated">在标准库中:</p>
<ul>
<li><p class="translated">涉及 <a class="reference internal" href="../library/datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime</span></code></a> 实例的操作，如果结果年份超出支持范围，并不总是引发 <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a>。现在此类错误将更仔细地检查，并会引发异常。（由 Mark Leander 报告，Anand B. Pillai 和 Alexander Belopolsky 提供补丁；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7150">bpo-7150</a>。）</p></li>
<li><p class="translated">当使用 <a class="reference internal" href="../library/decimal.html#decimal.Decimal" title="decimal.Decimal"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code></a> 实例与字符串的 <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">format()</span></code></a> 方法时，默认对齐方式之前是左对齐。这已更改为右对齐，可能会改变你的程序输出。（由 Mark Dickinson 更改；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=6857">bpo-6857</a>。）</p>
<p class="translated">涉及信号 NaN 值（或 <code class="docutils literal notranslate"><span class="pre">sNAN</span></code>）的比较现在会触发 <a class="reference internal" href="../library/decimal.html#decimal.InvalidOperation" title="decimal.InvalidOperation"><code class="xref py py-const docutils literal notranslate"><span class="pre">InvalidOperation</span></code></a>，而不是根据比较运算符静默地返回真或假值。静默 NaN 值（或 <code class="docutils literal notranslate"><span class="pre">NaN</span></code>）现在可以被哈希。 (由 Mark Dickinson 修复；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7279">bpo-7279</a>)</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/xml.etree.elementtree.html#module-xml.etree.ElementTree" title="xml.etree.ElementTree: Implementation of the ElementTree API."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.etree.ElementTree</span></code></a> 库在输出 XML 处理指令（看起来像 <code class="docutils literal notranslate"><span class="pre">&lt;?xml-stylesheet</span> <span class="pre">href=&quot;#style1&quot;?&gt;</span></code>）或注释（看起来像 <code class="docutils literal notranslate"><span class="pre">&lt;!--</span> <span class="pre">comment</span> <span class="pre">--&gt;</span></code>）时，不再转义与符号“&amp;”和尖括号“&lt;&gt;”。（由 Neil Muller 提供补丁；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2746">bpo-2746</a>。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">StringIO</span></code></a> 对象的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code> 方法在请求负长度时现在不执行任何操作，与其他文件类对象一致。（参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7348">bpo-7348</a>。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/syslog.html#module-syslog" title="syslog: An interface to the Unix syslog library routines. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">syslog</span></code></a> 模块现在将使用 <code class="docutils literal notranslate"><span class="pre">sys.argv[0]</span></code> 的值作为标识符，而不是之前的默认值 <code class="docutils literal notranslate"><span class="pre">'python'</span></code>。（由 Sean Reifschneider 更改；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=8451">bpo-8451</a>。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/tarfile.html#module-tarfile" title="tarfile: Read and write tar-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tarfile</span></code></a> 模块的默认错误处理已更改，不再抑制致命错误。之前的默认错误级别为 0，这意味着错误只会导致一条消息被写入调试日志，但由于调试日志默认不激活，这些错误会被忽略。现在的默认错误级别为 1，如果出现错误会引发异常。（由 Lars Gustäbel 改变；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=7357">bpo-7357</a>。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/urllib.parse.html#module-urllib.parse" title="urllib.parse: Parse URLs into or assemble them from components."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urlparse</span></code></a> 模块的 <a class="reference internal" href="../library/urllib.parse.html#urllib.parse.urlsplit" title="urllib.parse.urlsplit"><code class="xref py py-func docutils literal notranslate"><span class="pre">urlsplit()</span></code></a> 现在以一种符合 <span class="target" id="index-64"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3986.html"><strong>RFC 3986</strong></a> 的方式处理未知的 URL 方案：如果 URL 形如 <code class="docutils literal notranslate"><span class="pre">&quot;&lt;something&gt;://...&quot;</span></code>，则 <code class="docutils literal notranslate"><span class="pre">://</span></code> 之前的文本被视为方案，即使它是一个模块不知道的自定义方案。这一更改可能会破坏针对旧行为进行工作的代码。例如，Python 2.6.4 或 2.5 将返回以下内容：</p>
<div class="translated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">urlparse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urlparse</span><span class="o">.</span><span class="n">urlsplit</span><span class="p">(</span><span class="s1">&#39;invented://host/filename?query&#39;</span><span class="p">)</span>
<span class="go">(&#39;invented&#39;, &#39;&#39;, &#39;//host/filename?query&#39;, &#39;&#39;, &#39;&#39;)</span>
</pre></div>
</div>
<p class="translated">Python 2.7（以及Python 2.6.5）将返回：</p>
<div class="translated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">urlparse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urlparse</span><span class="o">.</span><span class="n">urlsplit</span><span class="p">(</span><span class="s1">&#39;invented://host/filename?query&#39;</span><span class="p">)</span>
<span class="go">(&#39;invented&#39;, &#39;host&#39;, &#39;/filename?query&#39;, &#39;&#39;, &#39;&#39;)</span>
</pre></div>
</div>
<p class="translated">（Python 2.7实际上产生的输出略有不同，因为它返回的是一个具名元组而不是标准元组。）</p>
</li>
</ul>
<p class="translated">对于C 扩展模块：</p>
<ul class="simple">
<li><p class="translated">使用整数格式代码与 <code class="docutils literal notranslate"><span class="pre">PyArg_Parse*</span></code> 函数族的 C 扩展现在将引发 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 异常，而不是触发 <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a> (参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=5080">bpo-5080</a>。)</p></li>
<li><p class="translated">使用新的 <a class="reference internal" href="../c-api/conversion.html#c.PyOS_string_to_double" title="PyOS_string_to_double"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyOS_string_to_double()</span></code></a> 函数，而不是已弃用的旧函数 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyOS_ascii_strtod()</span></code> 和 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyOS_ascii_atof()</span></code>。</p></li>
</ul>
<p class="translated">对于嵌入 Python 的应用程序：</p>
<ul class="simple">
<li><p class="translated"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_SetArgvEx()</span></code> 函数已添加，允许应用程序在使用现有的 <code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_SetArgv()</span></code> 函数时关闭安全漏洞。检查你是否调用了 <code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_SetArgv()</span></code>，并仔细考虑是否应该使用 <em>updatepath</em> 设置为 false 的 <code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_SetArgvEx()</span></code>。</p></li>
</ul>
</section>
<section id="new-features-added-to-python-2-7-maintenance-releases">
<span id="py27-maintenance-enhancements"></span><h2 class="translated">Python 2.7 维护版本中添加的新特性<a class="headerlink" href="#new-features-added-to-python-2-7-maintenance-releases" title="Link to this heading">¶</a></h2>
<p class="translated">当情况确实需要时，新特性可能会添加到 Python 2.7 的维护版本中。任何此类添加必须经过 Python 增强提案（PEP）流程，并充分说明为什么不能仅通过将新功能添加到 Python 3 或将其发布到 Python 包索引来妥善解决。</p>
<p class="translated">除了下面列出的具体提案外，还有一个一般性豁免，允许在任何 Python 2.7 维护版本中添加新的 <code class="docutils literal notranslate"><span class="pre">-3</span></code> 警告。</p>
<section id="two-new-environment-variables-for-debug-mode">
<h3 class="translated">调试模式的两个新环境变量<a class="headerlink" href="#two-new-environment-variables-for-debug-mode" title="Link to this heading">¶</a></h3>
<p class="translated">在调试模式下，默认不写入 <code class="docutils literal notranslate"><span class="pre">[xxx</span> <span class="pre">refs]</span></code> 统计信息，现在还必须设置 <code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONSHOWREFCOUNT</span></code> 环境变量。（由 Victor Stinner 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=31733">bpo-31733</a>。）</p>
<p class="translated">当 Python 编译时定义了 <code class="docutils literal notranslate"><span class="pre">COUNT_ALLOC</span></code>，默认不再转储分配计数：现在还必须设置 <code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONSHOWALLOCCOUNT</span></code> 环境变量。此外，分配计数现在转储到 stderr，而不是 stdout。（由 Victor Stinner 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=31692">bpo-31692</a>。）</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.7.15.</span></p>
</div>
</section>
<section id="pep-434-idle-enhancement-exception-for-all-branches">
<h3 class="translated">PEP 434：针对所有分支的 IDLE 增强功能豁免提案<a class="headerlink" href="#pep-434-idle-enhancement-exception-for-all-branches" title="Link to this heading">¶</a></h3>
<p class="translated"><span class="target" id="index-65"></span><a class="pep reference external" href="https://peps.python.org/pep-0434/"><strong>PEP 434</strong></a> 描述了对随 Python 一起提供的 IDLE 开发环境所做的更改的一般性豁免。此豁免使 IDLE 开发人员能够在所有受支持的 Python 2 和 3 版本中提供更一致的用户体验。</p>
<p class="translated">有关 IDLE 任何变更的详细信息，请参考特定版本的 NEWS 文件。</p>
</section>
<section id="pep-466-network-security-enhancements-for-python-2-7">
<h3 class="translated">PEP 466: 针对 Python 2.7 的网络安全加固<a class="headerlink" href="#pep-466-network-security-enhancements-for-python-2-7" title="Link to this heading">¶</a></h3>
<p class="translated"><span class="target" id="index-66"></span><a class="pep reference external" href="https://peps.python.org/pep-0466/"><strong>PEP 466</strong></a> 描述了一系列已获批准纳入 Python 2.7 维护版本的网络安全增强提案，其中首个变更出现在 Python 2.7.7 版本中。</p>
<p class="translated"><span class="target" id="index-67"></span><a class="pep reference external" href="https://peps.python.org/pep-0466/"><strong>PEP 466</strong></a> Python 2.7.7 中添加的相关特性：</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="../library/hmac.html#hmac.compare_digest" title="hmac.compare_digest"><code class="xref py py-func docutils literal notranslate"><span class="pre">hmac.compare_digest()</span></code></a> 从 Python 3 向下移植，以向 Python 2 应用提供抵抗定时攻击的比较操作。（由 Alex Gaynor 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=21306">bpo-21306</a>。）</p></li>
<li><p class="translated">官方 Windows 安装程序中的 OpenSSL 1.0.1g 已在 python.org 上升级。（由 Zachary Ware 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=21462">bpo-21462</a>。）</p></li>
</ul>
<p class="translated"><span class="target" id="index-68"></span><a class="pep reference external" href="https://peps.python.org/pep-0466/"><strong>PEP 466</strong></a> Python 2.7.8 中添加的相关特性：</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="../library/hashlib.html#hashlib.pbkdf2_hmac" title="hashlib.pbkdf2_hmac"><code class="xref py py-func docutils literal notranslate"><span class="pre">hashlib.pbkdf2_hmac()</span></code></a> 从 Python 3 向下移植，以向 Python 2 应用广泛提供适用于安全密码存储的哈希算法。（由 Alex Gaynor 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=21304">bpo-21304</a>。）</p></li>
<li><p class="translated">官方 Windows 安装程序中的 OpenSSL 1.0.1h 已在 python.org 上升级。（由 Zachary Ware 针对 <span class="target" id="index-69"></span><a class="cve reference external" href="https://www.cve.org/CVERecord?id=CVE-2014-0224`在 :issue:`21671"><strong>CVE 2014-0224`在 :issue:`21671</strong></a> 中贡献。）</p></li>
</ul>
<p class="translated"><span class="target" id="index-70"></span><a class="pep reference external" href="https://peps.python.org/pep-0466/"><strong>PEP 466</strong></a> Python 2.7.9 中添加的相关特性：</p>
<ul>
<li><p class="translated">大部分 Python 3.4 的 <a class="reference internal" href="../library/ssl.html#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> 模块已向下移植。这意味着 <a class="reference internal" href="../library/ssl.html#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> 现在支持服务器名称指示、TLS1.x 设置、访问平台证书存储、<a class="reference internal" href="../library/ssl.html#ssl.SSLContext" title="ssl.SSLContext"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> 类以及其他特性。（由 Alex Gaynor 和 David Reid 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=21308">bpo-21308</a>。）</p>
<p class="translated">有关具体细节，请参阅模块文档中标记为&quot;Version added: 2.7.9&quot;的说明注释。</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/os.html#os.urandom" title="os.urandom"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.urandom()</span></code></a> 已更改，以缓存对 <code class="docutils literal notranslate"><span class="pre">/dev/urandom</span></code> 的文件描述符，而不是在每次调用时重新打开 <code class="docutils literal notranslate"><span class="pre">/dev/urandom</span></code>。（由 Alex Gaynor 贡献；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=21305">bpo-21305</a>。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/hashlib.html#hashlib.algorithms_guaranteed" title="hashlib.algorithms_guaranteed"><code class="xref py py-data docutils literal notranslate"><span class="pre">hashlib.algorithms_guaranteed</span></code></a> 和 <a class="reference internal" href="../library/hashlib.html#hashlib.algorithms_available" title="hashlib.algorithms_available"><code class="xref py py-data docutils literal notranslate"><span class="pre">hashlib.algorithms_available</span></code></a> 从 Python 3 向下移植，以简化 Python 2 应用选择最强可用哈希算法的过程。（由 Alex Gaynor 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=21307">bpo-21307</a> 中贡献）</p></li>
</ul>
</section>
<section id="pep-477-backport-ensurepip-pep-453-to-python-2-7">
<h3 class="translated">PEP 477: 将 ensurepip (PEP 453) 向下移植到 Python 2.7<a class="headerlink" href="#pep-477-backport-ensurepip-pep-453-to-python-2-7" title="Link to this heading">¶</a></h3>
<p class="translated"><span class="target" id="index-71"></span><a class="pep reference external" href="https://peps.python.org/pep-0477/"><strong>PEP 477</strong></a> 批准将 <span class="target" id="index-72"></span><a class="pep reference external" href="https://peps.python.org/pep-0453/"><strong>PEP 453</strong></a> ensurepip 模块及其启用的新增文档纳入 Python 2.7 维护版本，首次出现在 Python 2.7.9 版本中。</p>
<section id="bootstrapping-pip-by-default">
<h4 class="translated">默认对 pip 进行初始配置<a class="headerlink" href="#bootstrapping-pip-by-default" title="Link to this heading">¶</a></h4>
<p class="translated">新的 <a class="reference internal" href="../library/ensurepip.html#module-ensurepip" title="ensurepip: Bootstrapping the &quot;pip&quot; installer into an existing Python installation or virtual environment."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ensurepip</span></code></a> 模块（定义于 <span class="target" id="index-73"></span><a class="pep reference external" href="https://peps.python.org/pep-0453/"><strong>PEP 453</strong></a>）提供了一个标准的跨平台机制，用于将 pip 安装程序引导到 Python 安装中。Python 2.7.9 中包含的 <code class="docutils literal notranslate"><span class="pre">pip</span></code> 版本是 <code class="docutils literal notranslate"><span class="pre">pip</span></code> 1.5.6，未来的 2.7.x 维护版本将更新捆绑版本为创建发布候选时最新的 <code class="docutils literal notranslate"><span class="pre">pip</span></code> 版本。</p>
<p class="translated">默认情况下，命令 <code class="docutils literal notranslate"><span class="pre">pip</span></code>、<code class="docutils literal notranslate"><span class="pre">pipX</span></code> 和 <code class="docutils literal notranslate"><span class="pre">pipX.Y</span></code> 将在所有平台上安装（其中 X.Y 代表 Python 安装的版本），同时安装 <code class="docutils literal notranslate"><span class="pre">pip</span></code> Python 包及其依赖项。</p>
<p class="translated">对于 CPython <a class="reference internal" href="../using/unix.html#building-python-on-unix"><span class="std std-ref">在 POSIX 系统上的源代码构建</span></a>，<code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">install</span></code> 和 <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">altinstall</span></code> 命令默认不会自动安装 <code class="docutils literal notranslate"><span class="pre">pip</span></code>。这种行为可以通过配置选项控制，并通过 Makefile 选项覆盖。</p>
<p class="translated">在 Windows 和 Mac OS X 上，现在 CPython 安装程序默认会将 <code class="docutils literal notranslate"><span class="pre">pip</span></code> 与 CPython 本身一同安装（用户可以在安装过程中选择不安装它）。 Window 用户需要选择执行 <code class="docutils literal notranslate"><span class="pre">PATH</span></code> 修改以使 <code class="docutils literal notranslate"><span class="pre">pip</span></code> 在命令行中默认可用，在其他情况下它仍然可以通过 Windows 版 Python 启动器以 <code class="docutils literal notranslate"><span class="pre">py</span> <span class="pre">-m</span> <span class="pre">pip</span></code> 的方式使用。</p>
<p class="translated">如 <span class="target" id="index-74"></span><a class="pep reference external" href="https://peps.python.org/pep-0477/#disabling-ensurepip-by-downstream-distributors"><strong>在 PEP 中讨论的</strong></a>，平台打包者可以选择默认不安装这些命令，只要在调用时，它们提供清晰简单的说明，说明如何在那个平台上安装它们（通常使用系统包管理器）。</p>
</section>
<section id="documentation-changes">
<h4 class="translated">文档更改<a class="headerlink" href="#documentation-changes" title="Link to this heading">¶</a></h4>
<p class="translated">作为此项更改的一部分，文档的 <a class="reference internal" href="../installing/index.html#installing-index"><span class="std std-ref">安装 Python 模块</span></a> 和 <a class="reference internal" href="../distributing/index.html#distributing-index"><span class="std std-ref">分发 Python 模块</span></a> 章节已经完全重新设计，快速入门和 FAQ 文档也是如此。 大部分打包指南文档现在都已被移至由 Python Packaging Authority 维护的 <a class="reference external" href="https://packaging.python.org">Python Packaging User Guide</a> 以及相应的独立项目文档。</p>
<p class="translated">不过，由于目前迁移过程尚未完成，这些指南的旧版本仍然可通过 <a class="reference internal" href="../extending/building.html#install-index"><span class="std std-ref">使用 setuptools 构建 C 和 C++ 扩展</span></a> 和 <a class="reference internal" href="../extending/building.html#setuptools-index"><span class="std std-ref">使用 setuptools 构建 C 和 C++ 扩展</span></a> 来访问。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-75"></span><a class="pep reference external" href="https://peps.python.org/pep-0453/"><strong>PEP 453</strong></a> -- Python安装过程中pip的显式引导机制</dt><dd><p class="translated">PEP 由Donald Stufft 和 Nick Coghlan 撰写，由 Donald Stufft、Nick Coghlan、Martin von Löwis 和 Ned Deily 实现。</p>
</dd>
</dl>
</div>
</section>
</section>
<section id="pep-476-enabling-certificate-verification-by-default-for-stdlib-http-clients">
<h3 class="translated">PEP 476: 默认为 stdlib http 客户端启用证书验证<a class="headerlink" href="#pep-476-enabling-certificate-verification-by-default-for-stdlib-http-clients" title="Link to this heading">¶</a></h3>
<p class="translated"><span class="target" id="index-76"></span><a class="pep reference external" href="https://peps.python.org/pep-0476/"><strong>PEP 476</strong></a> 更新了 <a class="reference internal" href="../library/http.html#module-http" title="http: HTTP status codes and messages"><code class="xref py py-mod docutils literal notranslate"><span class="pre">httplib</span></code></a> 及其使用的模块，例如 <a class="reference internal" href="../library/urllib.request.html#module-urllib.request" title="urllib.request: Extensible library for opening URLs."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib2</span></code></a> 和 <a class="reference internal" href="../library/xmlrpc.client.html#module-xmlrpc.client" title="xmlrpc.client: XML-RPC client access."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xmlrpclib</span></code></a>，现在默认验证服务器提供的证书是否由平台信任存储中的证书颁发机构签名，且其主机名与请求的主机名匹配，显著提高了许多应用程序的安全性。这一更改在 Python 2.7.9 版本中实现。</p>
<p class="translated">对于需要之前版本的旧有行为的应用程序，可以传入一个替代的上下文:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">urllib2</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">ssl</span>

<span class="c1"># 这将禁用所有验证</span>
<span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">_create_unverified_context</span><span class="p">()</span>

<span class="c1"># 这允许为特定主机使用特定证书，该证书不需要</span>
<span class="c1"># 在信任存储中</span>
<span class="n">context</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">create_default_context</span><span class="p">(</span><span class="n">cafile</span><span class="o">=</span><span class="s2">&quot;/path/to/file.crt&quot;</span><span class="p">)</span>

<span class="n">urllib2</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s2">&quot;https://invalid-cert&quot;</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="pep-493-https-verification-migration-tools-for-python-2-7">
<h3 class="translated">PEP 493：适用于Python 2.7 的 HTTPS 验证迁移工具<a class="headerlink" href="#pep-493-https-verification-migration-tools-for-python-2-7" title="Link to this heading">¶</a></h3>
<p class="translated"><span class="target" id="index-77"></span><a class="pep reference external" href="https://peps.python.org/pep-0493/"><strong>PEP 493</strong></a> 提供了额外的迁移工具，以支持对包含依赖历史宽松服务器证书处理的应用程序和服务的环境进行更渐进的基础设施升级过程。这些添加内容在 Python 2.7.12 版本中实现。</p>
<p class="translated">这些工具旨在用于那些无法修改以显式传递更宽松 SSL 上下文的应用程序和服务，在建立连接时使用。</p>
<p class="translated">对于完全无法修改的应用程序和服务，可以设置新的 <code class="docutils literal notranslate"><span class="pre">PYTHONHTTPSVERIFY</span></code> 环境变量为 <code class="docutils literal notranslate"><span class="pre">0</span></code>，以将整个 Python 进程恢复到 Python 2.7.8 及早期版本的默认宽松行为。</p>
<p class="translated">对于连接建立代码无法修改，但整体应用程序可以修改的情况，可以使用新的 <code class="xref py py-func docutils literal notranslate"><span class="pre">ssl._https_verify_certificates()</span></code> 函数来调整运行时的默认行为。</p>
</section>
<section id="new-make-regen-all-build-target">
<h3 class="translated">新增 <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">regen-all</span></code> 构建目标<a class="headerlink" href="#new-make-regen-all-build-target" title="Link to this heading">¶</a></h3>
<p class="translated">为了简化交叉编译，并确保 CPython 能够可靠地编译而不需要已存在可用的 Python 版本，基于 autotools 的构建系统将不再尝试根据文件修改时间隐式地重新编译已生成的文件。</p>
<p class="translated">取而代之的是，新增了一个 <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">regen-all</span></code> 命令以便在需要时强制重新生成这些文件（例如在基于预生成版本构建了 Python 的初始版本之后）。</p>
<p class="translated">还定义了其他一些更具选择性的重生成目标 —— 详情参见 <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/3.14/Makefile.pre.in">Makefile.pre.in</a>。</p>
<p class="translated">（由 Victor Stinner 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=23404">bpo-23404</a> 中贡献。）</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 2.7.14.</span></p>
</div>
</section>
<section id="removal-of-make-touch-build-target">
<h3 class="translated">移除了 <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">touch</span></code> 构建目标<a class="headerlink" href="#removal-of-make-touch-build-target" title="Link to this heading">¶</a></h3>
<p class="translated">之前用于通过更新生成文件的修改时间来请求隐式的重新生成这些文件的 <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">touch</span></code> 构建目标已被移除。</p>
<p class="translated">它已被新的 <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">regen-all</span></code> 目标所替代。</p>
<p class="translated">（由 Victor Stinner 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=23404">bpo-23404</a> 中贡献。）</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 2.7.14 版本发生变更.</span></p>
</div>
</section>
</section>
<section id="acknowledgements">
<span id="acks27"></span><h2 class="translated">致谢<a class="headerlink" href="#acknowledgements" title="Link to this heading">¶</a></h2>
<p class="translated">作者要感谢以下人员为本文的各种草案提供建议、更正和帮助： Nick Coghlan、 Philip Jenvey、 Ryan Lovett、 R. David Murray、 Hugh Secker-Walker。</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#">Python 2.7 有什么新变化</a><ul>
<li><a class="reference internal" href="#the-future-for-python-2-x">Python 2.x的未来</a></li>
<li><a class="reference internal" href="#changes-to-the-handling-of-deprecation-warnings">对于弃用警告处理方式的改变</a></li>
<li><a class="reference internal" href="#python-3-1-features">Python 3.1 特性</a></li>
<li><a class="reference internal" href="#pep-372-adding-an-ordered-dictionary-to-collections">PEP 372：将有序字典 添加到收藏集</a></li>
<li><a class="reference internal" href="#pep-378-format-specifier-for-thousands-separator">PEP 378: 千位分隔符的格式说明符</a></li>
<li><a class="reference internal" href="#pep-389-the-argparse-module-for-parsing-command-lines">PEP 389：用于解析命令行的 argparse 模块</a></li>
<li><a class="reference internal" href="#pep-391-dictionary-based-configuration-for-logging">PEP 391: 基于字典的日志配置</a></li>
<li><a class="reference internal" href="#pep-3106-dictionary-views">PEP 3106: 字典视图</a></li>
<li><a class="reference internal" href="#pep-3137-the-memoryview-object">PEP 3137: memoryview 对象</a></li>
<li><a class="reference internal" href="#other-language-changes">其他语言特性修改</a><ul>
<li><a class="reference internal" href="#interpreter-changes">解释器改动</a></li>
<li><a class="reference internal" href="#optimizations">性能优化</a></li>
</ul>
</li>
<li><a class="reference internal" href="#new-and-improved-modules">新增和改进的模块</a><ul>
<li><a class="reference internal" href="#new-module-importlib">新增模块：importlib</a></li>
<li><a class="reference internal" href="#new-module-sysconfig">新增模块：sysconfig</a></li>
<li><a class="reference internal" href="#ttk-themed-widgets-for-tk">ttk：Tk 主题组件</a></li>
<li><a class="reference internal" href="#updated-module-unittest">更新的模块：unittest</a></li>
<li><a class="reference internal" href="#updated-module-elementtree-1-3">更新的模块：ElementTree 1.3</a></li>
</ul>
</li>
<li><a class="reference internal" href="#build-and-c-api-changes">构建和 C API 的变更</a><ul>
<li><a class="reference internal" href="#capsules">Capsule 对象</a></li>
<li><a class="reference internal" href="#port-specific-changes-windows">特定于 Windows 的更改：</a></li>
<li><a class="reference internal" href="#port-specific-changes-mac-os-x">特定于 Mac OS X 的更改：</a></li>
<li><a class="reference internal" href="#port-specific-changes-freebsd">特定于 FreeBSD 的更改：</a></li>
</ul>
</li>
<li><a class="reference internal" href="#other-changes-and-fixes">其他的变更和修正</a></li>
<li><a class="reference internal" href="#porting-to-python-2-7">移植到 Python 2.7</a></li>
<li><a class="reference internal" href="#new-features-added-to-python-2-7-maintenance-releases">Python 2.7 维护版本中添加的新特性</a><ul>
<li><a class="reference internal" href="#two-new-environment-variables-for-debug-mode">调试模式的两个新环境变量</a></li>
<li><a class="reference internal" href="#pep-434-idle-enhancement-exception-for-all-branches">PEP 434：针对所有分支的 IDLE 增强功能豁免提案</a></li>
<li><a class="reference internal" href="#pep-466-network-security-enhancements-for-python-2-7">PEP 466: 针对 Python 2.7 的网络安全加固</a></li>
<li><a class="reference internal" href="#pep-477-backport-ensurepip-pep-453-to-python-2-7">PEP 477: 将 ensurepip (PEP 453) 向下移植到 Python 2.7</a><ul>
<li><a class="reference internal" href="#bootstrapping-pip-by-default">默认对 pip 进行初始配置</a></li>
<li><a class="reference internal" href="#documentation-changes">文档更改</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pep-476-enabling-certificate-verification-by-default-for-stdlib-http-clients">PEP 476: 默认为 stdlib http 客户端启用证书验证</a></li>
<li><a class="reference internal" href="#pep-493-https-verification-migration-tools-for-python-2-7">PEP 493：适用于Python 2.7 的 HTTPS 验证迁移工具</a></li>
<li><a class="reference internal" href="#new-make-regen-all-build-target">新增 <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">regen-all</span></code> 构建目标</a></li>
<li><a class="reference internal" href="#removal-of-make-touch-build-target">移除了 <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">touch</span></code> 构建目标</a></li>
</ul>
</li>
<li><a class="reference internal" href="#acknowledgements">致谢</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一主题</h4>
    <p class="topless"><a href="3.0.html"
                          title="上一章">Python 3.0 有什么新变化</a></p>
  </div>
  <div>
    <h4>下一主题</h4>
    <p class="topless"><a href="2.6.html"
                          title="下一章">Python 2.6 有什么新变化</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">报告代码错误</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/whatsnew/2.7.rst?plain=1"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="折叠边栏">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="2.6.html" title="Python 2.6 有什么新变化"
             >下一页</a> |</li>
        <li class="right" >
          <a href="3.0.html" title="Python 3.0 有什么新变化"
             >上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.14.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python的新变化</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Python 2.7 有什么新变化</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q" id="search-box">
          <input type="submit" value="转到">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    主题
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>自动</option>
        <option value="light">明亮</option>
        <option value="dark">黑暗</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版权</a> 2001 Python Software Foundation.
    <br>
    本页面采用 Python 软件基金会许可证第 2 版授权。
    <br>
    文档中的示例、代码片段及其他代码内容额外采用零条款 BSD 许可证授权。
    <br>
    
      更多信息请参阅《<a href="/license.html"> 历史与许可 </a>》。<br>
    
    
    <br>

    Python 软件基金会是一家非营利性公司。
<a href="https://www.python.org/psf/donations/">请进行捐赠。</a>
<br>
    <br>
      最后更新于11月 25, 2025 (07:24 UTC) 。
    
      <a href="/bugs.html">发现了错误</a>？
    
    <br>

    使用<a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3 创建。
    </div>

  </body>
</html>
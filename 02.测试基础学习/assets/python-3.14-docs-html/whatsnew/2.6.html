<!DOCTYPE html>

<html lang="zh-CN" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="Python 2.6 有什么新变化" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/whatsnew/2.6.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="作者, A.M. Kuchling (amk at amk.ca),. 本文介绍了 Python 2.6 的新特性，它发布于 2008 年 10 月 1 日。发布日程说明见 PEP 361 。 Python 2.6 的重要主题是准备好迁移到 Python 3.0，该版本是这个编程语言的一次重大重新设计。 只要有可能，Python 2.6 就会纳入来自 3.0 的新特性和语法同时通过不移除旧特..." />
<meta property="og:image:width" content="1146" />
<meta property="og:image:height" content="600" />
<meta property="og:image" content="https://docs.python.org/3.14/zh-cn/_images/social_previews/summary_whatsnew_2.6_2feb2c1f.png" />
<meta property="og:image:alt" content="作者, A.M. Kuchling (amk at amk.ca),. 本文介绍了 Python 2.6 的新特性，它发布于 2008 年 10 月 1 日。发布日程说明见 PEP 361 。 Python 2.6 的重要主题是准备好迁移到 Python 3.0，该版本是这个编程语言的一次重大重新设计。 只要有可能，Python 2.6 就会纳入来自 3.0 的新特性和语法同时通过不移除旧特..." />
<meta name="description" content="作者, A.M. Kuchling (amk at amk.ca),. 本文介绍了 Python 2.6 的新特性，它发布于 2008 年 10 月 1 日。发布日程说明见 PEP 361 。 Python 2.6 的重要主题是准备好迁移到 Python 3.0，该版本是这个编程语言的一次重大重新设计。 只要有可能，Python 2.6 就会纳入来自 3.0 的新特性和语法同时通过不移除旧特..." />
<meta name="twitter:card" content="summary_large_image" />
<meta name="theme-color" content="#3776ab">

    <title>Python 2.6 有什么新变化 &#8212; Python 3.14.0 文档</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=234b1a7c" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=8cd84f99" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=5349f25f" />
    
    <script src="../_static/documentation_options.js?v=a595ec0e"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=beaddf03"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.14.0 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于此文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权" href="../copyright.html" />
    <link rel="next" title="Python 2.5 有什么新变化" href="2.5.html" />
    <link rel="prev" title="Python 2.7 有什么新变化" href="2.7.html" />
    
      
      <script defer file-types="bz2,epub,zip" data-domain="docs.python.org" src="https://analytics.python.org/js/script.file-downloads.outbound-links.js"></script>
      
      <link rel="canonical" href="https://docs.python.org/3/whatsnew/2.6.html">
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg">
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="菜单">
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo">
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q">
                <input type="submit" value="转到">
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    主题
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>自动</option>
        <option value="light">明亮</option>
        <option value="dark">黑暗</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#">Python 2.6 有什么新变化</a><ul>
<li><a class="reference internal" href="#python-3-0">Python 3.0</a></li>
<li><a class="reference internal" href="#changes-to-the-development-process">开发过程的变化</a><ul>
<li><a class="reference internal" href="#new-issue-tracker-roundup">新问题追踪：简述</a></li>
<li><a class="reference internal" href="#new-documentation-format-restructuredtext-using-sphinx">新的文档格式：使用 Sphinx 的 reStructuredText</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pep-343-the-with-statement">PEP 343: &quot;with&quot; 语句</a><ul>
<li><a class="reference internal" href="#writing-context-managers">编写上下文管理器</a></li>
<li><a class="reference internal" href="#the-contextlib-module">contextlib 模块</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pep-366-explicit-relative-imports-from-a-main-module">PEP 366: 从主模块显式相对导入</a></li>
<li><a class="reference internal" href="#pep-370-per-user-site-packages-directory">PEP 370: 分用户的 site-packages 目录</a></li>
<li><a class="reference internal" href="#pep-371-the-multiprocessing-package">PEP 371: <code class="docutils literal notranslate"><span class="pre">multiprocessing</span></code> (多进程)包</a></li>
<li><a class="reference internal" href="#pep-3101-advanced-string-formatting">PEP 3101: 高级字符串格式</a></li>
<li><a class="reference internal" href="#pep-3105-print-as-a-function">PEP 3105: <code class="docutils literal notranslate"><span class="pre">print</span></code> 改为函数</a></li>
<li><a class="reference internal" href="#pep-3110-exception-handling-changes">PEP 3110: 异常处理的变更</a></li>
<li><a class="reference internal" href="#pep-3112-byte-literals">PEP 3112: 字节字面值</a></li>
<li><a class="reference internal" href="#pep-3116-new-i-o-library">PEP 3116: 新 I/O 库</a></li>
<li><a class="reference internal" href="#pep-3118-revised-buffer-protocol">PEP 3118: 修改缓冲区协议</a></li>
<li><a class="reference internal" href="#pep-3119-abstract-base-classes">PEP 3119: 抽象基类</a></li>
<li><a class="reference internal" href="#pep-3127-integer-literal-support-and-syntax">PEP 3127: 整型文字支持和语法</a></li>
<li><a class="reference internal" href="#pep-3129-class-decorators">PEP 3129: 类装饰器</a></li>
<li><a class="reference internal" href="#pep-3141-a-type-hierarchy-for-numbers">PEP 3141: 数字的类型层级结构</a><ul>
<li><a class="reference internal" href="#the-fractions-module"><code class="xref py py-mod docutils literal notranslate"><span class="pre">fractions</span></code> 模块</a></li>
</ul>
</li>
<li><a class="reference internal" href="#other-language-changes">其他语言特性修改</a><ul>
<li><a class="reference internal" href="#optimizations">性能优化</a></li>
<li><a class="reference internal" href="#interpreter-changes">解释器改动</a></li>
</ul>
</li>
<li><a class="reference internal" href="#new-and-improved-modules">新增和改进的模块</a><ul>
<li><a class="reference internal" href="#the-ast-module"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code> 模块</a></li>
<li><a class="reference internal" href="#the-future-builtins-module"><code class="xref py py-mod docutils literal notranslate"><span class="pre">future_builtins</span></code> 模块</a></li>
<li><a class="reference internal" href="#the-json-module-javascript-object-notation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">json</span></code> 模块: JavaScript Object Notation</a></li>
<li><a class="reference internal" href="#the-plistlib-module-a-property-list-parser"><code class="xref py py-mod docutils literal notranslate"><span class="pre">plistlib</span></code> 模块：属性列表解析器</a></li>
<li><a class="reference internal" href="#ctypes-enhancements">ctypes 增强</a></li>
<li><a class="reference internal" href="#improved-ssl-support">改进的 SSL 支持</a></li>
</ul>
</li>
<li><a class="reference internal" href="#deprecations-and-removals">弃用和移除</a></li>
<li><a class="reference internal" href="#build-and-c-api-changes">构建和 C API 的变更</a><ul>
<li><a class="reference internal" href="#port-specific-changes-windows">特定于 Windows 的更改：</a></li>
<li><a class="reference internal" href="#port-specific-changes-mac-os-x">特定于 Mac OS X 的更改：</a></li>
<li><a class="reference internal" href="#port-specific-changes-irix">特定于 IRIX 的更改：</a></li>
</ul>
</li>
<li><a class="reference internal" href="#porting-to-python-2-6">移植到Python 2.6</a></li>
<li><a class="reference internal" href="#acknowledgements">致谢</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一主题</h4>
    <p class="topless"><a href="2.7.html"
                          title="上一章">Python 2.7 有什么新变化</a></p>
  </div>
  <div>
    <h4>下一主题</h4>
    <p class="topless"><a href="2.5.html"
                          title="下一章">Python 2.5 有什么新变化</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">报告代码错误</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/whatsnew/2.6.rst?plain=1"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="2.5.html" title="Python 2.5 有什么新变化"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="2.7.html" title="Python 2.7 有什么新变化"
             accesskey="P">上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.14.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python的新变化</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Python 2.6 有什么新变化</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q" id="search-box">
          <input type="submit" value="转到">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    主题
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>自动</option>
        <option value="light">明亮</option>
        <option value="dark">黑暗</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="what-s-new-in-python-2-6">
<span id="whats-new-in-2-6"></span><h1 class="translated">Python 2.6 有什么新变化<a class="headerlink" href="#what-s-new-in-python-2-6" title="Link to this heading">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd translated">作者<span class="colon">:</span></dt>
<dd class="field-odd translated"><p class="translated">A.M. Kuchling (amk at amk.ca)</p>
</dd>
</dl>
<p class="translated">本文介绍了 Python 2.6 的新特性，它发布于 2008 年 10 月 1 日。发布日程说明见 <span class="target" id="index-51"></span><a class="pep reference external" href="https://peps.python.org/pep-0361/"><strong>PEP 361</strong></a>。</p>
<p class="translated">Python 2.6 的重要主题是准备好迁移到 Python 3.0，该版本是这个编程语言的一次重大重新设计。 只要有可能，Python 2.6 就会纳入来自 3.0 的新特性和语法同时通过不移除旧特性或语法来保持与现有代码的兼容。 当无法做到这一点时，Python 2.6 会尽力而为，在 <code class="xref py py-mod docutils literal notranslate"><span class="pre">future_builtins</span></code> 模块中添加兼容性函数并用 <code class="xref std std-option docutils literal notranslate"><span class="pre">-3</span></code> 开关来警告将在 3.0 变得不受支持的用法。</p>
<p class="translated">标准库中增加了一些重要的新包，如 <a class="reference internal" href="../library/multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> 和 <a class="reference internal" href="../library/json.html#module-json" title="json: Encode and decode the JSON format."><code class="xref py py-mod docutils literal notranslate"><span class="pre">json</span></code></a> 模块等，但与 Python 3.0 完全无关联的新特性并不多。</p>
<p class="translated">Python 2.6 还对整个源代码进行了大量改进和错误修复。 通过搜索更改日志我们发现在 Python 2.5 和 2.6 之间应用了 259 个补丁并修复了 612 个错误。 这两个数字可能都被低估了。</p>
<p class="translated">本文并不试图提供新特性的完整规范说明，而是提供一个方便的概览。 要了解完整的细节，请参阅 Python 2.6 的文档。 如果你想了解有关设计和实现的具体考量，请参阅特定新特性 的 PEP。 在可能的情况下，“Python 有什么新变化”为每个更改的错误修正/补丁项提供链接。</p>
<section id="python-3-0">
<h2 class="translated">Python 3.0<a class="headerlink" href="#python-3-0" title="Link to this heading">¶</a></h2>
<p class="translated">Python版本2.6和3.0的开发周期是同步的，两个版本的alpha和beta版本是在同一天发布的。3.0的发展影响了2.6中的许多功能。</p>
<p class="translated">Python 3.0 是对 Python 的大范围重新设计，打破了与 2.x 系列的兼容性。  这意味着现有的 Python 代码需要进行一些转换才能在 Python 3.0 上运行。  不过，并非 3.0 中的所有更改都会破坏兼容性。 在新特性不会导致现有代码崩溃的情况下，它们会被回溯到 2.6，并在本文档的适当位置进行描述。 部分 3.0 衍生功能包括:</p>
<ul class="simple">
<li><p class="translated">用于将对象转换为复数的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__complex__()</span></code> 方法。</p></li>
<li><p class="translated">用于捕获异常的替代语法: <code class="docutils literal notranslate"><span class="pre">except</span> <span class="pre">TypeError</span> <span class="pre">as</span> <span class="pre">exc</span></code>。</p></li>
<li><p class="translated">增加 <a class="reference internal" href="../library/functools.html#functools.reduce" title="functools.reduce"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.reduce()</span></code></a> 作为内置 <code class="xref py py-func docutils literal notranslate"><span class="pre">reduce()</span></code> 函数的同义词。</p></li>
</ul>
<p class="translated">Python 3.0 新增了一些内置函数并对部分现有内置函数的语法进行了修改。 在 3.0 中新增的函数如 <a class="reference internal" href="../library/functions.html#bin" title="bin"><code class="xref py py-func docutils literal notranslate"><span class="pre">bin()</span></code></a> 已直接添加到 Python 2.6 中，但现有的内置函数则未做修改；作为替代，在 <code class="xref py py-mod docutils literal notranslate"><span class="pre">future_builtins</span></code> 模块中包含了使用新的 3.0 语义的版本。 要编写与 3.0 兼容的代码可以在必要时执行 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">future_builtins</span> <span class="pre">import</span> <span class="pre">hex,</span> <span class="pre">map</span></code>。</p>
<p class="translated">新增的命令行开关 <code class="xref std std-option docutils literal notranslate"><span class="pre">-3</span></code> 将启用对将在 Python 3.0 中移除的特性的警告。 你可以使用该开关运行代码以了解将代码移植到 3.0 需要做多少工作。 Python 代码可以使用布尔型变量 <code class="xref py py-data docutils literal notranslate"><span class="pre">sys.py3kwarning</span></code> 访问该开关的值，对于 C 扩展代码则可以使用 <code class="xref c c-data docutils literal notranslate"><span class="pre">Py_Py3kWarningFlag</span></code>。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p class="translated">3<em>xxx</em> 系列 PEP 包含针对 Python 3.0 的提议。 <span class="target" id="index-52"></span><a class="pep reference external" href="https://peps.python.org/pep-3000/"><strong>PEP 3000</strong></a> 描述了 Python 3.0 的开发进程。 从 <span class="target" id="index-53"></span><a class="pep reference external" href="https://peps.python.org/pep-3100/"><strong>PEP 3100</strong></a> 开始描述 Python 3.0 的主要目标，然后继续列出提议具体特性的更高数字的 PEP。</p>
</div>
</section>
<section id="changes-to-the-development-process">
<h2 class="translated">开发过程的变化<a class="headerlink" href="#changes-to-the-development-process" title="Link to this heading">¶</a></h2>
<p class="translated">在开发2.6时，Python开发过程经历了两个重大变化：我们从SourceForge的问题跟踪程序切换到定制的Roundup安装，文档从LaTeX转换为reStructuredText。</p>
<section id="new-issue-tracker-roundup">
<h3 class="translated">新问题追踪：简述<a class="headerlink" href="#new-issue-tracker-roundup" title="Link to this heading">¶</a></h3>
<p class="translated">很长一段时间以来，Python开发人员对SourceForge的bug跟踪器越来越恼火。SourceForge的托管解决方案不允许进行大量定制；例如，无法定制问题的生命周期。</p>
<p class="translated">Python软件基金会的基础设施委员会因此发布了一个问题跟踪器的征集公告，邀请志愿者设置不同的产品，并从SourceForge导入一些错误和补丁。评估了四种不同的跟踪器：<a class="reference external" href="https://www.atlassian.com/software/jira/">Jira</a>，<a class="reference external" href="https://launchpad.net/">Launchpad</a>，<a class="reference external" href="https://trac.edgewall.org/">Roundup &lt;https://roundup.sourceforge.io/&gt;`__和`Trac</a>。委员会最终确定Jira和Roundup为两个候选方案。Jira是一个商业产品，为自由软件项目提供免费托管实例；Roundup是一个开源项目，需要志愿者来管理，并需要一个服务器来托管。</p>
<p class="translated">在发出志愿者号召后，在https://bugs.python.org的一个Roundup的安装可以托管多个跟踪器，现在该服务器还托管Jython和Python网站的问题跟踪器。它肯定会在未来找到其他用途。在可能的情况下，此版本的“What's New in Python”链接到每个更改的bug/补丁项。</p>
<p class="translated">Python错误跟踪器的托管由南非斯泰伦博斯市的 <a class="reference external" href="https://upfrontsoftware.co.za">Upfront Systems</a> 友好提供。Martin von Löwis 在从 SourceForge 导入现有错误和补丁方面做了大量工作；他的导入脚本位于 <code class="docutils literal notranslate"><span class="pre">https://svn.python.org/view/tracker/importer/</span></code>，对于希望从 SourceForge 迁移到 Roundup 的其他项目可能有所帮助。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><a class="reference external" href="https://bugs.python.org">https://bugs.python.org</a></dt><dd><p class="translated">Python 的错误追踪器。</p>
</dd>
<dt class="translated"><a class="reference external" href="https://bugs.jython.org">https://bugs.jython.org</a>:</dt><dd><p class="translated">Jython 的错误追踪器。</p>
</dd>
<dt class="translated"><a class="reference external" href="https://roundup.sourceforge.io/">https://roundup.sourceforge.io/</a></dt><dd><p class="translated">Roundup 下载和文档。</p>
</dd>
<dt class="translated"><a class="reference external" href="https://svn.python.org/view/tracker/importer/">https://svn.python.org/view/tracker/importer/</a></dt><dd><p class="translated">Martin von Löwis 的转换脚本。</p>
</dd>
</dl>
</div>
</section>
<section id="new-documentation-format-restructuredtext-using-sphinx">
<h3 class="translated">新的文档格式：使用 Sphinx 的 reStructuredText<a class="headerlink" href="#new-documentation-format-restructuredtext-using-sphinx" title="Link to this heading">¶</a></h3>
<p class="translated">自 1989 年左右项目启动以来，Python 文档一直使用 LaTeX 编写。在 1980 年代和 1990 年代早期，大多数文档都是打印出来供日后学习的，而不是在网上查看。 LaTeX 被广泛使用，因为它既能提供美观的打印输出，又能在掌握了标记的基本规则后直接进行编写。</p>
<p class="translated">如今 LaTeX 仍被用于编写印刷出版物，但编程工具的格局已经发生了变化。 我们不再打印成堆的文档，取而代之的是在线浏览，HTML 已成为最重要的支持格式。 不幸的是，将 LaTeX 转换为 HTML 相当复杂，长期担任 Python 文档编辑的 Fred L. Drake Jr. 花了许多时间在维护转换过程上。 偶尔有人会建议将文档转换成 SGML，之后再转换成 XML，但进行良好的转换是一项艰巨的任务，从来没有人投入所需的时间来完成这项工作。</p>
<p class="translated">在 2.6 开发周期中，Georg Brandl 投入了大量精力来构建一个新的工具链，用于处理文档。由此产生的软件包名为 Sphinx，可从 <a class="reference external" href="https://www.sphinx-doc.org/">https://www.sphinx-doc.org/</a> 获取。</p>
<p class="translated">Sphinx 专注于 HTML 输出，可生成吸引人风格的现代 HTML；通过转换为 LaTeX，仍可支持打印输出。输入格式是 reStructuredText，这是一种支持自定义扩展和指令的标记语法，在 Python 社区很常用。</p>
<p class="translated">Sphinx 是一个可用于写文档的独立软件包，将近二十多个其他项目 (<a class="reference external" href="https://www.sphinx-doc.org/en/master/examples.html">列在 Sphinx 网站</a> 上) 已采用 Sphinx 作为其文档工具。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><a class="reference external" href="https://devguide.python.org/documenting/">Documenting Python</a></dt><dd><p class="translated">描述如何编写Python文档。</p>
</dd>
<dt class="translated"><a class="reference external" href="https://www.sphinx-doc.org/">Sphinx</a></dt><dd><p class="translated">Sphinx工具链的文档和代码。</p>
</dd>
<dt class="translated"><a class="reference external" href="https://docutils.sourceforge.io">Docutils</a></dt><dd><p class="translated">reStructuredText 的基础解析器和工具集。</p>
</dd>
</dl>
</div>
</section>
</section>
<section id="pep-343-the-with-statement">
<span id="pep-0343"></span><h2 class="translated">PEP 343: &quot;with&quot; 语句<a class="headerlink" href="#pep-343-the-with-statement" title="Link to this heading">¶</a></h2>
<p class="translated">在 Python 2.5 之前的版本中，&quot;<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>&quot; 语句是一个可选功能，可以通过 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">with_statement</span></code> 指令启用。 在 2.6 中，该语句不再需要特别启用；这意味着 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code> 现在总是一个关键字。 本节的其余部分是“Python 2.5 新特性”文档中相应部分的复制；如果你熟悉 Python 2.5 中的  '<code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code>' 语句，可以跳过本节。</p>
<p class="translated">'<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>' 语句澄清了以前使用 <code class="docutils literal notranslate"><span class="pre">try...finally</span></code> 块来确保执行清理代码的代码。在本节中，我将讨论该语句的常见用法。在下一节中，我将探讨实现细节，并展示如何编写与该语句一起使用的对象。</p>
<p class="translated">'<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>' 语句是一种基本结构如下所示的流程控制结构:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">expression</span> <span class="p">[</span><span class="k">as</span> <span class="n">variable</span><span class="p">]:</span>
    <span class="k">with</span><span class="o">-</span><span class="n">block</span>
</pre></div>
</div>
<p class="translated">表达式会被求值，并且其结果应为一个支持上下文协议的对象（即具有 <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> 和 <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 方法）。</p>
<p class="translated">在执行 <em>with-block</em> 之前，会调用对象的 <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> 方法，因此可以运行设置代码。它还可以返回一个值，该值绑定到 <em>variable*（如果给出的话）。（请注意，*variable</em> 并不是被赋值为 <em>expression</em> 的结果。）</p>
<p class="translated">在 <em>with-block</em> 执行完成后，即使块引发了异常，也会调用对象的 <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 方法，因此可以运行清理代码。</p>
<p class="translated">一些标准 Python 对象现在已支持上下文管理协议并可被用于 '<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>' 语句。 文件对象就是一个例子:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/etc/passwd&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
        <span class="nb">print</span> <span class="n">line</span>
        <span class="o">...</span> <span class="n">更多处理代码</span> <span class="o">...</span>
</pre></div>
</div>
<p class="translated">在此语句被执行之后，文件对象 <em>f</em> 将被自动关闭，即使是当 <a class="reference internal" href="../reference/compound_stmts.html#for"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">for</span></code></a> 循环在代码块中间引发了异常的时候也是如此。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p class="translated">在此情况下，<em>f</em> 就是由 <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> 所创建的对象，因为 <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> 会返回 <em>self</em>。</p>
</div>
<p class="translated"><a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> 模块的加锁和条件变量也支持 '<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>' 语句:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
<span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
    <span class="c1"># 关键代码段</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated">这个锁会在代码块被执行之前锁定并总是会在代码块完成之后释放。</p>
<p class="translated"><a class="reference internal" href="../library/decimal.html#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic Specification."><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code></a> 模块的 <a class="reference internal" href="../library/decimal.html#decimal.localcontext" title="decimal.localcontext"><code class="xref py py-func docutils literal notranslate"><span class="pre">localcontext()</span></code></a> 函数使得保存和恢复当前的十进制数上下文更为容易，它封装了计算所要使用的精度和舍入方式:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">decimal</span><span class="w"> </span><span class="kn">import</span> <span class="n">Decimal</span><span class="p">,</span> <span class="n">Context</span><span class="p">,</span> <span class="n">localcontext</span>

<span class="c1"># 使用默认精度 28 位显示</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">&#39;578&#39;</span><span class="p">)</span>
<span class="nb">print</span> <span class="n">v</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>

<span class="k">with</span> <span class="n">localcontext</span><span class="p">(</span><span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">16</span><span class="p">)):</span>
    <span class="c1"># 此代码块中的所有代码使用 16 位精度。</span>
    <span class="c1"># 退出代码块时恢复原始上下文。</span>
    <span class="nb">print</span> <span class="n">v</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>
</pre></div>
</div>
<section id="writing-context-managers">
<span id="new-26-context-managers"></span><h3 class="translated">编写上下文管理器<a class="headerlink" href="#writing-context-managers" title="Link to this heading">¶</a></h3>
<p class="translated">在底层，'<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>' 语句相当复杂。大多数人只会与现有对象一起使用 '<code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code>'，不需要了解这些细节，所以如果你愿意，可以跳过本节的其余部分。新对象的作者需要理解底层实现的细节，应该继续阅读。</p>
<p class="translated">在更高层级上对于上下文管理器协议的解释:</p>
<ul class="simple">
<li><p class="translated">表达式被评估，并应生成一个称为“上下文管理器”的对象。上下文管理器必须具有 <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> 和 <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 方法。</p></li>
<li><p class="translated">调用上下文管理器的 <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> 方法。返回的值被赋给 <em>VAR</em>。如果没有 <code class="docutils literal notranslate"><span class="pre">as</span> <span class="pre">VAR</span></code> 子句，该值将被丢弃。</p></li>
<li><p class="translated"><em>BLOCK</em> 中的代码会被执行。</p></li>
<li><p class="translated">如果 <em>BLOCK</em> 引发异常，将使用三个参数调用上下文管理器的 <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 方法，即异常详情（<code class="docutils literal notranslate"><span class="pre">type,</span> <span class="pre">value,</span> <span class="pre">traceback</span></code>，与 <a class="reference internal" href="../library/sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> 返回的值相同，如果没有发生异常，这些值也可以是 <code class="docutils literal notranslate"><span class="pre">None</span></code>）。该方法的返回值控制是否重新引发异常：任何假值将重新引发异常，而 <code class="docutils literal notranslate"><span class="pre">True</span></code> 将导致抑制异常。你很少会想抑制异常，因为如果你这样做，包含 '<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>' 语句的代码作者将永远不会意识到出了问题。</p></li>
<li><p class="translated">如果 <em>BLOCK</em> 没有引发异常，仍然会调用 <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 方法，但 <em>type</em>、<em>value</em> 和 <em>traceback</em> 都是 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p></li>
</ul>
<p class="translated">让我们通过一个例子来思考。我不会展示详细的代码，而只会概述支持事务的数据库所需的方法。</p>
<p class="translated">（对于不熟悉数据库术语的人来说：对数据库的一组更改被组合成一个事务。事务可以被提交，意味着所有更改都被写入数据库，或者被回滚，意味着所有更改都被丢弃，数据库保持不变。更多信息请参阅任何数据库教材。）</p>
<p class="translated">假设有一个表示数据库连接的对象。我们的目标将允许用户编写如下代码：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">db_connection</span> <span class="o">=</span> <span class="n">DatabaseConnection</span><span class="p">()</span>
<span class="k">with</span> <span class="n">db_connection</span> <span class="k">as</span> <span class="n">cursor</span><span class="p">:</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;insert into ...&#39;</span><span class="p">)</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;delete from ...&#39;</span><span class="p">)</span>
    <span class="c1"># ... 更多操作 ...</span>
</pre></div>
</div>
<p class="translated">如果块中的代码能完美运行则应当提交事务而如果出现异常则应当回滚。 以下是我假设的 <code class="xref py py-class docutils literal notranslate"><span class="pre">DatabaseConnection</span></code> 基本接口:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">DatabaseConnection</span><span class="p">:</span>
    <span class="c1"># 数据库接口</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cursor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;返回一个游标对象并开始一个新事务&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">commit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;提交当前事务&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">rollback</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;回滚当前事务&quot;</span>
</pre></div>
</div>
<p class="translated"><a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> 方法非常简单，只需开始一个新事务。对于此应用程序，生成的游标对象将是一个有用的结果，因此该方法将返回它。用户可以在他们的 '<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>' 语句中添加 <code class="docutils literal notranslate"><span class="pre">as</span> <span class="pre">cursor</span></code> 来将游标绑定到一个变量名。：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">DatabaseConnection</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># 开始新事务的代码</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">cursor</span>
</pre></div>
</div>
<p class="translated"><a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 方法是最复杂的，因为大部分工作都要在这里完成。该方法需要检查是否发生了异常。如果没有异常，事务被提交。如果发生了异常，事务被回滚。</p>
<p class="translated">在下面的代码中，执行将直接从函数末尾跳出，返回默认值 <code class="docutils literal notranslate"><span class="pre">None</span></code>。<code class="docutils literal notranslate"><span class="pre">None</span></code> 为假值，因此异常将自动重新抛出。如果你希望更明确，可以在标记的位置添加一个 <a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 语句。:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">DatabaseConnection</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">tb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># 没有异常，因此提交</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 发生异常，因此回滚。</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>
            <span class="c1"># 返回 False</span>
</pre></div>
</div>
</section>
<section id="the-contextlib-module">
<span id="new-module-contextlib"></span><h3 class="translated">contextlib 模块<a class="headerlink" href="#the-contextlib-module" title="Link to this heading">¶</a></h3>
<p class="translated"><a class="reference internal" href="../library/contextlib.html#module-contextlib" title="contextlib: Utilities for with-statement contexts."><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextlib</span></code></a> 模块提供了一些函数和一个装饰器，这些在编写用于与'<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>'语句一起使用的对象时非常有用。</p>
<p class="translated">该装饰器名为 <a class="reference internal" href="../library/contextlib.html#contextlib.contextmanager" title="contextlib.contextmanager"><code class="xref py py-func docutils literal notranslate"><span class="pre">contextmanager()</span></code></a>，它让你能编写单独的生成器函数而不是定义一个新类。 生成器应当产生恰好一个值。 到 <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 为止的代码将作为 <a class="reference internal" href="../reference/datamodel.html#object.__enter__" title="object.__enter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__enter__()</span></code></a> 方法执行，而产生的值将作为该方法的返回值被绑定到 '<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>' 语句的 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">as</span></code> 子句中的变量，如果有的话。 在 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 之后的代码将在 <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 方法中被执行。 在代码块中引发的任何异常都将由 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 语句引发。</p>
<p class="translated">使用这个装饰器，我们上一节中的数据库示例可以写成:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">contextlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">contextmanager</span>

<span class="nd">@contextmanager</span>
<span class="k">def</span><span class="w"> </span><span class="nf">db_transaction</span><span class="p">(</span><span class="n">connection</span><span class="p">):</span>
    <span class="n">cursor</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">cursor</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">connection</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>
        <span class="k">raise</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">connection</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

<span class="n">db</span> <span class="o">=</span> <span class="n">DatabaseConnection</span><span class="p">()</span>
<span class="k">with</span> <span class="n">db_transaction</span><span class="p">(</span><span class="n">db</span><span class="p">)</span> <span class="k">as</span> <span class="n">cursor</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated"><a class="reference internal" href="../library/contextlib.html#module-contextlib" title="contextlib: Utilities for with-statement contexts."><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextlib</span></code></a> 模块还有一个``nested(mgr1, mgr2, ...)``函数，它可以将多个上下文管理器组合在一起，这样你就不需要编写嵌套的'<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>'语句。在这个例子中，单个'<code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code>'语句既启动数据库事务又获取线程锁:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
<span class="k">with</span> <span class="n">nested</span> <span class="p">(</span><span class="n">db_transaction</span><span class="p">(</span><span class="n">db</span><span class="p">),</span> <span class="n">lock</span><span class="p">)</span> <span class="k">as</span> <span class="p">(</span><span class="n">cursor</span><span class="p">,</span> <span class="n">locked</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated">最后，<a class="reference internal" href="../library/contextlib.html#contextlib.closing" title="contextlib.closing"><code class="xref py py-func docutils literal notranslate"><span class="pre">closing()</span></code></a> 函数返回其参数以便它可被绑定到变量，并在代码块结束时调用参数的 <code class="docutils literal notranslate"><span class="pre">.close()</span></code> 方法。</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">urllib</span><span class="o">,</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">contextlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">closing</span>

<span class="k">with</span> <span class="n">closing</span><span class="p">(</span><span class="n">urllib</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;http://www.yahoo.com&#39;</span><span class="p">))</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-54"></span><a class="pep reference external" href="https://peps.python.org/pep-0343/"><strong>PEP 343</strong></a> - &quot;with&quot; 语句</dt><dd><p class="translated">PEP由Guido van Rossum和Nick Coghlan撰写；由Mike Bland、Guido van Rossum和Neal Norwitz实现。PEP展示了为'<a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a>'语句生成的代码，这对于学习该语句的工作原理很有帮助。</p>
</dd>
</dl>
<p class="translated"><a class="reference internal" href="../library/contextlib.html#module-contextlib" title="contextlib: Utilities for with-statement contexts."><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextlib</span></code></a> 模块的文档。</p>
</div>
</section>
</section>
<section id="pep-366-explicit-relative-imports-from-a-main-module">
<span id="pep-0366"></span><h2 class="translated">PEP 366: 从主模块显式相对导入<a class="headerlink" href="#pep-366-explicit-relative-imports-from-a-main-module" title="Link to this heading">¶</a></h2>
<p class="translated">Python 的 <a class="reference internal" href="../using/cmdline.html#cmdoption-m"><code class="xref std std-option docutils literal notranslate"><span class="pre">-m</span></code></a> 开关允许将一个模块作为脚本来运行。 当你运行一个位于某个包内的模块时，相对导入将无法正确运作。</p>
<p class="translated">Python 2.6的修复增加了一个 <a class="reference internal" href="../reference/datamodel.html#module.__package__" title="module.__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">module.__package__</span></code></a> 属性。当此属性存在时，相对导入将相对于此属性的值而不是 <a class="reference internal" href="../reference/datamodel.html#module.__name__" title="module.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> 属性。</p>
<p class="translated">PEP 302风格的导入器可以按需设置 <a class="reference internal" href="../reference/datamodel.html#module.__package__" title="module.__package__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__package__</span></code></a>。实现 <a class="reference internal" href="../using/cmdline.html#cmdoption-m"><code class="xref std std-option docutils literal notranslate"><span class="pre">-m</span></code></a> 开关的 <a class="reference internal" href="../library/runpy.html#module-runpy" title="runpy: Locate and run Python modules without importing them first."><code class="xref py py-mod docutils literal notranslate"><span class="pre">runpy</span></code></a> 模块现在就这样做，因此相对导入现在可以在从包内运行的脚本中正确工作。</p>
</section>
<section id="pep-370-per-user-site-packages-directory">
<span id="pep-0370"></span><h2 class="translated">PEP 370: 分用户的 site-packages 目录<a class="headerlink" href="#pep-370-per-user-site-packages-directory" title="Link to this heading">¶</a></h2>
<p class="translated">当你运行Python时，模块搜索路径 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> 通常包括一个路径以 <code class="docutils literal notranslate"><span class="pre">&quot;site-packages&quot;</span></code> 结尾的目录。这个目录旨在存放本地安装的、对所有使用该机器或特定站点安装的用户可用的包。</p>
<p class="translated">Python 2.6 引入了一个用于用户专属站点目录的惯例。 该目录根据具体系统平台各不相同:</p>
<ul class="simple">
<li><p class="translated">Unix 和 Mac OS X: <code class="file docutils literal notranslate"><span class="pre">~/.local/</span></code></p></li>
<li><p class="translated">Windows: <code class="file docutils literal notranslate"><span class="pre">%APPDATA%/Python</span></code></p></li>
</ul>
<p class="translated">在此目录中，会有特定版本的子目录，例如在Unix/Mac OS上的 <code class="file docutils literal notranslate"><span class="pre">lib/python2.6/site-packages</span></code> 和在Windows上的 <code class="file docutils literal notranslate"><span class="pre">Python26/site-packages</span></code>。</p>
<p class="translated">如果你不喜欢默认的目录，可以通过环境变量来覆盖它。 <span class="target" id="index-55"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONUSERBASE"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONUSERBASE</span></code></a> 设置支持此特性的所有 Python 版本所使用的根目录。 在 Windows 上，应用程序专属数据的目录可通过设置 <code class="xref std std-envvar docutils literal notranslate"><span class="pre">APPDATA</span></code> 环境变量来更改。 你也可以针对你的 Python 安装版修改 <code class="file docutils literal notranslate"><span class="pre">site.py</span></code> 文件。</p>
<p class="translated">此功能可以通过使用 <a class="reference internal" href="../using/cmdline.html#cmdoption-s"><code class="xref std std-option docutils literal notranslate"><span class="pre">-s</span></code></a> 选项运行Python或设置 <span class="target" id="index-56"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONNOUSERSITE"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONNOUSERSITE</span></code></a> 环境变量来完全禁用。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-57"></span><a class="pep reference external" href="https://peps.python.org/pep-0370/"><strong>PEP 370</strong></a> - 分用户的 site-packages 目录</dt><dd><p class="translated">PEP 由 Christian Heimes 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-371-the-multiprocessing-package">
<span id="pep-0371"></span><h2 class="translated">PEP 371: <code class="docutils literal notranslate"><span class="pre">multiprocessing</span></code> (多进程)包<a class="headerlink" href="#pep-371-the-multiprocessing-package" title="Link to this heading">¶</a></h2>
<p class="translated">新的 <a class="reference internal" href="../library/multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> 包让Python程序可以创建新进程来执行计算并返回结果给父进程。父进程和子进程可以使用队列和管道进行通信，使用锁和信号量同步它们的操作，并且可以共享简单的数据数组。</p>
<p class="translated">The <a class="reference internal" href="../library/multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> 模块起初是作为 <a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> 模块的精确模拟，使用进程而不是线程。 这个目标在 Python 2.6 的开发过程中被放弃了，但模块的总体思路仍然是类似的。 基础的类是 <a class="reference internal" href="../library/multiprocessing.html#multiprocessing.Process" title="multiprocessing.Process"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a>，它接受一个可调用对象和一组参数。 <a class="reference internal" href="../library/multiprocessing.html#multiprocessing.Process.start" title="multiprocessing.Process.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a> 方法将设置在一个子进程中运行的可调用对象，之后你可以调用 <a class="reference internal" href="../library/multiprocessing.html#multiprocessing.Process.is_alive" title="multiprocessing.Process.is_alive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_alive()</span></code></a> 方法来检查子进程是否仍在运行并调用 <a class="reference internal" href="../library/multiprocessing.html#multiprocessing.Process.join" title="multiprocessing.Process.join"><code class="xref py py-meth docutils literal notranslate"><span class="pre">join()</span></code></a> 方法来等待进程退出。</p>
<p class="translated">下面是一个简单的示例，子进程将计算阶乘。执行计算的函数写得很奇怪，以便当输入参数是 4 的倍数时，它会花费更长的时间。</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">multiprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Queue</span>


<span class="k">def</span><span class="w"> </span><span class="nf">factorial</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="s2">&quot;计算阶乘&quot;</span>
    <span class="c1"># 如果 N 是 4 的倍数，这个函数将会花费更长的时间。</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">N</span> <span class="o">%</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">.05</span> <span class="o">*</span> <span class="n">N</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span>

    <span class="c1"># 计算结果</span>
    <span class="n">fact</span> <span class="o">=</span> <span class="mi">1</span><span class="n">L</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="n">fact</span> <span class="o">*</span> <span class="n">i</span>

    <span class="c1"># 将结果放入队列</span>
    <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">fact</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>

    <span class="n">N</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">factorial</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
    <span class="nb">print</span> <span class="s1">&#39;Factorial&#39;</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="n">result</span>
</pre></div>
</div>
<p class="translated">使用 <a class="reference internal" href="../library/queue.html#queue.Queue" title="queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> 来传递阶乘的结果。<a class="reference internal" href="../library/queue.html#queue.Queue" title="queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a> 对象存储在一个全局变量中。子进程将使用创建子进程时的变量值；因为它是 <a class="reference internal" href="../library/queue.html#queue.Queue" title="queue.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a>，父进程和子进程可以使用该对象进行通信。（如果父进程更改全局变量的值，子进程的值不会受影响，反之亦然。）</p>
<p class="translated">另外两个类，<a class="reference internal" href="../library/multiprocessing.html#multiprocessing.pool.Pool" title="multiprocessing.pool.Pool"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pool</span></code></a> 和 <a class="reference internal" href="../library/multiprocessing.html#multiprocessing.Manager" title="multiprocessing.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a>，提供更高层级的接口。 <a class="reference internal" href="../library/multiprocessing.html#multiprocessing.pool.Pool" title="multiprocessing.pool.Pool"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pool</span></code></a> 将创建固定数量的工作进程，然后可以通过调用will create a fixed number of worker processes, and requests can then be distributed to the workers by calling <a class="reference internal" href="../library/multiprocessing.html#multiprocessing.pool.Pool.apply" title="multiprocessing.pool.Pool.apply"><code class="xref py py-meth docutils literal notranslate"><span class="pre">apply()</span></code></a> 或 <a class="reference internal" href="../library/multiprocessing.html#multiprocessing.pool.Pool.apply_async" title="multiprocessing.pool.Pool.apply_async"><code class="xref py py-meth docutils literal notranslate"><span class="pre">apply_async()</span></code></a> 来添加单个请求，通过调用 <a class="reference internal" href="../library/multiprocessing.html#multiprocessing.pool.Pool.map" title="multiprocessing.pool.Pool.map"><code class="xref py py-meth docutils literal notranslate"><span class="pre">map()</span></code></a> 或 <a class="reference internal" href="../library/multiprocessing.html#multiprocessing.pool.Pool.map_async" title="multiprocessing.pool.Pool.map_async"><code class="xref py py-meth docutils literal notranslate"><span class="pre">map_async()</span></code></a> 来添加多个请求以将请求分发给这些工作进程。 以下代码使用 <a class="reference internal" href="../library/multiprocessing.html#multiprocessing.pool.Pool" title="multiprocessing.pool.Pool"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pool</span></code></a> 将请求分散到 5 个工作进程并获取结果列表:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">multiprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Pool</span>

<span class="k">def</span><span class="w"> </span><span class="nf">factorial</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">):</span>
    <span class="s2">&quot;Compute a factorial.&quot;</span>
    <span class="o">...</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">factorial</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
    <span class="nb">print</span> <span class="n">v</span>
</pre></div>
</div>
<p class="translated">这会产生以下输出:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span>
<span class="mi">39916800</span>
<span class="mi">51090942171709440000</span>
<span class="mi">8222838654177922817725562880000000</span>
<span class="mi">33452526613163807108170062053440751665152000000000</span>
<span class="o">...</span>
</pre></div>
</div>
<p class="translated">另一个高层级的接口，<a class="reference internal" href="../library/multiprocessing.html#multiprocessing.Manager" title="multiprocessing.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> 类，将创建一个单独的可以拥有 Python 数据结构的主副本的服务器进程。 之后其他的进程可以使用代理对象来访问和修改这些数据结构。 以下示例通过调用 <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dict()</span></code></a> 方法创建了一个共享字典；随后工作进程可将值插入到字典中。 （不会自动为你执行锁定，这在本示例中无关紧要。 <a class="reference internal" href="../library/multiprocessing.html#multiprocessing.Manager" title="multiprocessing.Manager"><code class="xref py py-class docutils literal notranslate"><span class="pre">Manager</span></code></a> 的方法还包括 <a class="reference internal" href="../library/multiprocessing.html#multiprocessing.managers.SyncManager.Lock" title="multiprocessing.managers.SyncManager.Lock"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Lock()</span></code></a>, <a class="reference internal" href="../library/multiprocessing.html#multiprocessing.managers.SyncManager.RLock" title="multiprocessing.managers.SyncManager.RLock"><code class="xref py py-meth docutils literal notranslate"><span class="pre">RLock()</span></code></a> 和 <a class="reference internal" href="../library/multiprocessing.html#multiprocessing.managers.SyncManager.Semaphore" title="multiprocessing.managers.SyncManager.Semaphore"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Semaphore()</span></code></a> 用于创建共享锁。）</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">multiprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Pool</span><span class="p">,</span> <span class="n">Manager</span>

<span class="k">def</span><span class="w"> </span><span class="nf">factorial</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">):</span>
    <span class="s2">&quot;计算阶乘&quot;</span>
    <span class="c1"># 计算结果</span>
    <span class="n">fact</span> <span class="o">=</span> <span class="mi">1</span><span class="n">L</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="n">fact</span> <span class="o">*</span> <span class="n">i</span>

    <span class="c1"># 将结果存储在字典中</span>
    <span class="n">dictionary</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="n">fact</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">mgr</span> <span class="o">=</span> <span class="n">Manager</span><span class="p">()</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">mgr</span><span class="o">.</span><span class="n">dict</span><span class="p">()</span>         <span class="c1"># 创建共享字典</span>

    <span class="c1"># 使用池运行任务</span>
    <span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
        <span class="n">p</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">factorial</span><span class="p">,</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>

    <span class="c1"># 标记池为关闭 -- 不能再添加任务。</span>
    <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c1"># 等待任务退出</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

    <span class="c1"># 输出结果</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="nb">print</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span>
</pre></div>
</div>
<p class="translated">这将产生如下输出:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span> <span class="mi">1</span>
<span class="mi">11</span> <span class="mi">39916800</span>
<span class="mi">21</span> <span class="mi">51090942171709440000</span>
<span class="mi">31</span> <span class="mi">8222838654177922817725562880000000</span>
<span class="mi">41</span> <span class="mi">33452526613163807108170062053440751665152000000000</span>
<span class="mi">51</span> <span class="mf">15511187532873822802242430164693032110632597200169861120000.</span><span class="o">..</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p class="translated"><a class="reference internal" href="../library/multiprocessing.html#module-multiprocessing" title="multiprocessing: Process-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a> 模块的文档。</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-58"></span><a class="pep reference external" href="https://peps.python.org/pep-0371/"><strong>PEP 371</strong></a> - 添加多任务处理包</dt><dd><p class="translated">PEP 由 Jesse Noller 和 Richard Oudkerk 撰写，由 Richard Oudkerk 和 Jesse Noller 实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-3101-advanced-string-formatting">
<span id="pep-3101"></span><h2 class="translated">PEP 3101: 高级字符串格式<a class="headerlink" href="#pep-3101-advanced-string-formatting" title="Link to this heading">¶</a></h2>
<p class="translated">在 Python 3.0 中，<code class="docutils literal notranslate"><span class="pre">%</span></code> 运算符被更强大的字符串格式化方法 <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">format()</span></code></a> 所补充。对 <a class="reference internal" href="../library/stdtypes.html#str.format" title="str.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">str.format()</span></code></a> 方法的支持已经回溯到 Python 2.6。</p>
<p class="translated">在2.6版本中，8位字符串和Unicode字符串都有一个 <code class="docutils literal notranslate"><span class="pre">.format()</span></code> 方法，该方法将字符串视为模板，并接受要格式化的参数。格式化模板使用大括号（<code class="docutils literal notranslate"><span class="pre">{</span></code>, <code class="docutils literal notranslate"><span class="pre">}</span></code>）作为特殊字符：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># 将位置参数0替换到字符串中。</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;User ID: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;root&quot;</span><span class="p">)</span>
<span class="go">&#39;User ID: root&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 使用命名关键字参数</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;User ID: </span><span class="si">{uid}</span><span class="s2">   Last seen: </span><span class="si">{last_login}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
<span class="gp">... </span>   <span class="n">uid</span><span class="o">=</span><span class="s2">&quot;root&quot;</span><span class="p">,</span>
<span class="gp">... </span>   <span class="n">last_login</span> <span class="o">=</span> <span class="s2">&quot;5 Mar 2008 07:20&quot;</span><span class="p">)</span>
<span class="go">&#39;User ID: root   Last seen: 5 Mar 2008 07:20&#39;</span>
</pre></div>
</div>
<p class="translated">大括号可以通过双写来转义：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;Empty dict: {{}}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">()</span>
<span class="go">&quot;Empty dict: {}&quot;</span>
</pre></div>
</div>
<p class="translated">字段名可以是表示位置参数的整数，如 <code class="docutils literal notranslate"><span class="pre">{0}</span></code>、<code class="docutils literal notranslate"><span class="pre">{1}</span></code> 等，或者是关键字参数的名称。你还可以提供复合字段名来读取属性或访问字典键：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="s1">&#39;Platform: </span><span class="si">{0.platform}</span><span class="se">\n</span><span class="s1">Python version: </span><span class="si">{0.version}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sys</span><span class="p">)</span>
<span class="go">Platform: darwin</span>
<span class="go">Python version: 2.6a1+ (trunk:61261M, Mar  5 2008, 20:29:41)</span>
<span class="go">[GCC 4.0.1 (Apple Computer, Inc. build 5367)]&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">mimetypes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;Content-type: </span><span class="si">{0[.mp4]}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mimetypes</span><span class="o">.</span><span class="n">types_map</span><span class="p">)</span>
<span class="go">&#39;Content-type: video/mp4&#39;</span>
</pre></div>
</div>
<p class="translated">请注意，当使用类似 <code class="docutils literal notranslate"><span class="pre">[.mp4]</span></code> 的字典样式表示法时，你不需要在字符串周围加任何引号；它将使用 <code class="docutils literal notranslate"><span class="pre">.mp4</span></code> 作为键来查找值。以数字开头的字符串将被转换为整数。你不能在格式字符串内编写更复杂的表达式。</p>
<p class="translated">到目前为止，我们已经展示了如何指定要替换到结果字符串中的字段。精确的格式化方式也可以通过添加一个冒号后跟一个格式说明符来控制。例如：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># 字段 0：左对齐，填充至 15 个字符</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 字段 1：右对齐，填充至 6 个字符</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0:15}</span><span class="s1"> $</span><span class="si">{1:&gt;6}</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Registration&#39;</span><span class="p">,</span> <span class="mi">35</span><span class="p">)</span>
<span class="go">&#39;Registration    $    35&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Tutorial&#39;</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="go">&#39;Tutorial        $    50&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Banquet&#39;</span><span class="p">,</span> <span class="mi">125</span><span class="p">)</span>
<span class="go">&#39;Banquet         $   125&#39;</span>
</pre></div>
</div>
<p class="translated">格式说明符可以通过嵌套来引用其他字段:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;{0:</span><span class="si">{1}</span><span class="s1">}&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">width</span> <span class="o">=</span> <span class="mi">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Invoice #1234&#39;</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
<span class="go">&#39;Invoice #1234  &#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">width</span> <span class="o">=</span> <span class="mi">35</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;Invoice #1234&#39;</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
<span class="go">&#39;Invoice #1234                      &#39;</span>
</pre></div>
</div>
<p class="translated">可以指定所需宽度内的字段对齐方式：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p class="translated">字符</p></th>
<th class="head"><p class="translated">效果</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="translated">&lt; (默认)</p></td>
<td><p class="translated">左对齐</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">&gt;</p></td>
<td><p class="translated">右对齐</p></td>
</tr>
<tr class="row-even"><td><p class="translated">^</p></td>
<td><p class="translated">居中对齐</p></td>
</tr>
<tr class="row-odd"><td><p class="translated">=</p></td>
<td><p class="translated">（仅适用于数字类型）在符号后加空格。</p></td>
</tr>
</tbody>
</table>
<p class="translated">格式说明符还可以包括一个表示类型，它控制值的格式化方式。例如，浮点数可以格式化为常规数字或指数表示法：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">{0:g}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mf">3.75</span><span class="p">)</span>
<span class="go">&#39;3.75&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;</span><span class="si">{0:e}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mf">3.75</span><span class="p">)</span>
<span class="go">&#39;3.750000e+00&#39;</span>
</pre></div>
</div>
<p class="translated">有多种展示类型可供选择。请参考2.6版文档中的 <a class="reference internal" href="../library/string.html#formatstrings"><span class="std std-ref">完整列表</span></a>；以下是一个示例：</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">b</span></code></p></td>
<td><p class="translated">二进制。输出以2为底的数字。</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">c</span></code></p></td>
<td><p class="translated">字符。在打印之前将整数转换为相应的Unicode字符。</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">d</span></code></p></td>
<td><p class="translated">十进制整数。 输出以 10 为基数的数字。</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">o</span></code></p></td>
<td><p class="translated">八进制格式。 输出以 8 为基数的数字。</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">x</span></code></p></td>
<td><p class="translated">十六进制格式。 输出以 16 为基数的数字，使用小写字母表示 9 以上的数码。</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">e</span></code></p></td>
<td><p class="translated">指数表示法。用字母 'e' 以科学计数法打印数字以表示指数。</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">g</span></code></p></td>
<td><p class="translated">通用格式。这会将数字打印为定点数，除非数字过大，在这种情况下会切换到 'e' 指数表示法。</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">n</span></code></p></td>
<td><p class="translated">数字。这与 'g'（对于浮点数）或 'd'（对于整数）相同，不同之处在于它使用当前区域设置来插入适当的数字分隔符字符。</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><code class="docutils literal notranslate"><span class="pre">%</span></code></p></td>
<td><p class="translated">百分比。将数字乘以100并以固定 ('f') 格式显示，后跟一个百分号。</p></td>
</tr>
</tbody>
</table>
<p class="translated">类和类型可以定义一个 <a class="reference internal" href="../reference/datamodel.html#object.__format__" title="object.__format__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__format__()</span></code></a> 方法来控制它们的格式化方式。 它接受一个参数，即格式说明符:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__format__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">format_spec</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">format_spec</span><span class="p">,</span> <span class="n">unicode</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">unicode</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">还有一个内置函数 <a class="reference internal" href="../library/functions.html#format" title="format"><code class="xref py py-func docutils literal notranslate"><span class="pre">format()</span></code></a> 可以格式化单个值。 它会调用类型的 <a class="reference internal" href="../reference/datamodel.html#object.__format__" title="object.__format__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__format__()</span></code></a> 方法并传入给定的说明符:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">format</span><span class="p">(</span><span class="mf">75.6564</span><span class="p">,</span> <span class="s1">&#39;.2f&#39;</span><span class="p">)</span>
<span class="go">&#39;75.66&#39;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><a class="reference internal" href="../library/string.html#formatstrings"><span class="std std-ref">格式字符串语法</span></a></dt><dd><p class="translated">格式字段的参考文档。</p>
</dd>
<dt class="translated"><span class="target" id="index-59"></span><a class="pep reference external" href="https://peps.python.org/pep-3101/"><strong>PEP 3101</strong></a> - 高级字符串格式</dt><dd><p class="translated">PEP 由 Eric V. Smith 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-3105-print-as-a-function">
<span id="pep-3105"></span><h2 class="translated">PEP 3105: <code class="docutils literal notranslate"><span class="pre">print</span></code> 改为函数<a class="headerlink" href="#pep-3105-print-as-a-function" title="Link to this heading">¶</a></h2>
<p class="translated">在 Python 3.0 中 <code class="docutils literal notranslate"><span class="pre">print</span></code> 语句变成了 <a class="reference internal" href="../library/functions.html#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a> 函数。 将 <a class="reference internal" href="../library/functions.html#print" title="print"><code class="xref py py-func docutils literal notranslate"><span class="pre">print()</span></code></a> 变成函数使得可以通过 <code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">print(...)</span></code> 或从其他地方导入一个新函数来替换该函数。</p>
<p class="translated">Python 2.6 提供了 <code class="docutils literal notranslate"><span class="pre">__future__</span></code> 导入语句来移除 <code class="docutils literal notranslate"><span class="pre">print</span></code> 语法，让你可以改用函数形式。 例如:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">print_function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;# of entries&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dictionary</span><span class="p">),</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">新函数的签名为:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">print</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">形参包括:</p>
<ul class="simple">
<li><p class="translated"><em>args</em>: 相应值将会被打印的位置参数。</p></li>
<li><p class="translated"><em>sep</em>: 分隔符，它将在参数之间被打印。</p></li>
<li><p class="translated"><em>end</em>: 结束文本，它将在所有参数输出完毕之后被打印。</p></li>
<li><p class="translated"><em>file</em>: 将被作为输出发送目标的文件对象。</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-60"></span><a class="pep reference external" href="https://peps.python.org/pep-3105/"><strong>PEP 3105</strong></a> - print 改为函数</dt><dd><p class="translated">PEP 由 Georg Brandl 撰写。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-3110-exception-handling-changes">
<span id="pep-3110"></span><h2 class="translated">PEP 3110: 异常处理的变更<a class="headerlink" href="#pep-3110-exception-handling-changes" title="Link to this heading">¶</a></h2>
<p class="translated">Python 程序员偶尔会犯的一个错误是编写这样的代码:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">except</span> <span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c1"># 错误！</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated">作者可能试图捕获 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 和 <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 异常，但这段代码实际上做了不同的事情：它会捕获 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a> 并将生成的异常对象绑定到局部名称 <code class="docutils literal notranslate"><span class="pre">&quot;ValueError&quot;</span></code>。 <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> 异常根本不会被捕获。正确的代码应指定一个异常元组：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated">这个错误发生是因为这里逗号的使用是模糊的：它是表示解析树中的两个不同节点，还是表示一个元组节点？</p>
<p class="translated">Python 3.0 通过将逗号替换为单词 &quot;as&quot; 来使这一点明确。要捕获异常并将异常对象存储在变量 <code class="docutils literal notranslate"><span class="pre">exc</span></code> 中，你必须写成：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated">Python 3.0 将仅支持使用 &quot;as&quot;，因此将第一个示例解释为捕获两个不同的异常。Python 2.6 同时支持逗号和 &quot;as&quot;，因此现有代码将继续工作。因此，我们建议在编写仅在 2.6 上执行的新的 Python 代码时使用 &quot;as&quot;。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-61"></span><a class="pep reference external" href="https://peps.python.org/pep-3110/"><strong>PEP 3110</strong></a> - 在 Python 3000 中捕获异常</dt><dd><p class="translated">PEP 由 Collin Winter 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-3112-byte-literals">
<span id="pep-3112"></span><h2 class="translated">PEP 3112: 字节字面值<a class="headerlink" href="#pep-3112-byte-literals" title="Link to this heading">¶</a></h2>
<p class="translated">Python 3.0 采用 Unicode 作为语言的基本字符串类型，并以不同的方式表示 8 位字面量，要么作为 <code class="docutils literal notranslate"><span class="pre">b'string'</span></code>，要么使用 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 构造器。为了未来的兼容性，Python 2.6 添加了 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 作为 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 类型的同义词，并且也支持 <code class="docutils literal notranslate"><span class="pre">b''</span></code> 表示法。</p>
<p class="translated">2.6 的 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 与 3.0 的 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 类型在多方面存在差异；最显著的是，构造器完全不同。在 3.0 中，<code class="docutils literal notranslate"><span class="pre">bytes([65,</span> <span class="pre">66,</span> <span class="pre">67])</span></code> 长度为 3，包含表示 <code class="docutils literal notranslate"><span class="pre">ABC</span></code> 的字节；在 2.6 中，<code class="docutils literal notranslate"><span class="pre">bytes([65,</span> <span class="pre">66,</span> <span class="pre">67])</span></code> 返回表示列表的 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> 的 12 字节字符串。</p>
<p class="translated">在 2.6 中，<a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 的主要用途将是编写对象类型测试，例如 <code class="docutils literal notranslate"><span class="pre">isinstance(x,</span> <span class="pre">bytes)</span></code>。这将有助于 2to3 转换器，因为它无法判断 2.x 代码中的字符串是否意图包含字符或 8 位字节；现在你可以使用 <a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 或 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 来准确表示你的意图，并且生成的代码在 Python 3.0 中也是正确的。</p>
<p class="translated">还有一个 <code class="docutils literal notranslate"><span class="pre">__future__</span></code> 导入，它使所有字符串字面量变为 Unicode 字符串。这意味着可以使用 <code class="docutils literal notranslate"><span class="pre">\u</span></code> 转义序列来包含 Unicode 字符：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">unicode_literals</span>

<span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="se">\u751f\u3080\u304e\u3000\u751f\u3054</span><span class="s1">&#39;</span>
     <span class="s1">&#39;</span><span class="se">\u3081\u3000\u751f\u305f\u307e\u3054</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="nb">print</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>               <span class="c1"># 12 个 Unicode 字符</span>
</pre></div>
</div>
<p class="translated">在 C 层级上，Python 3.0 将重命名现有的 8 位字符串类型，从 Python 2.x 中的 <code class="xref c c-type docutils literal notranslate"><span class="pre">PyStringObject</span></code> 改为 <a class="reference internal" href="../c-api/bytes.html#c.PyBytesObject" title="PyBytesObject"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyBytesObject</span></code></a>。 Python 2.6 使用 <code class="docutils literal notranslate"><span class="pre">#define</span></code> 来支持使用 <a class="reference internal" href="../c-api/bytes.html#c.PyBytesObject" title="PyBytesObject"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBytesObject()</span></code></a>, <a class="reference internal" href="../c-api/bytes.html#c.PyBytes_Check" title="PyBytes_Check"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBytes_Check()</span></code></a>, <a class="reference internal" href="../c-api/bytes.html#c.PyBytes_FromStringAndSize" title="PyBytes_FromStringAndSize"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBytes_FromStringAndSize()</span></code></a> 等名称，以及所有用于字符串的其他函数。</p>
<p class="translated"><a class="reference internal" href="../library/stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 类型的实例与字符串一样属于不可变对象。 新增的 <a class="reference internal" href="../library/stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 类型则用于存储可变的字节序列:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bytearray</span><span class="p">([</span><span class="mi">65</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">67</span><span class="p">])</span>
<span class="go">bytearray(b&#39;ABC&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">u</span><span class="s1">&#39;</span><span class="se">\u21ef\u3244</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">bytearray(b&#39;\xe2\x87\xaf\xe3\x89\x84&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\xe3</span><span class="s1">&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">bytearray(b&#39;\xe3\x87\xaf\xe3\x89\x84&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unicode</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="go">u&#39;\u31ef \u3244&#39;</span>
</pre></div>
</div>
<p class="translated">字节数组支持大部分的字符串类型方法，如  <a class="reference internal" href="../library/stdtypes.html#bytearray.startswith" title="bytearray.startswith"><code class="xref py py-meth docutils literal notranslate"><span class="pre">startswith()</span></code></a>/<a class="reference internal" href="../library/stdtypes.html#bytearray.endswith" title="bytearray.endswith"><code class="xref py py-meth docutils literal notranslate"><span class="pre">endswith()</span></code></a> 、<a class="reference internal" href="../library/stdtypes.html#bytearray.find" title="bytearray.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find()</span></code></a>/<a class="reference internal" href="../library/stdtypes.html#bytearray.rfind" title="bytearray.rfind"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rfind()</span></code></a>，以及列表的某些方法，如  <a class="reference internal" href="../library/stdtypes.html#bytearray.append" title="bytearray.append"><code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code></a>、 <a class="reference internal" href="../library/stdtypes.html#bytearray.pop" title="bytearray.pop"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pop()</span></code></a> 和 <a class="reference internal" href="../library/stdtypes.html#bytearray.reverse" title="bytearray.reverse"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reverse()</span></code></a>。</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="s1">&#39;ABC&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;e&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">bytearray(b&#39;ABCde&#39;)</span>
</pre></div>
</div>
<p class="translated">也有一个相应的 C API，包含 <a class="reference internal" href="../c-api/bytearray.html#c.PyByteArray_FromObject" title="PyByteArray_FromObject"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyByteArray_FromObject()</span></code></a>, <a class="reference internal" href="../c-api/bytearray.html#c.PyByteArray_FromStringAndSize" title="PyByteArray_FromStringAndSize"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyByteArray_FromStringAndSize()</span></code></a> 以及各种其他函数。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-62"></span><a class="pep reference external" href="https://peps.python.org/pep-3112/"><strong>PEP 3112</strong></a> - Python 3000 中的字节字面值</dt><dd><p class="translated">PEP 由 Jason Orendorff 撰写， 补丁2.6 由 Christian Heimes 撰写。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-3116-new-i-o-library">
<span id="pep-3116"></span><h2 class="translated">PEP 3116: 新 I/O 库<a class="headerlink" href="#pep-3116-new-i-o-library" title="Link to this heading">¶</a></h2>
<p class="translated">Python 的内置文件对象支持多种方法，但文件型对象并不一定支持所有这些方法。 例如，模仿文件的对象通常支持 <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code>，但它们可能不支持 <code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code>。 Python 3.0 在 <a class="reference internal" href="../library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a> 模块中引入了一个分层的 I/O 库，它将缓冲和文本处理特性从基本读写操作中分离出来。</p>
<p class="translated"><a class="reference internal" href="../library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a> 模块提供了三个层次的抽象基类：</p>
<ul>
<li><p class="translated"><a class="reference internal" href="../library/io.html#io.RawIOBase" title="io.RawIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">RawIOBase</span></code></a> 定义了原始 I/O 操作: <a class="reference internal" href="../library/io.html#io.RawIOBase.read" title="io.RawIOBase.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a>, <a class="reference internal" href="../library/io.html#io.RawIOBase.readinto" title="io.RawIOBase.readinto"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readinto()</span></code></a>, <a class="reference internal" href="../library/io.html#io.RawIOBase.write" title="io.RawIOBase.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a>, <a class="reference internal" href="../library/io.html#io.IOBase.seek" title="io.IOBase.seek"><code class="xref py py-meth docutils literal notranslate"><span class="pre">seek()</span></code></a>, <a class="reference internal" href="../library/io.html#io.IOBase.tell" title="io.IOBase.tell"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tell()</span></code></a>, <a class="reference internal" href="../library/io.html#io.IOBase.truncate" title="io.IOBase.truncate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">truncate()</span></code></a> 和 <a class="reference internal" href="../library/io.html#io.IOBase.close" title="io.IOBase.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a>。 这个类的大多数方法通常会映射到单个系统调用。 还有 <a class="reference internal" href="../library/io.html#io.IOBase.readable" title="io.IOBase.readable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readable()</span></code></a>, <a class="reference internal" href="../library/io.html#io.IOBase.writable" title="io.IOBase.writable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">writable()</span></code></a> 和 <a class="reference internal" href="../library/io.html#io.IOBase.seekable" title="io.IOBase.seekable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">seekable()</span></code></a> 等方法用于确定给定的对象允许哪些操作。</p>
<p class="translated">Python 3.0 为文件和套接字提供了这个类的具体实现，但 Python 2.6 并没有以这种方式重新组织其文件和套接字对象。</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/io.html#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">BufferedIOBase</span></code></a> 是一个抽象基类，它在内存中缓冲数据以减少使用的系统调用次数，使 I/O 处理更为高效。 它支持 <a class="reference internal" href="../library/io.html#io.RawIOBase" title="io.RawIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">RawIOBase</span></code></a> 的所有方法，并增加了一个 <a class="reference internal" href="../library/io.html#io.BufferedIOBase.raw" title="io.BufferedIOBase.raw"><code class="xref py py-attr docutils literal notranslate"><span class="pre">raw</span></code></a> 属性用于存放下层的原始对象。</p>
<p class="translated">有五个具体类实现了这个 ABC. <a class="reference internal" href="../library/io.html#io.BufferedWriter" title="io.BufferedWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">BufferedWriter</span></code></a> 和 <a class="reference internal" href="../library/io.html#io.BufferedReader" title="io.BufferedReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">BufferedReader</span></code></a> 用于具有针对随机访问的 <a class="reference internal" href="../library/io.html#io.IOBase.seek" title="io.IOBase.seek"><code class="xref py py-meth docutils literal notranslate"><span class="pre">seek()</span></code></a> 方法的支持只写或只读使用的对象。 <a class="reference internal" href="../library/io.html#io.BufferedRandom" title="io.BufferedRandom"><code class="xref py py-class docutils literal notranslate"><span class="pre">BufferedRandom</span></code></a> 对象支持对相同下层流的读写访问，而 <a class="reference internal" href="../library/io.html#io.BufferedRWPair" title="io.BufferedRWPair"><code class="xref py py-class docutils literal notranslate"><span class="pre">BufferedRWPair</span></code></a> 用于像 TTY 这样同时具有针对未连接数据流的读写操作。 <a class="reference internal" href="../library/io.html#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">BytesIO</span></code></a> 类支持在内存缓冲区上进行读取、写入和定位操作。</p>
</li>
<li id="index-12"><p class="translated"><a class="reference internal" href="../library/io.html#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextIOBase</span></code></a>: 提供用于读写字符串的函数（记住，在 Python 3.0 中字符串将为 Unicode），并支持 <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a>。 <a class="reference internal" href="../library/io.html#io.TextIOBase" title="io.TextIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextIOBase</span></code></a> 定义了 <a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code></a> 方法并支持迭代对象。</p>
<p class="translated">有两个具体实现。 <a class="reference internal" href="../library/io.html#io.TextIOWrapper" title="io.TextIOWrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextIOWrapper</span></code></a> 包装了一个缓冲 I/O 对象，支持所有文本 I/O 方法并增加 <a class="reference internal" href="../library/io.html#io.TextIOBase.buffer" title="io.TextIOBase.buffer"><code class="xref py py-attr docutils literal notranslate"><span class="pre">buffer</span></code></a> 属性用于访问下层对象。 <a class="reference internal" href="../library/io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">StringIO</span></code></a> 简单地在内存中缓冲所有内容而不会将其写入磁盘。</p>
<p class="translated">（在Python 2.6中，<a class="reference internal" href="../library/io.html#io.StringIO" title="io.StringIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.StringIO</span></code></a> 是用纯Python实现的，因此相当慢。因此，你应该暂时使用现有的 <code class="xref py py-mod docutils literal notranslate"><span class="pre">StringIO</span></code> 模块或 <code class="xref py py-mod docutils literal notranslate"><span class="pre">cStringIO</span></code>。在某个时候，Python 3.0的 <a class="reference internal" href="../library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a> 模块将被重写为C以提高速度，并且C实现可能会向下移植到2.x版本。）</p>
</li>
</ul>
<p class="translated">在Python 2.6中，底层实现尚未重构以建立在 <a class="reference internal" href="../library/io.html#module-io" title="io: Core tools for working with streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a> 模块的类之上。提供该模块是为了更容易编写与3.0向前兼容的代码，并节省开发者编写自己的缓冲和文本I/O实现的努力。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-63"></span><a class="pep reference external" href="https://peps.python.org/pep-3116/"><strong>PEP 3116</strong></a> - 新 I/O</dt><dd><p class="translated">PEP由Daniel Stutzbach、Mike Verdone和Guido van Rossum撰写。由Guido van Rossum、Georg Brandl、Walter Doerwald、Jeremy Hylton、Martin von Löwis、Tony Lownds等人编写代码。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-3118-revised-buffer-protocol">
<span id="pep-3118"></span><h2 class="translated">PEP 3118: 修改缓冲区协议<a class="headerlink" href="#pep-3118-revised-buffer-protocol" title="Link to this heading">¶</a></h2>
<p class="translated">缓冲协议是一个C级API，允许Python类型交换指向其内部表示的指针。例如，内存映射文件可以被视为字符缓冲区，这使得另一个模块如 <a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 可以将内存映射文件视为要搜索的字符字符串。</p>
<p class="translated">缓冲区协议的主要用户是像NumPy这样的数值处理包，它们暴露数组的内部表示，以便调用者可以直接写入数组数据，而不是通过较慢的API。这个PEP根据NumPy开发的经验更新了缓冲区协议，增加了一些新功能，例如指示数组形状或锁定内存区域。</p>
<p class="translated">最重要的新C API函数是 <code class="docutils literal notranslate"><span class="pre">PyObject_GetBuffer(PyObject</span> <span class="pre">*obj,</span> <span class="pre">Py_buffer</span> <span class="pre">*view,</span> <span class="pre">int</span> <span class="pre">flags)</span></code>，它接受一个对象和一组标志，并填充 <code class="docutils literal notranslate"><span class="pre">Py_buffer</span></code> 结构，包含对象内存表示的信息。对象可以使用此操作锁定内存，而外部调用者可能正在修改内容，因此有一个相应的 <code class="docutils literal notranslate"><span class="pre">PyBuffer_Release(Py_buffer</span> <span class="pre">*view)</span></code> 来指示外部调用者已完成。</p>
<p class="translated"><a class="reference internal" href="../c-api/buffer.html#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetBuffer()</span></code></a> 的 <em>flags</em> 参数指明了对所返回内存的约束。 示例如下:</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="../c-api/buffer.html#c.PyBUF_WRITABLE" title="PyBUF_WRITABLE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_WRITABLE</span></code></a> 指明内存必须是可写的。</p></li>
<li><p class="translated"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_LOCK</span></code> 请求一个内存上的只读或独占锁。</p></li>
<li><p class="translated"><a class="reference internal" href="../c-api/buffer.html#c.PyBUF_C_CONTIGUOUS" title="PyBUF_C_CONTIGUOUS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_C_CONTIGUOUS</span></code></a> 和 <a class="reference internal" href="../c-api/buffer.html#c.PyBUF_F_CONTIGUOUS" title="PyBUF_F_CONTIGUOUS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyBUF_F_CONTIGUOUS</span></code></a> 需要 C 连续（最后一个维度变动最快）或 Fortran 连续（第一个维度变动最快）的数组布局。</p></li>
</ul>
<p class="translated">两个用于 <a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> 的新参数代码 <code class="docutils literal notranslate"><span class="pre">s*</span></code> 和 <code class="docutils literal notranslate"><span class="pre">z*</span></code>，将为形参返回锁定的缓冲区对象。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-64"></span><a class="pep reference external" href="https://peps.python.org/pep-3118/"><strong>PEP 3118</strong></a> - 修改缓冲区协议</dt><dd><p class="translated">PEP 由 Travis Oliphant 和 Carl Banks 撰写，由 Travis Oliphant 实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-3119-abstract-base-classes">
<span id="pep-3119"></span><h2 class="translated">PEP 3119: 抽象基类<a class="headerlink" href="#pep-3119-abstract-base-classes" title="Link to this heading">¶</a></h2>
<p class="translated">一些面向对象的语言如 Java 支持使用接口，即声明一个类具有一组给定的方法或支持给定的访问协议。 抽象基类 (ABC) 是 Python 中的等价特性。 ABC 支持由一个包含名为 <a class="reference internal" href="../library/abc.html#abc.ABCMeta" title="abc.ABCMeta"><code class="xref py py-class docutils literal notranslate"><span class="pre">ABCMeta</span></code></a> 的元类的 <a class="reference internal" href="../library/abc.html#module-abc" title="abc: Abstract base classes according to :pep:`3119`."><code class="xref py py-mod docutils literal notranslate"><span class="pre">abc</span></code></a> 模块，由 <a class="reference internal" href="../library/functions.html#isinstance" title="isinstance"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinstance()</span></code></a> 和 <a class="reference internal" href="../library/functions.html#issubclass" title="issubclass"><code class="xref py py-func docutils literal notranslate"><span class="pre">issubclass()</span></code></a> 内置函数提供的对该元类的特殊处理，以及一系列 Python 开发者认为会被广泛使用的基本 ABC 组成。 未来的 Python 版本可能会添加更多的 ABC。</p>
<p class="translated">让我们假设你有一个特定的类并想要知道它是否支持字典式访问。 然而，“字典式”一词的语意是模糊的。 它可能意味着能够通过 <code class="docutils literal notranslate"><span class="pre">obj[1]</span></code> 来访问条目。 它可能表示能够通过 <code class="docutils literal notranslate"><span class="pre">obj[2]</span> <span class="pre">=</span> <span class="pre">value</span></code> 来设置条目？ 或者这种对象具有 <code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">values()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">items()</span></code> 方法？ 那么是否要有迭代形式如 <code class="xref py py-meth docutils literal notranslate"><span class="pre">iterkeys()</span></code> 呢？ <code class="xref py py-meth docutils literal notranslate"><span class="pre">copy()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code> 呢？ 通过 <code class="xref py py-func docutils literal notranslate"><span class="pre">iter()</span></code> 来迭代对象呢？</p>
<p class="translated">Python 2.6 <a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 模块包括了代表这些区别的多个不同的 ABC。 <code class="xref py py-class docutils literal notranslate"><span class="pre">Iterable</span></code> 表明一个类定义了 <a class="reference internal" href="../reference/datamodel.html#object.__iter__" title="object.__iter__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__iter__()</span></code></a>，而 <code class="xref py py-class docutils literal notranslate"><span class="pre">Container</span></code> 意味着该类定义了 <a class="reference internal" href="../reference/datamodel.html#object.__contains__" title="object.__contains__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__contains__()</span></code></a> 方法因而支持 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></code> 表达式。 基本的字典接口如获取条目、设置条目，以及 <code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">values()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">items()</span></code> 等则是由 <code class="xref py py-class docutils literal notranslate"><span class="pre">MutableMapping</span></code> ABC 来定义的。</p>
<p class="translated">你可以从特定的抽象基类派生自己的类，以表明它们支持该抽象基类的接口：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">collections</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Storage</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">MutableMapping</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated">作为替代，你编写的类可以不从期望的 ABC 派生而是通过调用 ABC 的 <a class="reference internal" href="../library/abc.html#abc.ABCMeta.register" title="abc.ABCMeta.register"><code class="xref py py-meth docutils literal notranslate"><span class="pre">register()</span></code></a> 方法来注册该类:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">collections</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Storage</span><span class="p">:</span>
    <span class="o">...</span>

<span class="n">collections</span><span class="o">.</span><span class="n">MutableMapping</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Storage</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">对于你编写的类，从 ABC 派生可能会更清晰一些。 <a class="reference internal" href="../library/abc.html#abc.ABCMeta.register" title="abc.ABCMeta.register"><code class="xref py py-meth docutils literal notranslate"><span class="pre">register()</span></code></a>  方法适用于当你编写能够描述现有类型或类的新 ABC，或是当你想要声明某个实现特定 ABC 的第三方类的场合。 举例来说，如果你定义了一个 <code class="xref py py-class docutils literal notranslate"><span class="pre">PrintableType</span></code> ABC，这样做就是可以的:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 注册 Python 的类型</span>
<span class="n">PrintableType</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="n">PrintableType</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
<span class="n">PrintableType</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">类应该遵守抽象基类指定的语义，但 Python 无法检查这一点；这取决于类作者理解抽象基类的要求并相应地实现代码。</p>
<p class="translated">要检查一个对象是否支持特定接口，你现在可以编写：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">MutableMapping</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;期望映射对象，而不是 </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">不要觉得你必须像上面例子那样开始编写大量检查。Python 有一种强烈的鸭子类型传统，在这种传统中，从不进行显式类型检查，代码只是简单地调用对象上的方法，相信这些方法会存在，如果不存在则会引发异常。在检查 ABC 时要明智，并且只在绝对必要时才进行检查。</p>
<p class="translated">你可以通过在类定义中使用 <code class="docutils literal notranslate"><span class="pre">abc.ABCMeta</span></code> 作为元类来编写自己的 ABC:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Drawable</span><span class="p">():</span>
    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">ABCMeta</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">draw_doubled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Square</span><span class="p">(</span><span class="n">Drawable</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
        <span class="o">...</span>
</pre></div>
</div>
<p class="translated">在上面的 <code class="xref py py-class docutils literal notranslate"><span class="pre">Drawable</span></code> ABC 中，<code class="xref py py-meth docutils literal notranslate"><span class="pre">draw_doubled()</span></code> 方法以两倍大小渲染对象并可依据 <code class="xref py py-class docutils literal notranslate"><span class="pre">Drawable</span></code> 描述的其他方法来实现。 因此实现此 ABC 的类不需要提供自己的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">draw_doubled()</span></code> 实现，尽管它们可以这样做。 不过，必须要有一个 <code class="xref py py-meth docutils literal notranslate"><span class="pre">draw()</span></code> 的实现，ABC 无法提供可用的泛型实现。</p>
<p class="translated">你可以将 <a class="reference internal" href="../library/abc.html#abc.abstractmethod" title="abc.abstractmethod"><code class="xref py py-deco docutils literal notranslate"><span class="pre">&#64;~abc.abstractmethod</span></code></a> 装饰器应用于必须实现的方法如 <code class="xref py py-meth docutils literal notranslate"><span class="pre">draw()</span></code>；那么 Python 将针对未定义该方法的类引发异常。 请注意只有在你实际尝试创建缺少该方法的子类的实例时异常才会被引发:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">Circle</span><span class="p">(</span><span class="n">Drawable</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">Can&#39;t instantiate abstract class Circle with abstract methods draw</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">可以使用 <code class="docutils literal notranslate"><span class="pre">&#64;abstractproperty</span></code> 装饰器声明抽象数据属性:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">abstractproperty</span>
<span class="o">...</span>

<span class="nd">@abstractproperty</span>
<span class="k">def</span><span class="w"> </span><span class="nf">readonly</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
   <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>
</pre></div>
</div>
<p class="translated">子类必须定义一个 <code class="docutils literal notranslate"><span class="pre">readonly</span></code> 属性。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-65"></span><a class="pep reference external" href="https://peps.python.org/pep-3119/"><strong>PEP 3119</strong></a> - 引入抽象基类</dt><dd><p class="translated">PEP 由 Guido van Rossum 和 Talin 编写。由 Guido van Rossum 实现。由 Benjamin Aranguren 回退到 2.6 版本，Alex Martelli 协助。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-3127-integer-literal-support-and-syntax">
<span id="pep-3127"></span><h2 class="translated">PEP 3127: 整型文字支持和语法<a class="headerlink" href="#pep-3127-integer-literal-support-and-syntax" title="Link to this heading">¶</a></h2>
<p class="translated">Python 3.0 改变了八进制（基数为8）整数的语法，使用 &quot;0o&quot; 或 &quot;0O&quot; 作为前缀，而不是以零开头，并增加了对二进制（基数为2）整数的支持，使用 &quot;0b&quot; 或 &quot;0B&quot; 作为前缀。</p>
<p class="translated">Python 2.6 并没有放弃以零开头表示八进制数的支持，但增加了对 &quot;0o&quot; 和 &quot;0b&quot; 的支持:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mo">0o21</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="mi">8</span> <span class="o">+</span> <span class="mi">1</span>
<span class="go">(17, 17)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mb">0b101111</span>
<span class="go">47</span>
</pre></div>
</div>
<p class="translated">内置的 <a class="reference internal" href="../library/functions.html#oct" title="oct"><code class="xref py py-func docutils literal notranslate"><span class="pre">oct()</span></code></a> 函数仍然返回以零开头的数字，而新的 <a class="reference internal" href="../library/functions.html#bin" title="bin"><code class="xref py py-func docutils literal notranslate"><span class="pre">bin()</span></code></a> 函数返回数字的二进制表示:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">oct</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="go">&#39;052&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">future_builtins</span><span class="o">.</span><span class="n">oct</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="go">&#39;0o52&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bin</span><span class="p">(</span><span class="mi">173</span><span class="p">)</span>
<span class="go">&#39;0b10101101&#39;</span>
</pre></div>
</div>
<p class="translated">内置的 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">long()</span></code> 函数现在接受 &quot;0o&quot; 和 &quot;0b&quot; 前缀，当请求基数为8或2时，或者当 <em>base</em> 参数为零（表示应从字符串确定使用的基数）:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span> <span class="p">(</span><span class="s1">&#39;0o52&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="s1">&#39;1101&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">13</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="s1">&#39;0b1101&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">13</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="s1">&#39;0b1101&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">13</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-66"></span><a class="pep reference external" href="https://peps.python.org/pep-3127/"><strong>PEP 3127</strong></a> - 整型字面量支持和语法</dt><dd><p class="translated">PEP 由 Patrick Maupin 编写；由 Eric Smith 回退到 2.6 版本。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-3129-class-decorators">
<span id="pep-3129"></span><h2 class="translated">PEP 3129: 类装饰器<a class="headerlink" href="#pep-3129-class-decorators" title="Link to this heading">¶</a></h2>
<p class="translated">装饰器已从函数扩展到类。 现在可以合法地编写:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@foo</span>
<span class="nd">@bar</span>
<span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="p">:</span>
  <span class="k">pass</span>
</pre></div>
</div>
<p class="translated">这相当于：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="p">:</span>
  <span class="k">pass</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="n">bar</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-67"></span><a class="pep reference external" href="https://peps.python.org/pep-3129/"><strong>PEP 3129</strong></a> - 类装饰器</dt><dd><p class="translated">PEP 由 Collin Winter 撰写。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-3141-a-type-hierarchy-for-numbers">
<span id="pep-3141"></span><h2 class="translated">PEP 3141: 数字的类型层级结构<a class="headerlink" href="#pep-3141-a-type-hierarchy-for-numbers" title="Link to this heading">¶</a></h2>
<p class="translated">Python 3.0 增加了几种受 Scheme 数值塔启发的数值类型的抽象基类。这些类已回退到 2.6 版本，作为 <a class="reference internal" href="../library/numbers.html#module-numbers" title="numbers: Numeric abstract base classes (Complex, Real, Integral, etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">numbers</span></code></a> 模块。</p>
<p class="translated">最通用的 ABC 是 <code class="xref py py-class docutils literal notranslate"><span class="pre">Number</span></code>。它定义了没有任何操作，仅用于通过 <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">Number)</span></code> 检查对象是否为数字。</p>
<p class="translated"><code class="xref py py-class docutils literal notranslate"><span class="pre">Complex</span></code> 是 <code class="xref py py-class docutils literal notranslate"><span class="pre">Number</span></code> 的子类。复数可以进行加法、减法、乘法、除法和指数运算，并且可以检索实部和虚部以及获得一个数的共轭。Python 内置的复数类型是 <code class="xref py py-class docutils literal notranslate"><span class="pre">Complex</span></code> 的实现。</p>
<p class="translated"><code class="xref py py-class docutils literal notranslate"><span class="pre">Real</span></code> 进一步从 <code class="xref py py-class docutils literal notranslate"><span class="pre">Complex</span></code> 派生，并添加了仅适用于实数的操作：<code class="xref py py-func docutils literal notranslate"><span class="pre">floor()</span></code>，<code class="xref py py-func docutils literal notranslate"><span class="pre">trunc()</span></code>，四舍五入，取模 N 的余数，地板除法以及比较操作。</p>
<p class="translated"><code class="xref py py-class docutils literal notranslate"><span class="pre">Rational</span></code> 数从 <code class="xref py py-class docutils literal notranslate"><span class="pre">Real</span></code> 派生，具有 <code class="xref py py-attr docutils literal notranslate"><span class="pre">numerator</span></code> 和 <code class="xref py py-attr docutils literal notranslate"><span class="pre">denominator</span></code> 属性，并且可以转换为浮点数。Python 2.6 在 <a class="reference internal" href="../library/fractions.html#module-fractions" title="fractions: Rational numbers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">fractions</span></code></a> 模块中添加了一个简单的有理数类，<code class="xref py py-class docutils literal notranslate"><span class="pre">Fraction</span></code>。（它被称为 <code class="xref py py-class docutils literal notranslate"><span class="pre">Fraction</span></code> 而不是 <code class="xref py py-class docutils literal notranslate"><span class="pre">Rational</span></code>，以避免与 <a class="reference internal" href="../library/numbers.html#numbers.Rational" title="numbers.Rational"><code class="xref py py-class docutils literal notranslate"><span class="pre">numbers.Rational</span></code></a> 名称冲突。）</p>
<p class="translated"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code> 数从 <code class="xref py py-class docutils literal notranslate"><span class="pre">Rational</span></code> 派生，可以使用 <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> 进行左右移位，通过按位操作（如 <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">|</span></code>）进行组合，并且可以用作数组索引和切片边界。</p>
<p class="translated">在 Python 3.0 中，PEP 稍微重新定义了现有的内置函数 <a class="reference internal" href="../library/functions.html#round" title="round"><code class="xref py py-func docutils literal notranslate"><span class="pre">round()</span></code></a>，<a class="reference internal" href="../library/math.html#math.floor" title="math.floor"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.floor()</span></code></a>，<a class="reference internal" href="../library/math.html#math.ceil" title="math.ceil"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.ceil()</span></code></a>，并添加了一个新的函数 <a class="reference internal" href="../library/math.html#math.trunc" title="math.trunc"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.trunc()</span></code></a>，该函数已被回移植到 Python 2.6。<a class="reference internal" href="../library/math.html#math.trunc" title="math.trunc"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.trunc()</span></code></a> 向零舍入，返回介于函数参数和零之间的最接近的 <code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code>。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-68"></span><a class="pep reference external" href="https://peps.python.org/pep-3141/"><strong>PEP 3141</strong></a> - 数字的类型层次结构</dt><dd><p class="translated">PEP 由 Jeffrey Yasskin 撰写。</p>
</dd>
</dl>
<p class="translated"><a class="reference external" href="https://www.gnu.org/software/guile/manual/html_node/Numerical-Tower.html#Numerical-Tower">Scheme 的数值塔</a>，来自 Guile 手册。</p>
<p class="translated"><a class="reference external" href="https://conservatory.scheme.org/schemers/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%_sec_6.2">Scheme 的数字数据类型</a>，来自 R5RS Scheme 规范。</p>
</div>
<section id="the-fractions-module">
<h3 class="translated"><a class="reference internal" href="../library/fractions.html#module-fractions" title="fractions: Rational numbers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">fractions</span></code></a> 模块<a class="headerlink" href="#the-fractions-module" title="Link to this heading">¶</a></h3>
<p class="translated">为了完善数值类型的层次结构，<a class="reference internal" href="../library/fractions.html#module-fractions" title="fractions: Rational numbers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">fractions</span></code></a> 模块提供了一个有理数类。有理数将它们的值存储为一个分数的分子和分母，可以精确表示诸如 <code class="docutils literal notranslate"><span class="pre">2/3</span></code> 这样的数，而浮点数只能近似表示。</p>
<p class="translated"><code class="xref py py-class docutils literal notranslate"><span class="pre">Fraction</span></code> 构造函数接受两个 <code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code> 值，这两个值将分别是结果分数的分子和分母。</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">从</span> <span class="n">fractions</span> <span class="n">导入</span> <span class="n">Fraction</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">(0.66666666666666663, 0.40000000000000002)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">+</span><span class="n">b</span>
<span class="go">Fraction(16, 15)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">/</span><span class="n">b</span>
<span class="go">Fraction(5, 3)</span>
</pre></div>
</div>
<p class="translated">为了将浮点数转换为有理数，float 类型现在有一个 <code class="xref py py-meth docutils literal notranslate"><span class="pre">as_integer_ratio()</span></code> 方法，该方法返回一个分数的分子和分母，该分数计算结果与相同的浮点值相等:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mf">2.5</span><span class="p">)</span> <span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">()</span>
<span class="go">(5, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mf">3.1415</span><span class="p">)</span> <span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">()</span>
<span class="go">(7074029114692207L, 2251799813685248L)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span> <span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">()</span>
<span class="go">(6004799503160661L, 18014398509481984L)</span>
</pre></div>
</div>
<p class="translated">请注意，只能由浮点数近似表示的值，例如 1./3，不会被简化为被近似的数；分数尝试**精确**匹配浮点值。</p>
<p class="translated"><a class="reference internal" href="../library/fractions.html#module-fractions" title="fractions: Rational numbers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">fractions</span></code></a> 模块基于 Sjoerd Mullender 的实现，该实现曾在 Python 的 <code class="file docutils literal notranslate"><span class="pre">Demo/classes/</span></code> 目录中存在很长时间。这一实现由 Jeffrey Yasskin 进行了显著更新。</p>
</section>
</section>
<section id="other-language-changes">
<h2 class="translated">其他语言特性修改<a class="headerlink" href="#other-language-changes" title="Link to this heading">¶</a></h2>
<p class="translated">对Python 语言核心进行的小改动：</p>
<ul>
<li><p class="translated">包含 <code class="file docutils literal notranslate"><span class="pre">__main__.py</span></code> 文件的目录和 zip 存档现在可以通过将其名称传递给解释器来直接执行。目录或 zip 存档会自动插入到 sys.path 的第一个条目中。（建议和初始补丁由 Andy Chu 提出，随后由 Phillip J. Eby 和 Nick Coghlan 修订；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1739468">bpo-1739468</a>。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/functions.html#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a> 函数在假设所有错误意味着 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code> 方法以某种方式失败，并且 <a class="reference internal" href="../library/functions.html#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a> 的返回值因此为 <code class="docutils literal notranslate"><span class="pre">False</span></code> 的情况下，会捕获并忽略所有错误。然而，这种逻辑不应适用于 <a class="reference internal" href="../library/exceptions.html#KeyboardInterrupt" title="KeyboardInterrupt"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> 和 <a class="reference internal" href="../library/exceptions.html#SystemExit" title="SystemExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SystemExit</span></code></a>；Python 2.6 在 <a class="reference internal" href="../library/functions.html#hasattr" title="hasattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">hasattr()</span></code></a> 遇到这些异常时将不再丢弃它们。（由 Benjamin Peterson 修复；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2196">bpo-2196</a>。）</p></li>
<li><p class="translated">当使用 <code class="docutils literal notranslate"><span class="pre">**</span></code> 语法调用函数以提供关键字参数时，你不再需要使用 Python 字典；现在任何映射都将有效:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">):</span>
<span class="gp">... </span>   <span class="nb">print</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ud</span><span class="o">=</span><span class="n">UserDict</span><span class="o">.</span><span class="n">UserDict</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ud</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ud</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;string&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="o">**</span><span class="n">ud</span><span class="p">)</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;]</span>
</pre></div>
</div>
<p class="translated">（由 Alexander Belopolsky 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1686487">bpo-1686487</a> 中贡献。）</p>
<p class="translated">在函数调用的 <code class="docutils literal notranslate"><span class="pre">*args</span></code> 参数之后提供关键字参数也是合法的。</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span> <span class="n">args</span><span class="p">,</span> <span class="n">kw</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="n">keyword</span><span class="o">=</span><span class="mi">13</span><span class="p">)</span>
<span class="go">(1, 2, 3, 4, 5, 6) {&#39;keyword&#39;: 13}</span>
</pre></div>
</div>
<p class="translated">在之前版本中这会导致语法错误。 （由 Amaury Forgeot d'Arc 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=3473">bpo-3473</a>。）</p>
</li>
<li><p class="translated">一个新的内置函数 <code class="docutils literal notranslate"><span class="pre">next(iterator,</span> <span class="pre">[default])</span></code> 返回指定迭代器的下一个项目。如果提供了 <em>default</em> 参数，当 <em>iterator</em> 耗尽时会返回该值；否则，将引发 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 异常。（已在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2719">bpo-2719</a> 中回溯。）</p></li>
<li><p class="translated">元组现在有了 <a class="reference internal" href="../library/stdtypes.html#tuple.index" title="tuple.index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">index()</span></code></a> 和 <a class="reference internal" href="../library/stdtypes.html#tuple.count" title="tuple.count"><code class="xref py py-meth docutils literal notranslate"><span class="pre">count()</span></code></a> 方法，与列表类型的 <a class="reference internal" href="../library/stdtypes.html#list.index" title="list.index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">index()</span></code></a> 和 <a class="reference internal" href="../library/stdtypes.html#list.count" title="list.count"><code class="xref py py-meth docutils literal notranslate"><span class="pre">count()</span></code></a> 方法相匹配:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p class="translated">（由 Raymond Hettinger 贡献）</p>
</li>
<li><p class="translated">内置类型现在改进了对扩展切片语法的支持，接受各种 <code class="docutils literal notranslate"><span class="pre">(start,</span> <span class="pre">stop,</span> <span class="pre">step)</span></code> 的组合。之前，支持是部分的，某些边缘情况无法工作。（由 Thomas Wouters 实现。）</p>
</li>
<li><p class="translated">属性现在有三个属性，<code class="xref py py-attr docutils literal notranslate"><span class="pre">getter</span></code>、<code class="xref py py-attr docutils literal notranslate"><span class="pre">setter</span></code> 和 <code class="xref py py-attr docutils literal notranslate"><span class="pre">deleter</span></code>，这些是装饰器，提供了向现有属性添加获取器、设置器或删除器函数的有用快捷方式。你可以像这样使用它们:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>

    <span class="nd">@x</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@x</span><span class="o">.</span><span class="n">deleter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>

<span class="k">class</span><span class="w"> </span><span class="nc">D</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
    <span class="nd">@C</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">getter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">*</span> <span class="mi">2</span>

    <span class="nd">@x</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">value</span> <span class="o">/</span> <span class="mi">2</span>
</pre></div>
</div>
</li>
<li><p class="translated">内置集合类型的几种方法现在接受多个可迭代对象：<code class="xref py py-meth docutils literal notranslate"><span class="pre">intersection()</span></code>、<code class="xref py py-meth docutils literal notranslate"><span class="pre">intersection_update()</span></code>、<code class="xref py py-meth docutils literal notranslate"><span class="pre">union()</span></code>、<code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code>、<code class="xref py py-meth docutils literal notranslate"><span class="pre">difference()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">difference_update()</span></code>。</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="s1">&#39;1234567890&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="s1">&#39;abc123&#39;</span><span class="p">,</span> <span class="s1">&#39;cdf246&#39;</span><span class="p">)</span>  <span class="c1"># 所有输入的交集</span>
<span class="go">set([&#39;2&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="s1">&#39;246&#39;</span><span class="p">,</span> <span class="s1">&#39;789&#39;</span><span class="p">)</span>
<span class="go">set([&#39;1&#39;, &#39;0&#39;, &#39;3&#39;, &#39;5&#39;])</span>
</pre></div>
</div>
<p class="translated">（由 Raymond Hettinger 贡献。）</p>
</li>
<li><p class="translated">添加了许多浮点特性。<a class="reference internal" href="../library/functions.html#float" title="float"><code class="xref py py-func docutils literal notranslate"><span class="pre">float()</span></code></a> 函数现在会将字符串 <code class="docutils literal notranslate"><span class="pre">nan</span></code> 转换为 IEEE 754 非数值，将 <code class="docutils literal notranslate"><span class="pre">+inf</span></code> 和 <code class="docutils literal notranslate"><span class="pre">-inf</span></code> 转换为正无穷或负无穷。这适用于任何具有 IEEE 754 语义的平台。（由 Christian Heimes 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1635">bpo-1635</a>。）</p>
<p class="translated"><a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> 模块中的其他函数，<code class="xref py py-func docutils literal notranslate"><span class="pre">isinf()</span></code> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">isnan()</span></code>，如果它们的浮点参数是无穷大或非数值，则返回真。（<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1640">bpo-1640</a>）</p>
<p class="translated">添加了转换函数，用于将浮点数转换为十六进制字符串（<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=3008">bpo-3008</a>）。这些函数在将浮点数转换为字符串表示形式以及从字符串表示形式转换回浮点数时，不会引入十进制和二进制之间的转换误差。浮点数有一个 <a class="reference internal" href="../library/functions.html#hex" title="hex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">hex()</span></code></a> 方法，返回其字符串表示形式，而 <code class="docutils literal notranslate"><span class="pre">float.fromhex()</span></code> 方法将字符串转换回数字：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mf">3.75</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span>
<span class="go">&#39;0x1.e000000000000p+1&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">float</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="s1">&#39;0x1.e000000000000p+1&#39;</span><span class="p">)</span>
<span class="go">3.75</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span>
<span class="go">&#39;0x1.5555555555555p-2&#39;</span>
</pre></div>
</div>
</li>
<li><p class="translated">一个数值上的细节：在支持有符号零（-0 和 +0）的系统上，从两个浮点数创建复数时，<a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a> 构造函数现在将保留零的符号。（由 Mark T. Dickinson 修复；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1507">bpo-1507</a>。）</p></li>
<li><p class="translated">从父类继承 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> 方法的类可以通过设置 <code class="docutils literal notranslate"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">None</span></code> 来表示该类不可哈希。这将使 <code class="docutils literal notranslate"><span class="pre">hash(obj)</span></code> 抛出 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>，并且该类不会被视为实现了 <code class="xref py py-class docutils literal notranslate"><span class="pre">Hashable</span></code> ABC。</p>
<p class="translated">当你定义了 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__cmp__()</span></code> 或 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__eq__()</span></code> 方法，且这些方法通过值而不是身份比较对象时，应该这样做。所有对象都有一个默认的哈希方法，使用 <code class="docutils literal notranslate"><span class="pre">id(obj)</span></code> 作为哈希值。没有简洁的方法来移除从父类继承的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hash__()</span></code> 方法，因此将 <code class="docutils literal notranslate"><span class="pre">None</span></code> 赋值作为覆盖实现。在 C 语言层面，扩展可以将 <code class="docutils literal notranslate"><span class="pre">tp_hash</span></code> 设置为 <a class="reference internal" href="../c-api/object.html#c.PyObject_HashNotImplemented" title="PyObject_HashNotImplemented"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_HashNotImplemented()</span></code></a>。（由 Nick Coghlan 和 Amaury Forgeot d'Arc 修复；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2235">bpo-2235</a>。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> 异常现在继承自 <a class="reference internal" href="../library/exceptions.html#BaseException" title="BaseException"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseException</span></code></a> 而不是 <a class="reference internal" href="../library/exceptions.html#Exception" title="Exception"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Exception</span></code></a>。这意味着 <code class="docutils literal notranslate"><span class="pre">except</span> <span class="pre">Exception:</span></code> 的异常处理程序不会意外捕获 <a class="reference internal" href="../library/exceptions.html#GeneratorExit" title="GeneratorExit"><code class="xref py py-exc docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a>。（由 Chad Austin 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1537">bpo-1537</a>。）</p></li>
<li><p class="translated">生成器对象现在具有一个 <code class="xref py py-attr docutils literal notranslate"><span class="pre">gi_code</span></code> 属性，该属性引用支持生成器的原始代码对象。（由 Collin Winter 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1473257">bpo-1473257</a>。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/functions.html#compile" title="compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">compile()</span></code></a> 内置函数现在接受关键字参数以及位置参数。（由 Thomas Wouters 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1444529">bpo-1444529</a>。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/functions.html#complex" title="complex"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex()</span></code></a> 构造函数现在接受包含括号内复数的字符串，这意味着 <code class="docutils literal notranslate"><span class="pre">complex(repr(cplx))</span></code> 现在将进行往返值。例如，<code class="docutils literal notranslate"><span class="pre">complex('(3+4j)')</span></code> 现在返回值 (3+4j)。（<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1491866">bpo-1491866</a>）</p></li>
<li><p class="translated">字符串 <code class="xref py py-meth docutils literal notranslate"><span class="pre">translate()</span></code> 方法现在接受 <code class="docutils literal notranslate"><span class="pre">None</span></code> 作为翻译表参数，这被视为身份转换。这使得仅删除字符的操作更容易进行。（由 Bengt Richter 贡献并由 Raymond Hettinger 实现；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1193128">bpo-1193128</a>。）</p></li>
<li><p class="translated">内置的 <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> 函数现在检查其接收对象上的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__dir__()</span></code> 方法。该方法必须返回包含对象有效属性名称的字符串列表，并让对象控制 <a class="reference internal" href="../library/functions.html#dir" title="dir"><code class="xref py py-func docutils literal notranslate"><span class="pre">dir()</span></code></a> 产生的值。具有 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code> 或 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code> 方法的对象可以使用此方法来宣传它们将支持的伪属性。（<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1591665">bpo-1591665</a>）</p></li>
<li><p class="translated">实例方法对象具有新的属性，用于构成方法的对象和函数；<code class="xref py py-attr docutils literal notranslate"><span class="pre">im_self</span></code> 的新同义词是 <a class="reference internal" href="../reference/datamodel.html#method.__self__" title="method.__self__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__self__</span></code></a>，<code class="xref py py-attr docutils literal notranslate"><span class="pre">im_func</span></code> 也可作为 <a class="reference internal" href="../reference/datamodel.html#method.__func__" title="method.__func__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__func__</span></code></a> 使用。旧名称在 Python 2.6 中仍然受支持，但在 3.0 中已移除。</p></li>
<li><p class="translated">一个不为人知的变化：当你在 <a class="reference internal" href="../reference/compound_stmts.html#class"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">class</span></code></a> 语句内使用 <a class="reference internal" href="../library/functions.html#locals" title="locals"><code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code></a> 函数时，生成的字典不再返回自由变量。（在这种情况下，自由变量是指在 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">class</span></code> 语句中引用的但不是类属性的变量。）</p></li>
</ul>
<section id="optimizations">
<h3 class="translated">性能优化<a class="headerlink" href="#optimizations" title="Link to this heading">¶</a></h3>
<ul>
<li><p class="translated"><a class="reference internal" href="../library/warnings.html#module-warnings" title="warnings: Issue warning messages and control their disposition."><code class="xref py py-mod docutils literal notranslate"><span class="pre">warnings</span></code></a> 模块已用 C 语言重写。这使得从解析器中调用警告成为可能，也可能使解释器的启动更快。（由 Neal Norwitz 和 Brett Cannon 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1631171">bpo-1631171</a>。）</p></li>
<li><p class="translated">类型对象现在有一个方法缓存，可以减少查找特定类的正确方法实现所需的工作；一旦缓存，解释器无需遍历基类来确定要调用的正确方法。如果基类或类本身被修改，缓存将被清除，因此即使在 Python 的动态特性面前，缓存也应保持正确。（最初的优化由 Armin Rigo 实现，由 Kevin Jacobs 更新以适用于 Python 2.6；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1700288">bpo-1700288</a>。）</p>
<p class="translated">默认情况下，此更改仅应用于包含在 Python 核心中的类型。扩展模块可能不兼容此缓存，因此它们必须显式将 <code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TPFLAGS_HAVE_VERSION_TAG</span></code> 添加到模块的 <code class="docutils literal notranslate"><span class="pre">tp_flags</span></code> 字段以启用方法缓存。（为了与方法缓存兼容，扩展模块的代码不得直接访问和修改其实现的任何类型的 <code class="docutils literal notranslate"><span class="pre">tp_dict</span></code> 成员。大多数模块不会这样做，但 Python 解释器无法确定这一点。参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1878">bpo-1878</a> 以了解一些讨论。）</p>
</li>
<li><p class="translated">使用关键字参数的函数调用通过进行快速指针比较而显著加快，通常节省了完整字符串比较的时间。（由 Raymond Hettinger 贡献，基于 Antoine Pitrou 的初始实现；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1819">bpo-1819</a>。）</p></li>
<li><p class="translated">由于在 Need For Speed sprint 中的工作，<a class="reference internal" href="../library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> 模块中的所有函数都已用 C 语言重写。（由 Raymond Hettinger 贡献。）</p></li>
<li><p class="translated">一些标准内置类型现在在其类型对象中设置了一个位。这加快了检查对象是否为这些类型的子类的速度。（由 Neal Norwitz 贡献。）</p></li>
<li><p class="translated">Unicode 字符串现在使用更快的代码来检测空白字符和换行符；这使得 <code class="xref py py-meth docutils literal notranslate"><span class="pre">split()</span></code> 方法的速度提高了约 25%，<code class="xref py py-meth docutils literal notranslate"><span class="pre">splitlines()</span></code> 方法的速度提高了约 35%。(由 Antoine Pitrou 贡献。) 通过使用 pymalloc 为 Unicode 字符串的数据分配内存，减少了内存使用。</p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">with</span></code> 语句现在将 <a class="reference internal" href="../reference/datamodel.html#object.__exit__" title="object.__exit__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__exit__()</span></code></a> 方法存储在堆栈上，从而产生了一小部分速度提升。(由 Jeffrey Yasskin 实现)</p></li>
<li><p class="translated">为了减少内存使用，垃圾收集器现在在收集最高代对象的垃圾时将清除内部空闲列表。这可能会更快地将内存返回给操作系统。</p></li>
</ul>
</section>
<section id="interpreter-changes">
<span id="new-26-interpreter"></span><h3 class="translated">解释器改动<a class="headerlink" href="#interpreter-changes" title="Link to this heading">¶</a></h3>
<p class="translated">两个命令行选项已被保留供其他 Python 实现使用。<code class="xref std std-option docutils literal notranslate"><span class="pre">-J</span></code> 开关已被保留供 Jython 使用，用于 Jython 特定的选项，例如传递给底层 JVM 的开关。<a class="reference internal" href="../using/cmdline.html#cmdoption-X"><code class="xref std std-option docutils literal notranslate"><span class="pre">-X</span></code></a> 已被保留用于特定 Python 实现的选项，如 CPython、Jython 或 IronPython。如果使用 Python 2.6 时使用任一选项，解释器将报告该选项当前未使用。</p>
<p class="translated">现在可以通过向 Python 解释器提供 <a class="reference internal" href="../using/cmdline.html#cmdoption-B"><code class="xref std std-option docutils literal notranslate"><span class="pre">-B</span></code></a> 开关，或在运行解释器之前设置 <span class="target" id="index-69"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONDONTWRITEBYTECODE"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONDONTWRITEBYTECODE</span></code></a> 环境变量，来阻止 Python 写入 <code class="file docutils literal notranslate"><span class="pre">.pyc</span></code> 或 <code class="file docutils literal notranslate"><span class="pre">.pyo</span></code> 文件。此设置作为 <code class="docutils literal notranslate"><span class="pre">sys.dont_write_bytecode</span></code> 变量对 Python 程序可用，Python 代码可以更改该值以修改解释器的行为。(由 Neal Norwitz 和 Georg Brandl 贡献)</p>
<p class="translated">可以通过在运行解释器之前设置 <span class="target" id="index-70"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONIOENCODING"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONIOENCODING</span></code></a> 环境变量来指定标准输入、输出和标准错误的编码。值应为形如 <code class="docutils literal notranslate"><span class="pre">&lt;编码&gt;</span></code> 或 <code class="docutils literal notranslate"><span class="pre">&lt;编码&gt;:&lt;错误处理器&gt;</span></code> 的字符串。<em>编码</em> 部分指定编码的名称，例如 <code class="docutils literal notranslate"><span class="pre">utf-8</span></code> 或 <code class="docutils literal notranslate"><span class="pre">latin-1</span></code>；可选的 <em>错误处理器</em> 部分指定对无法由编码处理的字符的处理方式，应为 &quot;error&quot;、&quot;ignore&quot; 或 &quot;replace&quot; 之一。（由 Martin von Löwis 贡献。）</p>
</section>
</section>
<section id="new-and-improved-modules">
<h2 class="translated">新增和改进的模块<a class="headerlink" href="#new-and-improved-modules" title="Link to this heading">¶</a></h2>
<p class="translated">与每个版本一样，Python 的标准库进行了一系列增强和错误修复。以下是一些最显著变化的部分列表，按模块名称字母顺序排序。请在源树中的 <code class="file docutils literal notranslate"><span class="pre">Misc/NEWS</span></code> 文件中查阅更完整的变化列表，或通过 Subversion 日志查看所有细节。</p>
<ul>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncore</span></code> 和 <code class="xref py py-mod docutils literal notranslate"><span class="pre">asynchat</span></code> 模块再次得到积极维护，并应用了许多补丁和错误修复。（由 Josiah Carlson 维护；参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1736190">bpo-1736190</a> 了解其中一个补丁。）</p></li>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">bsddb</span></code> 模块也有了新的维护者 Jesús Cea Avión，该包现在可作为独立包使用。该包的网页为 <a class="reference external" href="https://www.jcea.es/programacion/pybsddb.htm">www.jcea.es/programacion/pybsddb.htm</a>。计划在 Python 3.0 中从标准库中移除该包，因为其发布频率远高于 Python。</p>
<p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">bsddb.dbshelve</span></code> 模块现在使用最高可用的序列化协议，而不是限制自己使用协议 1。（由 W. Barnes 贡献。）</p>
</li>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cgi</span></code> 模块现在可以从 HTTP POST 请求的查询字符串中读取变量。这使得可以使用包含查询字符串的表单操作，例如 &quot;/cgi-bin/add.py?category=1&quot;。（由 Alexandre Fiori 和 Nubis 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1817">bpo-1817</a>。）</p>
<p class="translated"><code class="xref py py-func docutils literal notranslate"><span class="pre">parse_qs()</span></code> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">parse_qsl()</span></code> 函数已从 <code class="xref py py-mod docutils literal notranslate"><span class="pre">cgi</span></code> 模块移至 <a class="reference internal" href="../library/urllib.parse.html#module-urllib.parse" title="urllib.parse: Parse URLs into or assemble them from components."><code class="xref py py-mod docutils literal notranslate"><span class="pre">urlparse</span></code></a> 模块。在 <code class="xref py py-mod docutils literal notranslate"><span class="pre">cgi</span></code> 模块中仍然可用的版本将在 2.6 版本中触发 <a class="reference internal" href="../library/exceptions.html#PendingDeprecationWarning" title="PendingDeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PendingDeprecationWarning</span></code></a> 警告消息（<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=600362">bpo-600362</a>）。</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/cmath.html#module-cmath" title="cmath: Mathematical functions for complex numbers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmath</span></code></a> 模块经历了广泛的修订，由 Mark Dickinson 和 Christian Heimes 贡献。新增了五个函数：</p>
<ul class="simple">
<li><p class="translated"><code class="xref py py-func docutils literal notranslate"><span class="pre">polar()</span></code> 将复数转换为极坐标形式，返回复数的模和辐角。</p></li>
<li><p class="translated"><code class="xref py py-func docutils literal notranslate"><span class="pre">rect()</span></code> 执行相反的操作，将模和辐角对转换回相应的复数。</p></li>
<li><p class="translated"><code class="xref py py-func docutils literal notranslate"><span class="pre">phase()</span></code> 返回复数的辐角（也称为角度）。</p></li>
<li><p class="translated"><code class="xref py py-func docutils literal notranslate"><span class="pre">isnan()</span></code> 如果其参数的实部或虚部为 NaN，则返回 True。</p></li>
<li><p class="translated"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinf()</span></code> 如果其参数的实部或虚部为无穷大，则返回 True。</p></li>
</ul>
<p class="translated">这些修订还提高了 <a class="reference internal" href="../library/cmath.html#module-cmath" title="cmath: Mathematical functions for complex numbers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmath</span></code></a> 模块的数值稳定性。对于所有函数，结果的实部和虚部在可能的情况下都精确到几个最小精度单位（ulps）。详情请见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1381">bpo-1381</a>。<code class="xref py py-func docutils literal notranslate"><span class="pre">asinh()</span></code>、<code class="xref py py-func docutils literal notranslate"><span class="pre">atanh()</span></code> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">atan()</span></code> 的分支切割也已修正。</p>
<p class="translated">该模块的测试已大幅扩展；近 2000 个新测试用例对代数函数进行了测试。</p>
<p class="translated">在 IEEE 754 平台上，<a class="reference internal" href="../library/cmath.html#module-cmath" title="cmath: Mathematical functions for complex numbers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmath</span></code></a> 模块现在以符合 C99 标准附录 'G' 的方式处理 IEEE 754 特殊值和浮点异常。</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 模块中的新数据类型：<code class="docutils literal notranslate"><span class="pre">namedtuple(typename,</span> <span class="pre">fieldnames)</span></code> 是一个工厂函数，用于创建标准元组的子类，其字段可以通过名称和索引访问。例如：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">var_type</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;variable&#39;</span><span class="p">,</span>
<span class="gp">... </span>            <span class="s1">&#39;id name type size&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 名称可以用空格或逗号分隔。</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># &#39;id, name, type, size&#39; 也是有效的。</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">var_type</span><span class="o">.</span><span class="n">_fields</span>
<span class="go">(&#39;id&#39;, &#39;name&#39;, &#39;type&#39;, &#39;size&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">var</span> <span class="o">=</span> <span class="n">var_type</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;frequency&#39;</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">var</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">var</span><span class="o">.</span><span class="n">id</span>    <span class="c1"># 等效</span>
<span class="go">1 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">var</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">var</span><span class="o">.</span><span class="n">type</span>  <span class="c1"># 等效</span>
<span class="go">int int</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">var</span><span class="o">.</span><span class="n">_asdict</span><span class="p">()</span>
<span class="go">{&#39;size&#39;: 4, &#39;type&#39;: &#39;int&#39;, &#39;id&#39;: 1, &#39;name&#39;: &#39;frequency&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v2</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;amplitude&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v2</span>
<span class="go">variable(id=1, name=&#39;amplitude&#39;, type=&#39;int&#39;, size=4)</span>
</pre></div>
</div>
<p class="translated">标准库中多个返回元组的地方已被修改为返回 <code class="xref py py-func docutils literal notranslate"><span class="pre">namedtuple()</span></code> 实例。例如，<code class="xref py py-meth docutils literal notranslate"><span class="pre">Decimal.as_tuple()</span></code> 方法现在返回一个具有 <code class="xref py py-attr docutils literal notranslate"><span class="pre">sign</span></code>、<code class="xref py py-attr docutils literal notranslate"><span class="pre">digits</span></code> 和 <code class="xref py py-attr docutils literal notranslate"><span class="pre">exponent</span></code> 字段的命名元组。</p>
<p class="translated">（由 Raymond Hettinger 贡献。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/collections.html#module-collections" title="collections: Container datatypes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">collections</span></code></a> 模块的另一个变化是 <code class="xref py py-class docutils literal notranslate"><span class="pre">deque</span></code> 类型现在支持可选的 <em>maxlen</em> 参数；如果提供，deque 的大小将被限制为不超过 <em>maxlen</em> 项。向已满的 deque 添加更多项会导致旧项被丢弃。</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dq</span><span class="o">=</span><span class="n">deque</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dq</span>
<span class="go">deque([], maxlen=3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="n">dq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="n">dq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dq</span>
<span class="go">deque([1, 2, 3], maxlen=3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dq</span>
<span class="go">deque([2, 3, 4], maxlen=3)</span>
</pre></div>
</div>
<p class="translated">（由 Raymond Hettinger 贡献。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/http.cookies.html#module-http.cookies" title="http.cookies: Support for HTTP state management (cookies)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">Cookie</span></code></a> 模块的 <a class="reference internal" href="../library/http.cookies.html#http.cookies.Morsel" title="http.cookies.Morsel"><code class="xref py py-class docutils literal notranslate"><span class="pre">Morsel</span></code></a> 对象现在支持 <a class="reference internal" href="../library/http.cookies.html#http.cookies.Morsel.httponly" title="http.cookies.Morsel.httponly"><code class="xref py py-attr docutils literal notranslate"><span class="pre">httponly</span></code></a> 属性。在某些浏览器中，设置了此属性的 cookie 不能被 JavaScript 代码访问或操作。（由 Arvin Schnell 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1638033">bpo-1638033</a>。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/curses.html#module-curses" title="curses: An interface to the curses library, providing portable terminal handling. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">curses</span></code></a> 模块中的一个新窗口方法 <code class="xref py py-meth docutils literal notranslate"><span class="pre">chgat()</span></code>，用于更改单行上一定数量字符的显示属性。（由 Fabian Kreutz 贡献。）</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 从 y=0,x=21 开始的粗体文本</span>
<span class="c1"># 并影响该行的其余部分。</span>
<span class="n">stdscr</span><span class="o">.</span><span class="n">chgat</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="n">curses</span><span class="o">.</span><span class="n">A_BOLD</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated"><a class="reference internal" href="../library/curses.html#module-curses.textpad" title="curses.textpad: Emacs-like input editing in a curses window."><code class="xref py py-mod docutils literal notranslate"><span class="pre">curses.textpad</span></code></a> 模块中的 <code class="xref py py-class docutils literal notranslate"><span class="pre">Textbox</span></code> 类现在支持在插入模式和覆盖模式下编辑。通过在创建 <code class="xref py py-class docutils literal notranslate"><span class="pre">Textbox</span></code> 实例时为 <em>insert_mode</em> 参数提供真值来启用插入模式。</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/datetime.html#module-datetime" title="datetime: Basic date and time types."><code class="xref py py-mod docutils literal notranslate"><span class="pre">datetime</span></code></a> 模块的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">strftime()</span></code> 方法现在支持 <code class="docutils literal notranslate"><span class="pre">%f</span></code> 格式代码，该代码扩展为对象中的微秒数，左侧用零填充至六位。 (由 Skip Montanaro 贡献; <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1158">bpo-1158</a>.)</p></li>
<li><p class="translated"><a class="reference internal" href="../library/decimal.html#module-decimal" title="decimal: Implementation of the General Decimal Arithmetic Specification."><code class="xref py py-mod docutils literal notranslate"><span class="pre">decimal</span></code></a> 模块已更新至 <a class="reference external" href="https://speleotrove.com/decimal/decarith.html">通用小数规范</a> 的 1.66 版本。新特性包括一些基本数学函数的方法，例如 <code class="xref py py-meth docutils literal notranslate"><span class="pre">exp()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">log10()</span></code>:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">exp</span><span class="p">()</span>
<span class="go">Decimal(&quot;2.718281828459045235360287471&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="s2">&quot;2.7182818&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">ln</span><span class="p">()</span>
<span class="go">Decimal(&quot;0.9999999895305022877376682436&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span><span class="o">.</span><span class="n">log10</span><span class="p">()</span>
<span class="go">Decimal(&quot;3&quot;)</span>
</pre></div>
</div>
<p class="translated">现在 <code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code> 对象的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">as_tuple()</span></code> 方法将返回一个由 <code class="xref py py-attr docutils literal notranslate"><span class="pre">sign</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">digits</span></code> 和 <code class="xref py py-attr docutils literal notranslate"><span class="pre">exponent</span></code> 字段组成的具名元组。</p>
<p class="translated">（由 Facundo Batista 和 Mark Dickinson 实现。 具名元组支持由 Raymond Hettinger 添加。）</p>
</li>
<li><p class="translated">现在 <a class="reference internal" href="../library/difflib.html#module-difflib" title="difflib: Helpers for computing differences between objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">difflib</span></code></a> 模块的 <code class="xref py py-class docutils literal notranslate"><span class="pre">SequenceMatcher</span></code> 类将返回代表匹配结果的具名元组，包含 <code class="xref py py-attr docutils literal notranslate"><span class="pre">a</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">b</span></code> 和 <code class="xref py py-attr docutils literal notranslate"><span class="pre">size</span></code> 等属性。 （由 Raymond Hettinger 贡献。）</p></li>
<li><p class="translated">在 <a class="reference internal" href="../library/ftplib.html#ftplib.FTP" title="ftplib.FTP"><code class="xref py py-class docutils literal notranslate"><span class="pre">ftplib.FTP</span></code></a> 类构造函数以及 <code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code> 方法中添加了一个可选的 <code class="docutils literal notranslate"><span class="pre">timeout</span></code> 参数，用于指定以秒为单位的超时时间。 (由 Facundo Batista 添加。)此外，<code class="xref py py-class docutils literal notranslate"><span class="pre">FTP</span></code> 类的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">storbinary()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">storlines()</span></code> 方法现在接受一个可选的 <em>callback</em> 参数，该参数在数据发送后会对每个数据块进行调用。 (由 Phil Schwartz 贡献; <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1221598">bpo-1221598</a>.)</p></li>
<li><p class="translated">内置函数 <code class="xref py py-func docutils literal notranslate"><span class="pre">reduce()</span></code> 也在 <a class="reference internal" href="../library/functools.html#module-functools" title="functools: Higher-order functions and operations on callable objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">functools</span></code></a> 模块中提供。在 Python 3.0 中，内置函数已被移除，<code class="xref py py-func docutils literal notranslate"><span class="pre">reduce()</span></code> 只能从 <a class="reference internal" href="../library/functools.html#module-functools" title="functools: Higher-order functions and operations on callable objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">functools</span></code></a> 中获取；目前没有计划在 2.x 系列中移除该内置函数。 (由 Christian Heimes 修复; <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1739906">bpo-1739906</a>.)</p></li>
<li><p class="translated">在可能的情况下，<a class="reference internal" href="../library/getpass.html#module-getpass" title="getpass: Portable reading of passwords and retrieval of the userid."><code class="xref py py-mod docutils literal notranslate"><span class="pre">getpass</span></code></a> 模块现在将使用 <code class="file docutils literal notranslate"><span class="pre">/dev/tty</span></code> 来打印提示信息并读取密码，如果无法使用则回退到标准错误和标准输入。如果密码可能在终端上回显，则在显示提示之前会打印一条警告信息。 (由 Gregory P. Smith 贡献)</p></li>
<li><p class="translated"><a class="reference internal" href="../library/glob.html#glob.glob" title="glob.glob"><code class="xref py py-func docutils literal notranslate"><span class="pre">glob.glob()</span></code></a> 函数现在可以在使用 Unicode 路径并在目录中匹配到 Unicode 文件名时返回 Unicode 文件名。 (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1001604">bpo-1001604</a>)</p></li>
<li><p class="translated"><a class="reference internal" href="../library/heapq.html#module-heapq" title="heapq: Heap queue algorithm (a.k.a. priority queue)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">heapq</span></code></a> 模块中的新函数 <code class="docutils literal notranslate"><span class="pre">merge(iter1,</span> <span class="pre">iter2,</span> <span class="pre">...)</span></code> 接受任意数量的返回已排序数据的可迭代对象，并返回一个新的生成器，该生成器返回所有迭代器的内容，同样按顺序排序。例如:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">heapq</span><span class="o">.</span><span class="n">merge</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">]))</span>
<span class="go">[1, 2, 3, 5, 8, 9, 16]</span>
</pre></div>
</div>
<p class="translated">另一个新函数，<code class="docutils literal notranslate"><span class="pre">heappushpop(heap,</span> <span class="pre">item)</span></code>，将 <em>item</em> 推入 <em>heap</em>，然后弹出并返回最小的元素。这比先调用 <code class="xref py py-func docutils literal notranslate"><span class="pre">heappush()</span></code> 再调用 <code class="xref py py-func docutils literal notranslate"><span class="pre">heappop()</span></code> 更高效。</p>
<p class="translated"><a class="reference internal" href="../library/heapq.html#module-heapq" title="heapq: Heap queue algorithm (a.k.a. priority queue)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">heapq</span></code></a> 现在实现为仅使用小于比较，而不是之前使用的小于或等于比较。这使得 <a class="reference internal" href="../library/heapq.html#module-heapq" title="heapq: Heap queue algorithm (a.k.a. priority queue)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">heapq</span></code></a> 对类型的用法与 <a class="reference internal" href="../library/stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list.sort()</span></code></a> 方法一致。（由 Raymond Hettinger 贡献。）</p>
</li>
<li><p class="translated">可选的 <code class="docutils literal notranslate"><span class="pre">timeout</span></code> 参数，指定以秒为单位的超时时间，已添加到 <a class="reference internal" href="../library/http.client.html#http.client.HTTPConnection" title="http.client.HTTPConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">httplib.HTTPConnection</span></code></a> 和 <a class="reference internal" href="../library/http.client.html#http.client.HTTPSConnection" title="http.client.HTTPSConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTTPSConnection</span></code></a> 类构造函数中。（由 Facundo Batista 添加。）</p></li>
<li><p class="translated">大多数 <a class="reference internal" href="../library/inspect.html#module-inspect" title="inspect: Extract information and source code from live objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect</span></code></a> 模块的函数，如 <code class="xref py py-func docutils literal notranslate"><span class="pre">getmoduleinfo()</span></code> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">getargs()</span></code>，现在返回命名元组。除了像元组一样行为，返回值的元素也可以作为属性访问。（由 Raymond Hettinger 贡献。）</p>
<p class="translated">此模块中的新增函数包括 <code class="xref py py-func docutils literal notranslate"><span class="pre">isgenerator()</span></code>、 <code class="xref py py-func docutils literal notranslate"><span class="pre">isgeneratorfunction()</span></code> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">isabstract()</span></code>。</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/itertools.html#module-itertools" title="itertools: Functions creating iterators for efficient looping."><code class="xref py py-mod docutils literal notranslate"><span class="pre">itertools</span></code></a> 模块增加了几个新函数。</p>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">izip_longest(iter1,</span> <span class="pre">iter2,</span> <span class="pre">...[,</span> <span class="pre">fillvalue])</span></code> 将基于每个元素创建元组；如果某些可迭代对象长度小于其他的，缺失的值将被设为 <em>fillvalue</em>。 例如:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">tuple</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">izip_longest</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]))</span>
<span class="go">((1, 1), (2, 2), (3, 3), (None, 4), (None, 5))</span>
</pre></div>
</div>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">product(iter1,</span> <span class="pre">iter2,</span> <span class="pre">...,</span> <span class="pre">[repeat=N])</span></code> 将返回所提供可迭代对象的笛卡尔积，即包含从每个可迭代对象返回的元素的每种可能组合的元组的集合。:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]))</span>
<span class="go">[(1, 4), (1, 5), (1, 6),</span>
<span class="go"> (2, 4), (2, 5), (2, 6),</span>
<span class="go"> (3, 4), (3, 5), (3, 6)]</span>
</pre></div>
</div>
<p class="translated">可选的*repeat*关键字参数用于计算一个可迭代对象或一组可迭代对象与其自身重复*N*次后的乘积。对于单个可迭代对象参数，返回*N*-元组:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
<span class="go">[(1, 1, 1), (1, 1, 2), (1, 2, 1), (1, 2, 2),</span>
<span class="go"> (2, 1, 1), (2, 1, 2), (2, 2, 1), (2, 2, 2)]</span>
</pre></div>
</div>
<p class="translated">对于两个可迭代对象，返回*2N*-元组。:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[(1, 3, 1, 3), (1, 3, 1, 4), (1, 3, 2, 3), (1, 3, 2, 4),</span>
<span class="go"> (1, 4, 1, 3), (1, 4, 1, 4), (1, 4, 2, 3), (1, 4, 2, 4),</span>
<span class="go"> (2, 3, 1, 3), (2, 3, 1, 4), (2, 3, 2, 3), (2, 3, 2, 4),</span>
<span class="go"> (2, 4, 1, 3), (2, 4, 1, 4), (2, 4, 2, 3), (2, 4, 2, 4)]</span>
</pre></div>
</div>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">combinations(iterable,</span> <span class="pre">r)</span></code> 基于 <em>iterable</em> 的元素返回长度为 <em>r</em> 的子序列。</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="s1">&#39;123&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">[(&#39;1&#39;, &#39;2&#39;), (&#39;1&#39;, &#39;3&#39;), (&#39;2&#39;, &#39;3&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="s1">&#39;123&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">[(&#39;1&#39;, &#39;2&#39;, &#39;3&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="s1">&#39;1234&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">[(&#39;1&#39;, &#39;2&#39;, &#39;3&#39;), (&#39;1&#39;, &#39;2&#39;, &#39;4&#39;),</span>
<span class="go"> (&#39;1&#39;, &#39;3&#39;, &#39;4&#39;), (&#39;2&#39;, &#39;3&#39;, &#39;4&#39;)]</span>
</pre></div>
</div>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">permutations(iter[,</span> <span class="pre">r])</span></code> 返回可迭代对象元素长度为 <em>r</em> 的所有排列。如果未指定 <em>r</em>，则默认为可迭代对象产生的元素数量。:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">permutations</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">[(1, 2), (1, 3), (1, 4),</span>
<span class="go"> (2, 1), (2, 3), (2, 4),</span>
<span class="go"> (3, 1), (3, 2), (3, 4),</span>
<span class="go"> (4, 1), (4, 2), (4, 3)]</span>
</pre></div>
</div>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">itertools.chain(*iterables)</span></code> 是 <a class="reference internal" href="../library/itertools.html#module-itertools" title="itertools: Functions creating iterators for efficient looping."><code class="xref py py-mod docutils literal notranslate"><span class="pre">itertools</span></code></a> 模块中已有的一个函数，在 Python 2.6 中新增了一个构造器。<code class="docutils literal notranslate"><span class="pre">itertools.chain.from_iterable(iterable)</span></code> 接受一个应返回其他可迭代对象的单一可迭代对象。<code class="xref py py-func docutils literal notranslate"><span class="pre">chain()</span></code> 将依次返回第一个可迭代对象的所有元素，然后是第二个可迭代对象的所有元素，依此类推。:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]))</span>
<span class="go">[1, 2, 3, 4, 5, 6]</span>
</pre></div>
</div>
<p class="translated">（全部由 Raymond Hettinger 贡献。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> 模块的 <code class="xref py py-class docutils literal notranslate"><span class="pre">FileHandler</span></code> 类及其子类 <code class="xref py py-class docutils literal notranslate"><span class="pre">WatchedFileHandler</span></code>、<code class="xref py py-class docutils literal notranslate"><span class="pre">RotatingFileHandler</span></code> 和 <code class="xref py py-class docutils literal notranslate"><span class="pre">TimedRotatingFileHandler</span></code> 现在在其构造器中有一个可选的 <em>delay</em> 参数。如果 <em>delay</em> 为真，日志文件的打开将被延迟，直到第一次调用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">emit()</span></code>。 (由 Vinay Sajip 贡献)</p>
<p class="translated"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimedRotatingFileHandler</span></code> 还有一个 <em>utc</em> 构造器参数。如果该参数为真，将使用 UTC 时间来确定午夜时刻和生成文件名；否则将使用本地时间。</p>
</li>
<li><p class="translated">为 <a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> 模块添加了一些新函数:</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="../library/math.html#math.isinf" title="math.isinf"><code class="xref py py-func docutils literal notranslate"><span class="pre">isinf()</span></code></a> 和 <a class="reference internal" href="../library/math.html#math.isnan" title="math.isnan"><code class="xref py py-func docutils literal notranslate"><span class="pre">isnan()</span></code></a> 分别用于判断给定浮点数是否为（正或负）无穷大或 NaN（非数字）。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/math.html#math.copysign" title="math.copysign"><code class="xref py py-func docutils literal notranslate"><span class="pre">copysign()</span></code></a> 复制 IEEE 754 数的符号位，返回 <em>x</em> 的绝对值与 <em>y</em> 的符号位组合的结果。例如，<code class="docutils literal notranslate"><span class="pre">math.copysign(1,</span> <span class="pre">-0.0)</span></code> 返回 -1.0。 (由 Christian Heimes 贡献)</p></li>
<li><p class="translated"><a class="reference internal" href="../library/math.html#math.factorial" title="math.factorial"><code class="xref py py-func docutils literal notranslate"><span class="pre">factorial()</span></code></a> 计算一个数的阶乘。 (由 Raymond Hettinger 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2138">bpo-2138</a>)</p></li>
<li><p class="translated"><a class="reference internal" href="../library/math.html#math.fsum" title="math.fsum"><code class="xref py py-func docutils literal notranslate"><span class="pre">fsum()</span></code></a> 将可迭代对象中的数字流相加，并小心避免通过使用部分和来损失精度。 (由 Jean Brouwers、Raymond Hettinger 和 Mark Dickinson 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2819">bpo-2819</a>)</p></li>
<li><p class="translated"><a class="reference internal" href="../library/math.html#math.acosh" title="math.acosh"><code class="xref py py-func docutils literal notranslate"><span class="pre">acosh()</span></code></a>、<a class="reference internal" href="../library/math.html#math.asinh" title="math.asinh"><code class="xref py py-func docutils literal notranslate"><span class="pre">asinh()</span></code></a> 和 <a class="reference internal" href="../library/math.html#math.atanh" title="math.atanh"><code class="xref py py-func docutils literal notranslate"><span class="pre">atanh()</span></code></a> 计算反双曲函数。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/math.html#math.log1p" title="math.log1p"><code class="xref py py-func docutils literal notranslate"><span class="pre">log1p()</span></code></a> 返回 <em>1+x</em> (以 <em>e</em> 为底) 的自然对数。</p></li>
<li><p class="translated"><code class="xref py py-func docutils literal notranslate"><span class="pre">trunc()</span></code> 将数字四舍五入至零，返回介于函数参数和零之间的最接近的 <code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code>。作为 <a class="reference external" href="#pep-3141">PEP 3141 数字类型层次结构</a> 的回退部分添加。</p></li>
</ul>
</li>
<li><p class="translated"><a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> 模块已改进，以在不同平台上提供更一致的行为，特别是在处理浮点异常和 IEEE 754 特殊值方面。</p>
<p class="translated">在可能的情况下，该模块遵循 C99 标准关于 754 特殊值的建议。例如，<code class="docutils literal notranslate"><span class="pre">sqrt(-1.)</span></code> 现在应在几乎所有平台上引发 <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>，而 <code class="docutils literal notranslate"><span class="pre">sqrt(float('NaN'))</span></code> 应在所有 IEEE 754 平台上返回 NaN。在 C99 标准附件 'F' 建议发出 '除以零' 或 '无效' 信号的地方，Python 将引发 <a class="reference internal" href="../library/exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。在 C99 标准附件 'F' 建议发出 '溢出' 信号的地方，Python 将引发 <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a>。（参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=711019">bpo-711019</a> 和 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1640">bpo-1640</a>。）</p>
<p class="translated">（由 Christian Heimes 和 Mark Dickinson 贡献。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/mmap.html#mmap.mmap" title="mmap.mmap"><code class="xref py py-class docutils literal notranslate"><span class="pre">mmap</span></code></a> 对象现在有一个 <code class="xref py py-meth docutils literal notranslate"><span class="pre">rfind()</span></code> 方法，从字符串末尾开始向后搜索子字符串。<code class="xref py py-meth docutils literal notranslate"><span class="pre">find()</span></code> 方法还增加了一个 <em>end</em> 参数，用于指定停止搜索的索引。（由 John Lenton 贡献。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/operator.html#module-operator" title="operator: Functions corresponding to the standard operators."><code class="xref py py-mod docutils literal notranslate"><span class="pre">operator</span></code></a> 模块增加了一个 <code class="xref py py-func docutils literal notranslate"><span class="pre">methodcaller()</span></code> 函数，它接受一个名称和一组可选的参数，返回一个可调用的对象，该对象将对传递给它的任何参数调用指定的函数。例如：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># 等价于 lambda s: s.replace(&#39;old&#39;, &#39;new&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">replacer</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">methodcaller</span><span class="p">(</span><span class="s1">&#39;replace&#39;</span><span class="p">,</span> <span class="s1">&#39;old&#39;</span><span class="p">,</span> <span class="s1">&#39;new&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">replacer</span><span class="p">(</span><span class="s1">&#39;old wine in old bottles&#39;</span><span class="p">)</span>
<span class="go">&#39;new wine in new bottles&#39;</span>
</pre></div>
</div>
<p class="translated">（由 Gregory Petrosyan 提供建议，之后由 Georg Brandl 贡献。）</p>
<p class="translated">现在 <code class="xref py py-func docutils literal notranslate"><span class="pre">attrgetter()</span></code> 函数可接受带点号的名称并执行相应的属性查找:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">inst_name</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span>
<span class="gp">... </span>       <span class="s1">&#39;__class__.__name__&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inst_name</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="go">&#39;str&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inst_name</span><span class="p">(</span><span class="n">help</span><span class="p">)</span>
<span class="go">&#39;_Helper&#39;</span>
</pre></div>
</div>
<p class="translated">（由 Barry Warsaw 提供建议，之后由 Georg Brandl 贡献。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os</span></code></a> 模块现在包装了几个新的系统调用。<code class="docutils literal notranslate"><span class="pre">fchmod(fd,</span> <span class="pre">mode)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">fchown(fd,</span> <span class="pre">uid,</span> <span class="pre">gid)</span></code> 更改已打开文件的模式和所有权，<code class="docutils literal notranslate"><span class="pre">lchmod(path,</span> <span class="pre">mode)</span></code> 更改符号链接的模式。（由 Georg Brandl 和 Christian Heimes 贡献。）</p>
<p class="translated"><code class="xref py py-func docutils literal notranslate"><span class="pre">chflags()</span></code> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">lchflags()</span></code> 是对应系统调用（在可用的情况下）的封装，用于更改文件上的标志。标志值的常量在 <a class="reference internal" href="../library/stat.html#module-stat" title="stat: Utilities for interpreting the results of os.stat(), os.lstat() and os.fstat()."><code class="xref py py-mod docutils literal notranslate"><span class="pre">stat</span></code></a> 模块中定义；一些可能的值包括 <code class="xref py py-const docutils literal notranslate"><span class="pre">UF_IMMUTABLE</span></code> 表示文件不可更改，以及 <code class="xref py py-const docutils literal notranslate"><span class="pre">UF_APPEND</span></code> 表示数据只能追加到文件中。（由 M. Levinson 贡献。）</p>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">os.closerange(low,</span> <span class="pre">high)</span></code> 高效地关闭从 <em>low</em> 到 <em>high</em> 的所有文件描述符，忽略任何错误，并且不包括 <em>high</em> 本身。此函数现在被 <a class="reference internal" href="../library/subprocess.html#module-subprocess" title="subprocess: Subprocess management."><code class="xref py py-mod docutils literal notranslate"><span class="pre">subprocess</span></code></a> 模块使用，以加快启动进程的速度。（由 Georg Brandl 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1663329">bpo-1663329</a>。）</p>
</li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">os.environ</span></code> 对象的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">clear()</span></code> 方法现在除了清除对象的键之外，还会使用 <a class="reference internal" href="../library/os.html#os.unsetenv" title="os.unsetenv"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.unsetenv()</span></code></a> 来取消设置环境变量。（由 Martin Horcicka 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1181">bpo-1181</a>。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/os.html#os.walk" title="os.walk"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.walk()</span></code></a> 函数现在有一个 <code class="docutils literal notranslate"><span class="pre">followlinks</span></code> 参数。如果设置为 True，它将跟随指向目录的符号链接并访问目录的内容。为了向后兼容，该参数的默认值为 false。请注意，如果存在指向父目录的符号链接，该函数可能会陷入无限递归。（<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1273829">bpo-1273829</a>）</p></li>
<li><p class="translated">在 <a class="reference internal" href="../library/os.path.html#module-os.path" title="os.path: Operations on pathnames."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os.path</span></code></a> 模块中，<code class="xref py py-func docutils literal notranslate"><span class="pre">splitext()</span></code> 函数已更改，不再在开头的句点字符处分割。这在处理 Unix 的点文件时会产生更好的结果。例如，<code class="docutils literal notranslate"><span class="pre">os.path.splitext('.ipython')</span></code> 现在返回 <code class="docutils literal notranslate"><span class="pre">('.ipython',</span> <span class="pre">'')</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">('',</span> <span class="pre">'.ipython')</span></code>。（<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1115886">bpo-1115886</a>）</p>
<p class="translated">一个新的函数，<code class="docutils literal notranslate"><span class="pre">os.path.relpath(path,</span> <span class="pre">start='.')</span></code>，返回从 <code class="docutils literal notranslate"><span class="pre">start</span></code> 路径（如果提供）或从当前工作目录到目标 <code class="docutils literal notranslate"><span class="pre">path</span></code> 的相对路径。（由 Richard Barran 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1339796">bpo-1339796</a>。）</p>
<p class="translated">在Windows上，<a class="reference internal" href="../library/os.path.html#os.path.expandvars" title="os.path.expandvars"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.path.expandvars()</span></code></a> 现在可以展开形如 &quot;%var%&quot; 的环境变量，并且 &quot;~user&quot; 将被展开为用户的主目录路径。（由 Josiah Carlson 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=957650">bpo-957650</a>。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/pdb.html#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pdb</span></code></a> 模块提供的 Python 调试器新增了一个命令：&quot;run&quot; 可以重新启动正在调试的 Python 程序，并且可以可选地接受新的命令行参数。（由 Rocky Bernstein 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1393667">bpo-1393667</a>。）</p></li>
<li><p class="translated">用于开始调试回溯的 <a class="reference internal" href="../library/pdb.html#pdb.post_mortem" title="pdb.post_mortem"><code class="xref py py-func docutils literal notranslate"><span class="pre">pdb.post_mortem()</span></code></a> 函数，现在如果没有提供回溯，将使用 <a class="reference internal" href="../library/sys.html#sys.exc_info" title="sys.exc_info"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_info()</span></code></a> 返回的回溯。（由 Facundo Batista 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1106316">bpo-1106316</a>。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/pickletools.html#module-pickletools" title="pickletools: Contains extensive comments about the pickle protocols and pickle-machine opcodes, as well as some useful functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickletools</span></code></a> 模块现在有一个 <code class="xref py py-func docutils literal notranslate"><span class="pre">optimize()</span></code> 函数，它接受一个包含 pickle 的字符串，并移除一些未使用的操作码，返回一个包含相同数据结构的更短的 pickle。（由 Raymond Hettinger 贡献。）</p></li>
<li><p class="translated">在 <a class="reference internal" href="../library/pkgutil.html#module-pkgutil" title="pkgutil: Utilities for the import system."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pkgutil</span></code></a> 模块中添加了一个 <code class="xref py py-func docutils literal notranslate"><span class="pre">get_data()</span></code> 函数，它返回随安装的 Python 包一起包含的资源文件的内容。例如：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">pkgutil</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">pkgutil</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">,</span> <span class="s1">&#39;exception_hierarchy.txt&#39;</span><span class="p">)</span>
<span class="go">BaseException</span>
<span class="go"> +-- SystemExit</span>
<span class="go"> +-- KeyboardInterrupt</span>
<span class="go"> +-- GeneratorExit</span>
<span class="go"> +-- Exception</span>
<span class="go">      +-- StopIteration</span>
<span class="go">      +-- StandardError</span>
<span class="go"> ...</span>
</pre></div>
</div>
<p class="translated">（由 Paul Moore 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2439">bpo-2439</a> 中贡献。）</p>
</li>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyexpat</span></code> 模块的 <code class="xref py py-class docutils literal notranslate"><span class="pre">Parser</span></code> 对象现在允许设置它们的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">buffer_size</span></code> 属性，以改变用于保存字符数据的缓冲区大小。（由 Achim Gaedke 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1137">bpo-1137</a>。）</p></li>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Queue</span></code> 模块现在提供了不同顺序检索条目的队列变体。<code class="xref py py-class docutils literal notranslate"><span class="pre">PriorityQueue</span></code> 类将排队项存储在堆中并按优先级顺序检索它们，而 <code class="xref py py-class docutils literal notranslate"><span class="pre">LifoQueue</span></code> 首先检索最近添加的条目，这意味着它表现得像一个栈。（由 Raymond Hettinger 贡献。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/random.html#module-random" title="random: Generate pseudo-random numbers with various common distributions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">random</span></code></a> 模块的 <code class="xref py py-class docutils literal notranslate"><span class="pre">Random</span></code> 对象现在可以在32位系统上被序列化，并在64位系统上反序列化，反之亦然。不幸的是，这一变化也意味着 Python 2.6 的 <code class="xref py py-class docutils literal notranslate"><span class="pre">Random</span></code> 对象无法在早期版本的 Python 上正确反序列化。（由 Shawn Ligocki 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1727780">bpo-1727780</a>。）</p>
<p class="translated">新的 <code class="docutils literal notranslate"><span class="pre">triangular(low,</span> <span class="pre">high,</span> <span class="pre">mode)</span></code> 函数返回遵循三角分布的随机数。返回值介于 <em>low</em> 和 <em>high</em> 之间，不包括 <em>high</em> 本身，且 <em>mode</em> 为分布中最频繁出现的值。（由 Wladmir van der Laan 和 Raymond Hettinger 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1681432">bpo-1681432</a>。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/re.html#module-re" title="re: Regular expression operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">re</span></code></a> 模块执行的长正则表达式搜索将检查是否有信号传递，因此耗时搜索现在可以被中断。（由 Josh Hoyt 和 Ralf Schmitt 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=846388">bpo-846388</a>。）</p>
<p class="translated">正则表达式模块通过为一个小型正则表达式专用虚拟机编译字节码来实现。未受信任的代码可能直接创建恶意的字节码字符串并导致崩溃，因此 Python 2.6 包含了一个用于验证正则表达式字节码的验证器。（由 Guido van Rossum 基于为 Google App Engine 的工作贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=3487">bpo-3487</a>。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/rlcompleter.html#module-rlcompleter" title="rlcompleter: Python identifier completion, suitable for the GNU readline library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">rlcompleter</span></code></a> 模块的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">Completer.complete()</span></code> 方法现在将忽略在评估名称时触发的异常。（由 Lorenz Quack 修复；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2250">bpo-2250</a>。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/sched.html#module-sched" title="sched: General purpose event scheduler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sched</span></code></a> 模块的 <code class="xref py py-class docutils literal notranslate"><span class="pre">scheduler</span></code> 实例现在有一个只读的 <a class="reference internal" href="../library/queue.html#module-queue" title="queue: A synchronized queue class."><code class="xref py py-attr docutils literal notranslate"><span class="pre">queue</span></code></a> 属性，返回调度器队列的内容，表示为一个命名元组列表，字段为 <code class="docutils literal notranslate"><span class="pre">(time,</span> <span class="pre">priority,</span> <span class="pre">action,</span> <span class="pre">argument)</span></code>。（由 Raymond Hettinger 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1861">bpo-1861</a>。）</p></li>
<li><p class="translated">模块 <a class="reference internal" href="../library/select.html#module-select" title="select: Wait for I/O completion on multiple streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">select</span></code></a> 现在为 Linux 的 <code class="xref c c-func docutils literal notranslate"><span class="pre">epoll()</span></code> 和 BSD 的 <code class="xref c c-func docutils literal notranslate"><span class="pre">kqueue()</span></code> 系统调用提供了包装函数。为现有的 <code class="xref py py-class docutils literal notranslate"><span class="pre">poll</span></code> 对象添加了 <code class="xref py py-meth docutils literal notranslate"><span class="pre">modify()</span></code> 方法；<code class="docutils literal notranslate"><span class="pre">pollobj.modify(fd,</span> <span class="pre">eventmask)</span></code> 接收一个文件描述符或文件对象以及一个事件掩码，修改该文件的记录事件掩码。（由 Christian Heimes 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1657">bpo-1657</a>。）</p></li>
<li><p class="translated">函数 <a class="reference internal" href="../library/shutil.html#shutil.copytree" title="shutil.copytree"><code class="xref py py-func docutils literal notranslate"><span class="pre">shutil.copytree()</span></code></a> 现在有一个可选的 <em>ignore</em> 参数，该参数接收一个可调用对象。这个可调用对象将接收每个目录路径和目录内容的列表，并返回一个将被忽略、不进行复制的名称列表。</p>
<p class="translated">模块 <a class="reference internal" href="../library/shutil.html#module-shutil" title="shutil: High-level file operations, including copying."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shutil</span></code></a> 还提供了一个 <code class="xref py py-func docutils literal notranslate"><span class="pre">ignore_patterns()</span></code> 函数，用于与这个新参数一起使用。<code class="xref py py-func docutils literal notranslate"><span class="pre">ignore_patterns()</span></code> 接收任意数量的 glob-style 模式，并返回一个可调用对象，该对象将忽略匹配这些模式中的任何一个的文件和目录。以下示例复制一个目录树，但跳过 <code class="file docutils literal notranslate"><span class="pre">.svn</span></code> 目录和以 '~' 结尾的 Emacs 备份文件：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">shutil</span><span class="o">.</span><span class="n">copytree</span><span class="p">(</span><span class="s1">&#39;Doc/library&#39;</span><span class="p">,</span> <span class="s1">&#39;/tmp/library&#39;</span><span class="p">,</span>
                <span class="n">ignore</span><span class="o">=</span><span class="n">shutil</span><span class="o">.</span><span class="n">ignore_patterns</span><span class="p">(</span><span class="s1">&#39;*~&#39;</span><span class="p">,</span> <span class="s1">&#39;.svn&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p class="translated">（由 Tarek Ziadé 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2663">bpo-2663</a> 中贡献。）</p>
</li>
<li><p class="translated">将信号处理与 Tkinter 或 GTk+ 使用的 GUI 事件循环集成长期以来一直是一个问题；大多数软件最终采用轮询方式，每隔一小段时间唤醒一次以检查是否有任何 GUI 事件发生。模块 <a class="reference internal" href="../library/signal.html#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal notranslate"><span class="pre">signal</span></code></a> 现在可以使这更高效。调用 <code class="docutils literal notranslate"><span class="pre">signal.set_wakeup_fd(fd)</span></code> 设置一个文件描述符；当接收到信号时，向该文件描述符写入一个字节。还有一个 C 级函数 <a class="reference internal" href="../c-api/exceptions.html#c.PySignal_SetWakeupFd" title="PySignal_SetWakeupFd"><code class="xref c c-func docutils literal notranslate"><span class="pre">PySignal_SetWakeupFd()</span></code></a>，用于设置描述符。</p>
<p class="translated">事件循环将使用此方法通过打开管道来创建两个描述符，一个用于读取，一个用于写入。可写描述符将传递给 <code class="xref py py-func docutils literal notranslate"><span class="pre">set_wakeup_fd()</span></code>，可读描述符将通过 <code class="xref c c-func docutils literal notranslate"><span class="pre">select()</span></code> 或 <code class="xref c c-func docutils literal notranslate"><span class="pre">poll()</span></code> 添加到事件循环监视的描述符列表中。接收到信号时，将写入一个字节，唤醒主事件循环，避免需要轮询。</p>
<p class="translated">（由 Adam Olsen 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1583">bpo-1583</a> 中贡献。）</p>
<p class="translated"><code class="xref py py-func docutils literal notranslate"><span class="pre">siginterrupt()</span></code> 函数现在可以从 Python 代码中使用，允许更改信号是否可以中断系统调用。（由 Ralf Schmitt 贡献。）</p>
<p class="translated">还添加了 <code class="xref py py-func docutils literal notranslate"><span class="pre">setitimer()</span></code> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">getitimer()</span></code> 函数（在可用的情况下）。<code class="xref py py-func docutils literal notranslate"><span class="pre">setitimer()</span></code> 允许设置间隔定时器，该定时器将在指定时间后向进程发送信号，时间测量可以是墙钟时间、消耗的进程时间或进程+系统时间之和。（由 Guilherme Polo 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2240">bpo-2240</a>。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/smtplib.html#module-smtplib" title="smtplib: SMTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">smtplib</span></code></a> 模块现在支持通过 SSL 的 SMTP，这得益于 <code class="xref py py-class docutils literal notranslate"><span class="pre">SMTP_SSL</span></code> 类的添加。这个类支持与现有 <code class="xref py py-class docutils literal notranslate"><span class="pre">SMTP</span></code> 类相同的接口。（由 Monty Taylor 贡献。）这两个类构造函数还有一个可选的 <code class="docutils literal notranslate"><span class="pre">timeout</span></code> 参数，用于指定初始连接尝试的超时时间，以秒为单位。（由 Facundo Batista 贡献。）</p>
<p class="translated">模块中还添加了 LMTP 协议（<span class="target" id="index-71"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2033.html"><strong>RFC 2033</strong></a>）的实现。当在不需要管理邮件队列的代理之间传输电子邮件时，使用 LMTP 代替 SMTP。（LMTP 由 Leif Hedstrom 实现；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=957003">bpo-957003</a>。）</p>
<p class="translated"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SMTP.starttls()</span></code> 现在符合 <span class="target" id="index-72"></span><a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc3207.html"><strong>RFC 3207</strong></a> 标准，并忘记从服务器获得的任何非 TLS 协商本身获得的知识。（补丁由 Bill Fenner 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=829951">bpo-829951</a>。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> 模块现在支持 TIPC (<a class="reference external" href="https://tipc.sourceforge.net/">https://tipc.sourceforge.net/</a>)，这是一种为集群环境设计的高性能非IP协议。TIPC 地址为 4- 或 5- 元组。（由 Alberto Bertogli 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1646">bpo-1646</a>。）</p>
<p class="translated">新函数 <code class="xref py py-func docutils literal notranslate"><span class="pre">create_connection()</span></code> 接收一个地址并使用可选的超时值进行连接，返回已连接的套接字对象。此函数还会查找地址的类型，并使用 IPv4 或 IPv6 适当地进行连接。将代码改为使用 <code class="xref py py-func docutils literal notranslate"><span class="pre">create_connection()</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">socket(socket.AF_INET,</span> <span class="pre">...)</span></code> 可能是使代码支持 IPv6 所需的全部工作。</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/socketserver.html#module-socketserver" title="socketserver: A framework for network servers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">SocketServer</span></code></a> 模块中的基类现在支持在服务器 <a class="reference internal" href="../library/socketserver.html#socketserver.BaseServer.timeout" title="socketserver.BaseServer.timeout"><code class="xref py py-attr docutils literal notranslate"><span class="pre">timeout</span></code></a> 属性指定的不活动时间后调用 <a class="reference internal" href="../library/socketserver.html#socketserver.BaseServer.handle_timeout" title="socketserver.BaseServer.handle_timeout"><code class="xref py py-meth docutils literal notranslate"><span class="pre">handle_timeout()</span></code></a> 方法。(由 Michael Pomraning 贡献。) <a class="reference internal" href="../library/socketserver.html#socketserver.BaseServer.serve_forever" title="socketserver.BaseServer.serve_forever"><code class="xref py py-meth docutils literal notranslate"><span class="pre">serve_forever()</span></code></a> 方法现在接受一个可选的轮询间隔（以秒为单位），控制服务器检查关闭请求的频率。（由 Pedro Werneck 和 Jeffrey Yasskin 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=742598">bpo-742598</a>, <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1193577">bpo-1193577</a>。）</p></li>
<li><p class="translated">由 Gerhard Häring 维护的 <a class="reference internal" href="../library/sqlite3.html#module-sqlite3" title="sqlite3: A DB-API 2.0 implementation using SQLite 3.x."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sqlite3</span></code></a> 模块已从 Python 2.5 中的版本 2.3.2 更新到版本 2.4.1。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/struct.html#module-struct" title="struct: Interpret bytes as packed binary data."><code class="xref py py-mod docutils literal notranslate"><span class="pre">struct</span></code></a> 模块现在支持 C99 的 <span class="c-expr sig sig-inline c"><span class="kt">_Bool</span></span> 类型，使用格式字符 <code class="docutils literal notranslate"><span class="pre">'?'</span></code>。（由 David Remahl 贡献。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/subprocess.html#module-subprocess" title="subprocess: Subprocess management."><code class="xref py py-mod docutils literal notranslate"><span class="pre">subprocess</span></code></a> 模块提供的 <a class="reference internal" href="../library/subprocess.html#subprocess.Popen" title="subprocess.Popen"><code class="xref py py-class docutils literal notranslate"><span class="pre">Popen</span></code></a> 对象现在具有 <a class="reference internal" href="../library/subprocess.html#subprocess.Popen.terminate" title="subprocess.Popen.terminate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">terminate()</span></code></a>、<a class="reference internal" href="../library/subprocess.html#subprocess.Popen.kill" title="subprocess.Popen.kill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kill()</span></code></a> 和 <a class="reference internal" href="../library/subprocess.html#subprocess.Popen.send_signal" title="subprocess.Popen.send_signal"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_signal()</span></code></a> 方法。在 Windows 上，<code class="xref py py-meth docutils literal notranslate"><span class="pre">send_signal()</span></code> 仅支持 <a class="reference internal" href="../library/signal.html#signal.SIGTERM" title="signal.SIGTERM"><code class="xref py py-const docutils literal notranslate"><span class="pre">SIGTERM</span></code></a> 信号，所有这些方法都是 Win32 API 函数 <code class="xref c c-func docutils literal notranslate"><span class="pre">TerminateProcess()</span></code> 的别名。（由 Christian Heimes 贡献。)</p></li>
<li><p class="translated">在 <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a> 模块中新增了一个变量 <code class="xref py py-attr docutils literal notranslate"><span class="pre">float_info</span></code>，它是一个包含从 <code class="file docutils literal notranslate"><span class="pre">float.h</span></code> 文件中获取的关于平台浮点支持信息的对象。该对象的属性包括 <code class="xref py py-attr docutils literal notranslate"><span class="pre">mant_dig</span></code> (尾数的位数) 、<code class="xref py py-attr docutils literal notranslate"><span class="pre">epsilon</span></code> (1.0 与下一个可表示的最大值之间的最小差值) 以及其他几个属性。（由 Christian Heimes 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1534">bpo-1534</a>。）</p>
<p class="translated">另一个新变量 <code class="xref py py-attr docutils literal notranslate"><span class="pre">dont_write_bytecode</span></code> 控制着 Python 在导入模块时是否写入任何 <code class="file docutils literal notranslate"><span class="pre">.pyc</span></code> 或 <code class="file docutils literal notranslate"><span class="pre">.pyo</span></code> 文件。如果该变量为真，则不写入编译文件。该变量在启动时通过向 Python 解释器提供 <a class="reference internal" href="../using/cmdline.html#cmdoption-B"><code class="xref std std-option docutils literal notranslate"><span class="pre">-B</span></code></a> 开关或通过在运行解释器之前设置 <span class="target" id="index-73"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONDONTWRITEBYTECODE"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONDONTWRITEBYTECODE</span></code></a> 环境变量来初始设置。Python 代码随后可以更改此变量的值，以控制是否写入字节码文件。（由 Neal Norwitz 和 Georg Brandl 贡献。）</p>
<p class="translated">通过读取名为 <code class="docutils literal notranslate"><span class="pre">sys.flags</span></code> 的命名元组的属性，可以获取提供给 Python 解释器的命令行参数信息。例如，如果 Python 以详细模式执行，则 <code class="xref py py-attr docutils literal notranslate"><span class="pre">verbose</span></code> 属性为真，<code class="xref py py-attr docutils literal notranslate"><span class="pre">debug</span></code> 在调试模式下为真，等等。这些属性都是只读的。（由 Christian Heimes 贡献。）</p>
<p class="translated">新增了一个函数 <code class="xref py py-func docutils literal notranslate"><span class="pre">getsizeof()</span></code>，它接受一个 Python 对象并返回该对象使用的内存量，以字节为单位。内置对象返回正确结果；第三方扩展可能不会，但可以定义一个 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__sizeof__()</span></code> 方法来返回对象的大小。（由 Robert Schuppenies 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2898">bpo-2898</a>。）</p>
<p class="translated">现在可以通过调用 <a class="reference internal" href="../library/sys.html#sys.getprofile" title="sys.getprofile"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getprofile()</span></code></a> 和 <a class="reference internal" href="../library/sys.html#sys.gettrace" title="sys.gettrace"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.gettrace()</span></code></a> 来确定当前的剖析器和跟踪器函数。（由 Georg Brandl 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1648">bpo-1648</a>。）</p>
</li>
<li><p class="translated">模块 <a class="reference internal" href="../library/tarfile.html#module-tarfile" title="tarfile: Read and write tar-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tarfile</span></code></a> 现在除了已支持的 POSIX.1-1988 (ustar) 和 GNU tar 格式外，还支持 POSIX.1-2001 (pax) tar文件。默认格式为 GNU tar；可以通过指定 <code class="docutils literal notranslate"><span class="pre">format</span></code> 参数来使用不同的格式打开文件:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">tar</span> <span class="o">=</span> <span class="n">tarfile</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;output.tar&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span>
                   <span class="nb">format</span><span class="o">=</span><span class="n">tarfile</span><span class="o">.</span><span class="n">PAX_FORMAT</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">新的 <code class="docutils literal notranslate"><span class="pre">encoding</span></code> 和 <code class="docutils literal notranslate"><span class="pre">errors</span></code> 参数用于指定字符转换的编码和错误处理方案。<code class="docutils literal notranslate"><span class="pre">'strict'</span></code>、<code class="docutils literal notranslate"><span class="pre">'ignore'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">'replace'</span></code> 是 Python 处理错误的三个标准方式；<code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code> 是一个特殊值，它会将错误的字符替换为它们的 UTF-8 表示形式。（字符转换是因为 PAX 格式支持 Unicode 文件名，默认使用 UTF-8 编码。）</p>
<p class="translated">方法 <code class="xref py py-meth docutils literal notranslate"><span class="pre">TarFile.add()</span></code> 现在接受一个 <code class="docutils literal notranslate"><span class="pre">exclude</span></code> 参数，该参数是一个函数，用于排除某些文件名不存入归档。该函数必须接受一个文件名，并在文件应被排除时返回 true，在文件应被归档时返回 false。该函数应用于最初传递给 <code class="xref py py-meth docutils literal notranslate"><span class="pre">add()</span></code> 的名称以及递归添加的目录中的文件名。</p>
<p class="translated">（所有改变均由 Lars Gustäbel 贡献）。</p>
</li>
<li><p class="translated">在类 <code class="xref py py-class docutils literal notranslate"><span class="pre">telnetlib.Telnet</span></code> 的构造函数中添加了一个可选的 <code class="docutils literal notranslate"><span class="pre">timeout</span></code> 参数，用于指定以秒为单位的超时时间。（由 Facundo Batista 添加。）</p></li>
<li><p class="translated">类 <a class="reference internal" href="../library/tempfile.html#tempfile.NamedTemporaryFile" title="tempfile.NamedTemporaryFile"><code class="xref py py-class docutils literal notranslate"><span class="pre">tempfile.NamedTemporaryFile</span></code></a> 通常在文件关闭时删除其创建的临时文件。现在可以通过向构造函数传递 <code class="docutils literal notranslate"><span class="pre">delete=False</span></code> 来改变此行为。（由 Damien Miller 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1537850">bpo-1537850</a>。）</p>
<p class="translated">新增类 <code class="xref py py-class docutils literal notranslate"><span class="pre">SpooledTemporaryFile</span></code>，其行为类似于临时文件，但会在内存中存储数据，直到超过最大大小。达到该限制后，内容将被写入磁盘上的临时文件。（由 Dustin J. Mitchell 贡献。）</p>
<p class="translated"><code class="xref py py-class docutils literal notranslate"><span class="pre">NamedTemporaryFile</span></code> 和 <code class="xref py py-class docutils literal notranslate"><span class="pre">SpooledTemporaryFile</span></code> 类都可作为上下文管理器使用，因此你可以编写 <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">tempfile.NamedTemporaryFile()</span> <span class="pre">as</span> <span class="pre">tmp:</span> <span class="pre">...</span></code>。 (由 Alexander Belopolsky 贡献; <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2021">bpo-2021</a>.)</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/test.html#module-test.support" title="test.support: Support for Python's regression test suite."><code class="xref py py-mod docutils literal notranslate"><span class="pre">test.test_support</span></code></a> 模块增加了一些用于编写测试的上下文管理器。<a class="reference internal" href="../library/test.html#test.support.os_helper.EnvironmentVarGuard" title="test.support.os_helper.EnvironmentVarGuard"><code class="xref py py-func docutils literal notranslate"><span class="pre">EnvironmentVarGuard()</span></code></a> 是一个上下文管理器，它可以临时更改环境变量并自动将其恢复为旧值。</p>
<p class="translated">另一个上下文管理器 <code class="xref py py-class docutils literal notranslate"><span class="pre">TransientResource</span></code> 可以围绕对可能可用或不可用的资源的调用；它将捕获并忽略指定的异常列表。例如，网络测试在连接到外部网站时可能会忽略某些失败情况:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">test_support</span><span class="o">.</span><span class="n">TransientResource</span><span class="p">(</span><span class="ne">IOError</span><span class="p">,</span>
                                <span class="n">errno</span><span class="o">=</span><span class="n">errno</span><span class="o">.</span><span class="n">ETIMEDOUT</span><span class="p">):</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s1">&#39;https://sf.net&#39;</span><span class="p">)</span>
    <span class="o">...</span>
</pre></div>
</div>
<p class="translated">最后，<code class="xref py py-func docutils literal notranslate"><span class="pre">check_warnings()</span></code> 重置 <code class="xref py py-mod docutils literal notranslate"><span class="pre">warning</span></code> 模块的警告过滤器，并返回一个将记录所有触发的警告消息的对象 (<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=3781">bpo-3781</a>):</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">test_support</span><span class="o">.</span><span class="n">check_warnings</span><span class="p">()</span> <span class="k">as</span> <span class="n">wrec</span><span class="p">:</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;always&quot;</span><span class="p">)</span>
    <span class="c1"># ... 触发警告的代码 ...</span>
    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">wrec</span><span class="o">.</span><span class="n">message</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;function is outdated&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">wrec</span><span class="o">.</span><span class="n">warnings</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Multiple warnings raised&quot;</span>
</pre></div>
</div>
<p class="translated">（由 Brett Cannon 贡献。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/textwrap.html#module-textwrap" title="textwrap: Text wrapping and filling"><code class="xref py py-mod docutils literal notranslate"><span class="pre">textwrap</span></code></a> 模块现在可以通过指定 <code class="docutils literal notranslate"><span class="pre">drop_whitespace=False</span></code> 作为参数来保留新创建行首尾的现有空白:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;This  sentence  has a bunch   of</span>
<span class="gp">... </span><span class="s2">  extra   whitespace.&quot;&quot;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="go">This  sentence</span>
<span class="go">has a bunch</span>
<span class="go">of    extra</span>
<span class="go">whitespace.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">drop_whitespace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="go">This  sentence</span>
<span class="go">  has a bunch</span>
<span class="go">   of    extra</span>
<span class="go">   whitespace.</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">（由 Dwayne Bailey 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1581073">bpo-1581073</a> 中贡献。）</p>
</li>
<li><p class="translated">模块 <a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> 的 API 正在被修改，以使用属性如 <code class="xref py py-attr docutils literal notranslate"><span class="pre">daemon</span></code> 而不是 <code class="xref py py-meth docutils literal notranslate"><span class="pre">setDaemon()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">isDaemon()</span></code> 方法，并且一些方法已被重命名，使用下划线而不是驼峰命名法；例如，<code class="xref py py-meth docutils literal notranslate"><span class="pre">activeCount()</span></code> 方法被重命名为 <code class="xref py py-meth docutils literal notranslate"><span class="pre">active_count()</span></code>。模块的 2.6 和 3.0 版本都支持相同的属性和重命名的方法，但不删除旧方法。Python 3.x 中旧 API 的弃用日期尚未确定；旧 API 不会在任何 2.x 版本中被移除。（由多人执行，最著名的是 Benjamin Peterson。）</p>
<p class="translated">模块 <a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> 的 <code class="xref py py-class docutils literal notranslate"><span class="pre">Thread</span></code> 对象获得了一个 <code class="xref py py-attr docutils literal notranslate"><span class="pre">ident</span></code> 属性，该属性返回线程的标识符，一个非零整数。（由 Gregory P. Smith 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2871">bpo-2871</a>。）</p>
</li>
<li><p class="translated">模块 <a class="reference internal" href="../library/timeit.html#module-timeit" title="timeit: Measure the execution time of small code snippets."><code class="xref py py-mod docutils literal notranslate"><span class="pre">timeit</span></code></a> 现在接受可调用对象以及字符串作为被计时的语句和设置代码。添加了两个便捷函数用于创建 <code class="xref py py-class docutils literal notranslate"><span class="pre">Timer</span></code> 实例：<code class="docutils literal notranslate"><span class="pre">repeat(stmt,</span> <span class="pre">setup,</span> <span class="pre">time,</span> <span class="pre">repeat,</span> <span class="pre">number)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">timeit(stmt,</span> <span class="pre">setup,</span> <span class="pre">time,</span> <span class="pre">number)</span></code> 创建一个实例并调用相应的方法。（由 Erik Demaine 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1533909">bpo-1533909</a>。）</p></li>
<li><p class="translated">模块 <code class="xref py py-mod docutils literal notranslate"><span class="pre">Tkinter</span></code> 现在接受列表和元组作为选项，在将结果值传递给 Tcl/Tk 之前用空格分隔元素。（由 Guilherme Polo 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2906">bpo-2906</a>。）</p></li>
<li><p class="translated">模块 <a class="reference internal" href="../library/turtle.html#module-turtle" title="turtle: An educational framework for simple graphics applications"><code class="xref py py-mod docutils literal notranslate"><span class="pre">turtle</span></code></a> 用于海龟图形，由 Gregor Lingl 大大增强。模块中的新功能包括：</p>
<ul class="simple">
<li><p class="translated">改进了海龟移动和旋转的动画。</p></li>
<li><p class="translated">使用新的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">delay()</span></code>、<code class="xref py py-meth docutils literal notranslate"><span class="pre">tracer()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">speed()</span></code> 方法控制海龟移动。</p></li>
<li><p class="translated">能够为海龟设置新形状，并定义新的坐标系。</p></li>
<li><p class="translated">海龟现在有一个 <code class="xref py py-meth docutils literal notranslate"><span class="pre">undo()</span></code> 方法，可以回滚操作。</p></li>
<li><p class="translated">简单支持对鼠标和键盘活动等输入事件做出反应，使得编写简单游戏成为可能。</p></li>
<li><p class="translated"><code class="file docutils literal notranslate"><span class="pre">turtle.cfg</span></code> 文件可被用来定制海龟绘图屏幕的初始外观。</p></li>
<li><p class="translated">模块的文档字符串可以被替换为已翻译成另一种语言的新文档字符串。</p></li>
</ul>
<p class="translated">(<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1513695">bpo-1513695</a>)</p>
</li>
<li><p class="translated">在 <a class="reference internal" href="../library/urllib.request.html#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib.urlopen</span></code></a> 函数和 <code class="xref py py-class docutils literal notranslate"><span class="pre">urllib.ftpwrapper</span></code> 类构造器以及 <a class="reference internal" href="../library/urllib.request.html#urllib.request.urlopen" title="urllib.request.urlopen"><code class="xref py py-func docutils literal notranslate"><span class="pre">urllib2.urlopen</span></code></a> 函数中添加了一个可选的 <code class="docutils literal notranslate"><span class="pre">timeout</span></code> 参数。该参数指定以秒为单位的超时时间。例如:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">u</span> <span class="o">=</span> <span class="n">urllib2</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s2">&quot;http://slow.example.com&quot;</span><span class="p">,</span>
<span class="go">                        timeout=3)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">urllib2.URLError</span>: <span class="n">&lt;urlopen error timed out&gt;</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">（由 Facundo Batista 添加。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/unicodedata.html#module-unicodedata" title="unicodedata: Access the Unicode Database."><code class="xref py py-mod docutils literal notranslate"><span class="pre">unicodedata</span></code></a> 模块提供的Unicode数据库已更新至版本5.1.0。（由Martin von Löwis更新；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=3811">bpo-3811</a>。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/warnings.html#module-warnings" title="warnings: Issue warning messages and control their disposition."><code class="xref py py-mod docutils literal notranslate"><span class="pre">warnings</span></code></a> 模块的 <code class="xref py py-func docutils literal notranslate"><span class="pre">formatwarning()</span></code> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">showwarning()</span></code> 增加了一个可选的 <em>line</em> 参数，用于提供源代码行。（作为 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1631171">bpo-1631171</a> 的一部分添加，该问题重新实现了 <a class="reference internal" href="../library/warnings.html#module-warnings" title="warnings: Issue warning messages and control their disposition."><code class="xref py py-mod docutils literal notranslate"><span class="pre">warnings</span></code></a> 模块的C代码部分。）</p>
<p class="translated">新增函数 <code class="xref py py-func docutils literal notranslate"><span class="pre">catch_warnings()</span></code> 是一个用于测试目的的上下文管理器，允许你临时修改警告过滤器，然后恢复其原始值（<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=3781">bpo-3781</a>）。</p>
</li>
<li><p class="translated">XML-RPC的 <a class="reference internal" href="../library/xmlrpc.server.html#module-xmlrpc.server" title="xmlrpc.server: Basic XML-RPC server implementations."><code class="xref py py-class docutils literal notranslate"><span class="pre">SimpleXMLRPCServer</span></code></a> 和 <a class="reference internal" href="../library/xmlrpc.server.html#module-xmlrpc.server" title="xmlrpc.server: Basic XML-RPC server implementations."><code class="xref py py-class docutils literal notranslate"><span class="pre">DocXMLRPCServer</span></code></a> 类现在可以通过将 <code class="docutils literal notranslate"><span class="pre">False</span></code> 作为 <em>bind_and_activate</em> 构造器参数传递来防止立即打开并绑定到其套接字。这可用于在调用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">server_bind()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">server_activate()</span></code> 方法打开套接字并开始监听连接之前修改实例的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">allow_reuse_address</span></code> 属性。（由Peter Parente贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1599845">bpo-1599845</a>。）</p>
<p class="translated"><code class="xref py py-class docutils literal notranslate"><span class="pre">SimpleXMLRPCServer</span></code> 还有一个 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_send_traceback_header</span></code> 属性；如果为真，异常和格式化的回溯将作为 HTTP 头部 &quot;X-Exception&quot; 和 &quot;X-Traceback&quot; 返回。此功能仅用于调试目的，不应在生产服务器上使用，因为回溯可能会泄露密码或其他敏感信息。（由 Alan McIntyre 作为其 Google 2007 年夏季代码项目的一部分贡献。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/xmlrpc.client.html#module-xmlrpc.client" title="xmlrpc.client: XML-RPC client access."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xmlrpclib</span></code></a> 模块不再自动将 <a class="reference internal" href="../library/datetime.html#datetime.date" title="datetime.date"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.date</span></code></a> 和 <a class="reference internal" href="../library/datetime.html#datetime.time" title="datetime.time"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.time</span></code></a> 转换为 <a class="reference internal" href="../library/xmlrpc.client.html#xmlrpc.client.DateTime" title="xmlrpc.client.DateTime"><code class="xref py py-class docutils literal notranslate"><span class="pre">xmlrpclib.DateTime</span></code></a> 类型；转换语义并不一定适用于所有应用程序。使用 <code class="xref py py-mod docutils literal notranslate"><span class="pre">xmlrpclib</span></code> 的代码应转换 <code class="xref py py-class docutils literal notranslate"><span class="pre">date</span></code> 和 <a class="reference internal" href="../library/datetime.html#datetime.time" title="datetime.time"><code class="xref py py-class docutils literal notranslate"><span class="pre">time</span></code></a> 实例。（<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1330538">bpo-1330538</a>）代码还可以处理 1900 年之前的日期（由 Ralf Schmitt 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2014">bpo-2014</a>）以及使用 <code class="docutils literal notranslate"><span class="pre">&lt;i8&gt;</span></code> 在 XML-RPC 响应中表示的 64 位整数（由 Riku Lindblad 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2985">bpo-2985</a>）。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/zipfile.html#module-zipfile" title="zipfile: Read and write ZIP-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipfile</span></code></a> 模块的 <code class="xref py py-class docutils literal notranslate"><span class="pre">ZipFile</span></code> 类现在有 <code class="xref py py-meth docutils literal notranslate"><span class="pre">extract()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">extractall()</span></code> 方法，可以将单个文件或存档中的所有文件解压到当前目录，或指定目录:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">z</span> <span class="o">=</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">ZipFile</span><span class="p">(</span><span class="s1">&#39;python-251.zip&#39;</span><span class="p">)</span>

<span class="c1"># 解压单个文件，将其写入</span>
<span class="c1"># 相对于 /tmp 目录。</span>
<span class="n">z</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="s1">&#39;Python/sysmodule.c&#39;</span><span class="p">,</span> <span class="s1">&#39;/tmp&#39;</span><span class="p">)</span>

<span class="c1"># 解压存档中的所有文件。</span>
<span class="n">z</span><span class="o">.</span><span class="n">extractall</span><span class="p">()</span>
</pre></div>
</div>
<p class="translated">（由 Alan McIntyre 在 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=467924">bpo-467924</a> 中贡献。）</p>
<p class="translated"><a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open()</span></code></a>、<code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">extract()</span></code> 方法现在可以接受文件名或 <code class="xref py py-class docutils literal notranslate"><span class="pre">ZipInfo</span></code> 对象。这在存档意外包含重复文件名时很有用。（由 Graham Horler 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1775025">bpo-1775025</a>。）</p>
<p class="translated">最后，<a class="reference internal" href="../library/zipfile.html#module-zipfile" title="zipfile: Read and write ZIP-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipfile</span></code></a> 现在支持使用 Unicode 文件名存档文件。（由 Alexey Borzenkov 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1734346">bpo-1734346</a>。）</p>
</li>
</ul>
<section id="the-ast-module">
<h3 class="translated"><a class="reference internal" href="../library/ast.html#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code></a> 模块<a class="headerlink" href="#the-ast-module" title="Link to this heading">¶</a></h3>
<p class="translated"><a class="reference internal" href="../library/ast.html#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code></a> 模块提供了 Python 代码的抽象语法树（Abstract Syntax Tree）表示，Armin Ronacher 贡献了一组辅助函数，用于执行各种常见任务。这些函数对于 HTML 模板包、代码分析器以及处理 Python 代码的类似工具将非常有用。</p>
<p class="translated"><code class="xref py py-func docutils literal notranslate"><span class="pre">parse()</span></code> 函数接受一个表达式并返回一个 AST。<code class="xref py py-func docutils literal notranslate"><span class="pre">dump()</span></code> 函数输出树的表示，适用于调试:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">ast</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">d = </span><span class="si">{}</span>
<span class="s2">for i in &#39;abcdefghijklm&#39;:</span>
<span class="s2">    d[i + i] = ord(i) - ord(&#39;a&#39;) + 1</span>
<span class="s2">print d</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
<span class="nb">print</span> <span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">输出是一棵深度嵌套的树:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Module</span><span class="p">(</span><span class="n">body</span><span class="o">=</span><span class="p">[</span>
  <span class="n">Assign</span><span class="p">(</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span>
    <span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">Store</span><span class="p">())</span>
   <span class="p">],</span> <span class="n">value</span><span class="o">=</span><span class="n">Dict</span><span class="p">(</span><span class="n">keys</span><span class="o">=</span><span class="p">[],</span> <span class="n">values</span><span class="o">=</span><span class="p">[]))</span>
  <span class="n">For</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">Store</span><span class="p">()),</span>
      <span class="nb">iter</span><span class="o">=</span><span class="n">Str</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="s1">&#39;abcdefghijklm&#39;</span><span class="p">),</span> <span class="n">body</span><span class="o">=</span><span class="p">[</span>
    <span class="n">Assign</span><span class="p">(</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span>
      <span class="n">Subscript</span><span class="p">(</span><span class="n">value</span><span class="o">=</span>
        <span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">Load</span><span class="p">()),</span>
          <span class="nb">slice</span><span class="o">=</span>
          <span class="n">Index</span><span class="p">(</span><span class="n">value</span><span class="o">=</span>
            <span class="n">BinOp</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">Load</span><span class="p">()),</span> <span class="n">op</span><span class="o">=</span><span class="n">Add</span><span class="p">(),</span>
             <span class="n">right</span><span class="o">=</span><span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">Load</span><span class="p">()))),</span> <span class="n">ctx</span><span class="o">=</span><span class="n">Store</span><span class="p">())</span>
     <span class="p">],</span> <span class="n">value</span><span class="o">=</span>
     <span class="n">BinOp</span><span class="p">(</span><span class="n">left</span><span class="o">=</span>
      <span class="n">BinOp</span><span class="p">(</span><span class="n">left</span><span class="o">=</span>
       <span class="n">Call</span><span class="p">(</span><span class="n">func</span><span class="o">=</span>
        <span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s1">&#39;ord&#39;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">Load</span><span class="p">()),</span> <span class="n">args</span><span class="o">=</span><span class="p">[</span>
          <span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">Load</span><span class="p">())</span>
         <span class="p">],</span> <span class="n">keywords</span><span class="o">=</span><span class="p">[],</span> <span class="n">starargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span>
       <span class="n">op</span><span class="o">=</span><span class="n">Sub</span><span class="p">(),</span> <span class="n">right</span><span class="o">=</span><span class="n">Call</span><span class="p">(</span><span class="n">func</span><span class="o">=</span>
        <span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s1">&#39;ord&#39;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">Load</span><span class="p">()),</span> <span class="n">args</span><span class="o">=</span><span class="p">[</span>
          <span class="n">Str</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
         <span class="p">],</span> <span class="n">keywords</span><span class="o">=</span><span class="p">[],</span> <span class="n">starargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">)),</span>
       <span class="n">op</span><span class="o">=</span><span class="n">Add</span><span class="p">(),</span> <span class="n">right</span><span class="o">=</span><span class="n">Num</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
    <span class="p">],</span> <span class="n">orelse</span><span class="o">=</span><span class="p">[])</span>
   <span class="n">Print</span><span class="p">(</span><span class="n">dest</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="p">[</span>
     <span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">Load</span><span class="p">())</span>
   <span class="p">],</span> <span class="n">nl</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
 <span class="p">])</span>
</pre></div>
</div>
<p class="translated"><code class="xref py py-func docutils literal notranslate"><span class="pre">literal_eval()</span></code> 方法接受一个字符串或表示字面量表达式的 AST，解析并评估它，并返回结果值。字面量表达式是只包含字符串、数字、字典等，但不包含语句或函数调用的 Python 表达式。如果你需要评估一个表达式，但不能接受使用 <a class="reference internal" href="../library/functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 调用的安全风险，<code class="xref py py-func docutils literal notranslate"><span class="pre">literal_eval()</span></code> 将安全地处理它:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">literal</span> <span class="o">=</span> <span class="s1">&#39;(&quot;a&quot;, &quot;b&quot;, {2:4, 3:8, 1:2})&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">literal</span><span class="p">)</span>
<span class="go">(&#39;a&#39;, &#39;b&#39;, {1: 2, 2: 4, 3: 8})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="s1">&#39;&quot;a&quot; + &quot;b&quot;&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">malformed string</span>
</pre></div>
</div>
<p class="translated">该模块还包括 <code class="xref py py-class docutils literal notranslate"><span class="pre">NodeVisitor</span></code> 和 <code class="xref py py-class docutils literal notranslate"><span class="pre">NodeTransformer</span></code> 类，用于遍历和修改 AST，以及用于常见转换（如更改行号）的函数。</p>
</section>
<section id="the-future-builtins-module">
<h3 class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">future_builtins</span></code> 模块<a class="headerlink" href="#the-future-builtins-module" title="Link to this heading">¶</a></h3>
<p class="translated">Python 3.0 对内置函数库进行了许多更改，大多数更改无法在 Python 2.x 系统中引入因为它们会破坏兼容性。 <code class="xref py py-mod docutils literal notranslate"><span class="pre">future_builtins</span></code> 模块提供了这些内置函数的不同版本，可以在编写 3.0 兼容的代码时导入。</p>
<p class="translated">目前此模块中的函数包括:</p>
<ul class="simple">
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">ascii(obj)</span></code>: 等同于 <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a>。在 Python 3.0 中，<a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 将返回一个 Unicode 字符串，而 <a class="reference internal" href="../library/functions.html#ascii" title="ascii"><code class="xref py py-func docutils literal notranslate"><span class="pre">ascii()</span></code></a> 将返回一个纯 ASCII 字节串。</p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">filter(predicate,</span> <span class="pre">iterable)</span></code>, <code class="docutils literal notranslate"><span class="pre">map(func,</span> <span class="pre">iterable1,</span> <span class="pre">...)</span></code>: 3.0 版本返回迭代器，与返回列表的 2.x 内置函数不同。</p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">hex(value)</span></code>, <code class="docutils literal notranslate"><span class="pre">oct(value)</span></code>: 这些版本将调用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__index__()</span></code> 方法而不是 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__hex__()</span></code> 或 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__oct__()</span></code> 方法，并将结果转换为十六进制或八进制。<a class="reference internal" href="../library/functions.html#oct" title="oct"><code class="xref py py-func docutils literal notranslate"><span class="pre">oct()</span></code></a> 将使用新的 <code class="docutils literal notranslate"><span class="pre">0o</span></code> 表示法来表示其结果。</p></li>
</ul>
</section>
<section id="the-json-module-javascript-object-notation">
<h3 class="translated"><a class="reference internal" href="../library/json.html#module-json" title="json: Encode and decode the JSON format."><code class="xref py py-mod docutils literal notranslate"><span class="pre">json</span></code></a> 模块: JavaScript Object Notation<a class="headerlink" href="#the-json-module-javascript-object-notation" title="Link to this heading">¶</a></h3>
<p class="translated">新的 <a class="reference internal" href="../library/json.html#module-json" title="json: Encode and decode the JSON format."><code class="xref py py-mod docutils literal notranslate"><span class="pre">json</span></code></a> 模块支持将 Python 类型编码和解码为 JSON（JavaScript 对象表示法）。JSON 是一种轻量级的数据交换格式，常用于 Web 应用程序。有关 JSON 的更多信息，请参见 <a class="reference external" href="http://www.json.org">http://www.json.org</a>。</p>
<p class="translated"><a class="reference internal" href="../library/json.html#module-json" title="json: Encode and decode the JSON format."><code class="xref py py-mod docutils literal notranslate"><span class="pre">json</span></code></a> 模块支持对大多数内置 Python 类型进行解码和编码。以下示例展示了如何编码和解码字典:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;spam&quot;</span><span class="p">:</span> <span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="s2">&quot;parrot&quot;</span><span class="p">:</span> <span class="mi">42</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">in_json</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="c1"># 编码数据</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">in_json</span>
<span class="go">&#39;{&quot;parrot&quot;: 42, &quot;spam&quot;: &quot;foo&quot;}&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">in_json</span><span class="p">)</span> <span class="c1"># 解码到一个 Python 对象</span>
<span class="go">{&quot;spam&quot;: &quot;foo&quot;, &quot;parrot&quot;: 42}</span>
</pre></div>
</div>
<p class="translated">你还可以编写自己的解码器和编码器以支持更多类型。还支持对 JSON 字符串进行美化打印。</p>
<p class="translated"><a class="reference internal" href="../library/json.html#module-json" title="json: Encode and decode the JSON format."><code class="xref py py-mod docutils literal notranslate"><span class="pre">json</span></code></a> (最初称为 simplejson) 由 Bob Ippolito 编写。</p>
</section>
<section id="the-plistlib-module-a-property-list-parser">
<h3 class="translated"><a class="reference internal" href="../library/plistlib.html#module-plistlib" title="plistlib: Generate and parse Apple plist files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">plistlib</span></code></a> 模块：属性列表解析器<a class="headerlink" href="#the-plistlib-module-a-property-list-parser" title="Link to this heading">¶</a></h3>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">.plist</span></code> 格式通常在 Mac OS X 上用于存储基本数据类型（数字、字符串、列表和字典），通过将它们序列化成基于 XML 的格式。它类似于 XML-RPC 数据类型的序列化。</p>
<p class="translated">尽管该格式主要在 Mac OS X 上使用，但它本身并没有特定于 Mac 的内容，Python 实现在任何支持 Python 的平台上都能工作，因此 <a class="reference internal" href="../library/plistlib.html#module-plistlib" title="plistlib: Generate and parse Apple plist files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">plistlib</span></code></a> 模块已被提升到标准库中。</p>
<p class="translated">此模块的用法很简单:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">plistlib</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">datetime</span>

<span class="c1"># 创建数据结构</span>
<span class="n">data_struct</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">lastAccessed</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">(),</span>
                   <span class="n">version</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                   <span class="n">categories</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;Personal&#39;</span><span class="p">,</span><span class="s1">&#39;Shared&#39;</span><span class="p">,</span><span class="s1">&#39;Private&#39;</span><span class="p">))</span>

<span class="c1"># 创建包含 XML 的字符串。</span>
<span class="n">plist_str</span> <span class="o">=</span> <span class="n">plistlib</span><span class="o">.</span><span class="n">writePlistToString</span><span class="p">(</span><span class="n">data_struct</span><span class="p">)</span>
<span class="n">new_struct</span> <span class="o">=</span> <span class="n">plistlib</span><span class="o">.</span><span class="n">readPlistFromString</span><span class="p">(</span><span class="n">plist_str</span><span class="p">)</span>
<span class="nb">print</span> <span class="n">data_struct</span>
<span class="nb">print</span> <span class="n">new_struct</span>

<span class="c1"># 将数据结构写入文件并重新读取。</span>
<span class="n">plistlib</span><span class="o">.</span><span class="n">writePlist</span><span class="p">(</span><span class="n">data_struct</span><span class="p">,</span> <span class="s1">&#39;/tmp/customizations.plist&#39;</span><span class="p">)</span>
<span class="n">new_struct</span> <span class="o">=</span> <span class="n">plistlib</span><span class="o">.</span><span class="n">readPlist</span><span class="p">(</span><span class="s1">&#39;/tmp/customizations.plist&#39;</span><span class="p">)</span>

<span class="c1"># read/writePlist 接受文件类对象以及路径。</span>
<span class="n">plistlib</span><span class="o">.</span><span class="n">writePlist</span><span class="p">(</span><span class="n">data_struct</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="ctypes-enhancements">
<h3 class="translated">ctypes 增强<a class="headerlink" href="#ctypes-enhancements" title="Link to this heading">¶</a></h3>
<p class="translated">Thomas Heller 继续维护和增强 <a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 模块。</p>
<p class="translated"><a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 现在支持 <code class="xref py py-class docutils literal notranslate"><span class="pre">c_bool</span></code> 数据类型，它表示 C99 的 <code class="docutils literal notranslate"><span class="pre">bool</span></code> 类型。（由 David Remahl 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1649190">bpo-1649190</a>。）</p>
<p class="translated"><a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 模块的字符串、缓冲区和数组类型已改进对扩展切片语法的支持，可以提供各种 <code class="docutils literal notranslate"><span class="pre">(start,</span> <span class="pre">stop,</span> <span class="pre">step)</span></code> 组合。（由 Thomas Wouters 实现。）</p>
<p class="translated">所有 <a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 数据类型现在支持 <code class="xref py py-meth docutils literal notranslate"><span class="pre">from_buffer()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">from_buffer_copy()</span></code> 方法，这些方法基于提供的缓冲区对象创建 ctypes 实例。<code class="xref py py-meth docutils literal notranslate"><span class="pre">from_buffer_copy()</span></code> 方法复制对象的内容，而 <code class="xref py py-meth docutils literal notranslate"><span class="pre">from_buffer()</span></code> 方法将共享同一内存区域。</p>
<p class="translated">新的调用约定指示 <a class="reference internal" href="../library/ctypes.html#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 在每次包装调用的开始清除 <code class="docutils literal notranslate"><span class="pre">errno</span></code> 或 Win32 LastError 变量。（由 Thomas Heller 实现；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1798">bpo-1798</a>。）</p>
<p class="translated">现在可以在函数调用后检索 Unix <code class="docutils literal notranslate"><span class="pre">errno</span></code> 变量。在创建包装函数时，可以将 <code class="docutils literal notranslate"><span class="pre">use_errno=True</span></code> 作为关键字参数提供给 <code class="xref py py-func docutils literal notranslate"><span class="pre">DLL()</span></code> 函数，然后调用模块级方法 <code class="xref py py-meth docutils literal notranslate"><span class="pre">set_errno()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_errno()</span></code> 来设置和检索错误值。</p>
<p class="translated">Win32 LastError 变量同样由 <code class="xref py py-func docutils literal notranslate"><span class="pre">DLL()</span></code>、<code class="xref py py-func docutils literal notranslate"><span class="pre">OleDLL()</span></code> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">WinDLL()</span></code> 函数支持。提供 <code class="docutils literal notranslate"><span class="pre">use_last_error=True</span></code> 作为关键字参数，然后调用模块级方法 <code class="xref py py-meth docutils literal notranslate"><span class="pre">set_last_error()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_last_error()</span></code>。</p>
<p class="translated"><code class="xref py py-func docutils literal notranslate"><span class="pre">byref()</span></code> 函数用于检索指向 ctypes 实例的指针，现在有一个可选的 <em>offset</em> 参数，该参数是一个字节计数，将添加到返回的指针中。</p>
</section>
<section id="improved-ssl-support">
<h3 class="translated">改进的 SSL 支持<a class="headerlink" href="#improved-ssl-support" title="Link to this heading">¶</a></h3>
<p class="translated">Bill Janssen 对 Python 2.6 的安全套接字层（SSL）支持进行了大量改进，通过添加一个新的模块 <a class="reference internal" href="../library/ssl.html#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a>，该模块构建在 <a class="reference external" href="https://www.openssl.org/">OpenSSL</a> 库之上。这个新模块提供了对协商协议、使用的 X.509 证书的更多控制，并更好地支持在 Python 中编写 SSL 服务器（而不是客户端）。<a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> 模块中现有的 SSL 支持没有被移除，继续有效，但将在 Python 3.0 中被移除。</p>
<p class="translated">要使用新模块，你必须首先以常规方式创建一个TCP连接，然后将其传递给 <code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.wrap_socket()</span></code> 函数。可以指定是否需要证书，并通过调用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">getpeercert()</span></code> 方法获取证书信息。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p class="translated"><a class="reference internal" href="../library/ssl.html#module-ssl" title="ssl: TLS/SSL wrapper for socket objects"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> 模块的文档。</p>
</div>
</section>
</section>
<section id="deprecations-and-removals">
<h2 class="translated">弃用和移除<a class="headerlink" href="#deprecations-and-removals" title="Link to this heading">¶</a></h2>
<ul>
<li><p class="translated">字符串异常已被移除。尝试使用它们将引发 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p></li>
<li><p class="translated">根据 <span class="target" id="index-74"></span><a class="pep reference external" href="https://peps.python.org/pep-0352/"><strong>PEP 352</strong></a> 的要求，对 <a class="reference internal" href="../library/exceptions.html#Exception" title="Exception"><code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></a> 接口的更改仍在进行中。对于2.6版本，<code class="xref py py-attr docutils literal notranslate"><span class="pre">message</span></code> 属性已被弃用，转而使用 <a class="reference internal" href="../library/exceptions.html#BaseException.args" title="BaseException.args"><code class="xref py py-attr docutils literal notranslate"><span class="pre">args</span></code></a> 属性。</p></li>
<li><p class="translated">（3.0警告模式）Python 3.0将提供一个重新组织的标准库，该库将删除许多过时的模块并重命名其他模块。在3.0警告模式下运行的Python 2.6将在导入这些模块时发出警告。</p>
<p class="translated">已弃用的模块列表如下：<code class="xref py py-mod docutils literal notranslate"><span class="pre">audiodev</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">bgenlocations</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">buildtools</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">bundlebuilder</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">Canvas</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">compiler</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">dircache</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">dl</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">fpformat</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">gensuitemodule</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">ihooks</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">imageop</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">imgfile</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">linuxaudiodev</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">mhlib</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">mimetools</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">multifile</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">new</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">pure</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">statvfs</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">sunaudiodev</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">test.testall</span></code> 和 <code class="xref py py-mod docutils literal notranslate"><span class="pre">toaiff</span></code>。</p>
</li>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">gopherlib</span></code> 模块已被移除。</p></li>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">MimeWriter</span></code> 模块和 <code class="xref py py-mod docutils literal notranslate"><span class="pre">mimify</span></code> 模块已被弃用；请改用 <a class="reference internal" href="../library/email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code></a> 包。</p></li>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">md5</span></code> 模块已被弃用；请改用 <a class="reference internal" href="../library/hashlib.html#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code class="xref py py-mod docutils literal notranslate"><span class="pre">hashlib</span></code></a> 模块。</p></li>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">posixfile</span></code> 模块已被弃用；<a class="reference internal" href="../library/fcntl.html#fcntl.lockf" title="fcntl.lockf"><code class="xref py py-func docutils literal notranslate"><span class="pre">fcntl.lockf()</span></code></a> 可提供更好的锁机制。</p></li>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">popen2</span></code> 模块已被弃用；请使用 <a class="reference internal" href="../library/subprocess.html#module-subprocess" title="subprocess: Subprocess management."><code class="xref py py-mod docutils literal notranslate"><span class="pre">subprocess</span></code></a> 模块。</p></li>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">rgbimg</span></code> 模块已被移除。</p></li>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sets</span></code> 模块已被弃用；最好使用内置的 <a class="reference internal" href="../library/stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a> 和 <a class="reference internal" href="../library/stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a> 类型。</p></li>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sha</span></code> 模块已被弃用；请使用 <a class="reference internal" href="../library/hashlib.html#module-hashlib" title="hashlib: Secure hash and message digest algorithms."><code class="xref py py-mod docutils literal notranslate"><span class="pre">hashlib</span></code></a> 模块。</p></li>
</ul>
</section>
<section id="build-and-c-api-changes">
<h2 class="translated">构建和 C API 的变更<a class="headerlink" href="#build-and-c-api-changes" title="Link to this heading">¶</a></h2>
<p class="translated">针对 Python 构建过程和 C API 的变更包括:</p>
<ul>
<li><p class="translated">Python现在必须使用C89编译器进行编译（19年后！）。这意味着Python源代码树已删除其自身的 <code class="xref c c-func docutils literal notranslate"><span class="pre">memmove()</span></code> 和 <code class="xref c c-func docutils literal notranslate"><span class="pre">strerror()</span></code> 实现，这些功能在C89标准库中。</p></li>
<li><p class="translated">Python 2.6可以使用Microsoft Visual Studio 2008（版本9.0）构建，这也是新的默认编译器。请查看 <code class="file docutils literal notranslate"><span class="pre">PCbuild</span></code> 目录以获取构建文件。（由Christian Heimes实现。）</p></li>
<li><p class="translated">在Mac OS X上，Python 2.6可以编译为四路通用构建。<strong class="program">configure</strong> 脚本可以接受一个 <code class="xref std std-option docutils literal notranslate"><span class="pre">--with-universal-archs=[32-bit|64-bit|all]</span></code> 开关，控制生成的二进制文件是为32位架构（x86，PowerPC）、64位（x86-64和PPC-64）还是两者都支持。（由Ronald Oussoren贡献。）</p></li>
<li><p class="translated">在Python 2.6.6中新增的函数 <code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_SetArgvEx()</span></code>，设置 <code class="docutils literal notranslate"><span class="pre">sys.argv</span></code> 的值，并且可以可选地根据 <em>updatepath</em> 参数的值更新 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> 以包括包含由 <code class="docutils literal notranslate"><span class="pre">sys.argv[0]</span></code> 指定的脚本的目录。</p>
<p class="translated">此函数的添加是为了关闭嵌入Python的应用程序的安全漏洞。旧的函数 <code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_SetArgv()</span></code> 总是更新 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code>，有时还会添加当前目录。这意味着，如果你在一个由其他人控制的目录中运行嵌入Python的应用程序，攻击者可以在该目录中放置一个木马模块（例如，一个名为 <code class="file docutils literal notranslate"><span class="pre">os.py</span></code> 的文件），你的应用程序将会导入并运行它。</p>
<p class="translated">如果你维护一个嵌入Python的C/C++应用程序，检查你是否调用了 <code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_SetArgv()</span></code> 并仔细考虑应用程序是否应该使用 <em>updatepath</em> 设置为false的 <code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_SetArgvEx()</span></code>。请注意，使用此函数将破坏与Python 2.6.5及更早版本兼容性；如果你必须继续使用早期版本，你可以保留对 <code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_SetArgv()</span></code> 的调用，并在之后调用 <code class="docutils literal notranslate"><span class="pre">PyRun_SimpleString(&quot;sys.path.pop(0)\n&quot;)</span></code> 来丢弃 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> 的第一个组件。</p>
<p class="translated">安全问题报告为 <span class="target" id="index-75"></span><a class="cve reference external" href="https://www.cve.org/CVERecord?id=CVE-2008-5983"><strong>CVE 2008-5983</strong></a>；在 <a class="reference external" href="https://github.com/python/cpython/issues/50003">gh-50003</a> 中讨论，并由Antoine Pitrou修复。</p>
</li>
<li><p class="translated">BerkeleyDB模块现在有一个C API对象，作为 <code class="docutils literal notranslate"><span class="pre">bsddb.db.api</span></code> 提供。这个对象可以被其他希望使用 <code class="xref py py-mod docutils literal notranslate"><span class="pre">bsddb</span></code> 模块实现自己目的的C扩展使用。（由Duncan Grisby贡献。）</p></li>
<li><p class="translated">新的缓冲区接口，之前在 <a class="reference external" href="#pep-3118-revised-buffer-protocol">PEP 3118 部分</a> 中描述，增加了 <a class="reference internal" href="../c-api/buffer.html#c.PyObject_GetBuffer" title="PyObject_GetBuffer"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_GetBuffer()</span></code></a> 和 <a class="reference internal" href="../c-api/buffer.html#c.PyBuffer_Release" title="PyBuffer_Release"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyBuffer_Release()</span></code></a>，以及其他一些函数。</p></li>
<li><p class="translated">Python 对 C 标准输入输出库的使用现在是线程安全的，或者至少与底层库一样线程安全。一个长期存在的潜在错误是，如果一个线程在另一个线程正在读取或写入文件对象时关闭该文件对象。在 2.6 版本中，文件对象具有引用计数，由 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyFile_IncUseCount()</span></code> 和 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyFile_DecUseCount()</span></code> 函数操作。文件对象只有在引用计数为零时才能被关闭。<code class="xref c c-func docutils literal notranslate"><span class="pre">PyFile_IncUseCount()</span></code> 应在仍持有 GIL 时调用，在进行使用 <code class="docutils literal notranslate"><span class="pre">FILE</span> <span class="pre">*</span></code> 指针的 I/O 操作之前，而 <code class="xref c c-func docutils literal notranslate"><span class="pre">PyFile_DecUseCount()</span></code> 应在重新获取 GIL 后立即调用。（由 Antoine Pitrou 和 Gregory P. Smith 贡献。）</p></li>
<li><p class="translated">在两个不同线程中同时导入模块不再会导致死锁；现在会引发一个 <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>。一个新的 API 函数 <a class="reference internal" href="../c-api/import.html#c.PyImport_ImportModuleNoBlock" title="PyImport_ImportModuleNoBlock"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_ImportModuleNoBlock()</span></code></a>，首先会在 <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code> 中查找模块，然后在获取导入锁后尝试导入它。如果导入锁被另一个线程持有，则会引发 <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>。（由 Christian Heimes 贡献。）</p></li>
<li><p class="translated">有几个函数返回有关平台浮点支持的信息。<a class="reference internal" href="../c-api/float.html#c.PyFloat_GetMax" title="PyFloat_GetMax"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFloat_GetMax()</span></code></a> 返回最大可表示的浮点值，而 <a class="reference internal" href="../c-api/float.html#c.PyFloat_GetMin" title="PyFloat_GetMin"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFloat_GetMin()</span></code></a> 返回最小正值。<a class="reference internal" href="../c-api/float.html#c.PyFloat_GetInfo" title="PyFloat_GetInfo"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyFloat_GetInfo()</span></code></a> 返回一个对象，其中包含来自 <code class="file docutils literal notranslate"><span class="pre">float.h</span></code> 文件的更多信息，例如 <code class="docutils literal notranslate"><span class="pre">&quot;mant_dig&quot;</span></code> (尾数中的数字位数) 、<code class="docutils literal notranslate"><span class="pre">&quot;epsilon&quot;</span></code> (1.0 与下一个最大可表示值之间的最小差异) 以及其他几个信息。（由 Christian Heimes 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1534">bpo-1534</a>。）</p></li>
<li><p class="translated">使用 <a class="reference internal" href="../c-api/complex.html#c.PyComplex_AsCComplex" title="PyComplex_AsCComplex"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyComplex_AsCComplex()</span></code></a> 的 C 函数和方法现在将接受具有 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__complex__()</span></code> 方法的参数。特别是，<a class="reference internal" href="../library/cmath.html#module-cmath" title="cmath: Mathematical functions for complex numbers."><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmath</span></code></a> 模块中的函数现在将接受具有此方法的对象。这是 Python 3.0 变更的一个回退版本。（由 Mark Dickinson 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1675423">bpo-1675423</a>。）</p></li>
<li><p class="translated">Python 的 C API 现在包括两个用于不区分大小写的字符串比较函数，<code class="docutils literal notranslate"><span class="pre">PyOS_stricmp(char*,</span> <span class="pre">char*)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">PyOS_strnicmp(char*,</span> <span class="pre">char*,</span> <span class="pre">Py_ssize_t)</span></code>。（由 Christian Heimes 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1635">bpo-1635</a>。）</p></li>
<li><p class="translated">许多 C 扩展在 <code class="docutils literal notranslate"><span class="pre">init*</span></code> 函数中定义了自己的小宏，用于将整数和字符串添加到模块的字典中。Python 2.6 终于定义了用于向模块添加值的标准宏，<a class="reference internal" href="../c-api/module.html#c.PyModule_AddStringMacro" title="PyModule_AddStringMacro"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyModule_AddStringMacro</span></code></a> 和 <a class="reference internal" href="../c-api/module.html#c.PyModule_AddIntMacro" title="PyModule_AddIntMacro"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyModule_AddIntMacro()</span></code></a>。（由 Christian Heimes 贡献。）</p></li>
<li><p class="translated">一些宏在 3.0 和 2.6 中都被重命名，以更清楚地表明它们是宏，而不是函数。<code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_Size()</span></code> 变为 <a class="reference internal" href="../c-api/structures.html#c.Py_SIZE" title="Py_SIZE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_SIZE()</span></code></a>，<code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_Type()</span></code> 变为 <a class="reference internal" href="../c-api/structures.html#c.Py_TYPE" title="Py_TYPE"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_TYPE()</span></code></a>，<code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_Refcnt()</span></code> 变为 <a class="reference internal" href="../c-api/refcounting.html#c.Py_REFCNT" title="Py_REFCNT"><code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_REFCNT()</span></code></a>。混合大小写的宏在 Python 2.6 中仍然可用，以保持向后兼容。(<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1629">bpo-1629</a>)</p></li>
<li><p class="translated">Distutils 在运行调试版本的 Python 时，现在将构建的 C 扩展放置在不同的目录中。（由 Collin Winter 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1530959">bpo-1530959</a>。）</p></li>
<li><p class="translated">几种基本数据类型，如整数和字符串，维护内部的对象自由列表，这些对象可以重复使用。这些自由列表的数据结构现在遵循命名约定：变量始终命名为 <code class="docutils literal notranslate"><span class="pre">free_list</span></code>，计数器始终命名为 <code class="docutils literal notranslate"><span class="pre">numfree</span></code>，并且始终定义一个宏 <code class="docutils literal notranslate"><span class="pre">Py&lt;typename&gt;_MAXFREELIST</span></code>。</p></li>
<li><p class="translated">一个新的Makefile目标，&quot;make patchcheck&quot;，用于准备Python源代码树以生成补丁：它会修复所有修改过的&quot;.py&quot;文件中的尾部空白，检查文档是否已更改，并报告 <code class="file docutils literal notranslate"><span class="pre">Misc/ACKS</span></code> 和 <code class="file docutils literal notranslate"><span class="pre">Misc/NEWS</span></code> 文件是否已更新。（由 Brett Cannon 贡献。）</p>
<p class="translated">另一个新目标，&quot;make profile-opt&quot;，使用GCC的基于配置的优化来编译Python二进制文件。它会启用配置编译Python，运行测试套件以获取一组配置结果，然后使用这些结果进行优化编译。（由 Gregory P. Smith 贡献。）</p>
</li>
</ul>
<section id="port-specific-changes-windows">
<h3 class="translated">特定于 Windows 的更改：<a class="headerlink" href="#port-specific-changes-windows" title="Link to this heading">¶</a></h3>
<ul>
<li><p class="translated">对Windows 95、98、ME和NT4的支持已被放弃。Python 2.6至少需要Windows 2000 SP4。</p></li>
<li><p class="translated">Windows上的新默认编译器是Visual Studio 2008（版本9.0）。Visual Studio 2003（版本7.1）和2005（版本8.0）的构建目录已被移至PC/目录。新的 <code class="file docutils literal notranslate"><span class="pre">PCbuild</span></code> 目录支持X64的交叉编译、调试构建和配置引导优化（PGO）。PGO构建比普通构建大约快10%。 （由 Christian Heimes 贡献，Amaury Forgeot d'Arc 和 Martin von Löwis 提供帮助。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/msvcrt.html#module-msvcrt" title="msvcrt: Miscellaneous useful routines from the MS VC++ runtime. (Windows)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">msvcrt</span></code></a> 模块现在支持控制台 I/O API 的普通和宽字符变体。<a class="reference internal" href="../library/msvcrt.html#msvcrt.getwch" title="msvcrt.getwch"><code class="xref py py-func docutils literal notranslate"><span class="pre">getwch()</span></code></a> 函数读取按键并返回一个 Unicode 值，<a class="reference internal" href="../library/msvcrt.html#msvcrt.getwche" title="msvcrt.getwche"><code class="xref py py-func docutils literal notranslate"><span class="pre">getwche()</span></code></a> 函数也是如此。<a class="reference internal" href="../library/msvcrt.html#msvcrt.putwch" title="msvcrt.putwch"><code class="xref py py-func docutils literal notranslate"><span class="pre">putwch()</span></code></a> 函数接受一个Unicode字符并将其写入控制台。（由 Christian Heimes 贡献。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/os.path.html#os.path.expandvars" title="os.path.expandvars"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.path.expandvars()</span></code></a> 现在将展开形式为  &quot;%var%&quot;的环境变量，而 &quot;~user&quot; 将被展开为用户的主目录路径。（由 Josiah Carlson 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=957650">bpo-957650</a>。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> 模块的套接字对象现在有一个 <a class="reference internal" href="../library/socket.html#socket.socket.ioctl" title="socket.socket.ioctl"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ioctl()</span></code></a> 方法，它提供了一个有限的接口到 <code class="xref c c-func docutils literal notranslate"><span class="pre">WSAIoctl()</span></code> 系统接口。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/winreg.html#module-winreg" title="winreg: Routines and objects for manipulating the Windows registry. (Windows)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">_winreg</span></code></a> 模块现在有一个函数，<a class="reference internal" href="../library/winreg.html#winreg.ExpandEnvironmentStrings" title="winreg.ExpandEnvironmentStrings"><code class="xref py py-func docutils literal notranslate"><span class="pre">ExpandEnvironmentStrings()</span></code></a>，用于扩展输入字符串中的环境变量引用，如 <code class="docutils literal notranslate"><span class="pre">%NAME%</span></code>。该模块提供的句柄对象现在支持上下文协议，因此可以在 <a class="reference internal" href="../reference/compound_stmts.html#with"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">with</span></code></a> 语句中使用。（由 Christian Heimes 贡献。）</p>
<p class="translated"><a class="reference internal" href="../library/winreg.html#module-winreg" title="winreg: Routines and objects for manipulating the Windows registry. (Windows)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">_winreg</span></code></a> 还对 x64 系统提供了更好的支持，公开了 <a class="reference internal" href="../library/winreg.html#winreg.DisableReflectionKey" title="winreg.DisableReflectionKey"><code class="xref py py-func docutils literal notranslate"><span class="pre">DisableReflectionKey()</span></code></a>、<a class="reference internal" href="../library/winreg.html#winreg.EnableReflectionKey" title="winreg.EnableReflectionKey"><code class="xref py py-func docutils literal notranslate"><span class="pre">EnableReflectionKey()</span></code></a> 和 <a class="reference internal" href="../library/winreg.html#winreg.QueryReflectionKey" title="winreg.QueryReflectionKey"><code class="xref py py-func docutils literal notranslate"><span class="pre">QueryReflectionKey()</span></code></a> 函数，这些函数用于启用和禁用在 64 位系统上运行的 32 位进程的注册表反射。(<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1753245">bpo-1753245</a>)</p>
</li>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">msilib</span></code> 模块的 <code class="xref py py-class docutils literal notranslate"><span class="pre">Record</span></code> 对象增加了 <code class="xref py py-meth docutils literal notranslate"><span class="pre">GetInteger()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">GetString()</span></code> 方法，分别返回字段值作为整数或字符串。（由 Floris Bruynooghe 贡献；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=2125">bpo-2125</a>。）</p></li>
</ul>
</section>
<section id="port-specific-changes-mac-os-x">
<h3 class="translated">特定于 Mac OS X 的更改：<a class="headerlink" href="#port-specific-changes-mac-os-x" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p class="translated">现在，在编译Python的框架版本时，可以为 <strong class="program">configure</strong> 脚本添加 <code class="xref std std-option docutils literal notranslate"><span class="pre">--with-framework-name=</span></code> 选项来指定要使用的框架名称。</p></li>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">macfs</span></code> 模块已被移除。这也导致 <code class="xref py py-func docutils literal notranslate"><span class="pre">macostools.touched()</span></code> 函数被移除，因为它依赖于 <code class="xref py py-mod docutils literal notranslate"><span class="pre">macfs</span></code> 模块。(<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1490190">bpo-1490190</a>)</p></li>
<li><p class="translated">许多其他 Mac OS 模块已被弃用，并将在 Python 3.0 中移除：<code class="xref py py-mod docutils literal notranslate"><span class="pre">_builtinSuites</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">aepack</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">aetools</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">aetypes</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">applesingle</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">appletrawmain</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">appletrunner</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">argvemulator</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">Audio_mac</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">autoGIL</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">Carbon</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">cfmfile</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">CodeWarrior</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">ColorPicker</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">EasyDialogs</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">Explorer</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">Finder</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">FrameWork</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">findertools</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">ic</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">icglue</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">icopen</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">macerrors</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">MacOS</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">macfs</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">macostools</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">macresource</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">MiniAEFrame</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">Nav</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">Netscape</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">OSATerminology</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">pimp</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">PixMapWrapper</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">StdSuites</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">SystemEvents</span></code>、<code class="xref py py-mod docutils literal notranslate"><span class="pre">Terminal</span></code> 和 <code class="xref py py-mod docutils literal notranslate"><span class="pre">terminalcommand</span></code>。</p></li>
</ul>
</section>
<section id="port-specific-changes-irix">
<h3 class="translated">特定于 IRIX 的更改：<a class="headerlink" href="#port-specific-changes-irix" title="Link to this heading">¶</a></h3>
<p class="translated">一些旧的IRIX特定模块已被弃用，并将在Python 3.0中移除：<code class="xref py py-mod docutils literal notranslate"><span class="pre">al</span></code> 和 <code class="xref py py-mod docutils literal notranslate"><span class="pre">AL</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">cd</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">cddb</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">cdplayer</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">CL</span></code> 和 <code class="xref py py-mod docutils literal notranslate"><span class="pre">cl</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">DEVICE</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">ERRNO</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">FILE</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">FL</span></code> 和 <code class="xref py py-mod docutils literal notranslate"><span class="pre">fl</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">flp</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">fm</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">GET</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">GLWS</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">GL</span></code> 和 <code class="xref py py-mod docutils literal notranslate"><span class="pre">gl</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">IN</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">IOCTL</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">jpeg</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">panelparser</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">readcd</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">SV</span></code> 和 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sv</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">torgb</span></code>，<code class="xref py py-mod docutils literal notranslate"><span class="pre">videoreader</span></code>，以及 <code class="xref py py-mod docutils literal notranslate"><span class="pre">WAIT</span></code>。</p>
</section>
</section>
<section id="porting-to-python-2-6">
<h2 class="translated">移植到Python 2.6<a class="headerlink" href="#porting-to-python-2-6" title="Link to this heading">¶</a></h2>
<p class="translated">本节列出了先前描述的改变以及可能需要修改你的代码的其他问题修正:</p>
<ul>
<li><p class="translated">预期为不可哈希的类应当在其定义中设置 <code class="docutils literal notranslate"><span class="pre">__hash__</span> <span class="pre">=</span> <span class="pre">None</span></code> 来指明这一点。</p></li>
<li><p class="translated">字符串异常已被移除。尝试使用它们将引发 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/collections.html#collections.deque" title="collections.deque"><code class="xref py py-class docutils literal notranslate"><span class="pre">collections.deque</span></code></a> 的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> 方法现在会在从可迭代对象添加元素之前清空deque中的任何现有内容。这一改变使得其行为与 <code class="docutils literal notranslate"><span class="pre">list.__init__()</span></code> 相匹配。</p></li>
<li><p class="translated">以前 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">object.__init__()</span></code></a> 接受任意参数和关键字参数，并忽略它们。在Python 2.6中，这不再被允许，并将导致 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。这将影响最终调用 <a class="reference internal" href="../library/functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 上相应方法（可能通过使用 <a class="reference internal" href="../library/functions.html#super" title="super"><code class="xref py py-func docutils literal notranslate"><span class="pre">super()</span></code></a>）的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> 方法。参见 <a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1683368">bpo-1683368</a> 进行讨论。</p></li>
<li><p class="translated"><code class="xref py py-class docutils literal notranslate"><span class="pre">Decimal</span></code> 构造函数现在在接受字符串时允许前导和尾随空格。以前它会引发 <code class="xref py py-exc docutils literal notranslate"><span class="pre">InvalidOperation</span></code> 异常。另一方面，<code class="xref py py-class docutils literal notranslate"><span class="pre">Context</span></code> 对象的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">create_decimal()</span></code> 方法现在明确禁止额外空格，并引发 <code class="xref py py-exc docutils literal notranslate"><span class="pre">ConversionSyntax</span></code> 异常。</p></li>
<li><p class="translated">由于实现上的意外，如果你将文件路径传递给内置的 <a class="reference internal" href="../library/functions.html#import__" title="__import__"><code class="xref py py-func docutils literal notranslate"><span class="pre">__import__()</span></code></a> 函数，它实际上会导入指定的文件。这从未打算工作，然而，现在的实现明确检查这种情况并引发 <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a>。</p></li>
<li><p class="translated">C API：<a class="reference internal" href="../c-api/import.html#c.PyImport_Import" title="PyImport_Import"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_Import()</span></code></a> 和 <a class="reference internal" href="../c-api/import.html#c.PyImport_ImportModule" title="PyImport_ImportModule"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyImport_ImportModule()</span></code></a> 函数现在默认为绝对导入，而不是相对导入。这将影响导入其他模块的C扩展。</p></li>
<li><p class="translated">C API：不应可哈希的扩展数据类型应将其 <code class="docutils literal notranslate"><span class="pre">tp_hash</span></code> 插槽定义为 <a class="reference internal" href="../c-api/object.html#c.PyObject_HashNotImplemented" title="PyObject_HashNotImplemented"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_HashNotImplemented()</span></code></a>。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> 模块的异常 <a class="reference internal" href="../library/socket.html#socket.error" title="socket.error"><code class="xref py py-exc docutils literal notranslate"><span class="pre">socket.error</span></code></a> 现在继承自 <a class="reference internal" href="../library/exceptions.html#IOError" title="IOError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IOError</span></code></a>。以前它不是 <code class="xref py py-exc docutils literal notranslate"><span class="pre">StandardError</span></code> 的子类，但现在通过 <a class="reference internal" href="../library/exceptions.html#IOError" title="IOError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IOError</span></code></a> 继承了。（由 Gregory P. Smith 实现；<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1706815">bpo-1706815</a>。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/xmlrpc.client.html#module-xmlrpc.client" title="xmlrpc.client: XML-RPC client access."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xmlrpclib</span></code></a> 模块不再自动将 <a class="reference internal" href="../library/datetime.html#datetime.date" title="datetime.date"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.date</span></code></a> 和 <a class="reference internal" href="../library/datetime.html#datetime.time" title="datetime.time"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime.time</span></code></a> 转换为 <a class="reference internal" href="../library/xmlrpc.client.html#xmlrpc.client.DateTime" title="xmlrpc.client.DateTime"><code class="xref py py-class docutils literal notranslate"><span class="pre">xmlrpclib.DateTime</span></code></a> 类型；转换语义并不一定适用于所有应用。使用 <code class="xref py py-mod docutils literal notranslate"><span class="pre">xmlrpclib</span></code> 的代码应转换 <code class="xref py py-class docutils literal notranslate"><span class="pre">date</span></code> 和 <a class="reference internal" href="../library/datetime.html#datetime.time" title="datetime.time"><code class="xref py py-class docutils literal notranslate"><span class="pre">time</span></code></a> 实例。（<a class="reference external" href="https://bugs.python.org/issue?&#64;action=redirect&amp;bpo=1330538">bpo-1330538</a>）</p></li>
<li><p class="translated">(3.0 警告模式) <a class="reference internal" href="../library/exceptions.html#Exception" title="Exception"><code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></a> 类在被切片或索引访问时会产生警告。<a class="reference internal" href="../library/exceptions.html#Exception" title="Exception"><code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></a> 像元组一样的行为正在被逐步淘汰。</p></li>
<li><p class="translated">（3.0 警告模式）两个字典或两个未实现比较方法的对象之间的不等比较会被报告为警告。<code class="docutils literal notranslate"><span class="pre">dict1</span> <span class="pre">==</span> <span class="pre">dict2</span></code> 仍然有效，但 <code class="docutils literal notranslate"><span class="pre">dict1</span> <span class="pre">&lt;</span> <span class="pre">dict2</span></code> 正在被逐步淘汰。</p>
<p class="translated">单元格之间的比较，这是 Python 作用域规则的实现细节，也会导致警告，因为在 3.0 中完全禁止此类比较。</p>
</li>
</ul>
<p class="translated">对于嵌入Python的应用程序：</p>
<ul class="simple">
<li><p class="translated">Python 2.6.6 中增加了 <code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_SetArgvEx()</span></code> 函数，这让应用可以弥补一个在使用现有 <code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_SetArgv()</span></code> 函数时会存在的安全漏洞。 请检查你是否有调用 <code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_SetArgv()</span></code> 并仔细考虑应用是否应当改用 <code class="xref c c-func docutils literal notranslate"><span class="pre">PySys_SetArgvEx()</span></code> 并将 <em>updatepath</em> 设为假值。</p></li>
</ul>
</section>
<section id="acknowledgements">
<span id="acks"></span><h2 class="translated">致谢<a class="headerlink" href="#acknowledgements" title="Link to this heading">¶</a></h2>
<p class="translated">作者感谢以下人员对本文各种草稿给予的建议，更正和协助： Georg Brandl、Steve Brown、Nick Coghlan、Ralph Corderoy、Jim Jewett、Kent Johnson、Chris Lambacher、 Martin Michlmayr、Antoine Pitrou、Brian Warner。</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#">Python 2.6 有什么新变化</a><ul>
<li><a class="reference internal" href="#python-3-0">Python 3.0</a></li>
<li><a class="reference internal" href="#changes-to-the-development-process">开发过程的变化</a><ul>
<li><a class="reference internal" href="#new-issue-tracker-roundup">新问题追踪：简述</a></li>
<li><a class="reference internal" href="#new-documentation-format-restructuredtext-using-sphinx">新的文档格式：使用 Sphinx 的 reStructuredText</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pep-343-the-with-statement">PEP 343: &quot;with&quot; 语句</a><ul>
<li><a class="reference internal" href="#writing-context-managers">编写上下文管理器</a></li>
<li><a class="reference internal" href="#the-contextlib-module">contextlib 模块</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pep-366-explicit-relative-imports-from-a-main-module">PEP 366: 从主模块显式相对导入</a></li>
<li><a class="reference internal" href="#pep-370-per-user-site-packages-directory">PEP 370: 分用户的 site-packages 目录</a></li>
<li><a class="reference internal" href="#pep-371-the-multiprocessing-package">PEP 371: <code class="docutils literal notranslate"><span class="pre">multiprocessing</span></code> (多进程)包</a></li>
<li><a class="reference internal" href="#pep-3101-advanced-string-formatting">PEP 3101: 高级字符串格式</a></li>
<li><a class="reference internal" href="#pep-3105-print-as-a-function">PEP 3105: <code class="docutils literal notranslate"><span class="pre">print</span></code> 改为函数</a></li>
<li><a class="reference internal" href="#pep-3110-exception-handling-changes">PEP 3110: 异常处理的变更</a></li>
<li><a class="reference internal" href="#pep-3112-byte-literals">PEP 3112: 字节字面值</a></li>
<li><a class="reference internal" href="#pep-3116-new-i-o-library">PEP 3116: 新 I/O 库</a></li>
<li><a class="reference internal" href="#pep-3118-revised-buffer-protocol">PEP 3118: 修改缓冲区协议</a></li>
<li><a class="reference internal" href="#pep-3119-abstract-base-classes">PEP 3119: 抽象基类</a></li>
<li><a class="reference internal" href="#pep-3127-integer-literal-support-and-syntax">PEP 3127: 整型文字支持和语法</a></li>
<li><a class="reference internal" href="#pep-3129-class-decorators">PEP 3129: 类装饰器</a></li>
<li><a class="reference internal" href="#pep-3141-a-type-hierarchy-for-numbers">PEP 3141: 数字的类型层级结构</a><ul>
<li><a class="reference internal" href="#the-fractions-module"><code class="xref py py-mod docutils literal notranslate"><span class="pre">fractions</span></code> 模块</a></li>
</ul>
</li>
<li><a class="reference internal" href="#other-language-changes">其他语言特性修改</a><ul>
<li><a class="reference internal" href="#optimizations">性能优化</a></li>
<li><a class="reference internal" href="#interpreter-changes">解释器改动</a></li>
</ul>
</li>
<li><a class="reference internal" href="#new-and-improved-modules">新增和改进的模块</a><ul>
<li><a class="reference internal" href="#the-ast-module"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code> 模块</a></li>
<li><a class="reference internal" href="#the-future-builtins-module"><code class="xref py py-mod docutils literal notranslate"><span class="pre">future_builtins</span></code> 模块</a></li>
<li><a class="reference internal" href="#the-json-module-javascript-object-notation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">json</span></code> 模块: JavaScript Object Notation</a></li>
<li><a class="reference internal" href="#the-plistlib-module-a-property-list-parser"><code class="xref py py-mod docutils literal notranslate"><span class="pre">plistlib</span></code> 模块：属性列表解析器</a></li>
<li><a class="reference internal" href="#ctypes-enhancements">ctypes 增强</a></li>
<li><a class="reference internal" href="#improved-ssl-support">改进的 SSL 支持</a></li>
</ul>
</li>
<li><a class="reference internal" href="#deprecations-and-removals">弃用和移除</a></li>
<li><a class="reference internal" href="#build-and-c-api-changes">构建和 C API 的变更</a><ul>
<li><a class="reference internal" href="#port-specific-changes-windows">特定于 Windows 的更改：</a></li>
<li><a class="reference internal" href="#port-specific-changes-mac-os-x">特定于 Mac OS X 的更改：</a></li>
<li><a class="reference internal" href="#port-specific-changes-irix">特定于 IRIX 的更改：</a></li>
</ul>
</li>
<li><a class="reference internal" href="#porting-to-python-2-6">移植到Python 2.6</a></li>
<li><a class="reference internal" href="#acknowledgements">致谢</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一主题</h4>
    <p class="topless"><a href="2.7.html"
                          title="上一章">Python 2.7 有什么新变化</a></p>
  </div>
  <div>
    <h4>下一主题</h4>
    <p class="topless"><a href="2.5.html"
                          title="下一章">Python 2.5 有什么新变化</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">报告代码错误</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/whatsnew/2.6.rst?plain=1"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="折叠边栏">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="2.5.html" title="Python 2.5 有什么新变化"
             >下一页</a> |</li>
        <li class="right" >
          <a href="2.7.html" title="Python 2.7 有什么新变化"
             >上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.14.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python的新变化</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Python 2.6 有什么新变化</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q" id="search-box">
          <input type="submit" value="转到">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    主题
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>自动</option>
        <option value="light">明亮</option>
        <option value="dark">黑暗</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版权</a> 2001 Python Software Foundation.
    <br>
    本页面采用 Python 软件基金会许可证第 2 版授权。
    <br>
    文档中的示例、代码片段及其他代码内容额外采用零条款 BSD 许可证授权。
    <br>
    
      更多信息请参阅《<a href="/license.html"> 历史与许可 </a>》。<br>
    
    
    <br>

    Python 软件基金会是一家非营利性公司。
<a href="https://www.python.org/psf/donations/">请进行捐赠。</a>
<br>
    <br>
      最后更新于11月 25, 2025 (07:24 UTC) 。
    
      <a href="/bugs.html">发现了错误</a>？
    
    <br>

    使用<a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3 创建。
    </div>

  </body>
</html>
<!DOCTYPE html>

<html lang="zh-CN" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="Python 2.3 有什么新变化" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/whatsnew/2.3.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="作者, A.M. Kuchling,. 本文介绍了 Python 2.3 的新特性。 Python 2.3 发布于 2003 年 7 月 29 日。 Python 2.3 的主要主题是完善在 2.2 中添加的一些功能、为核心语言添加各种小但实用的增强功能，以及扩展标准库。 上一版本引入的新对象模型已经受益于 18 个月的错误修复和优化努力，这些优化提升了新式类的性能。 新增了几个内置函数，例..." />
<meta property="og:image:width" content="1146" />
<meta property="og:image:height" content="600" />
<meta property="og:image" content="https://docs.python.org/3.14/zh-cn/_images/social_previews/summary_whatsnew_2.3_87506c6b.png" />
<meta property="og:image:alt" content="作者, A.M. Kuchling,. 本文介绍了 Python 2.3 的新特性。 Python 2.3 发布于 2003 年 7 月 29 日。 Python 2.3 的主要主题是完善在 2.2 中添加的一些功能、为核心语言添加各种小但实用的增强功能，以及扩展标准库。 上一版本引入的新对象模型已经受益于 18 个月的错误修复和优化努力，这些优化提升了新式类的性能。 新增了几个内置函数，例..." />
<meta name="description" content="作者, A.M. Kuchling,. 本文介绍了 Python 2.3 的新特性。 Python 2.3 发布于 2003 年 7 月 29 日。 Python 2.3 的主要主题是完善在 2.2 中添加的一些功能、为核心语言添加各种小但实用的增强功能，以及扩展标准库。 上一版本引入的新对象模型已经受益于 18 个月的错误修复和优化努力，这些优化提升了新式类的性能。 新增了几个内置函数，例..." />
<meta name="twitter:card" content="summary_large_image" />
<meta name="theme-color" content="#3776ab">

    <title>Python 2.3 有什么新变化 &#8212; Python 3.14.0 文档</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=234b1a7c" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=8cd84f99" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=5349f25f" />
    
    <script src="../_static/documentation_options.js?v=a595ec0e"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=beaddf03"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.14.0 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于此文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权" href="../copyright.html" />
    <link rel="next" title="Python 2.2 有什么新变化" href="2.2.html" />
    <link rel="prev" title="Python 2.4 有什么新变化" href="2.4.html" />
    
      
      <script defer file-types="bz2,epub,zip" data-domain="docs.python.org" src="https://analytics.python.org/js/script.file-downloads.outbound-links.js"></script>
      
      <link rel="canonical" href="https://docs.python.org/3/whatsnew/2.3.html">
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg">
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="菜单">
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo">
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q">
                <input type="submit" value="转到">
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    主题
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>自动</option>
        <option value="light">明亮</option>
        <option value="dark">黑暗</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#">Python 2.3 有什么新变化</a><ul>
<li><a class="reference internal" href="#pep-218-a-standard-set-datatype">PEP 218: 标准集合数据类型</a></li>
<li><a class="reference internal" href="#pep-255-simple-generators">PEP 255: 简单的生成器</a></li>
<li><a class="reference internal" href="#pep-263-source-code-encodings">PEP 263: 源代码的字符编码格式</a></li>
<li><a class="reference internal" href="#pep-273-importing-modules-from-zip-archives">PEP 273: 从ZIP压缩包导入模块</a></li>
<li><a class="reference internal" href="#pep-277-unicode-file-name-support-for-windows-nt">PEP 277: 针对 Windows NT 的 Unicode 文件名支持</a></li>
<li><a class="reference internal" href="#pep-278-universal-newline-support">PEP 278: 通用换行支持</a></li>
<li><a class="reference internal" href="#pep-279-enumerate">PEP 279: enumerate()</a></li>
<li><a class="reference internal" href="#pep-282-the-logging-package">PEP 282: logging 包</a></li>
<li><a class="reference internal" href="#pep-285-a-boolean-type">PEP 285: 布尔类型</a></li>
<li><a class="reference internal" href="#pep-293-codec-error-handling-callbacks">PEP 293: 编解码器错误处理回调</a></li>
<li><a class="reference internal" href="#pep-301-package-index-and-metadata-for-distutils">PEP 301: Distutils的软件包索引和元数据</a></li>
<li><a class="reference internal" href="#pep-302-new-import-hooks">PEP 302: 新导入钩子</a></li>
<li><a class="reference internal" href="#pep-305-comma-separated-files">PEP 305: 逗号分隔文件</a></li>
<li><a class="reference internal" href="#pep-307-pickle-enhancements">PEP 307：对 pickle 的改进</a></li>
<li><a class="reference internal" href="#extended-slices">扩展切片</a></li>
<li><a class="reference internal" href="#other-language-changes">其他语言特性修改</a><ul>
<li><a class="reference internal" href="#string-changes">字符串的改变</a></li>
<li><a class="reference internal" href="#optimizations">性能优化</a></li>
</ul>
</li>
<li><a class="reference internal" href="#new-improved-and-deprecated-modules">新增，改进和弃用的模块</a><ul>
<li><a class="reference internal" href="#date-time-type">Date/Time 类型</a></li>
<li><a class="reference internal" href="#the-optparse-module">optparse 模块</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pymalloc-a-specialized-object-allocator">Pymalloc：一种专用对象分配器</a></li>
<li><a class="reference internal" href="#build-and-c-api-changes">构建和 C API 的改变</a><ul>
<li><a class="reference internal" href="#port-specific-changes">移植专属的改变</a></li>
</ul>
</li>
<li><a class="reference internal" href="#other-changes-and-fixes">其他的改变和修正</a></li>
<li><a class="reference internal" href="#porting-to-python-2-3">移植到 Python 2.3</a></li>
<li><a class="reference internal" href="#acknowledgements">致谢</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一主题</h4>
    <p class="topless"><a href="2.4.html"
                          title="上一章">Python 2.4 有什么新变化</a></p>
  </div>
  <div>
    <h4>下一主题</h4>
    <p class="topless"><a href="2.2.html"
                          title="下一章">Python 2.2 有什么新变化</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">报告代码错误</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/whatsnew/2.3.rst?plain=1"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="2.2.html" title="Python 2.2 有什么新变化"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="2.4.html" title="Python 2.4 有什么新变化"
             accesskey="P">上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.14.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Python的新变化</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Python 2.3 有什么新变化</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q" id="search-box">
          <input type="submit" value="转到">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    主题
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>自动</option>
        <option value="light">明亮</option>
        <option value="dark">黑暗</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="what-s-new-in-python-2-3">
<h1 class="translated">Python 2.3 有什么新变化<a class="headerlink" href="#what-s-new-in-python-2-3" title="Link to this heading">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd translated">作者<span class="colon">:</span></dt>
<dd class="field-odd translated"><p class="translated">A.M. Kuchling</p>
</dd>
</dl>
<p class="translated">本文介绍了 Python 2.3 的新特性。 Python 2.3 发布于 2003 年 7 月 29 日。</p>
<p class="translated">Python 2.3 的主要主题是完善在 2.2 中添加的一些功能、为核心语言添加各种小但实用的增强功能，以及扩展标准库。 上一版本引入的新对象模型已经受益于 18 个月的错误修复和优化努力，这些优化提升了新式类的性能。 新增了几个内置函数，例如 <a class="reference internal" href="../library/functions.html#sum" title="sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">sum()</span></code></a> 和 <a class="reference internal" href="../library/functions.html#enumerate" title="enumerate"><code class="xref py py-func docutils literal notranslate"><span class="pre">enumerate()</span></code></a>。 <a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> 操作符现在可以用于子字符串搜索 (例如，<code class="docutils literal notranslate"><span class="pre">&quot;ab&quot;</span> <span class="pre">in</span> <span class="pre">&quot;abc&quot;</span></code> 将返回 <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>)。</p>
<p class="translated">许多新库功能包括布尔值、集合、堆、日期/时间数据类型，从ZIP格式的归档文件中导入模块的能力，期待已久的 Python 目录的元数据支持，更新版本的 IDLE，以及用于日志记录、文本包装、解析 CSV 文件、处理命令行选项、使用 BerkeleyDB 数据库的模块…… 新模块和增强模块的列表相当长。</p>
<p class="translated">本文并不试图提供对新功能的完整规范，而是提供了一个方便的概览。 有关详细信息，你应该参考 Python 2.3 的文档，例如 Python 库参考和 Python 参考手册。 如果你想了解完整的实现和设计原理，请参阅特定新功能的 PEP。</p>
<section id="pep-218-a-standard-set-datatype">
<h2 class="translated">PEP 218: 标准集合数据类型<a class="headerlink" href="#pep-218-a-standard-set-datatype" title="Link to this heading">¶</a></h2>
<p class="translated">新的 <code class="xref py py-mod docutils literal notranslate"><span class="pre">sets</span></code> 模块包含一个集合数据类型的实现。 <code class="xref py py-class docutils literal notranslate"><span class="pre">Set</span></code> 类用于可变集合，即可以添加和删除成员的集合。 <code class="xref py py-class docutils literal notranslate"><span class="pre">ImmutableSet</span></code> 类用于不可修改的集合，因此 <code class="xref py py-class docutils literal notranslate"><span class="pre">ImmutableSet</span></code> 的实例可以用作字典的键。 集合是基于字典构建的，因此集合中的元素必须是可哈希的。</p>
<p class="translated">这是一个简单的示例：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">sets</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">sets</span><span class="o">.</span><span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span>
<span class="go">Set([1, 2, 3])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="ow">in</span> <span class="n">S</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">0</span> <span class="ow">in</span> <span class="n">S</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span>
<span class="go">Set([1, 2, 5])</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">集合的并集和交集可以通过 <a class="reference internal" href="../library/stdtypes.html#frozenset.union" title="frozenset.union"><code class="xref py py-meth docutils literal notranslate"><span class="pre">union()</span></code></a> 和 <a class="reference internal" href="../library/stdtypes.html#frozenset.intersection" title="frozenset.intersection"><code class="xref py py-meth docutils literal notranslate"><span class="pre">intersection()</span></code></a> 方法计算；另一种表示法是使用按位操作符 <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">|</span></code>。 可变集合还具有这些方法的原地版本，分别为 <code class="xref py py-meth docutils literal notranslate"><span class="pre">union_update()</span></code> 和 <a class="reference internal" href="../library/stdtypes.html#frozenset.intersection_update" title="frozenset.intersection_update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">intersection_update()</span></code></a>。:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span> <span class="o">=</span> <span class="n">sets</span><span class="o">.</span><span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S2</span> <span class="o">=</span> <span class="n">sets</span><span class="o">.</span><span class="n">Set</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span>
<span class="go">Set([1, 2, 3, 4, 5, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span> <span class="o">|</span> <span class="n">S2</span>                  <span class="c1"># 替代写法</span>
<span class="go">Set([1, 2, 3, 4, 5, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span>
<span class="go">Set([])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span> <span class="o">&amp;</span> <span class="n">S2</span>                  <span class="c1"># 替代写法</span>
<span class="go">Set([])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span><span class="o">.</span><span class="n">union_update</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span>
<span class="go">Set([1, 2, 3, 4, 5, 6])</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">还可以计算两个集合的对称差集。 这是并集中不在交集中的所有元素。 换句话说，对称差集包含所有只在一个集合中的元素。 同样，还有一种替代表示法是使用按位操作符 (<code class="docutils literal notranslate"><span class="pre">^</span></code>)，并且有一个原地修改版本，名字比较长，叫 <a class="reference internal" href="../library/stdtypes.html#frozenset.symmetric_difference_update" title="frozenset.symmetric_difference_update"><code class="xref py py-meth docutils literal notranslate"><span class="pre">symmetric_difference_update()</span></code></a>。:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span> <span class="o">=</span> <span class="n">sets</span><span class="o">.</span><span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S2</span> <span class="o">=</span> <span class="n">sets</span><span class="o">.</span><span class="n">Set</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span><span class="o">.</span><span class="n">symmetric_difference</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span>
<span class="go">Set([1, 2, 5, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span> <span class="o">^</span> <span class="n">S2</span>
<span class="go">Set([1, 2, 5, 6])</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">另外还有 <code class="xref py py-meth docutils literal notranslate"><span class="pre">issubset()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">issuperset()</span></code> 方法用来检查一个集合是否为另一个集合的子集或超集:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span> <span class="o">=</span> <span class="n">sets</span><span class="o">.</span><span class="n">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S2</span> <span class="o">=</span> <span class="n">sets</span><span class="o">.</span><span class="n">Set</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S2</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">S1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S1</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-56"></span><a class="pep reference external" href="https://peps.python.org/pep-0218/"><strong>PEP 218</strong></a> - 添加内置集合对象类型</dt><dd><p class="translated">PEP 由 Greg V. Wilson 撰写 ; 由 Greg V. Wilson, Alex Martelli 和 GvR 实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-255-simple-generators">
<span id="section-generators"></span><h2 class="translated">PEP 255: 简单的生成器<a class="headerlink" href="#pep-255-simple-generators" title="Link to this heading">¶</a></h2>
<p class="translated">在 Python 2.2 中，生成器作为一个可选特性被添加，需要通过 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">generators</span></code> 指令来启用。 在 2.3 版本中，生成器不再需要特别启用，现在总是存在；这意味着 <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 现在始终是一个关键字。 本节的其余部分是从《Python 2.2的新特性》文档中复制的生成器描述；如果你在 Python 2.2 发布时已经阅读过，可以跳过本节的其余部分。</p>
<p class="translated">你一定熟悉在 Python 或 C 语言中函数调用的工作方式。 当你调用一个函数时，它会获得一个私有命名空间，在这个命名空间中创建其局部变量。 当函数执行到 <a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 语句时，这些局部变量会被销毁，并将结果值返回给调用者。 稍后对同一个函数的调用将获得一套全新的局部变量。 但是，如果局部变量在函数退出时不被丢弃呢？如果你可以在函数停止的地方稍后恢复执行呢？这就是生成器所提供的功能；它们可以被视为可恢复的函数。</p>
<p class="translated">这里是一个生成器函数的最简示例:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">generate_ints</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">i</span>
</pre></div>
</div>
<p class="translated">一个新的关键字 <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 被引入用于生成器。 任何包含 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 语句的函数都是生成器函数；这由 Python 的字节码编译器检测到，并因此对函数进行特殊编译。</p>
<p class="translated">当你调用生成器函数时，它不会返回一个单独的值；相反，它会返回一个支持迭代器协议的生成器对象。在执行 <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 语句时，生成器会输出 <code class="docutils literal notranslate"><span class="pre">i</span></code> 的值 ，类似于 <a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 语句。 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 与 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code> 语句之间的最大区别在于，在到达 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 时，生成器的执行状态会暂停，并保留本地变量。 在下一次调用生成器 的 <code class="docutils literal notranslate"><span class="pre">.next()</span></code> 方法时，函数将在 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 语句之后立即恢复执行。 （由于复杂的原因，<code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 语句不允许在 <a class="reference internal" href="../reference/compound_stmts.html#try"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code></a>...<code class="xref std std-keyword docutils literal notranslate"><span class="pre">finally</span></code> 语句的 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">try</span></code> 代码块内出现；有关 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code> 和异常之间交互的完整解释，请阅读 <span class="target" id="index-57"></span><a class="pep reference external" href="https://peps.python.org/pep-0255/"><strong>PEP 255</strong></a>。）</p>
<p class="translated">下面是 <code class="xref py py-func docutils literal notranslate"><span class="pre">generate_ints()</span></code> 生成器的用法示例:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span> <span class="o">=</span> <span class="n">generate_ints</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span>
<span class="go">&lt;generator object at 0x8117f90&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gen</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;stdin&quot;</span>, line <span class="m">1</span>, in <span class="n">?</span>
  File <span class="nb">&quot;stdin&quot;</span>, line <span class="m">2</span>, in <span class="n">generate_ints</span>
<span class="gr">StopIteration</span>
</pre></div>
</div>
<p class="translated">你可以等价地写成 <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">generate_ints(5)</span></code> 或 <code class="docutils literal notranslate"><span class="pre">a,b,c</span> <span class="pre">=</span> <span class="pre">generate_ints(3)</span></code>。</p>
<p class="translated">在生成器函数内部， <a class="reference internal" href="../reference/simple_stmts.html#return"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> 语句只能不带值使用，并表示值的生成过程结束；之后，生成器不能再返回任何值。在生成器函数内部，带值的 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code>，例如 <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">5</span></code>，是语法错误。生成器结果的结束也可以通过手动引发 <a class="reference internal" href="../library/exceptions.html#StopIteration" title="StopIteration"><code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code></a> 异常来指示，或者只是让执行流自然地从函数底部流出。</p>
<p class="translated">你可以通过编写自己的类并将生成器的所有局部变量存储为实例变量，手动实现生成器的效果。例如，返回一个整数列表可以通过将 <code class="docutils literal notranslate"><span class="pre">self.count</span></code> 设置为0，并让 <a class="reference internal" href="../library/functions.html#next" title="next"><code class="xref py py-meth docutils literal notranslate"><span class="pre">next()</span></code></a> 方法递增 <code class="docutils literal notranslate"><span class="pre">self.count</span></code> 并返回它。然而，对于一个中等复杂的生成器，编写一个相应的类将会更加混乱。<code class="file docutils literal notranslate"><span class="pre">Lib/test/test_generators.py</span></code> 包含了一些更有趣的例子。其中最简单的一个使用生成器递归实现了树的中序遍历：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 一个递归地按顺序生成 Tree 叶子节点的生成器。</span>
<span class="k">def</span><span class="w"> </span><span class="nf">inorder</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">t</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inorder</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">left</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">x</span>
        <span class="k">yield</span> <span class="n">t</span><span class="o">.</span><span class="n">label</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inorder</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">right</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">x</span>
</pre></div>
</div>
<p class="translated">在 <code class="file docutils literal notranslate"><span class="pre">Lib/test/test_generators.py</span></code> 中还有另外两个例子，它们分别解决了N皇后问题（在$NxN$的棋盘上放置$N$个皇后，使得没有任何皇后威胁到其他皇后）和骑士巡游问题（在$NxN$的棋盘上，骑士访问每一个方格且不重复访问任何方格的路径）。</p>
<p class="translated">生成器的概念源自其他编程语言，尤其是 Icon（<a class="reference external" href="https://www2.cs.arizona.edu/icon/">https://www2.cs.arizona.edu/icon/</a> ），在 Icon 语言中，生成器的概念是核心。在 Icon 中，每个表达式和函数调用生成器的概念源自其他编程语言，尤其是 Icon。 在 Icon 中，每个表达式和函数调用都可以表现得像一个生成器。 以下是来自“Icon 编程语言概述”中的一个示例，展示了生成器的用法 <a class="reference external" href="https://www2.cs.arizona.edu/icon/docs/ipd266.htm">https://www2.cs.arizona.edu/icon/docs/ipd266.htm</a> ：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">sentence</span> <span class="o">:=</span> <span class="s2">&quot;Store it in the neighboring harbor&quot;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">:=</span> <span class="n">find</span><span class="p">(</span><span class="s2">&quot;or&quot;</span><span class="p">,</span> <span class="n">sentence</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="n">then</span> <span class="n">write</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">在Icon中，<code class="xref py py-func docutils literal notranslate"><span class="pre">find()</span></code> 函数返回子字符串&quot;or&quot;所在的索引：3、23、33。在 <a class="reference internal" href="../reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 语句中，<code class="docutils literal notranslate"><span class="pre">i</span></code> 首先被赋值为 3，但 3 小于 5，因此比较失败，Icon 会使用第二个值 23 进行重试。 23 大于 5，因此比较成功，代码将值 23 打印到屏幕上。</p>
<p class="translated">Python并不像Icon那样将生成器作为核心概念来采用。生成器被视为Python核心语言的一部分，但学习或使用它们并不是强制的；如果它们不能解决你遇到的问题，可以完全忽略它们。与Icon相比，Python接口的一个新颖特性是生成器的状态表示为一个具体的对象（迭代器），可以传递给其他函数或存储在数据结构中。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-58"></span><a class="pep reference external" href="https://peps.python.org/pep-0255/"><strong>PEP 255</strong></a> - 简单生成器</dt><dd><p class="translated">由 Neil Schemenauer, Tim Peters, Magnus Lie Hetland 撰写。 主要由 Neil Schemenauer 和 Tim Peters 实现，并包含来自 Python Labs 团队的修正。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-263-source-code-encodings">
<span id="section-encodings"></span><h2 class="translated">PEP 263: 源代码的字符编码格式<a class="headerlink" href="#pep-263-source-code-encodings" title="Link to this heading">¶</a></h2>
<p class="translated">现在可以声明Python源文件使用不同的字符集编码。通过在源文件的第一行或第二行包含特定格式的注释来声明编码。例如，一个UTF-8文件可以这样声明：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: UTF-8 -*-</span>
</pre></div>
</div>
<p class="translated">如果没有这样的编码声明，默认使用7位ASCII编码。执行或导入包含8位字符的字符串字面量且没有编码声明的模块时，在Python 2.3中会触发 <a class="reference internal" href="../library/exceptions.html#DeprecationWarning" title="DeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a> 警告；而在Python 2.4中，这将成为语法错误。</p>
<p class="translated">编码声明只影响Unicode字符串字面量，这些字面量将使用指定的编码转换为Unicode。请注意，Python的标识符仍然限制为ASCII字符，因此变量名不能使用超出常规字母数字字符范围的字符。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-59"></span><a class="pep reference external" href="https://peps.python.org/pep-0263/"><strong>PEP 263</strong></a> - 定义 Python 源代码的编码格式</dt><dd><p class="translated">由 Marc-André Lemburg 和 Martin von Löwis 撰写 ; 由 Suzuki Hisao 和 Martin von Löwis 实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-273-importing-modules-from-zip-archives">
<h2 class="translated">PEP 273: 从ZIP压缩包导入模块<a class="headerlink" href="#pep-273-importing-modules-from-zip-archives" title="Link to this heading">¶</a></h2>
<p class="translated">通过新的 <a class="reference internal" href="../library/zipimport.html#module-zipimport" title="zipimport: Support for importing Python modules from ZIP archives."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zipimport</span></code></a> 模块增加了从 ZIP 格式归档文件导入模块的支持。 你不需要显式地导入模块；它将在 ZIP 归档文件名被添加到 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> 的情况下自动导入。 例如：</p>
<div class="translated highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">amk@nyman:~/src/python$ </span>unzip<span class="w"> </span>-l<span class="w"> </span>/tmp/example.zip
<span class="go">Archive:  /tmp/example.zip</span>
<span class="go">  Length     Date   Time    Name</span>
<span class="go"> --------    ----   ----    ----</span>
<span class="go">     8467  11-26-02 22:30   jwzthreading.py</span>
<span class="go"> --------                   -------</span>
<span class="go">     8467                   1 file</span>
<span class="gp">amk@nyman:~/src/python$ </span>./python
<span class="go">Python 2.3 (#1, Aug 1 2003, 19:54:32)</span>
<span class="go">&gt;&gt;&gt; import sys</span>
<span class="go">&gt;&gt;&gt; sys.path.insert(0, &#39;/tmp/example.zip&#39;)  # 将 .zip 文件添加到 path 的开头</span>
<span class="go">&gt;&gt;&gt; import jwzthreading</span>
<span class="go">&gt;&gt;&gt; jwzthreading.__file__</span>
<span class="go">&#39;/tmp/example.zip/jwzthreading.py&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">sys.path</span></code> 中的一个条目现在可以是 ZIP 归档文件的文件名。ZIP 归档可以包含任何类型的文件，但只有名为 <code class="file docutils literal notranslate"><span class="pre">*.py</span></code>、<code class="file docutils literal notranslate"><span class="pre">*.pyc</span></code> 或 <code class="file docutils literal notranslate"><span class="pre">*.pyo</span></code> 的文件可以被导入。如果归档仅包含 <code class="file docutils literal notranslate"><span class="pre">*.py</span></code> 文件，Python 不会尝试通过添加相应的 <code class="file docutils literal notranslate"><span class="pre">*.pyc</span></code> 文件来修改归档，这意味着如果 ZIP 归档不包含 <code class="file docutils literal notranslate"><span class="pre">*.pyc</span></code> 文件，导入可能会相当慢。</p>
<p class="translated">也可以指定归档内的路径，以仅从子目录导入；例如，路径 <code class="file docutils literal notranslate"><span class="pre">/tmp/example.zip/lib/</span></code> 将仅从归档中的 <code class="file docutils literal notranslate"><span class="pre">lib/</span></code> 子目录导入。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-60"></span><a class="pep reference external" href="https://peps.python.org/pep-0273/"><strong>PEP 273</strong></a> - 从 ZIP 压缩包导入模块</dt><dd><p class="translated">由James C. Ahlstrom撰写，并提供了一个实现。Python 2.3遵循 <span class="target" id="index-61"></span><a class="pep reference external" href="https://peps.python.org/pep-0273/"><strong>PEP 273</strong></a> 中的规范，但使用了Just van Rossum编写的实现，该实现利用了 <span class="target" id="index-62"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a> 中描述的导入钩子。有关新导入钩子的描述，请参见 <a class="reference internal" href="#section-pep302"><span class="std std-ref">PEP 302: 新导入钩子</span></a> 的相关部分。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-277-unicode-file-name-support-for-windows-nt">
<h2 class="translated">PEP 277: 针对 Windows NT 的 Unicode 文件名支持<a class="headerlink" href="#pep-277-unicode-file-name-support-for-windows-nt" title="Link to this heading">¶</a></h2>
<p class="translated">在Windows NT、2000和XP上，系统将文件名存储为Unicode字符串。传统上，Python将文件名表示为字节字符串，这种方式不够完善，因为它会导致某些文件名无法访问。</p>
<p class="translated">Python 现在允许在所有期望文件名的函数中使用任意 Unicode 字符串（在文件系统的限制范围内），尤其是内置函数 <a class="reference internal" href="../library/functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>。如果将 Unicode 字符串传递给 <a class="reference internal" href="../library/os.html#os.listdir" title="os.listdir"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.listdir()</span></code></a>，Python 现在返回一个 Unicode 字符串列表。一个新的函数 <code class="xref py py-func docutils literal notranslate"><span class="pre">os.getcwdu()</span></code> 返回当前目录作为 Unicode 字符串。</p>
<p class="translated">字节串仍可被用作文件名，并且在 Windows 上 Python 将透明地使用 <code class="docutils literal notranslate"><span class="pre">mbcs</span></code> 编码格式将其转换为 Unicode。</p>
<p class="translated">其他系统也允许使用 Unicode 字符串作为文件名，但在将它们传递给系统之前将它们转换为字节字符串，这可能会引发 <a class="reference internal" href="../library/exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a>。应用程序可以通过检查 <a class="reference internal" href="../library/os.path.html#os.path.supports_unicode_filenames" title="os.path.supports_unicode_filenames"><code class="xref py py-const docutils literal notranslate"><span class="pre">os.path.supports_unicode_filenames</span></code></a> (一个布尔值) 来测试是否支持将任意 Unicode 字符串作为文件名。</p>
<p class="translated">在 MacOS 下，<a class="reference internal" href="../library/os.html#os.listdir" title="os.listdir"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.listdir()</span></code></a> 现在可以返回 Unicode 文件名。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-63"></span><a class="pep reference external" href="https://peps.python.org/pep-0277/"><strong>PEP 277</strong></a> - 针对 Windows NT 的 Unicode 文件名支持</dt><dd><p class="translated">由 Neil Hodgson 撰写 ; 由 Neil Hodgson, Martin von Löwis 和 Mark Hammond 实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-278-universal-newline-support">
<span id="index-8"></span><h2 class="translated">PEP 278: 通用换行支持<a class="headerlink" href="#pep-278-universal-newline-support" title="Link to this heading">¶</a></h2>
<p class="translated">目前使用的三大操作系统是微软的 Windows、苹果的 Macintosh OS 和各种 Unix 衍生系统。跨平台工作的一个小麻烦是，这三个平台都使用不同的字符来标记文本文件中的行结束。Unix 使用换行符（ASCII 字符 10），MacOS 使用回车符（ASCII 字符 13），Windows 使用回车符加换行符的双字符序列。</p>
<p class="translated">Python 的文件对象现在可以支持与 Python 运行平台不同的行结束约定。使用 <code class="docutils literal notranslate"><span class="pre">'U'</span></code> 或 <code class="docutils literal notranslate"><span class="pre">'rU'</span></code> 模式打开文件将以 <a class="reference internal" href="../glossary.html#term-universal-newlines"><span class="xref std std-term">universal newlines</span></a> 模式打开文件供读取。 所有这三种行结束约定都将在各种文件方法如 <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code> 返回的字符串中翻译为 <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>。</p>
<p class="translated">在导入模块和使用 <code class="xref py py-func docutils literal notranslate"><span class="pre">execfile()</span></code> 函数执行文件时，也会使用通用换行支持。 这意味着 Python 模块可以在所有三种操作系统之间共享，而无需转换行尾。</p>
<p class="translated">在编译 Python 时，可以通过在运行 Python 的 <strong class="program">configure</strong> 脚本时指定 <code class="xref std std-option docutils literal notranslate"><span class="pre">--without-universal-newlines</span></code> 开关禁用该功能。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-64"></span><a class="pep reference external" href="https://peps.python.org/pep-0278/"><strong>PEP 278</strong></a> - 通用换行支持</dt><dd><p class="translated">由 Jack Jansen 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-279-enumerate">
<span id="section-enumerate"></span><h2 class="translated">PEP 279: enumerate()<a class="headerlink" href="#pep-279-enumerate" title="Link to this heading">¶</a></h2>
<p class="translated">新的内置函数 <a class="reference internal" href="../library/functions.html#enumerate" title="enumerate"><code class="xref py py-func docutils literal notranslate"><span class="pre">enumerate()</span></code></a> 将使某些循环更加清晰。 在 <code class="docutils literal notranslate"><span class="pre">enumerate(thing)</span></code> 中，如果 <em>thing</em> 是迭代器或序列，则返回一个迭代器，该迭代器将返回 <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">thing[0])</span></code>，<code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">thing[1])</span></code>，<code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">thing[2])</span></code>，以此类推。</p>
<p class="translated">改变一个列表中每个元素的常见写法看起来像是这样:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)):</span>
    <span class="n">item</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="c1"># ... 基于条目计算某个结果 ...</span>
    <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
</pre></div>
</div>
<p class="translated">可以使用 <a class="reference internal" href="../library/functions.html#enumerate" title="enumerate"><code class="xref py py-func docutils literal notranslate"><span class="pre">enumerate()</span></code></a> 重写为：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
    <span class="c1"># ... 基于条目计算某个结果 ...</span>
    <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-65"></span><a class="pep reference external" href="https://peps.python.org/pep-0279/"><strong>PEP 279</strong></a> - 内置函数 enumerate()</dt><dd><p class="translated">由 Raymond D. Hettinger 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-282-the-logging-package">
<h2 class="translated">PEP 282: logging 包<a class="headerlink" href="#pep-282-the-logging-package" title="Link to this heading">¶</a></h2>
<p class="translated">Python 2.3 中新增了一个用于编写日志的标准软件包 <a class="reference internal" href="../library/logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a>。 它为生成日志输出提供了一个强大而灵活的机制，这些输出可以通过各种方式进行过滤和处理。用标准格式编写的配置文件可以用来控制程序的日志行为。 Python 包含的处理器可以将日志记录写入标准错误、文件或套接字，发送到系统日志，甚至通过电子邮件发送到特定地址；当然，你也可以编写自己的处理器类。</p>
<p class="translated"><a class="reference internal" href="../library/logging.html#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> 类是主要的类。大多数应用程序代码将处理一个或多个 <a class="reference internal" href="../library/logging.html#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> 对象，每个对象由应用程序的特定子系统使用。每个 <a class="reference internal" href="../library/logging.html#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> 都由一个名称标识，名称通过使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 作为组件分隔符组织成层次结构。例如，你可能有名为 <code class="docutils literal notranslate"><span class="pre">server</span></code>、<code class="docutils literal notranslate"><span class="pre">server.auth</span></code> 和 <code class="docutils literal notranslate"><span class="pre">server.network</span></code> 的 <a class="reference internal" href="../library/logging.html#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> 实例。后两个实例在层次结构中位于 <code class="docutils literal notranslate"><span class="pre">server</span></code> 之下。这意味着如果你提高 <code class="docutils literal notranslate"><span class="pre">server</span></code> 的详细级别或将 <code class="docutils literal notranslate"><span class="pre">server</span></code> 消息定向到不同的处理器，更改也将应用于记录到 <code class="docutils literal notranslate"><span class="pre">server.auth</span></code> 和 <code class="docutils literal notranslate"><span class="pre">server.network</span></code> 的记录。还有一个根 <a class="reference internal" href="../library/logging.html#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a>，它是所有其他记录器的父级。</p>
<p class="translated">为了简化使用，<a class="reference internal" href="../library/logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> 包提供了一些始终使用根日志的便捷函数:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>

<span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Debugging information&#39;</span><span class="p">)</span>
<span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Informational message&#39;</span><span class="p">)</span>
<span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Warning:config file </span><span class="si">%s</span><span class="s1"> not found&#39;</span><span class="p">,</span> <span class="s1">&#39;server.conf&#39;</span><span class="p">)</span>
<span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Error occurred&#39;</span><span class="p">)</span>
<span class="n">logging</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s1">&#39;Critical error -- shutting down&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">这会产生以下输出:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">WARNING</span><span class="p">:</span><span class="n">root</span><span class="p">:</span><span class="ne">Warning</span><span class="p">:</span><span class="n">config</span> <span class="n">file</span> <span class="n">server</span><span class="o">.</span><span class="n">conf</span> <span class="ow">not</span> <span class="n">found</span>
<span class="n">ERROR</span><span class="p">:</span><span class="n">root</span><span class="p">:</span><span class="n">Error</span> <span class="n">occurred</span>
<span class="n">CRITICAL</span><span class="p">:</span><span class="n">root</span><span class="p">:</span><span class="n">Critical</span> <span class="n">error</span> <span class="o">--</span> <span class="n">shutting</span> <span class="n">down</span>
</pre></div>
</div>
<p class="translated">在默认配置中，信息和调试信息被忽略，输出被发送到标准错误。 你可以通过调用根日志记录器上的 <a class="reference internal" href="../library/logging.html#logging.Logger.setLevel" title="logging.Logger.setLevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setLevel()</span></code></a> 方法来启用信息和调试信息的显示。</p>
<p class="translated">请注意 <a class="reference internal" href="../library/logging.html#logging.warning" title="logging.warning"><code class="xref py py-func docutils literal notranslate"><span class="pre">warning()</span></code></a> 调用使用了字符串格式化运算符；所有记录信息的函数都使用参数 <code class="docutils literal notranslate"><span class="pre">(msg,</span> <span class="pre">arg1,</span> <span class="pre">arg2,</span> <span class="pre">...)</span></code>，并记录 <code class="docutils literal notranslate"><span class="pre">msg</span> <span class="pre">%</span> <span class="pre">(arg1,</span> <span class="pre">arg2,</span> <span class="pre">...)</span></code> 产生的字符串。</p>
<p class="translated">还有一个 <a class="reference internal" href="../library/logging.html#logging.exception" title="logging.exception"><code class="xref py py-func docutils literal notranslate"><span class="pre">exception()</span></code></a> 函数可记录最近的回溯。如果为关键字参数 <em>exc_info</em> 指定了真值，其他函数也会记录回溯：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>    <span class="mi">1</span><span class="o">/</span><span class="mi">0</span>
    <span class="k">except</span><span class="p">:</span> <span class="n">logging</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s1">&#39;Problem recorded&#39;</span><span class="p">)</span>

<span class="n">f</span><span class="p">()</span>
</pre></div>
</div>
<p class="translated">这会产生以下输出:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ERROR</span><span class="p">:</span><span class="n">root</span><span class="p">:</span><span class="n">Problem</span> <span class="n">recorded</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&quot;t.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">6</span><span class="p">,</span> <span class="ow">in</span> <span class="n">f</span>
    <span class="mi">1</span><span class="o">/</span><span class="mi">0</span>
<span class="ne">ZeroDivisionError</span><span class="p">:</span> <span class="n">integer</span> <span class="n">division</span> <span class="ow">or</span> <span class="n">modulo</span> <span class="n">by</span> <span class="n">zero</span>
</pre></div>
</div>
<p class="translated">稍微高级一些的程序将使用除根记录器之外的记录器。<code class="docutils literal notranslate"><span class="pre">getLogger(name)</span></code> 函数用于获取特定的日志，如果该日志尚不存在则创建它。<code class="docutils literal notranslate"><span class="pre">getLogger(None)</span></code> 返回根记录器。:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;server&#39;</span><span class="p">)</span>
 <span class="o">...</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Listening on port </span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
 <span class="o">...</span>
<span class="n">log</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s1">&#39;Disk full&#39;</span><span class="p">)</span>
 <span class="o">...</span>
</pre></div>
</div>
<p class="translated">日志记录通常会向上传播，因此 <code class="docutils literal notranslate"><span class="pre">server</span></code> 和 <code class="docutils literal notranslate"><span class="pre">root</span></code> 也会看到记录到 <code class="docutils literal notranslate"><span class="pre">server.auth</span></code> 的信息，但 <a class="reference internal" href="../library/logging.html#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> 可以通过将其 <a class="reference internal" href="../library/logging.html#logging.Logger.propagate" title="logging.Logger.propagate"><code class="xref py py-attr docutils literal notranslate"><span class="pre">propagate</span></code></a> 属性设置为 <a class="reference internal" href="../library/constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> 来避免这种情况。</p>
<p class="translated"><a class="reference internal" href="../library/logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> 包提供了更多可以自定义的类。当 <a class="reference internal" href="../library/logging.html#logging.Logger" title="logging.Logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a> 实例被告知记录消息时，它会创建一个 <a class="reference internal" href="../library/logging.html#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 实例，该实例被发送到任意数量的不同 <a class="reference internal" href="../library/logging.html#logging.Handler" title="logging.Handler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Handler</span></code></a> 实例。记录器和处理器还可以附加过滤器列表，每个过滤器可以导致 <a class="reference internal" href="../library/logging.html#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 被忽略，或者可以在传递之前修改记录。当它们最终输出时，<a class="reference internal" href="../library/logging.html#logging.LogRecord" title="logging.LogRecord"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogRecord</span></code></a> 实例由 <a class="reference internal" href="../library/logging.html#logging.Formatter" title="logging.Formatter"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formatter</span></code></a> 类转换为文本。所有这些类都可以由你自己编写的特殊类替换。</p>
<p class="translated"><a class="reference internal" href="../library/logging.html#module-logging" title="logging: Flexible event logging system for applications."><code class="xref py py-mod docutils literal notranslate"><span class="pre">logging</span></code></a> 软件包具有所有这些功能，即使是最复杂的应用程序也能灵活运用。 本文仅是对其功能的不完整概述，因此请参阅软件包的参考文档了解所有细节。 阅读 <span class="target" id="index-66"></span><a class="pep reference external" href="https://peps.python.org/pep-0282/"><strong>PEP 282</strong></a> 也会有所帮助。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-67"></span><a class="pep reference external" href="https://peps.python.org/pep-0282/"><strong>PEP 282</strong></a> - Logging 系统</dt><dd><p class="translated">由 Vinay Sajip 和 Trent Mick 撰写 ; 由 Vinay Sajip 实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-285-a-boolean-type">
<span id="section-bool"></span><h2 class="translated">PEP 285: 布尔类型<a class="headerlink" href="#pep-285-a-boolean-type" title="Link to this heading">¶</a></h2>
<p class="translated">Python 2.3 中增加了布尔类型。 <code class="xref py py-mod docutils literal notranslate"><span class="pre">__builtin__</span></code> 模块中新增了两个常量： <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> 和 <a class="reference internal" href="../library/constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>。 (<a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> 和 <a class="reference internal" href="../library/constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> 常量被添加到了 Python 2.2.1 的内置模块中，但 2.2.1 版本的常量只是被设置为 1 和 0 的整数值，并不是一种不同的类型。)</p>
<p class="translated">这个新类型的类型对象名为 <a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>；它的构造函数接收任何 Python 值，并将其转换为 <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> 或 <a class="reference internal" href="../library/constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>。:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">([])</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="translated">大多数标准库模块和内置函数都改为返回布尔值：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;append&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p class="translated">添加 Python 布尔运算的主要目的是使代码更清晰。 例如，如果你在阅读一个函数时遇到 <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">1</span></code> 语句，你可能会想知道 <code class="docutils literal notranslate"><span class="pre">1</span></code> 代表的是布尔真值、索引还是乘以其他量的系数。 然而，如果语句是 <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">True</span></code>，返回值的含义就非常清楚了。</p>
<p class="translated">Python 的布尔值 <em>不是</em> 为了严格的类型检查而添加的。 像 Pascal 这样非常严格的语言也会阻止你使用布尔进行算术运算，并要求 <a class="reference internal" href="../reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 语句中的表达式总是求布尔结果。 正如 <span class="target" id="index-68"></span><a class="pep reference external" href="https://peps.python.org/pep-0285/"><strong>PEP 285</strong></a> 所明确指出的，Python 没有这么严格，以后也不会有。 这意味着你仍然可以在 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code> 语句中使用任何表达式，甚至是求值为 list、tuple 或一些随机对象的表达式。 布尔类型是 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> 类的子类，因此使用布尔值进行算术运算仍然有效：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kc">True</span> <span class="o">+</span> <span class="mi">1</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kc">False</span> <span class="o">+</span> <span class="mi">1</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kc">False</span> <span class="o">*</span> <span class="mi">75</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kc">True</span> <span class="o">*</span> <span class="mi">75</span>
<span class="go">75</span>
</pre></div>
</div>
<p class="translated">用一句话概括 <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> 和 <a class="reference internal" href="../library/constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>: 它们是拼写整数值 1 和 0 的另一种方式，唯一不同的是 <a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-func docutils literal notranslate"><span class="pre">str()</span></code></a> 和 <a class="reference internal" href="../library/functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a> 返回的字符串是 <code class="docutils literal notranslate"><span class="pre">'True'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">'False'</span></code>，而不是 <code class="docutils literal notranslate"><span class="pre">'1'</span></code> 和 <code class="docutils literal notranslate"><span class="pre">'0'</span></code>。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-69"></span><a class="pep reference external" href="https://peps.python.org/pep-0285/"><strong>PEP 285</strong></a> - 添加布尔类型</dt><dd><p class="translated">由 GvR 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-293-codec-error-handling-callbacks">
<h2 class="translated">PEP 293: 编解码器错误处理回调<a class="headerlink" href="#pep-293-codec-error-handling-callbacks" title="Link to this heading">¶</a></h2>
<p class="translated">将 Unicode 字符串编码为字节字符串时，可能会遇到无法编码的字符。 到目前为止，Python 允许将错误处理指定为 &quot;strict&quot; (引发 <a class="reference internal" href="../library/exceptions.html#UnicodeError" title="UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a>)、&quot;ignore&quot; (跳过该字符) 或 &quot;replace&quot; (在输出字符串中使用问号)，其中 &quot;strict&quot; 是默认行为。 可能需要指定对此类错误的其他处理方式，例如在转换后的字符串中插入 XML 字符引用或 HTML 实体引用。</p>
<p class="translated">Python 现在有一个灵活的框架，可以添加不同的处理策略。可以通过 <a class="reference internal" href="../library/codecs.html#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">codecs.register_error()</span></code></a> 添加新的错误处理器，然后编解码器可以通过 <a class="reference internal" href="../library/codecs.html#codecs.lookup_error" title="codecs.lookup_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">codecs.lookup_error()</span></code></a> 访问错误处理器。 错误处理器会获取必要的状态信息，如正在转换的字符串、字符串中检测到错误的位置以及目标编码。 然后，处理器可以引发异常或返回替换字符串。</p>
<p class="translated">使用该框架还实现了两个额外的错误处理器： &quot;backslashreplace&quot; 使用 Python 反斜杠引号来表示无法编码的字符，而 &quot;xmlcharrefreplace&quot; 则转换为 XML 字符引用。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-70"></span><a class="pep reference external" href="https://peps.python.org/pep-0293/"><strong>PEP 293</strong></a> - 编解码器错误处理回调</dt><dd><p class="translated">由 Walter Dörwald 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-301-package-index-and-metadata-for-distutils">
<span id="section-pep301"></span><h2 class="translated">PEP 301: Distutils的软件包索引和元数据<a class="headerlink" href="#pep-301-package-index-and-metadata-for-distutils" title="Link to this heading">¶</a></h2>
<p class="translated">广受期待的对 Python 编目的支持在 2.3 版中首次出现。</p>
<p class="translated">编目功能的核心是新的 Distutils <strong class="command">register</strong> 命令。 运行 <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">register</span></code> 将会收集描述软件包的元数据，例如其名称、版本、维护者、描述信息等等，并将其发送给中央编目服务器。 结果编目数据可在 <a class="reference external" href="https://pypi.org">https://pypi.org</a> 获取。</p>
<p class="translated">为了使目录更加有用，Distutils 的 <code class="xref py py-func docutils literal notranslate"><span class="pre">setup()</span></code> 函数中新增了一个可选的 <em>classifiers</em> 关键字参数。 可以提供一系列 <a class="reference external" href="http://catb.org/~esr/trove/">Trove</a> 风格的字符串来帮助对软件进行分类。</p>
<p class="translated">下面是一个带有分类器的 <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code> 示例，其编写是为了兼容旧版本的 Distutils：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">distutils</span><span class="w"> </span><span class="kn">import</span> <span class="n">core</span>
<span class="n">kw</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s2">&quot;Quixote&quot;</span><span class="p">,</span>
      <span class="s1">&#39;version&#39;</span><span class="p">:</span> <span class="s2">&quot;0.5.1&quot;</span><span class="p">,</span>
      <span class="s1">&#39;description&#39;</span><span class="p">:</span> <span class="s2">&quot;A highly Pythonic Web application framework&quot;</span><span class="p">,</span>
      <span class="c1"># ...</span>
      <span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">core</span><span class="p">,</span> <span class="s1">&#39;setup_keywords&#39;</span><span class="p">)</span> <span class="ow">and</span>
    <span class="s1">&#39;classifiers&#39;</span> <span class="ow">in</span> <span class="n">core</span><span class="o">.</span><span class="n">setup_keywords</span><span class="p">):</span>
    <span class="n">kw</span><span class="p">[</span><span class="s1">&#39;classifiers&#39;</span><span class="p">]</span> <span class="o">=</span> \
        <span class="p">[</span><span class="s1">&#39;Topic :: Internet :: WWW/HTTP :: Dynamic Content&#39;</span><span class="p">,</span>
         <span class="s1">&#39;Environment :: No Input/Output (Daemon)&#39;</span><span class="p">,</span>
         <span class="s1">&#39;Intended Audience :: Developers&#39;</span><span class="p">],</span>

<span class="n">core</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">完整的 classifiers 列表可通过运行 <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">register</span> <span class="pre">--list-classifiers</span></code> 来获取。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-71"></span><a class="pep reference external" href="https://peps.python.org/pep-0301/"><strong>PEP 301</strong></a> - Distutils 的软件包索引和元数据</dt><dd><p class="translated">由 Richard Jones 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-302-new-import-hooks">
<span id="section-pep302"></span><h2 class="translated">PEP 302: 新导入钩子<a class="headerlink" href="#pep-302-new-import-hooks" title="Link to this heading">¶</a></h2>
<p class="translated">虽然自从在 Python 1.3 中引入 <code class="xref py py-mod docutils literal notranslate"><span class="pre">ihooks</span></code> 模块后，就可以编写自定义导入钩子了，但由于编写新的导入钩子既困难又混乱，所以从来没有人对它真正满意过。 曾有人提出过各种替代方案，如 <code class="xref py py-mod docutils literal notranslate"><span class="pre">imputil</span></code> 和 <code class="xref py py-mod docutils literal notranslate"><span class="pre">iu</span></code> 模块，但都没有得到广泛认可，而且都不容易从 C 代码中使用。</p>
<p class="translated"><span class="target" id="index-72"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a> 借鉴了其前身，尤其是 Gordon McMillan 的 <code class="xref py py-mod docutils literal notranslate"><span class="pre">iu</span></code> 模块。 <a class="reference internal" href="../library/sys.html#module-sys" title="sys: Access system-specific parameters and functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">sys</span></code></a> 模块新增了三个条目：</p>
<ul class="simple">
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">sys.path_hooks</span></code> 是一个可调用对象列表，通常是类。 每个可调用对象都接收一个包含路径的字符串，然后返回一个可处理从该路径导入的导入器对象，如果不能处理该路径，则引发 <a class="reference internal" href="../library/exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> 异常。</p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">sys.path_importer_cache</span></code> 会缓存每条路径的导入器对象，因此 <code class="docutils literal notranslate"><span class="pre">sys.path_hooks</span></code> 只需为每条路径遍历一次。</p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">sys.meta_path</span></code> 是一个导入器对象列表，在检查 <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> 之前将遍历该列表。 该列表最初为空，但用户代码可以向其中添加对象。 其他内置模块和冻结模块可以通过添加到该列表中的对象导入。</p></li>
</ul>
<p class="translated">导入器对象必须有一个方法，即 <code class="docutils literal notranslate"><span class="pre">find_module(fullname,</span> <span class="pre">path=None)</span></code>。 <em>fullname</em> 将是一个模块或软件包名称，如 <code class="docutils literal notranslate"><span class="pre">string</span></code> 或 <code class="docutils literal notranslate"><span class="pre">distutils.core</span></code>。 <code class="xref py py-meth docutils literal notranslate"><span class="pre">find_module()</span></code> 必须返回一个加载器对象，该加载器对象必须有一个方法 <code class="docutils literal notranslate"><span class="pre">load_module(fullname)</span></code>，用于创建和返回相应的模块对象。</p>
<p class="translated">因此，Python 新导入逻辑的伪代码如下 (略有简化；详情请参见 <span class="target" id="index-73"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a>)：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">mp</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">meta_path</span><span class="p">:</span>
    <span class="n">loader</span> <span class="o">=</span> <span class="n">mp</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">loader</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">load_module</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>

<span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">hook</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">path_hooks</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">importer</span> <span class="o">=</span> <span class="n">hook</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="c1"># ImportError，则尝试其他路径钩子</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loader</span> <span class="o">=</span> <span class="n">importer</span><span class="o">.</span><span class="n">find_module</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>
            <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">load_module</span><span class="p">(</span><span class="n">fullname</span><span class="p">)</span>

<span class="c1"># 未找到！</span>
<span class="k">raise</span> <span class="ne">ImportError</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-74"></span><a class="pep reference external" href="https://peps.python.org/pep-0302/"><strong>PEP 302</strong></a> - 新导入钩</dt><dd><p class="translated">由 Just van Rossum 和 Paul Moore 撰写 ; 由 Just van Rossum 实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-305-comma-separated-files">
<span id="section-pep305"></span><h2 class="translated">PEP 305: 逗号分隔文件<a class="headerlink" href="#pep-305-comma-separated-files" title="Link to this heading">¶</a></h2>
<p class="translated">以逗号作为分隔符的文件是一种常用于从数据库和电子表格导出数据的格式。 Python 2.3 增加了一个针对逗号分隔文件的解析器。</p>
<p class="translated">逗号分隔文件乍一看非常简单:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">Costs</span><span class="p">,</span><span class="mi">150</span><span class="p">,</span><span class="mi">200</span><span class="p">,</span><span class="mf">3.95</span>
</pre></div>
</div>
<p class="translated">读取一行并调用 <code class="docutils literal notranslate"><span class="pre">line.split(',')</span></code>: 再简单不过了吧？ 但是考虑到可能包含逗号的字符串数据，事件就变得复杂起来:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;Costs&quot;</span><span class="p">,</span><span class="mi">150</span><span class="p">,</span><span class="mi">200</span><span class="p">,</span><span class="mf">3.95</span><span class="p">,</span><span class="s2">&quot;Includes taxes, shipping, and sundry items&quot;</span>
</pre></div>
</div>
<p class="translated">一个大的丑陋的正则表达式可以解析这些内容，但使用新的 <a class="reference internal" href="../library/csv.html#module-csv" title="csv: Write and read tabular data to and from delimited files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">csv</span></code></a> 软件包要简单得多：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">csv</span>

<span class="nb">input</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;datafile&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
<span class="n">reader</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">reader</span><span class="p">:</span>
    <span class="nb">print</span> <span class="n">line</span>
</pre></div>
</div>
<p class="translated"><a class="reference internal" href="../library/csv.html#csv.reader" title="csv.reader"><code class="xref py py-func docutils literal notranslate"><span class="pre">reader()</span></code></a> 函数有多种不同的选项。 字段分隔符不限于逗号，可以改为任何字符，引号和行尾字符也是如此。</p>
<p class="translated">可以定义和注册不同的逗号分隔文件方言；目前有两种方言，均由 Microsoft Excel 使用。一个单独的 <a class="reference internal" href="../library/csv.html#csv.writer" title="csv.writer"><code class="xref py py-class docutils literal notranslate"><span class="pre">csv.writer</span></code></a> 类将从一系列元组或列表生成逗号分隔文件，并对包含分隔符的字符串进行引用。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated">该实现在“Python 增强提议” - PEP <cite>305</cite> (CSV 文件 API)  中被提出</dt><dd><p class="translated">由 Kevin Altis, Dave Cole, Andrew McNamara, Skip Montanaro, Cliff Wells 撰写并实现。</p>
</dd>
</dl>
</div>
</section>
<section id="pep-307-pickle-enhancements">
<span id="section-pep307"></span><h2 class="translated">PEP 307：对 pickle 的改进<a class="headerlink" href="#pep-307-pickle-enhancements" title="Link to this heading">¶</a></h2>
<p class="translated"><a class="reference internal" href="../library/pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 和 <code class="xref py py-mod docutils literal notranslate"><span class="pre">cPickle</span></code> 模块在 2.3 开发周期中受到了关注。 在 2.2 中，新式类的 pickle 并不困难，但 pickle 得并不紧凑；<span class="target" id="index-75"></span><a class="pep reference external" href="https://peps.python.org/pep-0307/"><strong>PEP 307</strong></a> 引用了一个微不足道的例子，在这个例子中，新式类的 pickle 字符串比经典类的 pickle 字符串长三倍。</p>
<p class="translated">解决办法就是发明一种新的 pickle 协议。 <a class="reference internal" href="../library/pickle.html#pickle.dumps" title="pickle.dumps"><code class="xref py py-func docutils literal notranslate"><span class="pre">pickle.dumps()</span></code></a> 函数很早就支持文本或二进制标志。 在 2.3 中，该标志从布尔值重新定义为整数：0 表示旧的文本模式 pickle 格式，1 表示旧的二进制格式，现在 2 表示新的 2.3 专用格式。 一个新常量 <a class="reference internal" href="../library/pickle.html#pickle.HIGHEST_PROTOCOL" title="pickle.HIGHEST_PROTOCOL"><code class="xref py py-const docutils literal notranslate"><span class="pre">pickle.HIGHEST_PROTOCOL</span></code></a> 可用来选择最先进的协议。</p>
<p class="translated">unpickle 不再被视为安全操作。 2.2 的 <a class="reference internal" href="../library/pickle.html#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 提供了钩子，试图阻止不安全的类被 unpickle （特别是 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__safe_for_unpickling__</span></code> 属性），但这些代码都没有经过审计，因此在 2.3 中都被删除了。 在任何版本的 Python 中，你都不应该 unpickle 不信任的数据。</p>
<p class="translated">为了减少新式类的序列化开销，添加了一个新的接口用于自定义序列化，使用三个特殊方法：<a class="reference internal" href="../library/pickle.html#object.__getstate__" title="object.__getstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getstate__()</span></code></a>、<a class="reference internal" href="../library/pickle.html#object.__setstate__" title="object.__setstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setstate__()</span></code></a> 和 <a class="reference internal" href="../library/pickle.html#object.__getnewargs__" title="object.__getnewargs__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getnewargs__()</span></code></a>。请参考 <span class="target" id="index-76"></span><a class="pep reference external" href="https://peps.python.org/pep-0307/"><strong>PEP 307</strong></a> 了解这些方法的完整语义。</p>
<p class="translated">为了进一步压缩 pickle 类，现在可以使用整数代码而不是长字符串来标识 pickle 类。 Python 软件基金会将维护一个标准化代码列表；还有一系列供私人使用的代码。 目前还没有指定任何代码。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><span class="target" id="index-77"></span><a class="pep reference external" href="https://peps.python.org/pep-0307/"><strong>PEP 307</strong></a> - pickle 协议的扩展</dt><dd><p class="translated">PEP 由 Guido van Rossum 和 Tim Peters 撰写和实现。</p>
</dd>
</dl>
</div>
</section>
<section id="extended-slices">
<span id="section-slices"></span><h2 class="translated">扩展切片<a class="headerlink" href="#extended-slices" title="Link to this heading">¶</a></h2>
<p class="translated">从 Python 1.4 开始，切片语法支持可选的第三个“step”或“stride”参数。例如，这些都是合法的 Python 语法: <code class="docutils literal notranslate"><span class="pre">L[1:10:2]</span></code>，<code class="docutils literal notranslate"><span class="pre">L[:-1:1]</span></code>，<code class="docutils literal notranslate"><span class="pre">L[::-1]</span></code>。 这是应 Numerical Python 开发者的要求添加到 Python 中的，因为 Numerical Python 广泛使用第三个参数。 然而，Python 内置的 list、tuple 和字符串序列类型从未支持过这一特性，如果你尝试使用，会引发 <a class="reference internal" href="../library/exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。 Michael Hudson 提供了一个补丁来修复这一缺陷。</p>
<p class="translated">例如，你现在可以轻松地提取出具有偶数索引的列表元素：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[0, 2, 4, 6, 8]</span>
</pre></div>
</div>
<p class="translated">也可以用负值以按相反顺序复制相同的列表：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span>
</pre></div>
</div>
<p class="translated">这也适用于元组、数组和字符串：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">=</span><span class="s1">&#39;abcd&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
<span class="go">&#39;ac&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">&#39;dcba&#39;</span>
</pre></div>
</div>
<p class="translated">如果你有一个可变序列如列表或数组，你可以对扩展切片进行赋值或删除，但对扩展切片的赋值与对常规切片的赋值有一些区别。对常规片段的赋值可以用来改变序列的长度：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[0, 1, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[0, 4, 5, 6]</span>
</pre></div>
</div>
<p class="translated">扩展分片则没有这种灵活性。 在为扩展分片赋值时，语句右侧的列表必须包含与要替换的分片相同数量的项目：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[0, 1, 2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[0, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[0, 1, -1, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">?</span>
<span class="gr">ValueError</span>: <span class="n">attempt to assign sequence of size 3 to extended slice of size 2</span>
</pre></div>
</div>
<p class="translated">删除操作更为直观：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[0, 1, 2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
<span class="go">[0, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">a</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">[1, 3]</span>
</pre></div>
</div>
<p class="translated">现在，我们还可以将切片对象传递给内置序列的 <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a> 方法：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">[0, 2, 4]</span>
</pre></div>
</div>
<p class="translated">或者直接在下标中使用切片对象：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="go">[0, 2, 4]</span>
</pre></div>
</div>
<p class="translated">为了简化支持扩展切片的序列的实现，切片对象现在有了一个方法 <code class="docutils literal notranslate"><span class="pre">indices(length)</span></code>，在给定序列长度的情况下，它返回一个 <code class="docutils literal notranslate"><span class="pre">(start,</span> <span class="pre">stop,</span> <span class="pre">step)</span></code> 元组，可以直接传给 <a class="reference internal" href="../library/stdtypes.html#range" title="range"><code class="xref py py-func docutils literal notranslate"><span class="pre">range()</span></code></a>。 <code class="xref py py-meth docutils literal notranslate"><span class="pre">indices()</span></code> 处理省略和越界索引的方式与常规切片一致（这个无伤大雅的短语隐藏了大量令人困惑的细节！）。 该方法的使用方法如下：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">FakeSeq</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calc_item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="o">...</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">FakeSeq</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_item</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">indices</span><span class="p">)])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_item</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">从这个例子中还可以看到，内置的 <a class="reference internal" href="../library/functions.html#slice" title="slice"><code class="xref py py-class docutils literal notranslate"><span class="pre">slice</span></code></a> 对象现在是 slice 类型的类型对象，而不再是函数。 这与 Python 2.2 是一致的，在 Python 2.2 中，<a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>，<a class="reference internal" href="../library/stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 等也经历了同样的变化。</p>
</section>
<section id="other-language-changes">
<h2 class="translated">其他语言特性修改<a class="headerlink" href="#other-language-changes" title="Link to this heading">¶</a></h2>
<p class="translated">以下是 Python 2.3 针对核心 Python 语言的所有改变。</p>
<ul>
<li><p class="translated"><a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 语句现在将始终是关键字，如本文档的 <a class="reference internal" href="#section-generators"><span class="std std-ref">PEP 255: 简单的生成器</span></a> 一节所描述的。</p></li>
<li><p class="translated">新增内置函数 <a class="reference internal" href="../library/functions.html#enumerate" title="enumerate"><code class="xref py py-func docutils literal notranslate"><span class="pre">enumerate()</span></code></a>，如本文档的 <a class="reference internal" href="#section-enumerate"><span class="std std-ref">PEP 279: enumerate()</span></a> 一节所描述的。</p></li>
<li><p class="translated">新增两个常量 <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> 和 <a class="reference internal" href="../library/constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a> 以及内置的 <a class="reference internal" href="../library/functions.html#bool" title="bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a> 类型，如本文档的 <a class="reference internal" href="#section-bool"><span class="std std-ref">PEP 285: 布尔类型</span></a> 一节所描述的。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> 类型构造函数现在会返回一个长整数，而不会在字符串或浮点数太大而无法放入整数时引发 <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a>。 这可能会导致 <code class="docutils literal notranslate"><span class="pre">isinstance(int(expression),</span> <span class="pre">int)</span></code> 为假的矛盾结果，但在实践中似乎不太可能造成问题。</p></li>
<li><p class="translated">内置类型现在支持扩展的切分语法，详见本文档 <a class="reference internal" href="#section-slices"><span class="std std-ref">扩展切片</span></a> 一节。</p></li>
<li><p class="translated">一个新的内置函数 <code class="docutils literal notranslate"><span class="pre">sum(iterable,</span> <span class="pre">start=0)</span></code> 用于对可迭代对象中的数值项进行求和并返回其总和。<a class="reference internal" href="../library/functions.html#sum" title="sum"><code class="xref py py-func docutils literal notranslate"><span class="pre">sum()</span></code></a> 只接受数字，意味着你不能用它来连接一堆字符串。（由 Alex Martelli 贡献。）</p></li>
<li><p class="translated">以前 <code class="docutils literal notranslate"><span class="pre">list.insert(pos,</span> <span class="pre">value)</span></code> 在 <em>pos</em> 为负值时会将 <em>value</em> 插入到列表的前面。 现在，该行为已被修改为与切片索引一致，因此当 <em>pos</em> 为 -1 时，值将被插入最后一个元素之前，以此类推。</p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">list.index(value)</span></code> 会在列表中搜索 <em>value</em>，并返回其索引，现在可以使用可选的 <em>start</em> 和 <em>stop</em> 参数，将搜索范围限制在列表的一部分。</p></li>
<li><p class="translated">字典有一个新方法 <code class="docutils literal notranslate"><span class="pre">pop(key[,</span> <span class="pre">*default*])</span></code>，可返回 <em>key</em> 对应的值，并从字典中删除该键/值对。如果请求的键不在字典中，如果指定了 <em>default</em>，则返回 <em>default</em>，如果没有指定则会引发 <a class="reference internal" href="../library/exceptions.html#KeyError" title="KeyError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a>。</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">{1: 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;stdin&quot;</span>, line <span class="m">1</span>, in <span class="n">?</span>
<span class="gr">KeyError</span>: <span class="n">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;stdin&quot;</span>, line <span class="m">1</span>, in <span class="n">?</span>
<span class="gr">KeyError</span>: <span class="n">&#39;pop(): dictionary is empty&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">{}</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">还有一个新的类方法 <code class="docutils literal notranslate"><span class="pre">dict.fromkeys(iterable,</span> <span class="pre">value)</span></code>，用于创建一个字典，其键取自所提供的迭代器 <em>iterable</em>，所有值设置为 <em>value</em>，默认为 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<p class="translated">（由 Raymond Hettinger 贡献补丁。）</p>
<p class="translated">此外，现在 <a class="reference internal" href="../library/stdtypes.html#dict" title="dict"><code class="xref py py-func docutils literal notranslate"><span class="pre">dict()</span></code></a> 构建器可接受关键字参数以简化小型字典的创建:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">dict</span><span class="p">(</span><span class="n">red</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">blue</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">green</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">black</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">{&#39;blue&#39;: 2, &#39;black&#39;: 4, &#39;green&#39;: 3, &#39;red&#39;: 1}</span>
</pre></div>
</div>
<p class="translated">（由 Just van Rossum 贡献。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../reference/simple_stmts.html#assert"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">assert</span></code></a> 语句将不再检查 <code class="docutils literal notranslate"><span class="pre">__debug__</span></code> 旗标，因此你无法再通过为 <code class="docutils literal notranslate"><span class="pre">__debug__</span></code> 赋值来禁用断言。 使用 <a class="reference internal" href="../using/cmdline.html#cmdoption-O"><code class="xref std std-option docutils literal notranslate"><span class="pre">-O</span></code></a> 开关运行 Python 仍会生成不执行任何断言的代码。</p></li>
<li><p class="translated">大多数类型对象现在都是可调用的，因此你可以用它们来创建新对象，如函数、类和模块。（这意味着 <code class="xref py py-mod docutils literal notranslate"><span class="pre">new</span></code> 模块可以在未来的 Python 版本中被废弃，因为你现在可以使用 <a class="reference internal" href="../library/types.html#module-types" title="types: Names for built-in types."><code class="xref py py-mod docutils literal notranslate"><span class="pre">types</span></code></a> 模块中可用的类型对象）。例如，你可以用下面的代码创建一个新的模块对象：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">types</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">ModuleType</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">,</span><span class="s1">&#39;docstring&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">&lt;module &#39;abc&#39; (built-in)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="vm">__doc__</span>
<span class="go">&#39;docstring&#39;</span>
</pre></div>
</div>
</li>
<li><p class="translated">添加了一个新的警告 <a class="reference internal" href="../library/exceptions.html#PendingDeprecationWarning" title="PendingDeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PendingDeprecationWarning</span></code></a>，用于指示正在被废弃的功能。 默认情况下 <em>不会</em> 打印该警告。 要检查是否使用了将来会被废弃的功能，可在命令行中提供 <a class="reference internal" href="../using/cmdline.html#cmdoption-W"><code class="xref std std-option docutils literal notranslate"><span class="pre">-Walways::PendingDeprecationWarning::</span></code></a> 或使用 <a class="reference internal" href="../library/warnings.html#warnings.filterwarnings" title="warnings.filterwarnings"><code class="xref py py-func docutils literal notranslate"><span class="pre">warnings.filterwarnings()</span></code></a>。</p></li>
<li><p class="translated">与 <code class="docutils literal notranslate"><span class="pre">raise</span> <span class="pre">&quot;Error</span> <span class="pre">occurred&quot;</span></code> 一样，基于字符串的异常的废弃过程已经开始。 现在，引发字符串异常将触发 <a class="reference internal" href="../library/exceptions.html#PendingDeprecationWarning" title="PendingDeprecationWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PendingDeprecationWarning</span></code></a>。</p></li>
<li><p class="translated">现在使用 <code class="docutils literal notranslate"><span class="pre">None</span></code> 作为变量名将导致 <a class="reference internal" href="../library/exceptions.html#SyntaxWarning" title="SyntaxWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxWarning</span></code></a> 警告。 在未来的 Python 版本中，<code class="docutils literal notranslate"><span class="pre">None</span></code> 将最终成为一个保留关键字。</p></li>
<li><p class="translated">在 Python 2.1 中引入的文件对象的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">xreadlines()</span></code> 方法已不再需要，因为文件现在可以作为自己的迭代器来运行。 引入 <code class="xref py py-meth docutils literal notranslate"><span class="pre">xreadlines()</span></code> 的初衷是为了更快地循环遍历文件中的所有行，但现在只需写入 <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">line</span> <span class="pre">in</span> <span class="pre">file_obj</span></code> 即可。 文件对象还有一个新的只读 <code class="xref py py-attr docutils literal notranslate"><span class="pre">encoding</span></code> 属性，它给出了文件使用的编码；写入文件的 Unicode 字符串将使用给定的编码自动转换为字节。</p></li>
<li><p class="translated">新式类使用的方法解析顺序发生了变化，不过只有在继承层次结构非常复杂的情况下，你才会注意到这种差异。 经典类不受这一变化的影响。 Python 2.2 最初使用类祖先的拓扑排序，但 2.3 现在使用 C3 算法，如论文 <a class="reference external" href="https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.3910">&quot;A Monotonic Superclass Linearization for Dylan&quot;</a> 所述。 要了解这一变化的动机，请阅读 Michele Simionato 的文章 <a class="reference internal" href="../howto/mro.html#python-2-3-mro"><span class="std std-ref">Python 2.3 方法解析顺序</span></a>，或阅读 python-dev 上从 <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2002-October/029035.html">https://mail.python.org/pipermail/python-dev/2002-October/029035.html</a> 开始的消息。 Samuele Pedroni 首先指出了这个问题，并通过编码 C3 算法实现了修复。</p></li>
<li><p class="translated">Python 运行多线程程序时，会在执行 N 个字节码后切换线程。 N 的默认值已从 10 个字节码增加到 100 个，通过减少切换开销来加快单线程应用程序的速度。 一些多线程应用程序的响应时间可能会变慢，但这很容易解决，只需使用 <code class="docutils literal notranslate"><span class="pre">sys.setcheckinterval(N)</span></code> 将限制设回一个较低的数值即可。 使用新的 <code class="xref py py-func docutils literal notranslate"><span class="pre">sys.getcheckinterval()</span></code> 函数可以检索限制值。</p></li>
<li><p class="translated">一个微小但影响深远的变化是，由 Python 附带的模块定义的扩展类型的名称现在包含模块和类型名称前面的 <code class="docutils literal notranslate"><span class="pre">'.'</span></code>。 例如，在 Python 2.2 中，如果你创建了一个套接字并打印了它的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__class__</span></code>，你会得到这样的输出：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="vm">__class__</span>
<span class="go">&lt;type &#39;socket&#39;&gt;</span>
</pre></div>
</div>
<p class="translated">在 2.3 中，你会得到以下信息：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="vm">__class__</span>
<span class="go">&lt;type &#39;_socket.socket&#39;&gt;</span>
</pre></div>
</div>
</li>
<li><p class="translated">旧式类和新式类之间一个已知的不兼容问题已被移除：现在你可以为新式类的 <a class="reference internal" href="../reference/datamodel.html#type.__name__" title="type.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> 和 <a class="reference internal" href="../reference/datamodel.html#type.__bases__" title="type.__bases__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__bases__</span></code></a> 属性赋值。对于可以赋给 <code class="xref py py-attr docutils literal notranslate"><span class="pre">__bases__</span></code> 的值有一些限制，类似于对实例的 <a class="reference internal" href="../reference/datamodel.html#object.__class__" title="object.__class__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__class__</span></code></a> 属性赋值的限制。</p></li>
</ul>
<section id="string-changes">
<h3 class="translated">字符串的改变<a class="headerlink" href="#string-changes" title="Link to this heading">¶</a></h3>
<ul>
<li><p class="translated"><a class="reference internal" href="../reference/expressions.html#in"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">in</span></code></a> 运算符现在对字符串的作用不同了。 以前，当计算 <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">in</span> <span class="pre">Y</span></code> 时，<em>X</em> 和 <em>Y</em> 都是字符串，<em>X</em> 只能是单字符。 现在情况有所改变；<em>X</em> 可以是任意长度的字符串，如果 <em>X</em> 是 <em>Y</em> 的子串，<code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">in</span> <span class="pre">Y</span></code> 将返回 <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>。 如果 <em>X</em> 是空字符串，结果总是 <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>。</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;ab&#39;</span> <span class="ow">in</span> <span class="s1">&#39;abcd&#39;</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;ad&#39;</span> <span class="ow">in</span> <span class="s1">&#39;abcd&#39;</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;&#39;</span> <span class="ow">in</span> <span class="s1">&#39;abcd&#39;</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="translated">请注意，这不会告诉你子串从哪里开始；如果需要该信息，请使用字符串方法 <a class="reference internal" href="../library/stdtypes.html#str.find" title="str.find"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find()</span></code></a>。</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/stdtypes.html#str.strip" title="str.strip"><code class="xref py py-meth docutils literal notranslate"><span class="pre">strip()</span></code></a>、<a class="reference internal" href="../library/stdtypes.html#str.lstrip" title="str.lstrip"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lstrip()</span></code></a> 和 <a class="reference internal" href="../library/stdtypes.html#str.rstrip" title="str.rstrip"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rstrip()</span></code></a> 字符串方法现在有了一个可选参数，用于指定要删除的字符。默认值仍然是删除所有空白字符：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;   abc &#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
<span class="go">&#39;abc&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;&gt;&lt;&gt;&lt;abc&lt;&gt;&lt;&gt;&lt;&gt;&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;&lt;&gt;&#39;</span><span class="p">)</span>
<span class="go">&#39;abc&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;&gt;&lt;&gt;&lt;abc&lt;&gt;&lt;&gt;&lt;&gt;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;&lt;&gt;&#39;</span><span class="p">)</span>
<span class="go">&#39;abc&lt;&gt;&lt;&gt;&lt;&gt;\n&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="sa">u</span><span class="s1">&#39;</span><span class="se">\u4000\u4001</span><span class="s1">abc</span><span class="se">\u4000</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="sa">u</span><span class="s1">&#39;</span><span class="se">\u4000</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="go">u&#39;\u4001abc&#39;</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">（由 Simon Brunning 提议并由 Walter Dörwald 实现。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/stdtypes.html#str.startswith" title="str.startswith"><code class="xref py py-meth docutils literal notranslate"><span class="pre">startswith()</span></code></a> 和 <a class="reference internal" href="../library/stdtypes.html#str.endswith" title="str.endswith"><code class="xref py py-meth docutils literal notranslate"><span class="pre">endswith()</span></code></a> 字符串方法的 <em>start</em> 和 <em>end</em> 参数现在可接受负数。</p></li>
<li><p class="translated">另一个新增的字符串方法是 <a class="reference internal" href="../library/stdtypes.html#str.zfill" title="str.zfill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">zfill()</span></code></a>，原本是 <a class="reference internal" href="../library/string.html#module-string" title="string: Common string operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">string</span></code></a> 模块中的一个函数。 <a class="reference internal" href="../library/stdtypes.html#str.zfill" title="str.zfill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">zfill()</span></code></a> 会在一个表示数字的字符串左侧填充零直至达到指定的宽度。 请注意 <code class="docutils literal notranslate"><span class="pre">%</span></code> 运算符相比 <a class="reference internal" href="../library/stdtypes.html#str.zfill" title="str.zfill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">zfill()</span></code></a> 仍然是更灵活和更强大的。</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;45&#39;</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">&#39;0045&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;12345&#39;</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">&#39;12345&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;goofy&#39;</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">&#39;0goofy&#39;</span>
</pre></div>
</div>
<p class="translated">（由 Walter Dörwald 贡献。）</p>
</li>
<li><p class="translated">添加了一个新的类型对象 <code class="xref py py-class docutils literal notranslate"><span class="pre">basestring</span></code>。8位字符串和 Unicode 字符串都继承自这个类型，所以 <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">basestring)</span></code> 对这两种字符串都会返回 <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>。这是一个完全抽象的类型，所以你不能创建 <code class="xref py py-class docutils literal notranslate"><span class="pre">basestring</span></code> 实例。</p></li>
<li><p class="translated">内部字符串不再是不朽的，现在当它们唯一的引用来自内部字符串字典时，将按照通常的方式进行垃圾回收。（由 Oren Tirosh 实现。）</p></li>
</ul>
</section>
<section id="optimizations">
<h3 class="translated">性能优化<a class="headerlink" href="#optimizations" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p class="translated">新式类实例的创建速度获得大幅提升；现在已经比经典类更快了！</p></li>
<li><p class="translated">列表对象的 <a class="reference internal" href="../library/stdtypes.html#list.sort" title="list.sort"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort()</span></code></a> 方面已被 Tim Peters 全面改写，其实现的运行速度显著提高。</p></li>
<li><p class="translated">由于实现了Karatsuba乘法算法，大长整数的乘法现在更快了。这种算法的扩展性比学校乘法算法所需的*O*(<em>n</em><sup>2</sup>)要好得多。（原始补丁由Christopher A. Craig提供，Tim Peters进行了大量重写。）</p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">SET_LINENO</span></code> 操作码现已移除。这可能提供小幅速度提升，具体取决于你编译器的特性。详见 <a class="reference internal" href="#section-other"><span class="std std-ref">其他的改变和修正</span></a> 部分的详细解释。（由Michael Hudson移除。）</p></li>
<li><p class="translated"><code class="xref py py-func docutils literal notranslate"><span class="pre">xrange()</span></code> 对象现在拥有自己的迭代器，使得 <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">xrange(n)</span></code> 比 <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">range(n)</span></code> 稍微快一些。（由Raymond Hettinger提供补丁。）</p></li>
<li><p class="translated">在多个热点区域进行了一些小的调整以提升性能，例如内联函数或移除部分代码。（主要由GvR实现，但许多人都贡献了单个更改。）</p></li>
</ul>
<p class="translated">2.3 优化的总体结果是 Python 2.3 运行 pystone 基准测试的速度比 Python 2.2 加快了大约 25%。</p>
</section>
</section>
<section id="new-improved-and-deprecated-modules">
<h2 class="translated">新增，改进和弃用的模块<a class="headerlink" href="#new-improved-and-deprecated-modules" title="Link to this heading">¶</a></h2>
<p class="translated">一如既往，Python标准库获得了一系列增强和错误修复。以下是一些最显著变化的的部分列表，按模块名称字母顺序排序。查阅源树中的 <code class="file docutils literal notranslate"><span class="pre">Misc/NEWS</span></code> 文件可获得更完整的变化列表，或通过CVS日志查看所有详细信息。</p>
<ul>
<li><p class="translated"><a class="reference internal" href="../library/array.html#module-array" title="array: Space efficient arrays of uniformly typed numeric values."><code class="xref py py-mod docutils literal notranslate"><span class="pre">array</span></code></a> 模块现在支持使用 <code class="docutils literal notranslate"><span class="pre">'u'</span></code> 格式字符的Unicode字符数组。数组还支持使用 <code class="docutils literal notranslate"><span class="pre">+=</span></code> 赋值运算符来添加另一个数组的内容，以及使用 <code class="docutils literal notranslate"><span class="pre">*=</span></code> 赋值运算符来重复数组。（由 Jason Orendorff 贡献。）</p></li>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">bsddb</span></code> 模块已被 <a class="reference external" href="https://pybsddb.sourceforge.net">PyBSDDB</a> 包的4.1.6版本替换，提供了对BerkeleyDB库事务特性的更完整接口。</p>
<p class="translated">旧版本的模块已被重命名为 <code class="xref py py-mod docutils literal notranslate"><span class="pre">bsddb185</span></code>，并且不再自动构建；你需要编辑 <code class="file docutils literal notranslate"><span class="pre">Modules/Setup</span></code> 以启用它。请注意，新的 <code class="xref py py-mod docutils literal notranslate"><span class="pre">bsddb</span></code> 包旨在与旧模块兼容，因此如果你发现任何不兼容问题，请务必提交错误报告。在升级到 Python 2.3 时，如果新解释器是与新版本的底层 BerkeleyDB 库一起编译的，你几乎肯定需要将数据库文件转换为新的版本。你可以使用新脚本 <code class="file docutils literal notranslate"><span class="pre">db2pickle.py</span></code> 和 <code class="file docutils literal notranslate"><span class="pre">pickle2db.py</span></code> 相当容易地完成此操作，这些脚本位于发行版的 <code class="file docutils literal notranslate"><span class="pre">Tools/scripts</span></code> 目录中。如果你已经使用 PyBSDDB 包并将其作为 <code class="xref py py-mod docutils literal notranslate"><span class="pre">bsddb3</span></code> 导入，你将需要更改你的 <code class="docutils literal notranslate"><span class="pre">import</span></code> 语句以将其作为 <code class="xref py py-mod docutils literal notranslate"><span class="pre">bsddb</span></code> 导入。</p>
</li>
<li><p class="translated">新的 <a class="reference internal" href="../library/bz2.html#module-bz2" title="bz2: Interfaces for bzip2 compression and decompression."><code class="xref py py-mod docutils literal notranslate"><span class="pre">bz2</span></code></a> 模块是 bz2 数据压缩库的接口。bz2 压缩的数据通常比相应的 <a class="reference internal" href="../library/zlib.html#module-zlib" title="zlib: Low-level interface to compression and decompression routines compatible with gzip."><code class="xref py py-mod docutils literal notranslate"><span class="pre">zlib</span></code></a>-压缩数据更小。（由 Gustavo Niemeyer 贡献。）</p></li>
<li><p class="translated">在新的 <a class="reference internal" href="../library/datetime.html#module-datetime" title="datetime: Basic date and time types."><code class="xref py py-mod docutils literal notranslate"><span class="pre">datetime</span></code></a> 模块中添加了一组标准日期/时间类型。更多详细信息请参见下一节。</p></li>
<li><p class="translated">Distutils 的 <code class="xref py py-class docutils literal notranslate"><span class="pre">Extension</span></code> 类现在支持一个名为 <em>depends</em> 的额外构造函数参数，用于列出扩展所依赖的其他源文件。这使得 Distutils 在任何依赖文件被修改时重新编译模块。例如，如果 <code class="file docutils literal notranslate"><span class="pre">sampmodule.c</span></code> 包含头文件 <code class="file docutils literal notranslate"><span class="pre">sample.h</span></code>，你将像这样创建 <code class="xref py py-class docutils literal notranslate"><span class="pre">Extension</span></code> 对象:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">ext</span> <span class="o">=</span> <span class="n">Extension</span><span class="p">(</span><span class="s2">&quot;samp&quot;</span><span class="p">,</span>
                <span class="n">sources</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sampmodule.c&quot;</span><span class="p">],</span>
                <span class="n">depends</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sample.h&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p class="translated">修改 <code class="file docutils literal notranslate"><span class="pre">sample.h</span></code> 将导致模块被重新编译。 （由 Jeremy Hylton 贡献。）</p>
</li>
<li><p class="translated">对 Distutils 的其他小修改：现在它会检查 <span class="target" id="index-78"></span><a class="reference internal" href="../using/configure.html#envvar-CC"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">CC</span></code></a>, <span class="target" id="index-79"></span><a class="reference internal" href="../using/configure.html#envvar-CFLAGS"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">CFLAGS</span></code></a>, <code class="xref std std-envvar docutils literal notranslate"><span class="pre">CPP</span></code>, <span class="target" id="index-80"></span><a class="reference internal" href="../using/configure.html#envvar-LDFLAGS"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">LDFLAGS</span></code></a> 和 <span class="target" id="index-81"></span><a class="reference internal" href="../using/configure.html#envvar-CPPFLAGS"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">CPPFLAGS</span></code></a> 环境变量，使用它们来覆盖 Python 配置中的设置（由 Robert Weber 贡献）。</p></li>
<li><p class="translated">之前 <a class="reference internal" href="../library/doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> 模块只会在公共方法和函数的文档字符串中搜索测试用例，但现在它也会检查私有方法和函数。<a class="reference internal" href="../library/doctest.html#doctest.DocTestSuite" title="doctest.DocTestSuite"><code class="xref py py-func docutils literal notranslate"><span class="pre">DocTestSuite()</span></code></a> 函数从一组 <a class="reference internal" href="../library/doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> 测试中创建一个 <a class="reference internal" href="../library/unittest.html#unittest.TestSuite" title="unittest.TestSuite"><code class="xref py py-class docutils literal notranslate"><span class="pre">unittest.TestSuite</span></code></a> 对象。</p></li>
<li><p class="translated">新的 <code class="docutils literal notranslate"><span class="pre">gc.get_referents(object)</span></code> 函数将返回由 <em>object</em> 引用的所有对象组成的列表。</p></li>
<li><p class="translated">模块 <a class="reference internal" href="../library/getopt.html#module-getopt" title="getopt: Portable parser for command line options; support both short and long option names."><code class="xref py py-mod docutils literal notranslate"><span class="pre">getopt</span></code></a> 新增了一个函数 <a class="reference internal" href="../library/getopt.html#getopt.gnu_getopt" title="getopt.gnu_getopt"><code class="xref py py-func docutils literal notranslate"><span class="pre">gnu_getopt()</span></code></a>，该函数支持与现有 <a class="reference internal" href="../library/getopt.html#getopt.getopt" title="getopt.getopt"><code class="xref py py-func docutils literal notranslate"><span class="pre">getopt()</span></code></a> 函数相同的参数，但使用 GNU 风格的扫描模式。现有的 <a class="reference internal" href="../library/getopt.html#getopt.getopt" title="getopt.getopt"><code class="xref py py-func docutils literal notranslate"><span class="pre">getopt()</span></code></a> 函数在遇到非选项参数时停止处理选项，但在 GNU 风格模式下，处理会继续进行，这意味着选项和参数可以混合使用。例如：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">getopt</span><span class="o">.</span><span class="n">getopt</span><span class="p">([</span><span class="s1">&#39;-f&#39;</span><span class="p">,</span> <span class="s1">&#39;filename&#39;</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">,</span> <span class="s1">&#39;-v&#39;</span><span class="p">],</span> <span class="s1">&#39;f:v&#39;</span><span class="p">)</span>
<span class="go">([(&#39;-f&#39;, &#39;filename&#39;)], [&#39;output&#39;, &#39;-v&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getopt</span><span class="o">.</span><span class="n">gnu_getopt</span><span class="p">([</span><span class="s1">&#39;-f&#39;</span><span class="p">,</span> <span class="s1">&#39;filename&#39;</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">,</span> <span class="s1">&#39;-v&#39;</span><span class="p">],</span> <span class="s1">&#39;f:v&#39;</span><span class="p">)</span>
<span class="go">([(&#39;-f&#39;, &#39;filename&#39;), (&#39;-v&#39;, &#39;&#39;)], [&#39;output&#39;])</span>
</pre></div>
</div>
<p class="translated">（由 Peter Åstrand 贡献。）</p>
</li>
<li><p class="translated">现在 <a class="reference internal" href="../library/grp.html#module-grp" title="grp: The group database (getgrnam() and friends). (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">grp</span></code></a>, <a class="reference internal" href="../library/pwd.html#module-pwd" title="pwd: The password database (getpwnam() and friends). (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pwd</span></code></a> 和 <a class="reference internal" href="../library/resource.html#module-resource" title="resource: An interface to provide resource usage information on the current process. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">resource</span></code></a> 模块将返回加强版的元组:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">grp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">grp</span><span class="o">.</span><span class="n">getgrnam</span><span class="p">(</span><span class="s1">&#39;amk&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">gr_name</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">gr_gid</span>
<span class="go">(&#39;amk&#39;, 500)</span>
</pre></div>
</div>
</li>
<li><p class="translated">现在 <a class="reference internal" href="../library/gzip.html#module-gzip" title="gzip: Interfaces for gzip compression and decompression using file objects."><code class="xref py py-mod docutils literal notranslate"><span class="pre">gzip</span></code></a> 模块能够处理超过 2 GiB 的文件。</p></li>
<li><p class="translated">新的 <a class="reference internal" href="../library/heapq.html#module-heapq" title="heapq: Heap queue algorithm (a.k.a. priority queue)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">heapq</span></code></a> 模块包含了一个堆队列算法的实现。堆是一种类似数组的的数据结构，它保持元素处于部分排序状态，对于每个索引 <em>k</em>，满足 <code class="docutils literal notranslate"><span class="pre">heap[k]</span> <span class="pre">&lt;=</span> <span class="pre">heap[2*k+1]</span></code> 和 <code class="docutils literal notranslate"><span class="pre">heap[k]</span> <span class="pre">&lt;=</span> <span class="pre">heap[2*k+2]</span></code>。这使得快速移除最小元素变得容易，同时插入新元素并保持堆属性的时间复杂度为 <em>O</em>(log <em>n</em>)。（更多信息请参见 <a class="reference external" href="https://xlinux.nist.gov/dads//HTML/priorityque.html">https://xlinux.nist.gov/dads//HTML/priorityque.html</a>，了解优先队列数据结构。）</p>
<p class="translated">模块 <a class="reference internal" href="../library/heapq.html#module-heapq" title="heapq: Heap queue algorithm (a.k.a. priority queue)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">heapq</span></code></a> 提供了 <a class="reference internal" href="../library/heapq.html#heapq.heappush" title="heapq.heappush"><code class="xref py py-func docutils literal notranslate"><span class="pre">heappush()</span></code></a> 和 <a class="reference internal" href="../library/heapq.html#heapq.heappop" title="heapq.heappop"><code class="xref py py-func docutils literal notranslate"><span class="pre">heappop()</span></code></a> 函数，用于在保持堆属性的同时，对某些其他可变的 Python 序列类型添加和移除元素。以下是一个使用 Python 列表的示例：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">heapq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">heap</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
<span class="gp">... </span>   <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">heap</span>
<span class="go">[1, 3, 5, 11, 7]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">heap</span>
<span class="go">[5, 7, 11]</span>
</pre></div>
</div>
<p class="translated">（由 Kevin O'Connor 贡献。）</p>
</li>
<li><p class="translated">集成开发环境 IDLE 已使用 IDLEfork 项目（<a class="reference external" href="https://idlefork.sourceforge.net">https://idlefork.sourceforge.net</a>）的代码进行更新。最显著的功能是，正在开发的代码现在在子进程中执行，这意味着不再需要手动执行 <code class="docutils literal notranslate"><span class="pre">reload()</span></code> 操作。IDLE 的核心代码已作为 <a class="reference internal" href="../library/idle.html#module-idlelib" title="idlelib: Implementation package for the IDLE shell/editor."><code class="xref py py-mod docutils literal notranslate"><span class="pre">idlelib</span></code></a> 包纳入标准库。</p></li>
<li><p class="translated">模块 <a class="reference internal" href="../library/imaplib.html#module-imaplib" title="imaplib: IMAP4 protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">imaplib</span></code></a> 现在支持通过 SSL 的 IMAP。（由 Piers Lauder 和 Tino Lange 贡献。）</p></li>
<li><p class="translated">模块 <a class="reference internal" href="../library/itertools.html#module-itertools" title="itertools: Functions creating iterators for efficient looping."><code class="xref py py-mod docutils literal notranslate"><span class="pre">itertools</span></code></a> 包含了许多用于迭代器的实用函数，灵感来自 ML 和 Haskell 语言提供的各种函数。例如，<code class="docutils literal notranslate"><span class="pre">itertools.ifilter(predicate,</span> <span class="pre">iterator)</span></code> 返回迭代器中所有使函数 <code class="xref py py-func docutils literal notranslate"><span class="pre">predicate()</span></code> 返回 <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> 的元素，而 <code class="docutils literal notranslate"><span class="pre">itertools.repeat(obj,</span> <span class="pre">N)</span></code> 返回 <code class="docutils literal notranslate"><span class="pre">obj</span></code> <em>N</em> 次。模块中还有许多其他函数；详细信息请参阅包的参考文档。（由 Raymond Hettinger 贡献。）</p></li>
<li><p class="translated">模块 <a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> 中新增了两个函数，<code class="docutils literal notranslate"><span class="pre">degrees(rads)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">radians(degs)</span></code>，用于在弧度和度之间进行转换。模块 <a class="reference internal" href="../library/math.html#module-math" title="math: Mathematical functions (sin() etc.)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">math</span></code></a> 中的其他函数，如 <a class="reference internal" href="../library/math.html#math.sin" title="math.sin"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.sin()</span></code></a> 和 <a class="reference internal" href="../library/math.html#math.cos" title="math.cos"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.cos()</span></code></a>，一直需要以弧度为单位输入值。此外，<a class="reference internal" href="../library/math.html#math.log" title="math.log"><code class="xref py py-func docutils literal notranslate"><span class="pre">math.log()</span></code></a> 函数增加了一个可选的 <em>base</em> 参数，以便更容易计算除 <code class="docutils literal notranslate"><span class="pre">e</span></code> 和 <code class="docutils literal notranslate"><span class="pre">10</span></code> 以外的对数。（由 Raymond Hettinger 贡献。）</p></li>
<li><p class="translated">模块 <a class="reference internal" href="../library/posix.html#module-posix" title="posix: The most common POSIX system calls (normally used via module os). (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">posix</span></code></a> 中新增了几个 POSIX 函数（<code class="xref py py-func docutils literal notranslate"><span class="pre">getpgid()</span></code>、<code class="xref py py-func docutils literal notranslate"><span class="pre">killpg()</span></code>、<code class="xref py py-func docutils literal notranslate"><span class="pre">lchown()</span></code>、<code class="xref py py-func docutils literal notranslate"><span class="pre">loadavg()</span></code>、<code class="xref py py-func docutils literal notranslate"><span class="pre">major()</span></code>、<code class="xref py py-func docutils literal notranslate"><span class="pre">makedev()</span></code>、<code class="xref py py-func docutils literal notranslate"><span class="pre">minor()</span></code> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">mknod()</span></code>），该模块是 <a class="reference internal" href="../library/os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os</span></code></a> 模块的基础。（由 Gustavo Niemeyer、Geert Jansen 和 Denis S. Otkidach 贡献。）</p></li>
<li><p class="translated">在模块 <a class="reference internal" href="../library/os.html#module-os" title="os: Miscellaneous operating system interfaces."><code class="xref py py-mod docutils literal notranslate"><span class="pre">os</span></code></a> 中，<code class="xref py py-func docutils literal notranslate"><span class="pre">*stat()</span></code> 函数家族现在可以报告时间戳中的秒数分数。此类时间戳表示为浮点数，类似于 <a class="reference internal" href="../library/time.html#time.time" title="time.time"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.time()</span></code></a> 返回的值。</p>
<p class="translated">在测试过程中发现，某些应用程序在时间戳为浮点数时会崩溃。为了兼容性，当使用 <a class="reference internal" href="../library/os.html#os.stat_result" title="os.stat_result"><code class="xref py py-class docutils literal notranslate"><span class="pre">stat_result</span></code></a> 的元组接口时，时间戳将表示为整数。当使用命名字段（Python 2.2 首次引入的特性）时，时间戳仍然表示为整数，除非调用 <code class="xref py py-func docutils literal notranslate"><span class="pre">os.stat_float_times()</span></code> 以启用浮点数返回值:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="s2">&quot;/tmp&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">st_mtime</span>
<span class="go">1034791200</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">stat_float_times</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="s2">&quot;/tmp&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">st_mtime</span>
<span class="go">1034791200.6335014</span>
</pre></div>
</div>
<p class="translated">在 Python 2.4 中，默认将改为总是返回浮点数。</p>
<p class="translated">应用开发者应仅在所有库在面对浮点时间戳时均能正常工作，或者使用元组API时启用此功能。如果使用，该功能应在应用级别激活，而不是尝试在每次使用时启用。</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/optparse.html#module-optparse" title="optparse: Command-line option parsing library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">optparse</span></code></a> 模块包含一个新的命令行参数解析器，可以将选项值转换为特定的Python类型，并自动生成使用说明。更多详情请参见下一节。</p></li>
<li><p class="translated">旧的且从未文档化的 <code class="xref py py-mod docutils literal notranslate"><span class="pre">linuxaudiodev</span></code> 模块已被弃用，新增了一个名为 <code class="xref py py-mod docutils literal notranslate"><span class="pre">ossaudiodev</span></code> 的新版本。该模块被重命名是因为OSS声音驱动可以在除Linux之外的其他平台上使用，且接口也进行了整理和更新。（由Greg Ward和Nicholas FitzRoy-Dale贡献。）</p></li>
<li><p class="translated">新的 <a class="reference internal" href="../library/platform.html#module-platform" title="platform: Retrieves as much platform identifying data as possible."><code class="xref py py-mod docutils literal notranslate"><span class="pre">platform</span></code></a> 模块包含多个函数，尝试确定你正在运行的平台的各项属性。有获取架构、CPU类型、Windows操作系统版本，甚至Linux发行版版本的函数。（由Marc-André Lemburg贡献。）</p></li>
<li><p class="translated"><a class="reference internal" href="../library/pyexpat.html#module-xml.parsers.expat" title="xml.parsers.expat: An interface to the Expat non-validating XML parser."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pyexpat</span></code></a> 模块提供的解析器对象现在可以选择性地缓冲字符数据，从而减少对字符数据处理器的调用，提高性能。将解析器对象的 <a class="reference internal" href="../library/pyexpat.html#xml.parsers.expat.xmlparser.buffer_text" title="xml.parsers.expat.xmlparser.buffer_text"><code class="xref py py-attr docutils literal notranslate"><span class="pre">buffer_text</span></code></a> 属性设置为 <a class="reference internal" href="../library/constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> 将启用缓冲。</p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">sample(population,</span> <span class="pre">k)</span></code> 函数已添加到 <a class="reference internal" href="../library/random.html#module-random" title="random: Generate pseudo-random numbers with various common distributions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">random</span></code></a> 模块中。<em>population</em> 是一个包含种群元素的序列或 <code class="xref py py-class docutils literal notranslate"><span class="pre">xrange</span></code> 对象，<a class="reference internal" href="../library/random.html#random.sample" title="random.sample"><code class="xref py py-func docutils literal notranslate"><span class="pre">sample()</span></code></a> 从种群中不重复地选择 <em>k</em> 个元素。<em>k</em> 可以是任何不超过 <code class="docutils literal notranslate"><span class="pre">len(population)</span></code> 的值。例如：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">days</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Mo&#39;</span><span class="p">,</span> <span class="s1">&#39;Tu&#39;</span><span class="p">,</span> <span class="s1">&#39;We&#39;</span><span class="p">,</span> <span class="s1">&#39;Th&#39;</span><span class="p">,</span> <span class="s1">&#39;Fr&#39;</span><span class="p">,</span> <span class="s1">&#39;St&#39;</span><span class="p">,</span> <span class="s1">&#39;Sn&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">days</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>      <span class="c1"># 选择 3 个元素</span>
<span class="go">[&#39;St&#39;, &#39;Sn&#39;, &#39;Th&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">days</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>      <span class="c1"># 选择 7 个元素</span>
<span class="go">[&#39;Tu&#39;, &#39;Th&#39;, &#39;Mo&#39;, &#39;We&#39;, &#39;St&#39;, &#39;Fr&#39;, &#39;Sn&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">days</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>      <span class="c1"># 再次选择 7 个</span>
<span class="go">[&#39;We&#39;, &#39;Mo&#39;, &#39;Sn&#39;, &#39;Fr&#39;, &#39;Tu&#39;, &#39;St&#39;, &#39;Th&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">days</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>      <span class="c1"># 无法选择八个</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">?</span>
  File <span class="nb">&quot;random.py&quot;</span>, line <span class="m">414</span>, in <span class="n">sample</span>
<span class="w">    </span>  <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s2">&quot;sample larger than population&quot;</span>
<span class="gr">ValueError</span>: <span class="n">sample larger than population</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">10000</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="mi">10</span><span class="p">)</span>   <span class="c1"># Choose ten odd nos. under 10000</span>
<span class="go">[3407, 3805, 1505, 7023, 2401, 2267, 9733, 3151, 8083, 9195]</span>
</pre></div>
</div>
<p class="translated">现在 <a class="reference internal" href="../library/random.html#module-random" title="random: Generate pseudo-random numbers with various common distributions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">random</span></code></a> 模块使用新的“梅森旋转”算法，并以 C 实现。 它的速度更快并且与之前的算法相比研究更充分。</p>
<p class="translated">（所有改变均由 Raymond Hettinger 贡献。）</p>
</li>
<li><p class="translated"><a class="reference internal" href="../library/readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">readline</span></code></a> 模块也增加了几个新函数: <a class="reference internal" href="../library/readline.html#readline.get_history_item" title="readline.get_history_item"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_history_item()</span></code></a>, <a class="reference internal" href="../library/readline.html#readline.get_current_history_length" title="readline.get_current_history_length"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_current_history_length()</span></code></a> 和 <a class="reference internal" href="../library/readline.html#readline.redisplay" title="readline.redisplay"><code class="xref py py-func docutils literal notranslate"><span class="pre">redisplay()</span></code></a>。</p></li>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">rexec</span></code> 和 <code class="xref py py-mod docutils literal notranslate"><span class="pre">Bastion</span></code> 模块已被宣布废弃，尝试导入它们将会引发 <a class="reference internal" href="../library/exceptions.html#RuntimeError" title="RuntimeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> 异常。新式类提供了新的方法来突破 <code class="xref py py-mod docutils literal notranslate"><span class="pre">rexec</span></code> 提供的受限执行环境，并且没有人有兴趣或时间去修复它们。如果你的应用程序使用了 <code class="xref py py-mod docutils literal notranslate"><span class="pre">rexec</span></code>，请重写它们以使用其他替代方案。</p>
<p class="translated">（继续使用 Python 2.2 或 2.1 不会使你的应用程序更安全，因为这些版本中的 <code class="xref py py-mod docutils literal notranslate"><span class="pre">rexec</span></code> 模块存在已知漏洞。重申：如果你正在使用 <code class="xref py py-mod docutils literal notranslate"><span class="pre">rexec</span></code>，请立即停止使用。）</p>
</li>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">rotor</span></code> 模块已被弃用，因为它使用的加密算法被认为是不安全的。如果你需要加密，请使用单独提供的几种 AES Python 模块之一。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/shutil.html#module-shutil" title="shutil: High-level file operations, including copying."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shutil</span></code></a> 模块新增了一个 <code class="docutils literal notranslate"><span class="pre">move(src,</span> <span class="pre">dest)</span></code> 函数，用于递归地将文件或目录移动到新位置。</p></li>
<li><p class="translated">对更高级的 POSIX 信号处理的支持已添加到 <a class="reference internal" href="../library/signal.html#module-signal" title="signal: Set handlers for asynchronous events."><code class="xref py py-mod docutils literal notranslate"><span class="pre">signal</span></code></a> 模块中，但随后又因无法在各个平台间可靠地工作而被移除。</p></li>
<li><p class="translated"><a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> 模块现在支持超时设置。你可以在套接字对象上调用 <code class="docutils literal notranslate"><span class="pre">settimeout(t)</span></code> 方法来设置 <em>t</em> 秒的超时时间。后续的套接字操作如果超过 <em>t</em> 秒未完成将被中止，并引发 <a class="reference internal" href="../library/socket.html#socket.timeout" title="socket.timeout"><code class="xref py py-exc docutils literal notranslate"><span class="pre">socket.timeout</span></code></a> 异常。</p>
<p class="translated">最初的超时实现由 Tim O'Malley 完成。Michael Gilfix 将其集成到 Python 的 <a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> 模块中，并经过长时间的审查。代码提交后，Guido van Rossum 重写了部分内容。（这是一个协作开发过程的良好示例。）</p>
</li>
<li><p class="translated">在 Windows，<a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> 模块现在将附带安全套接字层（SSL）支持。</p></li>
<li><p class="translated">现在 C <code class="xref c c-macro docutils literal notranslate"><span class="pre">PYTHON_API_VERSION</span></code> 宏的值将在 Python 层级上暴露为 <code class="docutils literal notranslate"><span class="pre">sys.api_version</span></code>。 当前的异常可通过调用新的 <code class="xref py py-func docutils literal notranslate"><span class="pre">sys.exc_clear()</span></code> 函数来清除。</p></li>
<li><p class="translated">新的 <a class="reference internal" href="../library/tarfile.html#module-tarfile" title="tarfile: Read and write tar-format archive files."><code class="xref py py-mod docutils literal notranslate"><span class="pre">tarfile</span></code></a> 模块允许读取和写入 <strong class="program">tar</strong>格式的归档文件。（由 Lars Gustäbel 贡献。)</p></li>
<li><p class="translated">新的 <a class="reference internal" href="../library/textwrap.html#module-textwrap" title="textwrap: Text wrapping and filling"><code class="xref py py-mod docutils literal notranslate"><span class="pre">textwrap</span></code></a> 模块包含用于包装包含段落文本的字符串的函数。<code class="docutils literal notranslate"><span class="pre">wrap(text,</span> <span class="pre">width)</span></code> 函数接收一个字符串，并返回一个列表，其中包含将文本拆分为不超过所选宽度的行。<code class="docutils literal notranslate"><span class="pre">fill(text,</span> <span class="pre">width)</span></code> 函数返回一个单个字符串，重新格式化以适应不超过所选宽度的行。（如你所料，<a class="reference internal" href="../library/textwrap.html#textwrap.fill" title="textwrap.fill"><code class="xref py py-func docutils literal notranslate"><span class="pre">fill()</span></code></a> 是基于 <a class="reference internal" href="../library/textwrap.html#textwrap.wrap" title="textwrap.wrap"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap()</span></code></a> 构建的。例如:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">textwrap</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">paragraph</span> <span class="o">=</span> <span class="s2">&quot;Not a whit, we defy augury: ... more text ...&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">textwrap</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">paragraph</span><span class="p">,</span> <span class="mi">60</span><span class="p">)</span>
<span class="go">[&quot;Not a whit, we defy augury: there&#39;s a special providence in&quot;,</span>
<span class="go"> &quot;the fall of a sparrow. If it be now, &#39;tis not to come; if it&quot;,</span>
<span class="go"> ...]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">paragraph</span><span class="p">,</span> <span class="mi">35</span><span class="p">)</span>
<span class="go">Not a whit, we defy augury: there&#39;s</span>
<span class="go">a special providence in the fall of</span>
<span class="go">a sparrow. If it be now, &#39;tis not</span>
<span class="go">to come; if it be not to come, it</span>
<span class="go">will be now; if it be not now, yet</span>
<span class="go">it will come: the readiness is all.</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">该模块还包含一个 <a class="reference internal" href="../library/textwrap.html#textwrap.TextWrapper" title="textwrap.TextWrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextWrapper</span></code></a> 类，实际实现了文本包装策略。<a class="reference internal" href="../library/textwrap.html#textwrap.TextWrapper" title="textwrap.TextWrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">TextWrapper</span></code></a> 类和 <a class="reference internal" href="../library/textwrap.html#textwrap.wrap" title="textwrap.wrap"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap()</span></code></a> 以及 <a class="reference internal" href="../library/textwrap.html#textwrap.fill" title="textwrap.fill"><code class="xref py py-func docutils literal notranslate"><span class="pre">fill()</span></code></a> 函数都支持多个额外的关键字参数，用于微调格式；详情请参阅模块文档。（由 Greg Ward 贡献。）</p>
</li>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">thread</span></code> 和 <a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> 模块现在有配套模块 <code class="xref py py-mod docutils literal notranslate"><span class="pre">dummy_thread</span></code> 和 <code class="xref py py-mod docutils literal notranslate"><span class="pre">dummy_threading</span></code>，为不支持线程的平台提供了 <code class="xref py py-mod docutils literal notranslate"><span class="pre">thread</span></code> 模块接口的空实现。目的是通过在顶部放置以下代码来简化线程感知模块（那些不依赖线程运行的模块):</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">threading</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_threading</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">dummy_threading</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_threading</span>
</pre></div>
</div>
<p class="translated">在此示例中，<code class="xref py py-mod docutils literal notranslate"><span class="pre">_threading</span></code> 用作模块名称，以明确所使用的模块不一定是实际的 <a class="reference internal" href="../library/threading.html#module-threading" title="threading: Thread-based parallelism."><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> 模块。代码可以调用 <code class="xref py py-mod docutils literal notranslate"><span class="pre">_threading</span></code> 中的函数并使用其类，无论是否支持线程，从而避免使用 <a class="reference internal" href="../reference/compound_stmts.html#if"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">if</span></code></a> 语句，并使代码略显清晰。此模块不会神奇地使多线程代码在没有线程的情况下运行；等待另一个线程返回或执行某事的代码将永远挂起。</p>
</li>
<li><p class="translated">模块 <a class="reference internal" href="../library/time.html#module-time" title="time: Time access and conversions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">time</span></code></a> 的 <a class="reference internal" href="../library/time.html#time.strptime" title="time.strptime"><code class="xref py py-func docutils literal notranslate"><span class="pre">strptime()</span></code></a> 函数长期以来一直是个麻烦，因为它使用平台 C 库的 <a class="reference internal" href="../library/time.html#time.strptime" title="time.strptime"><code class="xref py py-func docutils literal notranslate"><span class="pre">strptime()</span></code></a> 实现，而不同平台有时会有奇怪的 bug。Brett Cannon 贡献了一个纯 Python 编写的便携实现，该实现应在所有平台上表现一致。</p></li>
<li><p class="translated">新的 <a class="reference internal" href="../library/timeit.html#module-timeit" title="timeit: Measure the execution time of small code snippets."><code class="xref py py-mod docutils literal notranslate"><span class="pre">timeit</span></code></a> 模块帮助测量 Python 代码片段执行所需的时间。文件 <code class="file docutils literal notranslate"><span class="pre">timeit.py</span></code> 可以直接从命令行运行，或者可以导入模块的 <a class="reference internal" href="../library/timeit.html#timeit.Timer" title="timeit.Timer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Timer</span></code></a> 类并直接使用。以下是一个简短示例，用于确定将 8 位字符串转换为 Unicode 是通过追加一个空 Unicode 字符串更快，还是使用 <code class="xref py py-func docutils literal notranslate"><span class="pre">unicode()</span></code> 函数更快：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">timeit</span>

<span class="n">timer1</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">Timer</span><span class="p">(</span><span class="s1">&#39;unicode(&quot;abc&quot;)&#39;</span><span class="p">)</span>
<span class="n">timer2</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">Timer</span><span class="p">(</span><span class="s1">&#39;&quot;abc&quot; + u&quot;&quot;&#39;</span><span class="p">)</span>

<span class="c1"># 运行三次试验</span>
<span class="nb">print</span> <span class="n">timer1</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">repeat</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="mi">100000</span><span class="p">)</span>
<span class="nb">print</span> <span class="n">timer2</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">repeat</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="mi">100000</span><span class="p">)</span>

<span class="c1"># 在我的笔记本电脑上输出如下：</span>
<span class="c1"># [0.36831796169281006, 0.37441694736480713, 0.35304892063140869]</span>
<span class="c1"># [0.17574405670166016, 0.18193507194519043, 0.17565798759460449]</span>
</pre></div>
</div>
</li>
<li><p class="translated">模块 <code class="xref py py-mod docutils literal notranslate"><span class="pre">Tix</span></code> 已收到针对当前版本 Tix 包的各种 bug 修复和更新。</p></li>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Tkinter</span></code> 模块现在可以与支持线程的 Tcl 版本一起工作。Tcl 的线程模型要求只能从创建它们的线程中访问小部件；从另一个线程访问可能会导致 Tcl 出现恐慌。对于某些 Tcl 接口，当从不同线程访问小部件时，<code class="xref py py-mod docutils literal notranslate"><span class="pre">Tkinter</span></code> 现在将自动避免这种情况，通过编组命令，将其传递给正确的线程，并等待结果。其他接口无法自动处理，但 <code class="xref py py-mod docutils literal notranslate"><span class="pre">Tkinter</span></code> 现在会在这种访问时引发异常，以便至少可以发现问题。有关此更改的更详细解释，请参阅 <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2002-December/031107.html">https://mail.python.org/pipermail/python-dev/2002-December/031107.html</a>。（由 Martin von Löwis 实现。）</p></li>
<li><p class="translated">通过 <code class="xref py py-mod docutils literal notranslate"><span class="pre">_tkinter</span></code> 调用 Tcl 方法不再仅返回字符串。相反，如果 Tcl 返回其他对象，这些对象将转换为它们的 Python 等效对象（如果存在的话），或者如果没有 Python 等效对象，则用 <code class="xref py py-class docutils literal notranslate"><span class="pre">_tkinter.Tcl_Obj</span></code> 对象包装。此行为可以通过 <code class="xref py py-class docutils literal notranslate"><span class="pre">tkapp</span></code> 对象的 <code class="xref py py-meth docutils literal notranslate"><span class="pre">wantobjects()</span></code> 方法进行控制。</p>
<p class="translated">当通过 <code class="xref py py-mod docutils literal notranslate"><span class="pre">Tkinter</span></code> 模块使用 <code class="xref py py-mod docutils literal notranslate"><span class="pre">_tkinter</span></code> (大多数 Tkinter 应用程序都会这样做) 时，此功能始终处于激活状态。它不应引起兼容性问题，因为 Tkinter 会尽可能将字符串结果转换为 Python 类型。</p>
<p class="translated">如果发现任何不兼容性，可以通过在创建第一个 <code class="xref py py-class docutils literal notranslate"><span class="pre">tkapp</span></code> 对象之前，将 <code class="xref py py-mod docutils literal notranslate"><span class="pre">Tkinter</span></code> 模块中的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">wantobjects</span></code> 变量设置为 false 来恢复旧的行为。:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">Tkinter</span>
<span class="n">Tkinter</span><span class="o">.</span><span class="n">wantobjects</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p class="translated">由此更改引起的任何问题都应作为错误报告。</p>
</li>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">UserDict</span></code> 模块新增了一个 <code class="xref py py-class docutils literal notranslate"><span class="pre">DictMixin</span></code> 类，该类为已具备最小映射接口的类定义了所有字典方法。这使得编写可替代字典的类变得大大简化，例如 <a class="reference internal" href="../library/shelve.html#module-shelve" title="shelve: Python object persistence."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shelve</span></code></a> 模块中的类。</p>
<p class="translated">添加该混入类作为超类将在类定义了 <a class="reference internal" href="../reference/datamodel.html#object.__getitem__" title="object.__getitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getitem__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code></a>, <a class="reference internal" href="../reference/datamodel.html#object.__delitem__" title="object.__delitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__delitem__()</span></code></a> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">keys()</span></code> 的时候提供完整的字典接口。 例如:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">UserDict</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">SeqDict</span><span class="p">(</span><span class="n">UserDict</span><span class="o">.</span><span class="n">DictMixin</span><span class="p">):</span>
<span class="gp">... </span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Dictionary lookalike implemented with lists.&quot;&quot;&quot;</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">keylist</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">valuelist</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keylist</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">raise</span> <span class="ne">KeyError</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">valuelist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keylist</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="gp">... </span>            <span class="bp">self</span><span class="o">.</span><span class="n">valuelist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
<span class="gp">... </span>        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
<span class="gp">... </span>            <span class="bp">self</span><span class="o">.</span><span class="n">keylist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="gp">... </span>            <span class="bp">self</span><span class="o">.</span><span class="n">valuelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keylist</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">raise</span> <span class="ne">KeyError</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">keylist</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">valuelist</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keylist</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">SeqDict</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>      <span class="c1"># See that other dictionary methods are implemented</span>
<span class="go">[&#39;__cmp__&#39;, &#39;__contains__&#39;, &#39;__delitem__&#39;, &#39;__doc__&#39;, &#39;__getitem__&#39;,</span>
<span class="go"> &#39;__init__&#39;, &#39;__iter__&#39;, &#39;__len__&#39;, &#39;__module__&#39;, &#39;__repr__&#39;,</span>
<span class="go"> &#39;__setitem__&#39;, &#39;clear&#39;, &#39;get&#39;, &#39;has_key&#39;, &#39;items&#39;, &#39;iteritems&#39;,</span>
<span class="go"> &#39;iterkeys&#39;, &#39;itervalues&#39;, &#39;keylist&#39;, &#39;keys&#39;, &#39;pop&#39;, &#39;popitem&#39;,</span>
<span class="go"> &#39;setdefault&#39;, &#39;update&#39;, &#39;valuelist&#39;, &#39;values&#39;]</span>
</pre></div>
</div>
<p class="translated">（由 Raymond Hettinger 贡献。）</p>
</li>
<li><p class="translated">现在 <a class="reference internal" href="../library/xml.dom.minidom.html#module-xml.dom.minidom" title="xml.dom.minidom: Minimal Document Object Model (DOM) implementation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xml.dom.minidom</span></code></a> 中的 DOM 实现能够通过向 DOM 节点的 <a class="reference internal" href="../library/xml.dom.minidom.html#xml.dom.minidom.Node.toxml" title="xml.dom.minidom.Node.toxml"><code class="xref py py-meth docutils literal notranslate"><span class="pre">toxml()</span></code></a> 和 <a class="reference internal" href="../library/xml.dom.minidom.html#xml.dom.minidom.Node.toprettyxml" title="xml.dom.minidom.Node.toprettyxml"><code class="xref py py-meth docutils literal notranslate"><span class="pre">toprettyxml()</span></code></a> 方法提供可选的 encoding 参数以特定的编码格式生成 XML 输出。</p></li>
<li><p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">xmlrpclib</span></code> 模块现在支持处理 nil 数据值（如 Python 的 <code class="docutils literal notranslate"><span class="pre">None</span></code>）的 XML-RPC 扩展。在解组 XML-RPC 响应时始终支持 nil 值。要生成包含 <code class="docutils literal notranslate"><span class="pre">None</span></code> 的请求，必须在创建 <code class="xref py py-class docutils literal notranslate"><span class="pre">Marshaller</span></code> 实例时为 <em>allow_none</em> 参数提供真值。</p></li>
<li><p class="translated">新的 <code class="xref py py-mod docutils literal notranslate"><span class="pre">DocXMLRPCServer</span></code> 模块允许编写自文档化的 XML-RPC 服务器。以演示模式（作为程序）运行它以查看其效果。将网页浏览器指向 RPC 服务器将生成 pydoc 风格的文档；将 xmlrpclib 指向服务器则允许调用实际方法。（由 Brian Quinlan 贡献。）</p></li>
<li><p class="translated">已添加对国际化域名（RFC 3454、3490、3491 和 3492）的支持。可以使用 &quot;idna&quot; 编码在 Unicode 域名和该名称的 ASCII 兼容编码（ACE）之间进行转换。:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="p">{}</span><span class="o">&gt;</span><span class="p">{}</span><span class="o">&gt;</span> <span class="sa">u</span><span class="s2">&quot;www.Alliancefrançaise.nu&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;idna&quot;</span><span class="p">)</span>
<span class="s1">&#39;www.xn--alliancefranaise-npb.nu&#39;</span>
</pre></div>
</div>
<p class="translated"><a class="reference internal" href="../library/socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> 模块也已扩展，能够在将 Unicode 主机名传递给 C 库之前透明地将其转换为 ACE 版本。处理主机名的模块（如 <code class="xref py py-mod docutils literal notranslate"><span class="pre">httplib</span></code> 和 <a class="reference internal" href="../library/ftplib.html#module-ftplib" title="ftplib: FTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ftplib</span></code></a>）也支持 Unicode 主机名；<code class="xref py py-mod docutils literal notranslate"><span class="pre">httplib</span></code> 还使用域名的 ACE 版本发送 HTTP <code class="docutils literal notranslate"><span class="pre">Host</span></code> 头。<a class="reference internal" href="../library/urllib.html#module-urllib" title="urllib"><code class="xref py py-mod docutils literal notranslate"><span class="pre">urllib</span></code></a> 支持带有非 ASCII 主机名的 Unicode URL，只要 URL 的 <code class="docutils literal notranslate"><span class="pre">path</span></code> 部分为 ASCII 即可。</p>
<p class="translated">为实现此项更改，增加了 <a class="reference internal" href="../library/stringprep.html#module-stringprep" title="stringprep: String preparation, as per RFC 3453"><code class="xref py py-mod docutils literal notranslate"><span class="pre">stringprep</span></code></a> 模块，<code class="docutils literal notranslate"><span class="pre">mkstringprep</span></code> 工具以及 <code class="docutils literal notranslate"><span class="pre">punycode</span></code> 编码格式。</p>
</li>
</ul>
<section id="date-time-type">
<h3 class="translated">Date/Time 类型<a class="headerlink" href="#date-time-type" title="Link to this heading">¶</a></h3>
<p class="translated">通过 <a class="reference internal" href="../library/datetime.html#module-datetime" title="datetime: Basic date and time types."><code class="xref py py-mod docutils literal notranslate"><span class="pre">datetime</span></code></a> 模块增加了适用于表示时间戳的日期和时间类型。 这些类型并不支持其他的历法或很多丰富的特性，只专注于简单地表示时间。</p>
<p class="translated">三种主要类型是：<a class="reference internal" href="../library/datetime.html#datetime.date" title="datetime.date"><code class="xref py py-class docutils literal notranslate"><span class="pre">date</span></code></a>，表示天、月和年；<a class="reference internal" href="../library/datetime.html#datetime.time" title="datetime.time"><code class="xref py py-class docutils literal notranslate"><span class="pre">time</span></code></a>，包含小时、分钟和秒；以及 <a class="reference internal" href="../library/datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime</span></code></a>，包含 <a class="reference internal" href="../library/datetime.html#datetime.date" title="datetime.date"><code class="xref py py-class docutils literal notranslate"><span class="pre">date</span></code></a> 和 <a class="reference internal" href="../library/datetime.html#datetime.time" title="datetime.time"><code class="xref py py-class docutils literal notranslate"><span class="pre">time</span></code></a> 的所有属性。还有一个 <a class="reference internal" href="../library/datetime.html#datetime.timedelta" title="datetime.timedelta"><code class="xref py py-class docutils literal notranslate"><span class="pre">timedelta</span></code></a> 类，表示两个时间点之间的差异，时区逻辑由继承自抽象 <a class="reference internal" href="../library/datetime.html#datetime.tzinfo" title="datetime.tzinfo"><code class="xref py py-class docutils literal notranslate"><span class="pre">tzinfo</span></code></a> 类的类实现。</p>
<p class="translated">你可以通过向适当的构造函数提供关键字参数来创建 <a class="reference internal" href="../library/datetime.html#datetime.date" title="datetime.date"><code class="xref py py-class docutils literal notranslate"><span class="pre">date</span></code></a> 和 <a class="reference internal" href="../library/datetime.html#datetime.time" title="datetime.time"><code class="xref py py-class docutils literal notranslate"><span class="pre">time</span></code></a> 的实例，例如 <code class="docutils literal notranslate"><span class="pre">datetime.date(year=1972,</span> <span class="pre">month=10,</span> <span class="pre">day=15)</span></code>，或者使用许多类方法之一。例如，<a class="reference internal" href="../library/datetime.html#datetime.date.today" title="datetime.date.today"><code class="xref py py-meth docutils literal notranslate"><span class="pre">today()</span></code></a> 类方法返回当前本地日期。</p>
<p class="translated">一旦创建，日期/时间类的实例都是不可变的。有几种方法可以从对象生成格式化字符串：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">datetime</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">now</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span>
<span class="go">&#39;2002-12-30T21:27:03.994956&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">now</span><span class="o">.</span><span class="n">ctime</span><span class="p">()</span>  <span class="c1"># 仅在date, datetime上可用</span>
<span class="go">&#39;Mon Dec 30 21:27:03 2002&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y </span><span class="si">%d</span><span class="s1"> %b&#39;</span><span class="p">)</span>
<span class="go">&#39;2002 30 Dec&#39;</span>
</pre></div>
</div>
<p class="translated"><a class="reference internal" href="../library/datetime.html#datetime.datetime.replace" title="datetime.datetime.replace"><code class="xref py py-meth docutils literal notranslate"><span class="pre">replace()</span></code></a> 方法允许修改 <a class="reference internal" href="../library/datetime.html#datetime.date" title="datetime.date"><code class="xref py py-class docutils literal notranslate"><span class="pre">date</span></code></a> 或 <a class="reference internal" href="../library/datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime</span></code></a> 实例的一个或多个字段，返回一个新的实例：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">datetime.datetime(2002, 12, 30, 22, 15, 38, 827738)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">year</span><span class="o">=</span><span class="mi">2001</span><span class="p">,</span> <span class="n">hour</span> <span class="o">=</span> <span class="mi">12</span><span class="p">)</span>
<span class="go">datetime.datetime(2001, 12, 30, 12, 15, 38, 827738)</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">实例可以进行比较、哈希和转换为字符串（结果与 <a class="reference internal" href="../library/datetime.html#datetime.datetime.isoformat" title="datetime.datetime.isoformat"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isoformat()</span></code></a> 相同）。<a class="reference internal" href="../library/datetime.html#datetime.date" title="datetime.date"><code class="xref py py-class docutils literal notranslate"><span class="pre">date</span></code></a> 和 <a class="reference internal" href="../library/datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime</span></code></a> 实例可以相互减去，并且可以添加到 <a class="reference internal" href="../library/datetime.html#datetime.timedelta" title="datetime.timedelta"><code class="xref py py-class docutils literal notranslate"><span class="pre">timedelta</span></code></a> 实例。最大的缺失功能是标准库不支持解析字符串并返回 <a class="reference internal" href="../library/datetime.html#datetime.date" title="datetime.date"><code class="xref py py-class docutils literal notranslate"><span class="pre">date</span></code></a> 或 <a class="reference internal" href="../library/datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime</span></code></a>。</p>
<p class="translated">更多相关信息，请参阅模块的参考文档。 （由 Tim Peters 贡献。）</p>
</section>
<section id="the-optparse-module">
<h3 class="translated">optparse 模块<a class="headerlink" href="#the-optparse-module" title="Link to this heading">¶</a></h3>
<p class="translated"><a class="reference internal" href="../library/getopt.html#module-getopt" title="getopt: Portable parser for command line options; support both short and long option names."><code class="xref py py-mod docutils literal notranslate"><span class="pre">getopt</span></code></a> 模块提供了简单的命令行参数解析。新的 <a class="reference internal" href="../library/optparse.html#module-optparse" title="optparse: Command-line option parsing library."><code class="xref py py-mod docutils literal notranslate"><span class="pre">optparse</span></code></a> 模块（原名Optik）提供了更复杂的命令行解析，遵循Unix约定，自动创建 <code class="xref std std-option docutils literal notranslate"><span class="pre">--help</span></code> 的输出，并且可以为不同的选项执行不同的操作。</p>
<p class="translated">首先，创建一个 <a class="reference internal" href="../library/optparse.html#optparse.OptionParser" title="optparse.OptionParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptionParser</span></code></a> 的实例，并告诉它你的程序有哪些选项。:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">optparse</span><span class="w"> </span><span class="kn">import</span> <span class="n">OptionParser</span>

<span class="n">op</span> <span class="o">=</span> <span class="n">OptionParser</span><span class="p">()</span>
<span class="n">op</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s1">&#39;-i&#39;</span><span class="p">,</span> <span class="s1">&#39;--input&#39;</span><span class="p">,</span>
              <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;string&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;input&#39;</span><span class="p">,</span>
              <span class="n">help</span><span class="o">=</span><span class="s1">&#39;设置输入文件名&#39;</span><span class="p">)</span>
<span class="n">op</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span><span class="s1">&#39;-l&#39;</span><span class="p">,</span> <span class="s1">&#39;--length&#39;</span><span class="p">,</span>
              <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;length&#39;</span><span class="p">,</span>
              <span class="n">help</span><span class="o">=</span><span class="s1">&#39;设置输出最大长度&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">通过调用 <a class="reference internal" href="../library/optparse.html#optparse.OptionParser.parse_args" title="optparse.OptionParser.parse_args"><code class="xref py py-meth docutils literal notranslate"><span class="pre">parse_args()</span></code></a> 方法来解析命令行。:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">options</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
<span class="nb">print</span> <span class="n">options</span>
<span class="nb">print</span> <span class="n">args</span>
</pre></div>
</div>
<p class="translated">这将返回一个包含所有选项值的对象，以及一个包含剩余参数的字符串列表。</p>
<p class="translated">现在，使用各种参数调用脚本将按预期工作。请注意，长度参数会自动转换为整数。</p>
<div class="translated highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>./python<span class="w"> </span>opt.py<span class="w"> </span>-i<span class="w"> </span>data<span class="w"> </span>arg1
<span class="go">&lt;Values at 0x400cad4c: {&#39;input&#39;: &#39;data&#39;, &#39;length&#39;: None}&gt;</span>
<span class="go">[&#39;arg1&#39;]</span>
<span class="gp">$ </span>./python<span class="w"> </span>opt.py<span class="w"> </span>--input<span class="o">=</span>data<span class="w"> </span>--length<span class="o">=</span><span class="m">4</span>
<span class="go">&lt;Values at 0x400cad2c: {&#39;input&#39;: &#39;data&#39;, &#39;length&#39;: 4}&gt;</span>
<span class="go">[]</span>
<span class="gp">$</span>
</pre></div>
</div>
<p class="translated">帮助信息会自动为你生成：</p>
<div class="translated highlight-shell-session notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>./python<span class="w"> </span>opt.py<span class="w"> </span>--help
<span class="go">用法：opt.py [选项]</span>

<span class="go">选项：</span>
<span class="go">  -h, --help            显示此帮助信息并退出</span>
<span class="go">  -iINPUT, --input=INPUT</span>
<span class="go">                        设置输入文件名</span>
<span class="go">  -lLENGTH, --length=LENGTH</span>
<span class="go">                        设置输出最大长度</span>
<span class="gp">$</span>
</pre></div>
</div>
<p class="translated">有关更多详细信息，请参见模块的文档。</p>
<p class="translated">Optik 由 Greg Ward 编写，吸收了 Getopt SIG 读者的建议。</p>
</section>
</section>
<section id="pymalloc-a-specialized-object-allocator">
<span id="section-pymalloc"></span><h2 class="translated">Pymalloc：一种专用对象分配器<a class="headerlink" href="#pymalloc-a-specialized-object-allocator" title="Link to this heading">¶</a></h2>
<p class="translated">Pymalloc 是由 Vladimir Marangozov 编写的一种专用对象分配器，作为特性添加到 Python 2.1 中。Pymalloc 旨在比系统的 <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> 更快，并且对于典型的 Python 程序分配模式具有更低的内存开销。该分配器使用 C 的 <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> 函数获取大内存池，然后从这些池中满足较小的内存请求。</p>
<p class="translated">在 2.1 和 2.2 版中，pymalloc 是一个实验性特性，默认不启用；你必须在编译 Python 时通过向 <strong class="program">configure</strong> 脚本提供 <code class="xref std std-option docutils literal notranslate"><span class="pre">--with-pymalloc</span></code> 选项来显式启用它。在 2.3 版中，pymalloc 进行了进一步改进，现在默认启用；你需要提供 <code class="xref std std-option docutils literal notranslate"><span class="pre">--without-pymalloc</span></code> 选项来禁用它。</p>
<p class="translated">这一更改对用 Python 编写的代码是透明的；然而，pymalloc 可能会暴露 C 扩展中的错误。C 扩展模块的作者应该测试其代码在 pymalloc 启用时的表现，因为一些不正确的代码可能导致运行时核心转储。</p>
<p class="translated">有一个特别常见的错误会导致问题。Python的C API中有许多内存分配函数，之前只是C库中 <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> 和 <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code> 的别名，这意味着如果你不小心调用了不匹配的函数，错误可能不会被注意到。当对象分配器启用时，这些函数不再是 <code class="xref c c-func docutils literal notranslate"><span class="pre">malloc()</span></code> 和 <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code> 的别名，调用错误的函数来释放内存可能会导致核心转储。例如，如果内存是使用 <a class="reference internal" href="../c-api/memory.html#c.PyObject_Malloc" title="PyObject_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Malloc()</span></code></a> 分配的，它必须使用 <a class="reference internal" href="../c-api/memory.html#c.PyObject_Free" title="PyObject_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Free()</span></code></a> 来释放，而不是 <code class="xref c c-func docutils literal notranslate"><span class="pre">free()</span></code>。Python自带的一些模块就遇到了这个问题，并且必须修复；毫无疑问，还有更多的第三方模块也会存在同样的问题。</p>
<p class="translated">作为这一变化的一部分，令人困惑的多种内存分配接口已被整合为两个API家族。使用一个家族分配的内存不得使用另一个家族的函数进行操作。有一个家族用于分配内存块，另一个家族的函数专门用于分配Python对象。</p>
<ul class="simple">
<li><p class="translated">要分配和释放一个普通的内存块，使用“原始内存”家族：<a class="reference internal" href="../c-api/memory.html#c.PyMem_Malloc" title="PyMem_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Malloc()</span></code></a>，<a class="reference internal" href="../c-api/memory.html#c.PyMem_Realloc" title="PyMem_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Realloc()</span></code></a> 和 <a class="reference internal" href="../c-api/memory.html#c.PyMem_Free" title="PyMem_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyMem_Free()</span></code></a>。</p></li>
<li><p class="translated">“对象内存”家族是上述pymalloc设施的接口，偏向于大量“小”分配：<a class="reference internal" href="../c-api/memory.html#c.PyObject_Malloc" title="PyObject_Malloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Malloc()</span></code></a>，<a class="reference internal" href="../c-api/memory.html#c.PyObject_Realloc" title="PyObject_Realloc"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Realloc()</span></code></a> 和 <a class="reference internal" href="../c-api/memory.html#c.PyObject_Free" title="PyObject_Free"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Free()</span></code></a>。</p></li>
<li><p class="translated">要分配和释放Python对象，使用“对象”家族：<a class="reference internal" href="../c-api/allocation.html#c.PyObject_New" title="PyObject_New"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyObject_New</span></code></a>，<a class="reference internal" href="../c-api/allocation.html#c.PyObject_NewVar" title="PyObject_NewVar"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyObject_NewVar</span></code></a> 和 <a class="reference internal" href="../c-api/allocation.html#c.PyObject_Del" title="PyObject_Del"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyObject_Del()</span></code></a>。</p></li>
</ul>
<p class="translated">感谢Tim Peters的大量工作，2.3中的pymalloc还提供了调试功能，用于捕获扩展模块和解释器本身的内存覆盖和双重释放。要启用此支持，请通过运行带:option:<cite>!--with-pydebug`选项的 :program:`configure</cite> 命令来编译Python解释器的调试版本。</p>
<p class="translated">为了帮助扩展开发者，Python 2.3的源代码中分发了一个头文件:file:<cite>Misc/pymemcompat.h</cite>，它允许Python扩展在编译针对自1.5.2以来的任何版本的Python时使用2.3的内存分配接口。你需要从Python的源代码分发中复制该文件，并将其与你的扩展源代码捆绑在一起。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<dl class="simple">
<dt class="translated"><a class="reference external" href="https://hg.python.org/cpython/file/default/Objects/obmalloc.c">https://hg.python.org/cpython/file/default/Objects/obmalloc.c</a></dt><dd><p class="translated">有关pymalloc实现的详细信息，请参阅Python源代码中 <code class="file docutils literal notranslate"><span class="pre">Objects/obmalloc.c</span></code> 文件顶部的注释。上述链接指向python.org SVN浏览器中的该文件。</p>
</dd>
</dl>
</div>
</section>
<section id="build-and-c-api-changes">
<h2 class="translated">构建和 C API 的改变<a class="headerlink" href="#build-and-c-api-changes" title="Link to this heading">¶</a></h2>
<p class="translated">针对 Python 构建过程和 C API 的改变包括:</p>
<ul class="simple">
<li><p class="translated">垃圾收集使用的循环检测实现已被证明是稳定的，因此现在已被设为强制性。你不能再编译不带此功能的Python，且 <strong class="program">configure</strong> 中的 <code class="xref std std-option docutils literal notranslate"><span class="pre">--with-cycle-gc</span></code> 选项已被移除。</p></li>
<li><p class="translated">现在可以可选地将Python构建为共享库(<code class="file docutils literal notranslate"><span class="pre">libpython2.3.so</span></code>)，方法是在运行Python的 <strong class="program">configure</strong> 脚本时提供 <code class="xref std std-option docutils literal notranslate"><span class="pre">--enable-shared</span></code> 选项。（由 Ondrej Palkovsky 贡献。）</p></li>
<li><p class="translated"><code class="xref c c-macro docutils literal notranslate"><span class="pre">DL_EXPORT</span></code> 和 <code class="xref c c-macro docutils literal notranslate"><span class="pre">DL_IMPORT</span></code> 宏现在已被弃用。Python扩展模块的初始化函数现在应使用新的宏 <a class="reference internal" href="../c-api/extension-modules.html#c.PyMODINIT_FUNC" title="PyMODINIT_FUNC"><code class="xref c c-macro docutils literal notranslate"><span class="pre">PyMODINIT_FUNC</span></code></a> 声明，而Python核心通常会使用 <code class="xref c c-macro docutils literal notranslate"><span class="pre">PyAPI_FUNC</span></code> 和 <code class="xref c c-macro docutils literal notranslate"><span class="pre">PyAPI_DATA</span></code> 宏。</p></li>
<li><p class="translated">通过向 <strong class="program">configure</strong> 脚本提供 <code class="xref std std-option docutils literal notranslate"><span class="pre">--without-doc-strings</span></code> 选项，可以编译不带任何内置函数和模块文档字符串的解释器。这使得Python可执行文件大约减小了10%，但也意味着你无法获取Python内置函数的帮助。（由 Gustavo Niemeyer 贡献。）</p></li>
<li><p class="translated"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_NoArgs()</span></code> 宏现已弃用，使用它的代码应进行修改。对于 Python 2.2 及更高版本，方法定义表可以指定 <a class="reference internal" href="../c-api/structures.html#c.METH_NOARGS" title="METH_NOARGS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">METH_NOARGS</span></code></a> 标志，表示没有参数，从而可以移除参数检查。如果需要与 Python 2.2 之前的版本兼容，代码可以使用 <code class="docutils literal notranslate"><span class="pre">PyArg_ParseTuple(args,</span> <span class="pre">&quot;&quot;)</span></code> 代替，但这会比使用 <a class="reference internal" href="../c-api/structures.html#c.METH_NOARGS" title="METH_NOARGS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">METH_NOARGS</span></code></a> 慢。</p></li>
<li><p class="translated"><a class="reference internal" href="../c-api/arg.html#c.PyArg_ParseTuple" title="PyArg_ParseTuple"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArg_ParseTuple()</span></code></a> 接受新的格式字符来表示各种大小的无符号整数：<code class="docutils literal notranslate"><span class="pre">B</span></code> 表示 <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span></span>，<code class="docutils literal notranslate"><span class="pre">H</span></code> 表示 <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="kt">int</span></span>，<code class="docutils literal notranslate"><span class="pre">I</span></code> 表示 <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span></span>，以及 <code class="docutils literal notranslate"><span class="pre">K</span></code> 表示 <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span>。</p></li>
<li><p class="translated">新增了一个函数 <code class="docutils literal notranslate"><span class="pre">PyObject_DelItemString(mapping,</span> <span class="pre">char</span> <span class="pre">*key)</span></code>，作为 <code class="docutils literal notranslate"><span class="pre">PyObject_DelItem(mapping,</span> <span class="pre">PyString_New(key))</span></code> 的简写。</p></li>
<li><p class="translated">文件对象现在以不同的方式管理其内部字符串缓冲区，需要在时按指数增加。这导致 <code class="file docutils literal notranslate"><span class="pre">Lib/test/test_bufio.py</span></code> 中的基准测试速度显著提升（根据一次测量，从 57 秒提升到 1.7 秒）。</p></li>
<li><p class="translated">现在可以为 C 扩展类型定义类方法和静态方法，通过在方法的 <a class="reference internal" href="../c-api/structures.html#c.PyMethodDef" title="PyMethodDef"><code class="xref c c-type docutils literal notranslate"><span class="pre">PyMethodDef</span></code></a> 结构中设置 <a class="reference internal" href="../c-api/structures.html#c.METH_CLASS" title="METH_CLASS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">METH_CLASS</span></code></a> 或 <a class="reference internal" href="../c-api/structures.html#c.METH_STATIC" title="METH_STATIC"><code class="xref c c-macro docutils literal notranslate"><span class="pre">METH_STATIC</span></code></a> 标志。</p></li>
<li><p class="translated">Python 现在包含 Expat XML 解析器的源代码副本，消除了对系统版本或本地安装的 Expat 的依赖。</p></li>
<li><p class="translated">如果在扩展中动态分配类型对象，你应该注意与 <a class="reference internal" href="../reference/datamodel.html#type.__module__" title="type.__module__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__module__</span></code></a> 和 <a class="reference internal" href="../reference/datamodel.html#type.__name__" title="type.__name__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__name__</span></code></a> 属性相关的规则变化。简而言之，你需要确保类型的字典中包含一个 <code class="docutils literal notranslate"><span class="pre">'__module__'</span></code> 键；将模块名作为类型名中最后一个点之前的部分将不再产生预期效果。更多详情，请阅读 API 参考文档或源代码。</p></li>
</ul>
<section id="port-specific-changes">
<h3 class="translated">移植专属的改变<a class="headerlink" href="#port-specific-changes" title="Link to this heading">¶</a></h3>
<p class="translated">对使用 EMX 运行环境将 Python 移植到 IBM 的 OS/2 系统的支持已合并到 Python 主源代码树中。EMX 是一个在 OS/2 系统API之上的 POSIX 模拟层。针对 EMX 的 Python 移植尝试支持 EMX 运行时暴露的所有 POSIX 类似功能，并且大部分成功；<code class="xref py py-func docutils literal notranslate"><span class="pre">fork()</span></code> 和 <a class="reference internal" href="../library/fcntl.html#module-fcntl" title="fcntl: The fcntl() and ioctl() system calls. (Unix)"><code class="xref py py-func docutils literal notranslate"><span class="pre">fcntl()</span></code></a> 受到底层模拟层限制的影响。标准的 OS/2 移植版本，使用 IBM 的 Visual Age 编译器，也在将 EMX 移植集成到 CVS 的过程中获得了对大小写敏感的导入语义的支持。（由 Andrew MacIntyre 贡献。）</p>
<p class="translated">在 MacOS 上，大多数工具箱模块已经通过弱链接来提高向后兼容性。这意味着如果当前 OS 版本中缺少单个例程，模块将不再加载失败。相反，调用缺失的例程将引发异常。（由 Jack Jansen 贡献。）</p>
<p class="translated">位于 Python 源代码分发版中的 <code class="file docutils literal notranslate"><span class="pre">Misc/RPM/</span></code> 目录中的 RPM 规范文件已更新为 2.3 版。（由 Sean Reifschneider 贡献。）</p>
<p class="translated">Python 现在支持的其他新平台包括 AtheOS（<a class="reference external" href="http://www.atheos.cx/">http://www.atheos.cx/</a>）、GNU/Hurd 和 OpenVMS。</p>
</section>
</section>
<section id="other-changes-and-fixes">
<span id="section-other"></span><h2 class="translated">其他的改变和修正<a class="headerlink" href="#other-changes-and-fixes" title="Link to this heading">¶</a></h2>
<p class="translated">一如既往，源代码树中散布着许多其他改进和错误修复。通过搜索 CVS 更改日志，发现在 Python 2.2 和 2.3 之间应用了 523 个补丁并修复了 514 个错误。这两个数字可能都被低估了。</p>
<p class="translated">一些较为重要的改变:</p>
<ul>
<li><p class="translated">如果设置了 <span class="target" id="index-82"></span><a class="reference internal" href="../using/cmdline.html#envvar-PYTHONINSPECT"><code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONINSPECT</span></code></a> 环境变量，Python 解释器在运行 Python 程序后会进入交互式提示符，就像使用 <a class="reference internal" href="../using/cmdline.html#cmdoption-i"><code class="xref std std-option docutils literal notranslate"><span class="pre">-i</span></code></a> 选项调用 Python 一样。环境变量可以在运行 Python 解释器之前设置，也可以由 Python 程序在其执行过程中设置。</p></li>
<li><p class="translated"><code class="file docutils literal notranslate"><span class="pre">regrtest.py</span></code> 脚本现在提供了一种方法，允许“所有资源除了 <em>foo</em>。”传递给 <code class="xref std std-option docutils literal notranslate"><span class="pre">-u</span></code> 选项的资源名现在可以以连字符（<code class="docutils literal notranslate"><span class="pre">'-'</span></code>）为前缀，表示“移除此资源”。例如，选项 '<code class="docutils literal notranslate"><span class="pre">-uall,-bsddb</span></code>' 可以用来启用除 <code class="docutils literal notranslate"><span class="pre">bsddb</span></code> 以外的所有资源。</p></li>
<li><p class="translated">用于构建文档的工具现在在 Cygwin 和 Unix 下都能工作。</p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">SET_LINENO</span></code> 操作码已被移除。在很久以前，这个操作码用于在追溯中生成行号和支持跟踪函数（例如，<a class="reference internal" href="../library/pdb.html#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pdb</span></code></a>）。自 Python 1.5 起，追溯中的行号已通过不同的机制计算，该机制与“python -O”兼容。对于 Python 2.3，Michael Hudson 实现了一个类似的方案来确定何时调用跟踪函数，完全移除了对 <code class="docutils literal notranslate"><span class="pre">SET_LINENO</span></code> 的需求。</p>
<p class="translated">从 Python 代码中很难检测到由此产生的差异，除非在未使用 <a class="reference internal" href="../using/cmdline.html#cmdoption-O"><code class="xref std std-option docutils literal notranslate"><span class="pre">-O</span></code></a> 的情况下运行 Python 时会有轻微的速度提升。</p>
<p class="translated">访问帧对象中的 <a class="reference internal" href="../reference/datamodel.html#frame.f_lineno" title="frame.f_lineno"><code class="xref py py-attr docutils literal notranslate"><span class="pre">f_lineno</span></code></a> 字段的 C 扩展应改为调用 <code class="docutils literal notranslate"><span class="pre">PyCode_Addr2Line(f-&gt;f_code,</span> <span class="pre">f-&gt;f_lasti)</span></code>。这将使代码在早期版本的 Python 中也能在“python -O”下按预期工作。</p>
<p class="translated">一个很酷的新特性是，跟踪函数现在可以分配给帧对象的 <a class="reference internal" href="../reference/datamodel.html#frame.f_lineno" title="frame.f_lineno"><code class="xref py py-attr docutils literal notranslate"><span class="pre">f_lineno</span></code></a> 属性，改变将要执行的行。<a class="reference internal" href="../library/pdb.html#module-pdb" title="pdb: The Python debugger for interactive interpreters."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pdb</span></code></a> 调试器中添加了一个 <code class="docutils literal notranslate"><span class="pre">jump</span></code> 命令，利用了这个新特性。（由 Richie Hindle 实现。）</p>
</li>
</ul>
</section>
<section id="porting-to-python-2-3">
<h2 class="translated">移植到 Python 2.3<a class="headerlink" href="#porting-to-python-2-3" title="Link to this heading">¶</a></h2>
<p class="translated">本节列出了先前描述的可能需要修改你的代码的改变：</p>
<ul>
<li><p class="translated">现在 <a class="reference internal" href="../reference/simple_stmts.html#yield"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">yield</span></code></a> 始终是一个关键字；如果它在你的代码中被用作变量名，则必须选择不同的名称。</p></li>
<li><p class="translated">对于字符串 <em>X</em> 和 <em>Y</em>，<code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">in</span> <span class="pre">Y</span></code> 现在当 <em>X</em> 长度超过一个字符时也是有效的。</p></li>
<li><p class="translated">现在 <a class="reference internal" href="../library/functions.html#int" title="int"><code class="xref py py-func docutils literal notranslate"><span class="pre">int()</span></code></a> 类型构造器在字符串或浮点数因太大而无法以整数类型来容纳时将返回一个长整数而不是引发 <a class="reference internal" href="../library/exceptions.html#OverflowError" title="OverflowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OverflowError</span></code></a>。</p></li>
<li><p class="translated">如果你的 Unicode 字符串包含 8 位字符，你必须通过在文件顶部添加注释来声明文件的编码（UTF-8、Latin-1 或其他）。更多信息请参见 <a class="reference internal" href="#section-encodings"><span class="std std-ref">PEP 263: 源代码的字符编码格式</span></a> 部分。</p></li>
<li><p class="translated">通过 <code class="xref py py-mod docutils literal notranslate"><span class="pre">_tkinter</span></code> 调用 Tcl 方法不再仅返回字符串。相反，如果 Tcl 返回其他对象，这些对象会被转换为它们的 Python 等效对象（如果存在的话），或者如果没有 Python 等效对象，则会被包装在 <code class="xref py py-class docutils literal notranslate"><span class="pre">_tkinter.Tcl_Obj</span></code> 对象中。</p></li>
<li><p class="translated">像 <code class="docutils literal notranslate"><span class="pre">0xffffffff</span></code> 这样的大型八进制和十六进制字面量现在会触发 <a class="reference internal" href="../library/exceptions.html#FutureWarning" title="FutureWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FutureWarning</span></code></a>。目前它们被存储为 32 位数字，并导致负值，但在 Python 2.4 中，它们将变为正的长整数。</p>
<p class="translated">有几种方法可以修复这个警告。如果你确实需要一个正数，只需在字面量末尾添加一个 <code class="docutils literal notranslate"><span class="pre">L</span></code>。如果你试图获取一个低位设置的 32 位整数，并且之前使用了类似 <code class="docutils literal notranslate"><span class="pre">~(1</span> <span class="pre">&lt;&lt;</span> <span class="pre">31)</span></code> 的表达式，最清晰的方法是从所有位都设置开始，然后清除所需的高位。例如，要仅清除最高位（位 31），你可以写 <code class="docutils literal notranslate"><span class="pre">0xffffffffL</span> <span class="pre">&amp;~(1L&lt;&lt;31)</span></code>。</p>
</li>
<li><p class="translated">你不能再通过赋值给 <code class="docutils literal notranslate"><span class="pre">__debug__</span></code> 来禁用断言。</p></li>
<li><p class="translated">Distutils 的 <code class="xref py py-func docutils literal notranslate"><span class="pre">setup()</span></code> 函数获得了各种新的关键字参数，例如 <em>depends</em>。旧版本的 Distutils 在传递未知关键字时会中止。解决方案是在你的 <code class="file docutils literal notranslate"><span class="pre">setup.py</span></code> 中检查新的 <code class="xref py py-func docutils literal notranslate"><span class="pre">get_distutil_options()</span></code> 函数的存在，并且仅在使用支持这些新关键字的 Distutils 版本时使用这些新关键字：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">distutils</span><span class="w"> </span><span class="kn">import</span> <span class="n">core</span>

<span class="n">kw</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;sources&#39;</span><span class="p">:</span> <span class="s1">&#39;foo.c&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">}</span>
<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">core</span><span class="p">,</span> <span class="s1">&#39;get_distutil_options&#39;</span><span class="p">):</span>
    <span class="n">kw</span><span class="p">[</span><span class="s1">&#39;depends&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;foo.h&#39;</span><span class="p">]</span>
<span class="n">ext</span> <span class="o">=</span> <span class="n">Extension</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="translated">现在使用 <code class="docutils literal notranslate"><span class="pre">None</span></code> 作为变量名将会导致 <a class="reference internal" href="../library/exceptions.html#SyntaxWarning" title="SyntaxWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SyntaxWarning</span></code></a> 警告。</p></li>
<li><p class="translated">由 Python 包含的模块定义的扩展类型名称现在包含模块和一个在类型名称前的 <code class="docutils literal notranslate"><span class="pre">'.'</span></code>。</p></li>
</ul>
</section>
<section id="acknowledgements">
<span id="acks"></span><h2 class="translated">致谢<a class="headerlink" href="#acknowledgements" title="Link to this heading">¶</a></h2>
<p class="translated">作者感谢以下人员为本文的各种草案提供建议，更正和帮助： Jeff Bauer、Simon Brunning、Brett Cannon、Michael Chermside、Andrew Dalke、Scott David Daniels、Fred L. Drake、Jr.、David Fraser、 Kelly Gerber、Raymond Hettinger、Michael Hudson、Chris Lambert、Detlef Lannert、Martin von Löwis、Andrew MacIntyre、Lalo Martins、Chad Netzer、Gustavo Niemeyer、Neal Norwitz、Hans Nowak、Chris Reedy、Francesco Ricciardi、Vinay Sajip、Neil Schemenauer、Roman Suzi、Jason Tishler、Just van Rossum。</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#">Python 2.3 有什么新变化</a><ul>
<li><a class="reference internal" href="#pep-218-a-standard-set-datatype">PEP 218: 标准集合数据类型</a></li>
<li><a class="reference internal" href="#pep-255-simple-generators">PEP 255: 简单的生成器</a></li>
<li><a class="reference internal" href="#pep-263-source-code-encodings">PEP 263: 源代码的字符编码格式</a></li>
<li><a class="reference internal" href="#pep-273-importing-modules-from-zip-archives">PEP 273: 从ZIP压缩包导入模块</a></li>
<li><a class="reference internal" href="#pep-277-unicode-file-name-support-for-windows-nt">PEP 277: 针对 Windows NT 的 Unicode 文件名支持</a></li>
<li><a class="reference internal" href="#pep-278-universal-newline-support">PEP 278: 通用换行支持</a></li>
<li><a class="reference internal" href="#pep-279-enumerate">PEP 279: enumerate()</a></li>
<li><a class="reference internal" href="#pep-282-the-logging-package">PEP 282: logging 包</a></li>
<li><a class="reference internal" href="#pep-285-a-boolean-type">PEP 285: 布尔类型</a></li>
<li><a class="reference internal" href="#pep-293-codec-error-handling-callbacks">PEP 293: 编解码器错误处理回调</a></li>
<li><a class="reference internal" href="#pep-301-package-index-and-metadata-for-distutils">PEP 301: Distutils的软件包索引和元数据</a></li>
<li><a class="reference internal" href="#pep-302-new-import-hooks">PEP 302: 新导入钩子</a></li>
<li><a class="reference internal" href="#pep-305-comma-separated-files">PEP 305: 逗号分隔文件</a></li>
<li><a class="reference internal" href="#pep-307-pickle-enhancements">PEP 307：对 pickle 的改进</a></li>
<li><a class="reference internal" href="#extended-slices">扩展切片</a></li>
<li><a class="reference internal" href="#other-language-changes">其他语言特性修改</a><ul>
<li><a class="reference internal" href="#string-changes">字符串的改变</a></li>
<li><a class="reference internal" href="#optimizations">性能优化</a></li>
</ul>
</li>
<li><a class="reference internal" href="#new-improved-and-deprecated-modules">新增，改进和弃用的模块</a><ul>
<li><a class="reference internal" href="#date-time-type">Date/Time 类型</a></li>
<li><a class="reference internal" href="#the-optparse-module">optparse 模块</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pymalloc-a-specialized-object-allocator">Pymalloc：一种专用对象分配器</a></li>
<li><a class="reference internal" href="#build-and-c-api-changes">构建和 C API 的改变</a><ul>
<li><a class="reference internal" href="#port-specific-changes">移植专属的改变</a></li>
</ul>
</li>
<li><a class="reference internal" href="#other-changes-and-fixes">其他的改变和修正</a></li>
<li><a class="reference internal" href="#porting-to-python-2-3">移植到 Python 2.3</a></li>
<li><a class="reference internal" href="#acknowledgements">致谢</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一主题</h4>
    <p class="topless"><a href="2.4.html"
                          title="上一章">Python 2.4 有什么新变化</a></p>
  </div>
  <div>
    <h4>下一主题</h4>
    <p class="topless"><a href="2.2.html"
                          title="下一章">Python 2.2 有什么新变化</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">报告代码错误</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/whatsnew/2.3.rst?plain=1"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="折叠边栏">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="2.2.html" title="Python 2.2 有什么新变化"
             >下一页</a> |</li>
        <li class="right" >
          <a href="2.4.html" title="Python 2.4 有什么新变化"
             >上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.14.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python的新变化</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Python 2.3 有什么新变化</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q" id="search-box">
          <input type="submit" value="转到">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    主题
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>自动</option>
        <option value="light">明亮</option>
        <option value="dark">黑暗</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版权</a> 2001 Python Software Foundation.
    <br>
    本页面采用 Python 软件基金会许可证第 2 版授权。
    <br>
    文档中的示例、代码片段及其他代码内容额外采用零条款 BSD 许可证授权。
    <br>
    
      更多信息请参阅《<a href="/license.html"> 历史与许可 </a>》。<br>
    
    
    <br>

    Python 软件基金会是一家非营利性公司。
<a href="https://www.python.org/psf/donations/">请进行捐赠。</a>
<br>
    <br>
      最后更新于11月 25, 2025 (07:24 UTC) 。
    
      <a href="/bugs.html">发现了错误</a>？
    
    <br>

    使用<a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3 创建。
    </div>

  </body>
</html>
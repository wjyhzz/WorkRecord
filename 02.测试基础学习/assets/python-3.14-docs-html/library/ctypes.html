<!DOCTYPE html>

<html lang="zh-CN" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="ctypes --- Python 的外部函数库" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/ctypes.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="源代码: Lib/ctypes ctypes 是 Python 的外部函数库。它提供了与 C 兼容的数据类型，并允许调用 DLL 或共享库中的函数。可使用该模块以纯 Python 形式对这些库进行封装。 这是一个 optional module 。 如果它在你的 CPython 副本中缺失，请查看你的发行方（也就是说，向你提供 Python 的人）的文档。 如果你就是发行方，请参阅 针对可选..." />
<meta property="og:image:width" content="1146" />
<meta property="og:image:height" content="600" />
<meta property="og:image" content="https://docs.python.org/3.14/zh-cn/_images/social_previews/summary_library_ctypes_c3efb9a8.png" />
<meta property="og:image:alt" content="源代码: Lib/ctypes ctypes 是 Python 的外部函数库。它提供了与 C 兼容的数据类型，并允许调用 DLL 或共享库中的函数。可使用该模块以纯 Python 形式对这些库进行封装。 这是一个 optional module 。 如果它在你的 CPython 副本中缺失，请查看你的发行方（也就是说，向你提供 Python 的人）的文档。 如果你就是发行方，请参阅 针对可选..." />
<meta name="description" content="源代码: Lib/ctypes ctypes 是 Python 的外部函数库。它提供了与 C 兼容的数据类型，并允许调用 DLL 或共享库中的函数。可使用该模块以纯 Python 形式对这些库进行封装。 这是一个 optional module 。 如果它在你的 CPython 副本中缺失，请查看你的发行方（也就是说，向你提供 Python 的人）的文档。 如果你就是发行方，请参阅 针对可选..." />
<meta name="twitter:card" content="summary_large_image" />
<meta name="theme-color" content="#3776ab">

    <title>ctypes --- Python 的外部函数库 &#8212; Python 3.14.0 文档</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=234b1a7c" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=8cd84f99" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=5349f25f" />
    
    <script src="../_static/documentation_options.js?v=a595ec0e"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=beaddf03"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.14.0 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于此文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权" href="../copyright.html" />
    <link rel="next" title="命令行界面库" href="cmdlinelibs.html" />
    <link rel="prev" title="errno --- 标准 errno 系统符号" href="errno.html" />
    
      
      <script defer file-types="bz2,epub,zip" data-domain="docs.python.org" src="https://analytics.python.org/js/script.file-downloads.outbound-links.js"></script>
      
      <link rel="canonical" href="https://docs.python.org/3/library/ctypes.html">
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg">
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="菜单">
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo">
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q">
                <input type="submit" value="转到">
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    主题
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>自动</option>
        <option value="light">明亮</option>
        <option value="dark">黑暗</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code> --- Python 的外部函数库</a><ul>
<li><a class="reference internal" href="#ctypes-tutorial">ctypes 教程</a><ul>
<li><a class="reference internal" href="#loading-dynamic-link-libraries">载入动态连接库</a></li>
<li><a class="reference internal" href="#accessing-functions-from-loaded-dlls">操作导入的动态链接库中的函数</a></li>
<li><a class="reference internal" href="#calling-functions">调用函数</a></li>
<li><a class="reference internal" href="#fundamental-data-types">基础数据类型</a></li>
<li><a class="reference internal" href="#calling-functions-continued">调用函数，继续</a></li>
<li><a class="reference internal" href="#calling-variadic-functions">调用可变函数</a></li>
<li><a class="reference internal" href="#calling-functions-with-your-own-custom-data-types">使用自定义的数据类型调用函数</a></li>
<li><a class="reference internal" href="#specifying-the-required-argument-types-function-prototypes">指定必选参数的类型(函数原型)</a></li>
<li><a class="reference internal" href="#return-types">返回类型</a></li>
<li><a class="reference internal" href="#passing-pointers-or-passing-parameters-by-reference">传递指针（或以引用方式传递形参）</a></li>
<li><a class="reference internal" href="#structures-and-unions">结构体和联合</a></li>
<li><a class="reference internal" href="#structure-union-layout-alignment-and-byte-order">结构/联合布局、对齐和字节顺序</a></li>
<li><a class="reference internal" href="#bit-fields-in-structures-and-unions">结构体和联合中的位域</a></li>
<li><a class="reference internal" href="#arrays">数组</a></li>
<li><a class="reference internal" href="#pointers">指针</a></li>
<li><a class="reference internal" href="#thread-safety-without-the-gil">没有 GIL 时的线程安全性</a></li>
<li><a class="reference internal" href="#type-conversions">类型转换</a></li>
<li><a class="reference internal" href="#incomplete-types">不完整类型</a></li>
<li><a class="reference internal" href="#callback-functions">回调函数</a></li>
<li><a class="reference internal" href="#accessing-values-exported-from-dlls">访问 dll 的导出变量</a></li>
<li><a class="reference internal" href="#surprises">意外</a></li>
<li><a class="reference internal" href="#variable-sized-data-types">变长数据类型</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ctypes-reference">ctypes 参考手册</a><ul>
<li><a class="reference internal" href="#finding-shared-libraries">寻找动态链接库</a></li>
<li><a class="reference internal" href="#listing-loaded-shared-libraries">列出已加载的共享库</a></li>
<li><a class="reference internal" href="#loading-shared-libraries">加载共享库</a></li>
<li><a class="reference internal" href="#foreign-functions">外部函数</a></li>
<li><a class="reference internal" href="#function-prototypes">函数原型</a></li>
<li><a class="reference internal" href="#utility-functions">工具函数</a></li>
<li><a class="reference internal" href="#data-types">数据类型</a></li>
<li><a class="reference internal" href="#ctypes-fundamental-data-types-2">基础数据类型</a></li>
<li><a class="reference internal" href="#structured-data-types">结构化数据类型</a></li>
<li><a class="reference internal" href="#arrays-and-pointers">数组与指针</a></li>
<li><a class="reference internal" href="#exceptions">异常</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一主题</h4>
    <p class="topless"><a href="errno.html"
                          title="上一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">errno</span></code> --- 标准 errno 系统符号</a></p>
  </div>
  <div>
    <h4>下一主题</h4>
    <p class="topless"><a href="cmdlinelibs.html"
                          title="下一章">命令行界面库</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">报告代码错误</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/ctypes.rst?plain=1"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="cmdlinelibs.html" title="命令行界面库"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="errno.html" title="errno --- 标准 errno 系统符号"
             accesskey="P">上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.14.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" accesskey="U">通用操作系统服务</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code> --- Python 的外部函数库</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q" id="search-box">
          <input type="submit" value="转到">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    主题
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>自动</option>
        <option value="light">明亮</option>
        <option value="dark">黑暗</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-ctypes">
<span id="ctypes-a-foreign-function-library-for-python"></span><h1 class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code> --- Python 的外部函数库<a class="headerlink" href="#module-ctypes" title="Link to this heading">¶</a></h1>
<p class="translated"><strong>源代码:</strong> <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/3.14/Lib/ctypes">Lib/ctypes</a></p>
<hr class="docutils" />
<p class="translated"><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 是 Python 的外部函数库。它提供了与 C 兼容的数据类型，并允许调用 DLL 或共享库中的函数。可使用该模块以纯 Python 形式对这些库进行封装。</p>
<p class="translated">这是一个 <a class="reference internal" href="../glossary.html#term-optional-module"><span class="xref std std-term">optional module</span></a>。 如果它在你的 CPython 副本中缺失，请查看你的发行方（也就是说，向你提供 Python 的人）的文档。 如果你就是发行方，请参阅 <a class="reference internal" href="../using/configure.html#optional-module-requirements"><span class="std std-ref">针对可选模块的要求</span></a>。</p>
<section id="ctypes-tutorial">
<span id="ctypes-ctypes-tutorial"></span><h2 class="translated">ctypes 教程<a class="headerlink" href="#ctypes-tutorial" title="Link to this heading">¶</a></h2>
<p class="translated">注：本教程中的示例代码使用 <a class="reference internal" href="doctest.html#module-doctest" title="doctest: Test pieces of code within docstrings."><code class="xref py py-mod docutils literal notranslate"><span class="pre">doctest</span></code></a> 来保证它们能正确运行。 由于有些代码示例在 Linux, Windows 或 macOS 上的行为有所不同，它们在注释中包含了一些 doctest 指令。</p>
<p class="translated">注意：部分示例代码引用了 ctypes <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a> 类型。在 <code class="docutils literal notranslate"><span class="pre">sizeof(long)</span> <span class="pre">==</span> <span class="pre">sizeof(int)</span></code> 的平台上此类型是 <a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_long</span></code></a> 的一个别名。所以，在程序输出 <a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_long</span></code></a> 而不是你期望的 <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a> 时不必感到迷惑 --- 它们实际上是同一种类型。</p>
<section id="loading-dynamic-link-libraries">
<span id="ctypes-loading-dynamic-link-libraries"></span><h3 class="translated">载入动态连接库<a class="headerlink" href="#loading-dynamic-link-libraries" title="Link to this heading">¶</a></h3>
<p class="translated"><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 导出了 <em>cdll</em> 对象，在 Windows 系统中还导出了 <em>windll</em> 和 <em>oledll</em> 对象用于载入动态连接库。</p>
<p class="translated">您可以通过访问这些对象的属性来加载库。 <em>cdll</em> 加载使用标准 <code class="docutils literal notranslate"><span class="pre">cdecl</span></code> 调用约定导出函数的库，而 <em>windll</em> 库则使用 <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> 调用约定调用函数。 <em>oledll</em> 也使用 <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> 调用约定，并假定函数返回 Windows <code class="xref c c-type docutils literal notranslate"><span class="pre">HRESULT</span></code> 错误代码。 当函数调用失败时会使用错误代码自动引发 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-class docutils literal notranslate"><span class="pre">OSError</span></code></a> 异常。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版本发生变更: </span>原来在 Windows 下抛出的异常类型 <a class="reference internal" href="exceptions.html#WindowsError" title="WindowsError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">WindowsError</span></code></a> 现在是 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 的一个别名。</p>
</div>
<p class="translated">这是一些 Windows 下的例子。 请注意 <code class="docutils literal notranslate"><span class="pre">msvcrt</span></code> 是包含大部分 C 函数的 MS 标准 C 库，并会使用 <code class="docutils literal notranslate"><span class="pre">cdecl</span></code> 调用惯例:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="p">)</span>
<span class="go">&lt;WinDLL &#39;kernel32&#39;, handle ... at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cdll</span><span class="o">.</span><span class="n">msvcrt</span><span class="p">)</span>
<span class="go">&lt;CDLL &#39;msvcrt&#39;, handle ... at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span> <span class="o">=</span> <span class="n">cdll</span><span class="o">.</span><span class="n">msvcrt</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">Windows 会自动添加通常的 <code class="docutils literal notranslate"><span class="pre">.dll</span></code> 文件扩展名。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p class="translated">通过 <code class="docutils literal notranslate"><span class="pre">cdll.msvcrt</span></code> 调用的标准 C 函数，可能会导致调用一个过时的，与当前 Python 所不兼容的函数。因此，请尽量使用标准的 Python 函数，而不要使用 <code class="docutils literal notranslate"><span class="pre">msvcrt</span></code> 模块。</p>
</div>
<p class="translated">在 Linux 中，要求指定文件名 <em>包括</em> 扩展名来加载库，因此不能使用属性访问的方式来加载库。 你应当使用 dll 加载器的 <a class="reference internal" href="#ctypes.LibraryLoader.LoadLibrary" title="ctypes.LibraryLoader.LoadLibrary"><code class="xref py py-meth docutils literal notranslate"><span class="pre">LoadLibrary()</span></code></a> 方法，或是应当通过调用构造器创建 CDLL 的实例来加载库:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">LoadLibrary</span><span class="p">(</span><span class="s2">&quot;libc.so.6&quot;</span><span class="p">)</span>
<span class="go">&lt;CDLL &#39;libc.so.6&#39;, handle ... at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span> <span class="o">=</span> <span class="n">CDLL</span><span class="p">(</span><span class="s2">&quot;libc.so.6&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span>
<span class="go">&lt;CDLL &#39;libc.so.6&#39;, handle ... at ...&gt;</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="accessing-functions-from-loaded-dlls">
<span id="ctypes-accessing-functions-from-loaded-dlls"></span><h3 class="translated">操作导入的动态链接库中的函数<a class="headerlink" href="#accessing-functions-from-loaded-dlls" title="Link to this heading">¶</a></h3>
<p class="translated">通过操作dll对象的属性来操作这些函数。</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">printf</span>
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">)</span>
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">MyOwnFunction</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;ctypes.py&quot;</span>, line <span class="m">239</span>, in <span class="n">__getattr__</span>
<span class="w">    </span><span class="n">func</span> <span class="o">=</span> <span class="n">_StdcallFuncPtr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
<span class="gr">AttributeError</span>: <span class="n">function &#39;MyOwnFunction&#39; not found</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">请注意 win32 系统的动态库如 <code class="docutils literal notranslate"><span class="pre">kernel32</span></code> 和 <code class="docutils literal notranslate"><span class="pre">user32</span></code> 通常会同时导出一个函数的 ANSI 版本和 UNICODE 版本。 UNICODE 版本导出时会在名称后加上 <code class="docutils literal notranslate"><span class="pre">W</span></code>，而 ANSI 版本导出时会在名称后加上 <code class="docutils literal notranslate"><span class="pre">A</span></code>。 win32 <code class="docutils literal notranslate"><span class="pre">GetModuleHandle</span></code> 函数会为给定的模块名称返回一个 <em>模块句柄</em>，它具有以下的 C 原型，以及一个被用来根据是否定义了 UNICODE 将其中之一暴露为 <code class="docutils literal notranslate"><span class="pre">GetModuleHandle</span></code> 的宏:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">ANSI</span> <span class="n">version</span> <span class="o">*/</span>
<span class="n">HMODULE</span> <span class="n">GetModuleHandleA</span><span class="p">(</span><span class="n">LPCSTR</span> <span class="n">lpModuleName</span><span class="p">);</span>
<span class="o">/*</span> <span class="n">UNICODE</span> <span class="n">version</span> <span class="o">*/</span>
<span class="n">HMODULE</span> <span class="n">GetModuleHandleW</span><span class="p">(</span><span class="n">LPCWSTR</span> <span class="n">lpModuleName</span><span class="p">);</span>
</pre></div>
</div>
<p class="translated"><em>windll</em> 不会通过这样的魔法手段来帮你决定选择哪一种函数，你必须显式的调用 <code class="docutils literal notranslate"><span class="pre">GetModuleHandleA</span></code> 或 <code class="docutils literal notranslate"><span class="pre">GetModuleHandleW</span></code>，并分别使用字节对象或字符串对象作参数。</p>
<p class="translated">有时候，dlls的导出的函数名不符合 Python 的标识符规范，比如 <code class="docutils literal notranslate"><span class="pre">&quot;??2&#64;YAPAXI&#64;Z&quot;</span></code>。此时，你必须使用 <a class="reference internal" href="functions.html#getattr" title="getattr"><code class="xref py py-func docutils literal notranslate"><span class="pre">getattr()</span></code></a> 方法来获得该函数。</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">getattr</span><span class="p">(</span><span class="n">cdll</span><span class="o">.</span><span class="n">msvcrt</span><span class="p">,</span> <span class="s2">&quot;??2@YAPAXI@Z&quot;</span><span class="p">)</span>
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">Windows 下，有些 dll 导出的函数没有函数名，而是通过其顺序号调用。对此类函数，你也可以通过 dll 对象的数值索引来操作这些函数。</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">kernel32</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">&lt;_FuncPtr object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">kernel32</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;ctypes.py&quot;</span>, line <span class="m">310</span>, in <span class="n">__getitem__</span>
<span class="w">    </span><span class="n">func</span> <span class="o">=</span> <span class="n">_StdcallFuncPtr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
<span class="gr">AttributeError</span>: <span class="n">function ordinal 0 not found</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="calling-functions">
<span id="ctypes-calling-functions"></span><h3 class="translated">调用函数<a class="headerlink" href="#calling-functions" title="Link to this heading">¶</a></h3>
<p class="translated">你可以像任何其它 Python 可调用对象一样调用这些函数。 这个例子使用了 <code class="docutils literal notranslate"><span class="pre">rand()</span></code> 函数，它不接收任何参数并返回一个伪随机整数:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">rand</span><span class="p">())</span>
<span class="go">1804289383</span>
</pre></div>
</div>
<p class="translated">在 Windows 上，你可以调用 <code class="docutils literal notranslate"><span class="pre">GetModuleHandleA()</span></code> 函数，它返回一个 win32 模块句柄 (将 <code class="docutils literal notranslate"><span class="pre">None</span></code> 作为唯一参数传入以使用 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针来调用它):</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="kc">None</span><span class="p">)))</span>
<span class="go">0x1d000000</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">如果你用 <code class="docutils literal notranslate"><span class="pre">cdecl</span></code> 调用方式调用 <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> 约定的函数，则会甩出一个异常 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。反之亦然。</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cdll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">Procedure probably called with not enough arguments (4 bytes missing)</span>
<span class="gp">&gt;&gt;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">windll</span><span class="o">.</span><span class="n">msvcrt</span><span class="o">.</span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;spam&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ValueError</span>: <span class="n">Procedure probably called with too many arguments (4 bytes in excess)</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">你必须阅读这些库的头文件或说明文档来确定它们的正确的调用协议。</p>
<p class="translated">在 Windows 中，<a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 使用 win32 结构化异常处理来防止由于在调用函数时使用非法参数导致的程序崩溃。</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">OSError</span>: <span class="n">exception: access violation reading 0x00000020</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">然而，总有许多办法，通过调用 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 使得 Python 程序崩溃。因此，你必须小心使用。 <a class="reference internal" href="faulthandler.html#module-faulthandler" title="faulthandler: Dump the Python traceback."><code class="xref py py-mod docutils literal notranslate"><span class="pre">faulthandler</span></code></a> 模块可以用于帮助诊断程序崩溃的原因。（比如由于错误的C库函数调用导致的段错误）。</p>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">None</span></code>、整数、字节串对象和（Unicode）字符串是仅有的可以直接作为这些函数调用的形参的原生 Python 对象。 <code class="docutils literal notranslate"><span class="pre">None</span></code> 将作为 C <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针传入，字节串对象和字符串将作为指向包含其数据 (<span class="c-expr sig sig-inline c"><span class="kt">char</span><span class="p">*</span></span> 或 <span class="c-expr sig sig-inline c"><span class="n">wchar_t</span><span class="p">*</span></span>) 的内存块的指针传入。 Python 整数将作为平台默认的 C <span class="c-expr sig sig-inline c"><span class="kt">int</span></span> 类型传入，它们的值会被截断以适应 C 类型的长度。</p>
<p class="translated">在我们开始调用函数前，我们必须先了解作为函数参数的 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 数据类型。</p>
</section>
<section id="fundamental-data-types">
<span id="ctypes-fundamental-data-types"></span><h3 class="translated">基础数据类型<a class="headerlink" href="#fundamental-data-types" title="Link to this heading">¶</a></h3>
<p class="translated"><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 定义了一些和C兼容的基本数据类型：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p class="translated">ctypes 类型</p></th>
<th class="head"><p class="translated">C 类型</p></th>
<th class="head"><p class="translated">Python 类型</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#ctypes.c_bool" title="ctypes.c_bool"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_bool</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">_Bool</span></span></p></td>
<td><p class="translated">bool (1)</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#ctypes.c_char" title="ctypes.c_char"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">char</span></span></p></td>
<td><p class="translated">单字符字节串对象</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#ctypes.c_wchar" title="ctypes.c_wchar"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_wchar</span></code></a></p></td>
<td><p class="translated"><code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code></p></td>
<td><p class="translated">单字符字符串</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#ctypes.c_byte" title="ctypes.c_byte"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_byte</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">char</span></span></p></td>
<td><p class="translated">int</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#ctypes.c_ubyte" title="ctypes.c_ubyte"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ubyte</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span></span></p></td>
<td><p class="translated">int</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#ctypes.c_short" title="ctypes.c_short"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_short</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">short</span></span></p></td>
<td><p class="translated">int</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#ctypes.c_ushort" title="ctypes.c_ushort"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ushort</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span></span></p></td>
<td><p class="translated">int</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">int</span></span></p></td>
<td><p class="translated">int</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#ctypes.c_int8" title="ctypes.c_int8"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int8</span></code></a></p></td>
<td><p class="translated"><code class="xref c c-type docutils literal notranslate"><span class="pre">int8_t</span></code></p></td>
<td><p class="translated">int</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#ctypes.c_int16" title="ctypes.c_int16"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int16</span></code></a></p></td>
<td><p class="translated"><code class="xref c c-type docutils literal notranslate"><span class="pre">int16_t</span></code></p></td>
<td><p class="translated">int</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#ctypes.c_int32" title="ctypes.c_int32"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int32</span></code></a></p></td>
<td><p class="translated"><code class="xref c c-type docutils literal notranslate"><span class="pre">int32_t</span></code></p></td>
<td><p class="translated">int</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#ctypes.c_int64" title="ctypes.c_int64"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int64</span></code></a></p></td>
<td><p class="translated"><code class="xref c c-type docutils literal notranslate"><span class="pre">int64_t</span></code></p></td>
<td><p class="translated">int</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#ctypes.c_uint" title="ctypes.c_uint"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_uint</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span></span></p></td>
<td><p class="translated">int</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#ctypes.c_uint8" title="ctypes.c_uint8"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_uint8</span></code></a></p></td>
<td><p class="translated"><code class="xref c c-type docutils literal notranslate"><span class="pre">uint8_t</span></code></p></td>
<td><p class="translated">int</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#ctypes.c_uint16" title="ctypes.c_uint16"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_uint16</span></code></a></p></td>
<td><p class="translated"><code class="xref c c-type docutils literal notranslate"><span class="pre">uint16_t</span></code></p></td>
<td><p class="translated">int</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#ctypes.c_uint32" title="ctypes.c_uint32"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_uint32</span></code></a></p></td>
<td><p class="translated"><code class="xref c c-type docutils literal notranslate"><span class="pre">uint32_t</span></code></p></td>
<td><p class="translated">int</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#ctypes.c_uint64" title="ctypes.c_uint64"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_uint64</span></code></a></p></td>
<td><p class="translated"><code class="xref c c-type docutils literal notranslate"><span class="pre">uint64_t</span></code></p></td>
<td><p class="translated">int</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_long</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">long</span></span></p></td>
<td><p class="translated">int</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#ctypes.c_ulong" title="ctypes.c_ulong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ulong</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span></span></p></td>
<td><p class="translated">int</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#ctypes.c_longlong" title="ctypes.c_longlong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_longlong</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="n">__int64</span></span> 或 <span class="c-expr sig sig-inline c"><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span></p></td>
<td><p class="translated">int</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#ctypes.c_ulonglong" title="ctypes.c_ulonglong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ulonglong</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">__int64</span></span> 或 <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span></p></td>
<td><p class="translated">int</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#ctypes.c_size_t" title="ctypes.c_size_t"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_size_t</span></code></a></p></td>
<td><p class="translated"><code class="xref c c-type docutils literal notranslate"><span class="pre">size_t</span></code></p></td>
<td><p class="translated">int</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#ctypes.c_ssize_t" title="ctypes.c_ssize_t"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ssize_t</span></code></a></p></td>
<td><p class="translated"><code class="xref c c-type docutils literal notranslate"><span class="pre">ssize_t</span></code> 或 <span class="c-expr sig sig-inline c"><a class="reference internal" href="../c-api/intro.html#c.Py_ssize_t" title="Py_ssize_t"><span class="n">Py_ssize_t</span></a></span></p></td>
<td><p class="translated">int</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#ctypes.c_time_t" title="ctypes.c_time_t"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_time_t</span></code></a></p></td>
<td><p class="translated"><code class="xref c c-type docutils literal notranslate"><span class="pre">time_t</span></code></p></td>
<td><p class="translated">int</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#ctypes.c_float" title="ctypes.c_float"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_float</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">float</span></span></p></td>
<td><p class="translated">float</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#ctypes.c_double" title="ctypes.c_double"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_double</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">double</span></span></p></td>
<td><p class="translated">float</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#ctypes.c_longdouble" title="ctypes.c_longdouble"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_longdouble</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">long</span><span class="w"> </span><span class="kt">double</span></span></p></td>
<td><p class="translated">float</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">char</span><span class="p">*</span></span> (以 NUL 结尾)</p></td>
<td><p class="translated">字节串对象或 <code class="docutils literal notranslate"><span class="pre">None</span></code></p></td>
</tr>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#ctypes.c_wchar_p" title="ctypes.c_wchar_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_wchar_p</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="n">wchar_t</span><span class="p">*</span></span> (以 NUL 结尾)</p></td>
<td><p class="translated">字符串或 <code class="docutils literal notranslate"><span class="pre">None</span></code></p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#ctypes.c_void_p" title="ctypes.c_void_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_void_p</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span></p></td>
<td><p class="translated">int 或 <code class="docutils literal notranslate"><span class="pre">None</span></code></p></td>
</tr>
</tbody>
</table>
<ol class="arabic simple">
<li><p class="translated">构造函数接受任何具有真值的对象。</p></li>
</ol>
<p class="translated">此外，如果 IEC 60559 兼容的复数计算 (附件 G) 在 C 和 <code class="docutils literal notranslate"><span class="pre">libffi</span></code> 中都受到支持，则下列复数类型将可用：</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p class="translated">ctypes 类型</p></th>
<th class="head"><p class="translated">C 类型</p></th>
<th class="head"><p class="translated">Python 类型</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#ctypes.c_float_complex" title="ctypes.c_float_complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_float_complex</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">float</span><span class="w"> </span><span class="kt">complex</span></span></p></td>
<td><p class="translated">复数</p></td>
</tr>
<tr class="row-odd"><td><p class="translated"><a class="reference internal" href="#ctypes.c_double_complex" title="ctypes.c_double_complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_double_complex</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">double</span><span class="w"> </span><span class="kt">complex</span></span></p></td>
<td><p class="translated">复数</p></td>
</tr>
<tr class="row-even"><td><p class="translated"><a class="reference internal" href="#ctypes.c_longdouble_complex" title="ctypes.c_longdouble_complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_longdouble_complex</span></code></a></p></td>
<td><p class="translated"><span class="c-expr sig sig-inline c"><span class="kt">long</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="kt">complex</span></span></p></td>
<td><p class="translated">复数</p></td>
</tr>
</tbody>
</table>
<p class="translated">所有这些类型都可以通过使用正确类型和值的可选初始值调用它们来创建:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c_int</span><span class="p">()</span>
<span class="go">c_long(0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_wchar_p</span><span class="p">(</span><span class="s2">&quot;Hello, World&quot;</span><span class="p">)</span>
<span class="go">c_wchar_p(140018365411392)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_ushort</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="go">c_ushort(65533)</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">由于这些类型是可变的，它们的值也可以在以后更改:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">c_long(42)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">99</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">-99</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">给指针类型的实例Assigning a new value to instances of the pointer types <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a>, <a class="reference internal" href="#ctypes.c_wchar_p" title="ctypes.c_wchar_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_wchar_p</span></code></a> 和 <a class="reference internal" href="#ctypes.c_void_p" title="ctypes.c_void_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_void_p</span></code></a> 赋新值会改变它们所指向的 <em>内存位置</em>，而不是内存块的 <em>内容</em> (当然不是，因为 Python 字符串对象是不可变的):</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;Hello, World&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_s</span> <span class="o">=</span> <span class="n">c_wchar_p</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c_s</span><span class="p">)</span>
<span class="go">c_wchar_p(139966785747344)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c_s</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">Hello World</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c_s</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="s2">&quot;Hi, there&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c_s</span><span class="p">)</span>              <span class="c1"># 内存分配已改变</span>
<span class="go">c_wchar_p(139966783348904)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c_s</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="go">Hi, there</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>                <span class="c1"># 第一个对象未改变</span>
<span class="go">Hello, World</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">但你要注意不能将它们传递给会改变指针所指内存的函数。如果你需要可改变的内存块，ctypes 提供了 <a class="reference internal" href="#ctypes.create_string_buffer" title="ctypes.create_string_buffer"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_string_buffer()</span></code></a> 函数，它提供多种方式创建这种内存块。当前的内存块内容可以通过 <code class="docutils literal notranslate"><span class="pre">raw</span></code> 属性存取，如果你希望将它作为NUL结束的字符串，请使用 <code class="docutils literal notranslate"><span class="pre">value</span></code> 属性:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>            <span class="c1"># 创建一个 3 字节的缓冲区，初始化为 NUL 字节</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">))</span>
<span class="go">3 b&#39;\x00\x00\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Hello&quot;</span><span class="p">)</span>     <span class="c1"># 创建一个包含以 NUL 结束的字符串的缓冲区</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">))</span>
<span class="go">6 b&#39;Hello\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
<span class="go">b&#39;Hello&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Hello&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="c1"># 创建一个 10 字节的缓冲区</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">))</span>
<span class="go">10 b&#39;Hello\x00\x00\x00\x00\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;Hi&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">raw</span><span class="p">))</span>
<span class="go">10 b&#39;Hi\x00lo\x00\x00\x00\x00\x00&#39;</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated"><a class="reference internal" href="#ctypes.create_string_buffer" title="ctypes.create_string_buffer"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_string_buffer()</span></code></a> 函数取代了旧了 <code class="xref py py-func docutils literal notranslate"><span class="pre">c_buffer()</span></code> 函数（后者仍可作为别名使用）。 要创建一个包含 C 类型 <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code> 的 unicode 字符的可变内存块，请使用 <a class="reference internal" href="#ctypes.create_unicode_buffer" title="ctypes.create_unicode_buffer"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_unicode_buffer()</span></code></a> 函数。</p>
</section>
<section id="calling-functions-continued">
<span id="ctypes-calling-functions-continued"></span><h3 class="translated">调用函数，继续<a class="headerlink" href="#calling-functions-continued" title="Link to this heading">¶</a></h3>
<p class="translated">注意 printf 将打印到真正标准输出设备，而*不是* <a class="reference internal" href="sys.html#sys.stdout" title="sys.stdout"><code class="xref py py-data docutils literal notranslate"><span class="pre">sys.stdout</span></code></a>，因此这些实例只能在控制台提示符下工作，而不能在 <em>IDLE</em> 或 <em>PythonWin</em> 中运行。</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">printf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Hello, </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;World!&quot;</span><span class="p">)</span>
<span class="go">Hello, World!</span>
<span class="go">14</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;Hello, %S</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;World!&quot;</span><span class="p">)</span>
<span class="go">Hello, World!</span>
<span class="go">14</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> bottles of beer</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span>
<span class="go">42 bottles of beer</span>
<span class="go">19</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%f</span><span class="s2"> bottles of beer</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mf">42.5</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ctypes.ArgumentError</span>: <span class="n">argument 2: TypeError: Don&#39;t know how to convert parameter 2</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">正如前面所提到过的，除了整数、字符串以及字节串之外，所有的 Python 类型都必须使用它们对应的 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 类型包装，才能够被正确地转换为所需的C语言类型。</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;An int </span><span class="si">%d</span><span class="s2">, a double </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">1234</span><span class="p">,</span> <span class="n">c_double</span><span class="p">(</span><span class="mf">3.14</span><span class="p">))</span>
<span class="go">An int 1234, a double 3.140000</span>
<span class="go">31</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="calling-variadic-functions">
<span id="ctypes-calling-variadic-functions"></span><h3 class="translated">调用可变函数<a class="headerlink" href="#calling-variadic-functions" title="Link to this heading">¶</a></h3>
<p class="translated">在许多平台上通过 ctypes 调用可变函数与调用带有固定数量形参的函数是完全一样的。 在某些平台，特别是针对 Apple 平台的 ARM64 上，可变函数的调用约定与常规函数则是不同的。</p>
<p class="translated">在这些平台上要求为常规、非可变函数参数指定 <a class="reference internal" href="#ctypes._CFuncPtr.argtypes" title="ctypes._CFuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a> 属性：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">libc</span><span class="o">.</span><span class="n">printf</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_char_p</span><span class="p">]</span>
</pre></div>
</div>
<p class="translated">因为指定该属性不会影响可移植性所以建议总是为所有可变函数指定 <a class="reference internal" href="#ctypes._CFuncPtr.argtypes" title="ctypes._CFuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a>。</p>
</section>
<section id="calling-functions-with-your-own-custom-data-types">
<span id="ctypes-calling-functions-with-own-custom-data-types"></span><h3 class="translated">使用自定义的数据类型调用函数<a class="headerlink" href="#calling-functions-with-your-own-custom-data-types" title="Link to this heading">¶</a></h3>
<p class="translated">您也可以通过自定义 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 参数转换方式来允许将你自己的类实例作为函数参数。 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 会寻找 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_as_parameter_</span></code> 属性并使用它作为函数参数。 属性必须是整数、字符串、字节串、<a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 实例或者带有 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_as_parameter_</span></code> 属性的对象:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">Bottles</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">_as_parameter_</span> <span class="o">=</span> <span class="n">number</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bottles</span> <span class="o">=</span> <span class="n">Bottles</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> bottles of beer</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">bottles</span><span class="p">)</span>
<span class="go">42 bottles of beer</span>
<span class="go">19</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">如果你不想将实例数据存储在 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_as_parameter_</span></code> 实例变量中，可以定义一个根据请求提供属性的 <a class="reference internal" href="functions.html#property" title="property"><code class="xref py py-class docutils literal notranslate"><span class="pre">property</span></code></a>。</p>
</section>
<section id="specifying-the-required-argument-types-function-prototypes">
<span id="ctypes-specifying-required-argument-types"></span><h3 class="translated">指定必选参数的类型(函数原型)<a class="headerlink" href="#specifying-the-required-argument-types-function-prototypes" title="Link to this heading">¶</a></h3>
<p class="translated">可以通过设置 <a class="reference internal" href="#ctypes._CFuncPtr.argtypes" title="ctypes._CFuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a> 属性来指定从 DLL 导出函数的必选参数类型。</p>
<p class="translated"><a class="reference internal" href="#ctypes._CFuncPtr.argtypes" title="ctypes._CFuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a> 必须是一个 C 数据类型的序列（这里 <code class="xref py py-func docutils literal notranslate"><span class="pre">printf()</span></code> 函数可能不是一个好例子，因为它会根据格式字符串的不同接受可变数量和不同类型的形参，但另一方面这对尝试此功能来说也很方便）:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">c_char_p</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">,</span> <span class="n">c_int</span><span class="p">,</span> <span class="n">c_double</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;String &#39;</span><span class="si">%s</span><span class="s2">&#39;, Int </span><span class="si">%d</span><span class="s2">, Double </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;Hi&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">)</span>
<span class="go">String &#39;Hi&#39;, Int 10, Double 2.200000</span>
<span class="go">37</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">指定数据类型可以防止不合理的参数传递（就像 C 函数的原型），并且会自动尝试将参数转换为需要的类型:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ctypes.ArgumentError</span>: <span class="n">argument 2: TypeError: &#39;int&#39; object cannot be interpreted as ctypes.c_char_p</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">printf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%d</span><span class="s2"> </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">X 2 3.000000</span>
<span class="go">13</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">如果你定义了自己的类并将其传递给函数调用，则你必须为它们实现 <a class="reference internal" href="#ctypes._CData.from_param" title="ctypes._CData.from_param"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_param()</span></code></a> 类方法才能够在 <a class="reference internal" href="#ctypes._CFuncPtr.argtypes" title="ctypes._CFuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a> 序列中使用它们。 <a class="reference internal" href="#ctypes._CData.from_param" title="ctypes._CData.from_param"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_param()</span></code></a> 类方法接受传递给函数调用的 Python 对象，它应该进行类型检查或者其他必要的操作以确保这个对象是可接受的，然后返回对象本身、它的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_as_parameter_</span></code> 属性，或在此情况下作为 C 函数参数传入的任何东西。 同样，结果应该是整数、字符串、字节串、<a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 实例或是具有 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_as_parameter_</span></code> 属性的对象。</p>
</section>
<section id="return-types">
<span id="ctypes-return-types"></span><h3 class="translated">返回类型<a class="headerlink" href="#return-types" title="Link to this heading">¶</a></h3>
<p class="translated">在默认情况下都会假定函数返回 C <span class="c-expr sig sig-inline c"><span class="kt">int</span></span> 类型。 其他返回类型可通过设置函数对象的 setting the <a class="reference internal" href="#ctypes._CFuncPtr.restype" title="ctypes._CFuncPtr.restype"><code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code></a> 属性来指定。</p>
<p class="translated"><code class="xref c c-func docutils literal notranslate"><span class="pre">time()</span></code> 的 C 原型是 <code class="docutils literal notranslate"><span class="pre">time_t</span> <span class="pre">time(time_t</span> <span class="pre">*)</span></code>。 由于 <code class="xref c c-type docutils literal notranslate"><span class="pre">time_t</span></code> 的类型可能不同于默认返回类型 <span class="c-expr sig sig-inline c"><span class="kt">int</span></span>，你应当指定 <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> 属性:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">c_time_t</span>
</pre></div>
</div>
<p class="translated">参数类型可以使用 <a class="reference internal" href="#ctypes._CFuncPtr.argtypes" title="ctypes._CFuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a> 来指定:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">(</span><span class="n">POINTER</span><span class="p">(</span><span class="n">c_time_t</span><span class="p">),)</span>
</pre></div>
</div>
<p class="translated">调用该函数时如果要将 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针作为第一个参数，请使用 <code class="docutils literal notranslate"><span class="pre">None</span></code>:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
<span class="go">1150640792</span>
</pre></div>
</div>
<p class="translated">下面是一个更高级的示例，它使用了 <code class="xref py py-func docutils literal notranslate"><span class="pre">strchr()</span></code> 函数，该函数接收一个字符串指针和一个字符，并返回一个字符串指针:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">strchr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">))</span>
<span class="go">8059983</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">c_char_p</span>    <span class="c1"># c_char_p is a pointer to a string</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">))</span>
<span class="go">b&#39;def&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">如果你想要避免上面的 <a class="reference internal" href="functions.html#ord" title="ord"><code class="xref py py-func docutils literal notranslate"><span class="pre">ord(&quot;x&quot;)</span></code></a> 调用，你可以设置 <a class="reference internal" href="#ctypes._CFuncPtr.argtypes" title="ctypes._CFuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a> 属性，第二个参数将从单字符 Python 字节串对象转换为 C char：</p>
<div class="translated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">c_char_p</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">c_char_p</span><span class="p">,</span> <span class="n">c_char</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>
<span class="go">b&#39;def&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;def&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="gr">ctypes.ArgumentError</span>: <span class="n">argument 2: TypeError: one character bytes, bytearray or integer expected</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;x&quot;</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strchr</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;d&quot;</span><span class="p">)</span>
<span class="go">b&#39;def&#39;</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">如果外部函数返回一个整数，你也可以使用一个 Python 可调用对象（例如函数或类）作为 <a class="reference internal" href="#ctypes._CFuncPtr.restype" title="ctypes._CFuncPtr.restype"><code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code></a> 属性。 该可调用对象被调用时将附带 C 函数返回的 <em>整数</em>，其调用结果将被用作函数调用的结果值。 这对于检查错误返回值并自动引发异常来说很有用处:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span> <span class="o">=</span> <span class="n">windll</span><span class="o">.</span><span class="n">kernel32</span><span class="o">.</span><span class="n">GetModuleHandleA</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">ValidHandle</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">raise</span> <span class="n">WinError</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">value</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ValidHandle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="go">486539264</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetModuleHandle</span><span class="p">(</span><span class="s2">&quot;something silly&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">3</span>, in <span class="n">ValidHandle</span>
<span class="gr">OSError</span>: <span class="n">[Errno 126] The specified module could not be found.</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">WinError</span></code> 函数可以调用 Windows 的  <code class="docutils literal notranslate"><span class="pre">FormatMessage()</span></code> API 获取错误码的字符串说明，然后 <em>返回</em> 一个异常。 <code class="docutils literal notranslate"><span class="pre">WinError</span></code> 接收一个可选的错误码作为参数，如果没有的话，它将调用  <a class="reference internal" href="#ctypes.GetLastError" title="ctypes.GetLastError"><code class="xref py py-func docutils literal notranslate"><span class="pre">GetLastError()</span></code></a> 获取错误码。</p>
<p class="translated">请注意通过 <a class="reference internal" href="#ctypes._CFuncPtr.errcheck" title="ctypes._CFuncPtr.errcheck"><code class="xref py py-attr docutils literal notranslate"><span class="pre">errcheck</span></code></a> 属性可提供更强大的错误检查机制；详情见参考手册。</p>
</section>
<section id="passing-pointers-or-passing-parameters-by-reference">
<span id="ctypes-passing-pointers"></span><h3 class="translated">传递指针（或以引用方式传递形参）<a class="headerlink" href="#passing-pointers-or-passing-parameters-by-reference" title="Link to this heading">¶</a></h3>
<p class="translated">有时候 C 函数接口可能由于要往某个地址写入值，或者数据太大不适合作为值传递，从而希望接收一个 <em>指针</em> 作为数据参数类型。这和 <em>传递参数引用</em> 类似。</p>
<p class="translated"><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 暴露了 <a class="reference internal" href="#ctypes.byref" title="ctypes.byref"><code class="xref py py-func docutils literal notranslate"><span class="pre">byref()</span></code></a> 函数用于通过引用传递参数，使用 <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a> 函数也能达到同样的效果，只不过 <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a> 需要更多步骤，因为它要先构造一个真实指针对象。所以在 Python 代码本身不需要使用这个指针对象的情况下，使用 <a class="reference internal" href="#ctypes.byref" title="ctypes.byref"><code class="xref py py-func docutils literal notranslate"><span class="pre">byref()</span></code></a> 效率更高。</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">c_float</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">create_string_buffer</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\000</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
<span class="go">0 0.0 b&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">sscanf</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;1 3.14 Hello&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%f</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
<span class="gp">... </span>            <span class="n">byref</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">byref</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">s</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
<span class="go">1 3.1400001049 b&#39;Hello&#39;</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="structures-and-unions">
<span id="ctypes-structures-unions"></span><h3 class="translated">结构体和联合<a class="headerlink" href="#structures-and-unions" title="Link to this heading">¶</a></h3>
<p class="translated">结构体和联合必须派生自 <a class="reference internal" href="#ctypes.Structure" title="ctypes.Structure"><code class="xref py py-class docutils literal notranslate"><span class="pre">Structure</span></code></a> 和 <a class="reference internal" href="#ctypes.Union" title="ctypes.Union"><code class="xref py py-class docutils literal notranslate"><span class="pre">Union</span></code></a> 基类，这两个基类是在 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 模块中定义的。 每个子类都必须定义 <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> 属性。 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code> 必须是一个 <em>2元组</em> 的列表，其中包含一个 <em>字段名称</em> 和一个 <em>字段类型</em>。</p>
<p class="translated">type 字段必须是一个 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 类型，比如  <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a>，或者其他 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 类型: 结构体、联合、数组、指针。</p>
<p class="translated">这是一个简单的 POINT 结构体，它包含名称为 <em>x</em> 和 <em>y</em> 的两个变量，还展示了如何通过构造函数初始化结构体。</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">POINT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">point</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">10 20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">point</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">0 5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">POINT</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">too many initializers</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">当然，你可以构造更复杂的结构体。一个结构体可以通过设置 type 字段包含其他结构体或者自身。</p>
<p class="translated">这是以一个 RECT 结构体，他包含了两个 POINT ，分别叫 <em>upperleft</em> 和 <em>lowerright</em>:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">RECT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;upperleft&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;lowerright&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rc</span><span class="o">.</span><span class="n">upperleft</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">upperleft</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">0 5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rc</span><span class="o">.</span><span class="n">lowerright</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">lowerright</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">0 0</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">嵌套结构体可以通过几种方式构造初始化:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">(</span><span class="n">POINT</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
<p class="translated">字段 <a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descriptor</span></a> 可以从 <em>class</em> 提取，它们在调试时很有用处因为它们能提供有用的信息。 参见 <a class="reference internal" href="#ctypes.CField" title="ctypes.CField"><code class="xref py py-class docutils literal notranslate"><span class="pre">CField</span></code></a>:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">POINT</span><span class="o">.</span><span class="n">x</span>
<span class="go">&lt;ctypes.CField &#39;x&#39; type=c_int, ofs=0, size=4&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">POINT</span><span class="o">.</span><span class="n">y</span>
<span class="go">&lt;ctypes.CField &#39;y&#39; type=c_int, ofs=4, size=4&gt;</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition warning" id="ctypes-structureunion-alignment-byte-order">
<p class="admonition-title">警告</p>
<p class="translated"><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 不支持带位域的结构体、联合以值的方式传给函数。这可能在 32 位 x86 平台上可以正常工作，但是对于一般情况，这种行为是未定义的。带位域的结构体、联合应该总是通过指针传递给函数。</p>
</div>
</section>
<section id="structure-union-layout-alignment-and-byte-order">
<h3 class="translated">结构/联合布局、对齐和字节顺序<a class="headerlink" href="#structure-union-layout-alignment-and-byte-order" title="Link to this heading">¶</a></h3>
<p class="translated">默认情况下，结构体和联合的字段布局方式与 C 编译器的处理方式相同。可以通过在子类定义中指定 <a class="reference internal" href="#ctypes.Structure._layout_" title="ctypes.Structure._layout_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_layout_</span></code></a> 类属性来完全覆盖此行为；有关详细信息，请参阅该属性的文档。</p>
<p class="translated">通过分别设置类属性 <a class="reference internal" href="#ctypes.Structure._pack_" title="ctypes.Structure._pack_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_pack_</span></code></a> 和/或 <a class="reference internal" href="#ctypes.Structure._align_" title="ctypes.Structure._align_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_align_</span></code></a> 可以为字段和/或为结构体本身指定最大对齐值。 请参阅相应属性文档了解详情。</p>
<p class="translated"><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 中的结构体和联合使用的是本地字节序。要使用非本地字节序，可以使用 <a class="reference internal" href="#ctypes.BigEndianStructure" title="ctypes.BigEndianStructure"><code class="xref py py-class docutils literal notranslate"><span class="pre">BigEndianStructure</span></code></a>, <a class="reference internal" href="#ctypes.LittleEndianStructure" title="ctypes.LittleEndianStructure"><code class="xref py py-class docutils literal notranslate"><span class="pre">LittleEndianStructure</span></code></a>, <a class="reference internal" href="#ctypes.BigEndianUnion" title="ctypes.BigEndianUnion"><code class="xref py py-class docutils literal notranslate"><span class="pre">BigEndianUnion</span></code></a>, and <a class="reference internal" href="#ctypes.LittleEndianUnion" title="ctypes.LittleEndianUnion"><code class="xref py py-class docutils literal notranslate"><span class="pre">LittleEndianUnion</span></code></a> 作为基类。这些类不能包含指针字段。</p>
</section>
<section id="bit-fields-in-structures-and-unions">
<span id="ctypes-bit-fields-in-structures-unions"></span><h3 class="translated">结构体和联合中的位域<a class="headerlink" href="#bit-fields-in-structures-and-unions" title="Link to this heading">¶</a></h3>
<p class="translated">可以创建包含位字段的结构体和联合。 位字段只适用于整数字段，位宽度是由 <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> 元组中的第三项来指定的:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">Int</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;first_16&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;second_16&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">,</span> <span class="mi">16</span><span class="p">)]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Int</span><span class="o">.</span><span class="n">first_16</span><span class="p">)</span>
<span class="go">&lt;ctypes.CField &#39;first_16&#39; type=c_int, ofs=0, bit_size=16, bit_offset=0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Int</span><span class="o">.</span><span class="n">second_16</span><span class="p">)</span>
<span class="go">&lt;ctypes.CField &#39;second_16&#39; type=c_int, ofs=0, bit_size=16, bit_offset=16&gt;</span>
</pre></div>
</div>
<p class="translated">需要注意的是，位域在内存中的分配和布局并非 C 标准所定义；其实现取决于具体的编译器。默认情况下，Python 会尝试匹配当前平台上“原生”编译器的行为。有关默认行为以及如何修改它的详细信息，请参阅 <a class="reference internal" href="#ctypes.Structure._layout_" title="ctypes.Structure._layout_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_layout_</span></code></a> 属性。</p>
</section>
<section id="arrays">
<span id="ctypes-arrays"></span><h3 class="translated">数组<a class="headerlink" href="#arrays" title="Link to this heading">¶</a></h3>
<p class="translated">数组是一个序列，包含指定个数元素，且必须类型相同。</p>
<p class="translated">创建数组类型的推荐方式是使用一个类型乘以一个正数:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">TenPointsArrayType</span> <span class="o">=</span> <span class="n">POINT</span> <span class="o">*</span> <span class="mi">10</span>
</pre></div>
</div>
<p class="translated">下面是一个构造的数据案例，结构体中包含了4个 POINT 和一些其他东西。</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">POINT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">MyStruct</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">c_float</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;point_array&quot;</span><span class="p">,</span> <span class="n">POINT</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">MyStruct</span><span class="p">()</span><span class="o">.</span><span class="n">point_array</span><span class="p">))</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">和平常一样，通过调用它创建实例:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">arr</span> <span class="o">=</span> <span class="n">TenPointsArrayType</span><span class="p">()</span>
<span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">以上代码会打印几行 <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">0</span></code> ，因为数组内容被初始化为 0.</p>
<p class="translated">也能通过指定正确类型的数据来初始化:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TenIntegers</span> <span class="o">=</span> <span class="n">c_int</span> <span class="o">*</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ii</span> <span class="o">=</span> <span class="n">TenIntegers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
<span class="go">&lt;c_long_Array_10 object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ii</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">1 2 3 4 5 6 7 8 9 10</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="pointers">
<span id="ctypes-pointers"></span><h3 class="translated">指针<a class="headerlink" href="#pointers" title="Link to this heading">¶</a></h3>
<p class="translated">可以将 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 类型数据传入 <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a> 函数创建指针:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">指针实例拥有 <a class="reference internal" href="#ctypes._Pointer.contents" title="ctypes._Pointer.contents"><code class="xref py py-attr docutils literal notranslate"><span class="pre">contents</span></code></a> 属性，它返回指针指向的真实对象，如上面的 <code class="docutils literal notranslate"><span class="pre">i</span></code> 对象:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span>
<span class="go">c_long(42)</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">注意 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 并没有 OOR （返回原始对象）, 每次访问这个属性时都会构造返回一个新的相同对象:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span> <span class="ow">is</span> <span class="n">i</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span> <span class="ow">is</span> <span class="n">pi</span><span class="o">.</span><span class="n">contents</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">将这个指针的 contents 属性赋值为另一个 <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a> 实例将会导致该指针指向该实例的内存地址:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">(</span><span class="mi">99</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span> <span class="o">=</span> <span class="n">i</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">.</span><span class="n">contents</span>
<span class="go">c_long(99)</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">指针对象也可以通过整数下标进行访问:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">99</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">通过整数下标赋值可以改变指针所指向的真实内容:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">c_long(99)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">22</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">c_long(22)</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">使用 0 以外的索引也是合法的，但是你必须确保知道自己为什么这么做，就像 C 语言中: 你可以访问或者修改任意内存内容。 通常只会在函数接收指针是才会使用这种特性，而且你 <em>知道</em> 这个指针指向的是一个数组而不是单个值。</p>
<p class="translated">内部细节,  <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a> 函数不只是创建了一个指针实例，它首先创建了一个指针 <em>类型</em> 。这是通过调用 <a class="reference internal" href="#ctypes.POINTER" title="ctypes.POINTER"><code class="xref py py-func docutils literal notranslate"><span class="pre">POINTER()</span></code></a> 函数实现的，它接收  <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 类型为参数，返回一个新的类型:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span>
<span class="go">&lt;class &#39;ctypes.LP_c_long&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">expected c_long instead of int</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PI</span><span class="p">(</span><span class="n">c_int</span><span class="p">(</span><span class="mi">42</span><span class="p">))</span>
<span class="go">&lt;ctypes.LP_c_long object at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">无参调用指针类型可以创建一个 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针。 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针的布尔值是 <code class="docutils literal notranslate"><span class="pre">False</span></code></p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">null_ptr</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">)()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="n">null_ptr</span><span class="p">))</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">解引用指针的时候， <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 会帮你检测是否指针为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> (但是解引用无效的 非 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针仍会导致 Python 崩溃):</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">null_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">    </span><span class="o">....</span>
<span class="gr">ValueError</span>: <span class="n">NULL pointer access</span>
<span class="gp">&gt;&gt;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">null_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1234</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">    </span><span class="o">....</span>
<span class="gr">ValueError</span>: <span class="n">NULL pointer access</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="thread-safety-without-the-gil">
<span id="ctypes-thread-safety"></span><h3 class="translated">没有 GIL 时的线程安全性<a class="headerlink" href="#thread-safety-without-the-gil" title="Link to this heading">¶</a></h3>
<p class="translated">从 Python 3.13 开始，在 <a class="reference internal" href="../glossary.html#term-free-threading"><span class="xref std std-term">自由线程</span></a> 构建中可以禁用 <a class="reference internal" href="../glossary.html#term-GIL"><span class="xref std std-term">GIL</span></a>。在 ctypes 中，对单个对象的并发读写是安全的，但跨多个对象则不安全：</p>
<blockquote>
<div><div class="translated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">number</span> <span class="o">=</span> <span class="n">c_int</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pointer_a</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pointer_b</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p class="translated">在上述情况下，如果 GIL 已禁用，只有当一个对象对地址进行读写时才是安全的。因此，<code class="docutils literal notranslate"><span class="pre">pointer_a</span></code> 可以在多个线程之间共享和写入，但前提是 <code class="docutils literal notranslate"><span class="pre">pointer_b</span></code> 不同时尝试执行相同操作。如果这是个问题，可以考虑使用 <a class="reference internal" href="threading.html#threading.Lock" title="threading.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Lock</span></code></a> 来同步对内存的访问：</p>
<blockquote>
<div><div class="translated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">threading</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Thread 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
<span class="gp">... </span>   <span class="n">pointer_a</span><span class="o">.</span><span class="n">contents</span> <span class="o">=</span> <span class="mi">24</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Thread 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
<span class="gp">... </span>   <span class="n">pointer_b</span><span class="o">.</span><span class="n">contents</span> <span class="o">=</span> <span class="mi">42</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="type-conversions">
<span id="ctypes-type-conversions"></span><h3 class="translated">类型转换<a class="headerlink" href="#type-conversions" title="Link to this heading">¶</a></h3>
<p class="translated">通常，ctypes 会进行严格的类型检查。 这意味着，如果在某个函数的 <a class="reference internal" href="#ctypes._CFuncPtr.argtypes" title="ctypes._CFuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a> 列表中有 <code class="docutils literal notranslate"><span class="pre">POINTER(c_int)</span></code> 或在结构体定义中将其用作成员字段的类型，则只接受完全相同类型的实例。 此规则也有一些例外情况，在这些情况下 ctypes 可以接受其他对象。 例如，你可以传入兼容的数组实例而不是指针类型。 因此，对于 <code class="docutils literal notranslate"><span class="pre">POINTER(c_int)</span></code>，ctypes 接受一个 c_int 数组:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">Bar</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;values&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span> <span class="o">=</span> <span class="n">Bar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_int</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bar</span><span class="o">.</span><span class="n">count</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">bar</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="gp">...</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">此外，如果一个函数参数在 <a class="reference internal" href="#ctypes._CFuncPtr.argtypes" title="ctypes._CFuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a> 中显式地声明为指针类型 (如 <code class="docutils literal notranslate"><span class="pre">POINTER(c_int)</span></code>)，则可以向该函数传递所指向的类型的对象 (在本例 中为 <code class="docutils literal notranslate"><span class="pre">c_int</span></code>)。 在这种情况下，ctypes 将自动应用所需的 <a class="reference internal" href="#ctypes.byref" title="ctypes.byref"><code class="xref py py-func docutils literal notranslate"><span class="pre">byref()</span></code></a> 转换。conversion in this case automatically.</p>
<p class="translated">可以给指针内容赋值为 None 将其设置为 <code class="docutils literal notranslate"><span class="pre">Null</span></code></p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="kc">None</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">有时候你拥有一个不兼容的类型。 在 C 中，你可以将一个类型强制转换为另一个。 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 中的 a <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> 函数提供了相同的功能。 上面的结构体  <code class="docutils literal notranslate"><span class="pre">Bar</span></code> 的 <code class="docutils literal notranslate"><span class="pre">value</span></code> 字段接收  <code class="docutils literal notranslate"><span class="pre">POINTER(c_int)</span></code> 指针或者 <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a> 数组，但是不能接受其他类型的实例:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_byte</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">incompatible types, c_byte_Array_4 instance instead of LP_c_long instance</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">这种情况下, 需要手动使用 <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> 函数。</p>
<p class="translated"><a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> 函数可以将一个指针实例强制转换为另一种 ctypes 类型。 <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> 接收两个参数，一个 ctypes 指针对象或者可以被转换为指针的其他类型对象，和一个 ctypes 指针类型。 返回第二个类型的一个实例，该返回实例和第一个参数指向同一片内存空间:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_byte</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cast</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
<span class="go">&lt;ctypes.LP_c_long object at ...&gt;</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">所以  <a class="reference internal" href="#ctypes.cast" title="ctypes.cast"><code class="xref py py-func docutils literal notranslate"><span class="pre">cast()</span></code></a> 可以用来给结构体 <code class="docutils literal notranslate"><span class="pre">Bar</span></code> 的 <code class="docutils literal notranslate"><span class="pre">values</span></code> 字段赋值:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span> <span class="o">=</span> <span class="n">Bar</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bar</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">cast</span><span class="p">((</span><span class="n">c_byte</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)(),</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">bar</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="incomplete-types">
<span id="ctypes-incomplete-types"></span><h3 class="translated">不完整类型<a class="headerlink" href="#incomplete-types" title="Link to this heading">¶</a></h3>
<p class="translated"><em>不完整类型</em> 即还没有定义成员的结构体、联合或者数组。在 C 中，它们通常用于前置声明，然后在后面定义:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">cell</span><span class="p">;</span> <span class="o">/*</span> <span class="n">前向声明</span> <span class="o">*/</span>

<span class="n">struct</span> <span class="n">cell</span> <span class="p">{</span>
    <span class="n">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="n">struct</span> <span class="n">cell</span> <span class="o">*</span><span class="nb">next</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p class="translated">直接翻译成 ctypes 的代码如下，但是这行不通:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">cell</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;next&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">cell</span><span class="p">))]</span>
<span class="gp">...</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">2</span>, in <span class="n">cell</span>
<span class="gr">NameError</span>: <span class="n">name &#39;cell&#39; is not defined</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">因为新的 <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">cell</span></code> 在 class 语句本身中是不可用的。 在 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 中，我们可以定义 <code class="docutils literal notranslate"><span class="pre">cell</span></code> 类再在 class 语句之后设置 <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> 属性:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">cell</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span><span class="o">.</span><span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">),</span>
<span class="gp">... </span>                 <span class="p">(</span><span class="s2">&quot;next&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">cell</span><span class="p">))]</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">让我们试试。我们定义两个 <code class="docutils literal notranslate"><span class="pre">cell</span></code> 实例，让它们互相指向对方，然后通过指针链式访问几次:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span> <span class="o">=</span> <span class="n">cell</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;foo&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span> <span class="o">=</span> <span class="n">cell</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;bar&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c1</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c2</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">c1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">next</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">...</span>
<span class="go">foo bar foo bar foo bar foo bar</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="callback-functions">
<span id="ctypes-callback-functions"></span><h3 class="translated">回调函数<a class="headerlink" href="#callback-functions" title="Link to this heading">¶</a></h3>
<p class="translated"><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 允许创建一个指向 Python 可调用对象的 C 函数。它们有时候被称为 <em>回调函数</em> 。</p>
<p class="translated">首先，你必须为回调函数创建一个类，这个类知道调用约定，包括返回值类型以及函数接收的参数类型及个数。</p>
<p class="translated"><a class="reference internal" href="#ctypes.CFUNCTYPE" title="ctypes.CFUNCTYPE"><code class="xref py py-func docutils literal notranslate"><span class="pre">CFUNCTYPE()</span></code></a> 工厂函数使用 <code class="docutils literal notranslate"><span class="pre">cdecl</span></code> 调用约定创建回调函数类型。在 Windows 上， <a class="reference internal" href="#ctypes.WINFUNCTYPE" title="ctypes.WINFUNCTYPE"><code class="xref py py-func docutils literal notranslate"><span class="pre">WINFUNCTYPE()</span></code></a> 工厂函数使用 <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> 调用约定为回调函数创建类型。</p>
<p class="translated">这些工厂函数的第一个参数是返回值类型，回调函数的参数类型作为剩余参数。</p>
<p class="translated">这里展示一个使用标准 C 库的 <code class="xref c c-func docutils literal notranslate"><span class="pre">qsort()</span></code> 函数例子，使用它在一个回调函数的协助下对条目进行排序。 <code class="xref c c-func docutils literal notranslate"><span class="pre">qsort()</span></code> 将被用来给一个整数的数组排序:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">IntArray5</span> <span class="o">=</span> <span class="n">c_int</span> <span class="o">*</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ia</span> <span class="o">=</span> <span class="n">IntArray5</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">99</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">qsort</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="kc">None</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated"><code class="xref py py-func docutils literal notranslate"><span class="pre">qsort()</span></code> 被调用时必须传入一个指向要排序的数据的指针、数据数组中的条目数、每条目的大小以及一个指向比较函数即回调函数的指针。 回调函数将附带两个指向条目的指针进行调用，如果第一个条目小于第二个条目则它必须返回一个负整数，如果两者相等则返回零，在其他情况下则返回一个正整数。</p>
<p class="translated">所以，我们的回调函数要接收两个整数指针，返回一个整数。首先我们创建回调函数的 <code class="docutils literal notranslate"><span class="pre">类型</span></code></p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">CMPFUNC</span> <span class="o">=</span> <span class="n">CFUNCTYPE</span><span class="p">(</span><span class="n">c_int</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">首先，这是一个简单的回调，它会显示传入的值:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">py_cmp_func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;py_cmp_func&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="mi">0</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cmp_func</span> <span class="o">=</span> <span class="n">CMPFUNC</span><span class="p">(</span><span class="n">py_cmp_func</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">结果:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ia</span><span class="p">),</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">cmp_func</span><span class="p">)</span>
<span class="go">py_cmp_func 5 1</span>
<span class="go">py_cmp_func 33 99</span>
<span class="go">py_cmp_func 7 33</span>
<span class="go">py_cmp_func 5 7</span>
<span class="go">py_cmp_func 1 7</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">现在我们可以比较两个元素并返回有用的结果了:</p>
<div class="untranslated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">py_cmp_func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;py_cmp_func&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ia</span><span class="p">),</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">CMPFUNC</span><span class="p">(</span><span class="n">py_cmp_func</span><span class="p">))</span>
<span class="go">py_cmp_func 5 1</span>
<span class="go">py_cmp_func 33 99</span>
<span class="go">py_cmp_func 7 33</span>
<span class="go">py_cmp_func 1 7</span>
<span class="go">py_cmp_func 5 7</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">我们可以轻易地验证，现在数组是有序的了:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ia</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">1 5 7 33 99</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">这些工厂函数可以当作装饰器工厂，所以可以这样写:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@CFUNCTYPE</span><span class="p">(</span><span class="n">c_int</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_int</span><span class="p">))</span>
<span class="gp">... </span><span class="k">def</span><span class="w"> </span><span class="nf">py_cmp_func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;py_cmp_func&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qsort</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ia</span><span class="p">),</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">c_int</span><span class="p">),</span> <span class="n">py_cmp_func</span><span class="p">)</span>
<span class="go">py_cmp_func 5 1</span>
<span class="go">py_cmp_func 33 99</span>
<span class="go">py_cmp_func 7 33</span>
<span class="go">py_cmp_func 1 7</span>
<span class="go">py_cmp_func 5 7</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p class="translated">请确保你维持的 <a class="reference internal" href="#ctypes.CFUNCTYPE" title="ctypes.CFUNCTYPE"><code class="xref py py-func docutils literal notranslate"><span class="pre">CFUNCTYPE()</span></code></a> 对象的引用周期与它们在 C 代码中的使用期一样长。 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 不会确保这一点，如果不这样做，它们可能会被垃圾回收，导致程序在执行回调函数时发生崩溃。</p>
<p class="translated">注意，如果回调函数在Python之外的另外一个线程使用(比如，外部代码调用这个回调函数)， ctypes 会在每一次调用上创建一个虚拟 Python 线程。这个行为在大多数情况下是合理的，但也意味着如果有数据使用 <a class="reference internal" href="threading.html#threading.local" title="threading.local"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.local</span></code></a> 方式存储，将无法访问，就算它们是在同一个 C 线程中调用的 。</p>
</div>
</section>
<section id="accessing-values-exported-from-dlls">
<span id="ctypes-accessing-values-exported-from-dlls"></span><h3 class="translated">访问 dll 的导出变量<a class="headerlink" href="#accessing-values-exported-from-dlls" title="Link to this heading">¶</a></h3>
<p class="translated">某些共享库不仅会导出函数，还会导出变量。 一个例子就是 Python 库本身的 <a class="reference internal" href="../c-api/apiabiversion.html#c.Py_Version" title="Py_Version"><code class="xref c c-data docutils literal notranslate"><span class="pre">Py_Version</span></code></a>，Python 运行时版本号被编码为单个整数常量。</p>
<p class="translated"><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 可以通过类型的 <a class="reference internal" href="#ctypes._CData.in_dll" title="ctypes._CData.in_dll"><code class="xref py py-meth docutils literal notranslate"><span class="pre">in_dll()</span></code></a> 类方法访问这样的值。 <em>pythonapi</em> 是一个用于访问 Python C api 预定义符号:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">version</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="o">.</span><span class="n">in_dll</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">pythonapi</span><span class="p">,</span> <span class="s2">&quot;Py_Version&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">version</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
<span class="go">0x30c00a0</span>
</pre></div>
</div>
<p class="translated">一个扩展例子,  同时也展示了使用指针访问 Python 导出的 <a class="reference internal" href="../c-api/import.html#c.PyImport_FrozenModules" title="PyImport_FrozenModules"><code class="xref c c-data docutils literal notranslate"><span class="pre">PyImport_FrozenModules</span></code></a> 指针对象。</p>
<p class="translated">对文档中这个值的解释说明</p>
<blockquote>
<div><p class="translated">该指针被初始化为指向一个 <a class="reference internal" href="../c-api/import.html#c._frozen" title="_frozen"><code class="xref c c-struct docutils literal notranslate"><span class="pre">_frozen</span></code></a> 记录的数组，以一个所有成员均为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 或零的记录表示结束。 当一个冻结模块被导入时，它将在此表中被搜索。 第三方代码可以利用此方式来提供动态创建的冻结模块集。</p>
</div></blockquote>
<p class="translated">这足以证明修改这个指针是很有用的。为了让实例大小不至于太长，这里只展示如何使用 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 读取这个表:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">struct_frozen</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">c_char_p</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;code&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_ubyte</span><span class="p">)),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;size&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s2">&quot;get_code&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">c_ubyte</span><span class="p">)),</span>  <span class="c1"># 函数指针</span>
<span class="gp">... </span>               <span class="p">]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">我们定义了 <a class="reference internal" href="../c-api/import.html#c._frozen" title="_frozen"><code class="xref c c-struct docutils literal notranslate"><span class="pre">_frozen</span></code></a> 数据类型，所以我们可以获取表的指针:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">FrozenTable</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">struct_frozen</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">table</span> <span class="o">=</span> <span class="n">FrozenTable</span><span class="o">.</span><span class="n">in_dll</span><span class="p">(</span><span class="n">pythonapi</span><span class="p">,</span> <span class="s2">&quot;_PyImport_FrozenBootstrap&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">由于 <code class="docutils literal notranslate"><span class="pre">table</span></code> 是一个指向 <code class="docutils literal notranslate"><span class="pre">struct_frozen</span></code> 数组的 <code class="docutils literal notranslate"><span class="pre">指针</span></code>，我们可以遍历它，只不过需要自己判断循环是否结束，因为指针本身并不包含长度。 它早晚会因为访问到野指针或者什么的把自己搞崩溃，所以我们最好在遇到  <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 后就让它退出循环:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">table</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">break</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;ascii&quot;</span><span class="p">),</span> <span class="n">item</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">_frozen_importlib 31764</span>
<span class="go">_frozen_importlib_external 41499</span>
<span class="go">zipimport 12345</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">Python 的冻结模块和冻结包(由负 <code class="docutils literal notranslate"><span class="pre">size</span></code> 成员表示)并不是广为人知的事情，它们仅仅用于实验。例如，可以使用 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">__hello__</span></code> 尝试一下这个功能。</p>
</section>
<section id="surprises">
<span id="ctypes-surprises"></span><h3 class="translated">意外<a class="headerlink" href="#surprises" title="Link to this heading">¶</a></h3>
<p class="translated"><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 也有自己的边界，有时候会发生一些意想不到的事情。</p>
<p class="translated">比如下面的例子:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">POINT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">c_int</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">RECT</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">POINT</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">POINT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span> <span class="o">=</span> <span class="n">RECT</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">1 2 3 4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 现在交换这两个</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="go">3 4 3 4</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">嗯。我们预想应该打印 <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">4</span> <span class="pre">1</span> <span class="pre">2</span></code> 。但是为什么呢? 这是 <code class="docutils literal notranslate"><span class="pre">rc.a,</span> <span class="pre">rc.b</span> <span class="pre">=</span> <span class="pre">rc.b,</span> <span class="pre">rc.a</span></code> 这行代码展开后的步骤:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">temp0</span><span class="p">,</span> <span class="n">temp1</span> <span class="o">=</span> <span class="n">rc</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">temp0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rc</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">temp1</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">注意 <code class="docutils literal notranslate"><span class="pre">temp0</span></code> 和 <code class="docutils literal notranslate"><span class="pre">temp1</span></code> 对象始终引用了对象 <code class="docutils literal notranslate"><span class="pre">rc</span></code> 的内容。然后执行 <code class="docutils literal notranslate"><span class="pre">rc.a</span> <span class="pre">=</span> <span class="pre">temp0</span></code> 会把 <code class="docutils literal notranslate"><span class="pre">temp0</span></code> 的内容拷贝到 <code class="docutils literal notranslate"><span class="pre">rc</span></code> 的空间。这也改变了  <code class="docutils literal notranslate"><span class="pre">temp1</span></code> 的内容。最终导致赋值语句 <code class="docutils literal notranslate"><span class="pre">rc.b</span> <span class="pre">=</span> <span class="pre">temp1</span></code> 没有产生预想的效果。</p>
<p class="translated">记住，访问被包含在结构体、联合、数组中的对象并不会将其 <em>复制</em> 出来，而是得到了一个代理对象，它是对根对象的内部内容的一层包装。</p>
<p class="translated">下面是另一个可能和预期有偏差的例子:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">c_char_p</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;abc def ghi&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">value</span>
<span class="go">b&#39;abc def ghi&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="n">s</span><span class="o">.</span><span class="n">value</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p class="translated">使用  <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a>  实例化的对象只能将其值设置为 bytes 或者整数。</p>
</div>
<p class="translated">为什么这里打印了 <code class="docutils literal notranslate"><span class="pre">False</span></code> ？ ctypes 实例是一些内存块加上一些用于访问这些内存块的 <a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descriptor</span></a> 组成。将 Python 对象存储在内存块并不会存储对象本身，而是存储了对象的 <code class="docutils literal notranslate"><span class="pre">内容</span></code> 。每次访问对象的内容都会构造一个新的 Python 对象。</p>
</section>
<section id="variable-sized-data-types">
<span id="ctypes-variable-sized-data-types"></span><h3 class="translated">变长数据类型<a class="headerlink" href="#variable-sized-data-types" title="Link to this heading">¶</a></h3>
<p class="translated"><a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 对变长数组和结构体提供了一些支持 。</p>
<p class="untranslated">The <a class="reference internal" href="#ctypes.resize" title="ctypes.resize"><code class="xref py py-func docutils literal notranslate"><span class="pre">resize()</span></code></a> function can be used to resize the memory buffer of an
existing ctypes object.  The function takes the object as first argument, and
the requested size in bytes as the second argument.  The memory block cannot be
made smaller than the natural memory block specified by the objects type, a
<a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> is raised if this is tried:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">short_array</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_short</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">short_array</span><span class="p">))</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resize</span><span class="p">(</span><span class="n">short_array</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">    </span><span class="o">...</span>
<span class="gr">ValueError</span>: <span class="n">minimum size is 8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resize</span><span class="p">(</span><span class="n">short_array</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sizeof</span><span class="p">(</span><span class="n">short_array</span><span class="p">)</span>
<span class="go">32</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sizeof</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">short_array</span><span class="p">))</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">这非常好，但是要怎么访问数组中额外的元素呢？因为数组类型已经定义包含4个元素，导致我们访问新增元素时会产生以下错误:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">short_array</span><span class="p">[:]</span>
<span class="go">[0, 0, 0, 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">short_array</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">    </span><span class="o">...</span>
<span class="gr">IndexError</span>: <span class="n">invalid index</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">使用  <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 访问变长数据类型的一个可行方法是利用 Python 的动态特性，根据具体情况，在知道这个数据的大小后，(重新)指定这个数据的类型。</p>
</section>
</section>
<section id="ctypes-reference">
<span id="ctypes-ctypes-reference"></span><h2 class="translated">ctypes 参考手册<a class="headerlink" href="#ctypes-reference" title="Link to this heading">¶</a></h2>
<section id="finding-shared-libraries">
<span id="ctypes-finding-shared-libraries"></span><h3 class="translated">寻找动态链接库<a class="headerlink" href="#finding-shared-libraries" title="Link to this heading">¶</a></h3>
<p class="translated">在编译型语言中，动态链接库会在编译、链接或者程序运行时访问。</p>
<p class="translated"><a class="reference internal" href="#ctypes.util.find_library" title="ctypes.util.find_library"><code class="xref py py-func docutils literal notranslate"><span class="pre">find_library()</span></code></a> 函数的目的是以类似于编译器或运行时加载器的方式来定位库（在有多个共享库版本的平台上应当加载最新的版本），而 ctypes 库加载器的行为类似于程序已经运行时直接调用运行时加载器。</p>
<p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes.util</span></code> 模块提供了一个函数，可以帮助确定要加载的库。</p>
<dl class="py data">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">ctypes.util.</span></span><span class="sig-name descname"><span class="pre">find_library</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span></dt>
<dd><p class="translated">尝试寻找一个库然后返回其路径名， <em>name</em> 是库名称, 且去除了 <em>lib</em> 等前缀和 <code class="docutils literal notranslate"><span class="pre">.so</span></code> 、 <code class="docutils literal notranslate"><span class="pre">.dylib</span></code> 、版本号等后缀(这是 posix 连接器 <code class="xref std std-option docutils literal notranslate"><span class="pre">-l</span></code> 选项使用的格式)。如果没有找到对应的库，则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code> 。</p>
</dd></dl>

<p class="translated">确切的功能取决于系统。</p>
<p class="translated">在 Linux 中，<a class="reference internal" href="#ctypes.util.find_library" title="ctypes.util.find_library"><code class="xref py py-func docutils literal notranslate"><span class="pre">find_library()</span></code></a> 会尝试运行外部程序 (<code class="docutils literal notranslate"><span class="pre">/sbin/ldconfig</span></code>, <code class="docutils literal notranslate"><span class="pre">gcc</span></code>, <code class="docutils literal notranslate"><span class="pre">objdump</span></code>  和 <code class="docutils literal notranslate"><span class="pre">ld</span></code>) 来查找库文件。 它会返回库文件的文件名。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版本发生变更: </span>在Linux 上，如果其他方式找不到的话，会使用环境变量 <code class="docutils literal notranslate"><span class="pre">LD_LIBRARY_PATH</span></code> 搜索动态链接库。</p>
</div>
<p class="translated">这是一些例子:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes.util</span><span class="w"> </span><span class="kn">import</span> <span class="n">find_library</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">)</span>
<span class="go">&#39;libm.so.6&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">)</span>
<span class="go">&#39;libc.so.6&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;bz2&quot;</span><span class="p">)</span>
<span class="go">&#39;libbz2.so.1.0&#39;</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">在 macOS 和 Android 上，<a class="reference internal" href="#ctypes.util.find_library" title="ctypes.util.find_library"><code class="xref py py-func docutils literal notranslate"><span class="pre">find_library()</span></code></a> 使用系统的标准命名方案和路径来定位库，并在成功时返回完整的路径名:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes.util</span><span class="w"> </span><span class="kn">import</span> <span class="n">find_library</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">)</span>
<span class="go">&#39;/usr/lib/libc.dylib&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">)</span>
<span class="go">&#39;/usr/lib/libm.dylib&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;bz2&quot;</span><span class="p">)</span>
<span class="go">&#39;/usr/lib/libbz2.dylib&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_library</span><span class="p">(</span><span class="s2">&quot;AGL&quot;</span><span class="p">)</span>
<span class="go">&#39;/System/Library/Frameworks/AGL.framework/AGL&#39;</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">在 Windows 中，<a class="reference internal" href="#ctypes.util.find_library" title="ctypes.util.find_library"><code class="xref py py-func docutils literal notranslate"><span class="pre">find_library()</span></code></a> 会沿着系统搜索路径进行搜索，并返回完整的路径名称，但由于没有预定义的命名方案因此像 <code class="docutils literal notranslate"><span class="pre">find_library(&quot;c&quot;)</span></code> 这样的调用会失败并返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<p class="translated">如果使用 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 包装一个共享库，则更好的做法 <em>可能</em> 是开发时就确定好共享库的名称，并将其硬编码到包装模块中而不是在运行时使用 <a class="reference internal" href="#ctypes.util.find_library" title="ctypes.util.find_library"><code class="xref py py-func docutils literal notranslate"><span class="pre">find_library()</span></code></a> 来定位库。</p>
</section>
<section id="listing-loaded-shared-libraries">
<span id="ctypes-listing-loaded-shared-libraries"></span><h3 class="translated">列出已加载的共享库<a class="headerlink" href="#listing-loaded-shared-libraries" title="Link to this heading">¶</a></h3>
<p class="translated">在编写依赖于从共享库加载的代码时，了解当前进程中已加载哪些共享库可能会很有用。</p>
<p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes.util</span></code> 模块提供了 <a class="reference internal" href="#ctypes.util.dllist" title="ctypes.util.dllist"><code class="xref py py-func docutils literal notranslate"><span class="pre">dllist()</span></code></a> 函数，该函数会调用各种平台提供的不同 API，以帮助确定当前进程中已加载了哪些共享库。</p>
<p class="translated">此函数的确切输出取决于系统。在大多数平台上，该列表的第一个条目代表当前进程本身，可能是空字符串。例如，在基于 glibc 的 Linux 上，返回结果可能如下：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes.util</span><span class="w"> </span><span class="kn">import</span> <span class="n">dllist</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dllist</span><span class="p">()</span>
<span class="go">[&#39;&#39;, &#39;linux-vdso.so.1&#39;, &#39;/lib/x86_64-linux-gnu/libm.so.6&#39;, &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;, ... ]</span>
</pre></div>
</div>
</section>
<section id="loading-shared-libraries">
<span id="ctypes-loading-shared-libraries"></span><h3 class="translated">加载共享库<a class="headerlink" href="#loading-shared-libraries" title="Link to this heading">¶</a></h3>
<p class="translated">有很多方式可以将共享库加载到 Python 进程。其中之一是实例化以下类的其中一个:</p>
<dl class="py class">
<dt class="sig sig-object py" id="ctypes.CDLL">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">CDLL</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">DEFAULT_MODE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_errno</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_last_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">winmode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.CDLL" title="Link to this definition">¶</a></dt>
<dd><p class="translated">该类的实例代表已加载的共享库。 这些库中的函数使用标准的 C 调用约定，并被预期会返回 <span class="c-expr sig sig-inline c"><span class="kt">int</span></span>。</p>
<p class="translated">在 Windows 上创建 <a class="reference internal" href="#ctypes.CDLL" title="ctypes.CDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">CDLL</span></code></a> 实例可能会失败，即使 DLL 名称确实存在。 当某个被加载 DLL 所依赖的 DLL 未找到时，将引发 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 错误并附带消息 <em>&quot;[WinError 126] The specified module could not be found&quot;.</em> 此错误消息不包含缺失 DLL 的名称，因为 Windows API 并不会返回此类信息，这使得此错误难以诊断。 要解决此错误并确定是哪一个 DLL 未找到，你需要找出所依赖的 DLL 列表并使用 Windows 调试与跟踪工具确定是哪一个未找到。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>现在 <em>name</em> 形参可以是一个 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>。</p>
</div>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p class="translated"><a class="reference external" href="https://docs.microsoft.com/cpp/build/reference/dependents">Microsoft DUMPBIN 工具</a> -- 一个用于查找 DLL 依赖的工具。</p>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="ctypes.OleDLL">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">OleDLL</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">DEFAULT_MODE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_errno</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_last_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">winmode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.OleDLL" title="Link to this definition">¶</a></dt>
<dd><p class="translated">这个类的实例代表已加载的共享库，这些库中的函数使用 <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> 调用约定，并且预期返回 Windows 专属的 <a class="reference internal" href="#ctypes.HRESULT" title="ctypes.HRESULT"><code class="xref py py-class docutils literal notranslate"><span class="pre">HRESULT</span></code></a> 代码。 <a class="reference internal" href="#ctypes.HRESULT" title="ctypes.HRESULT"><code class="xref py py-class docutils literal notranslate"><span class="pre">HRESULT</span></code></a> 值包含指明函数调用是失败还是成功的信息，并带有额外的错误码。 如果返回值是提示失败，则会自动引发 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-class docutils literal notranslate"><span class="pre">OSError</span></code></a>。</p>
<div class="availability docutils container">
<p class="translated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版本发生变更: </span>过去会引发 <a class="reference internal" href="exceptions.html#WindowsError" title="WindowsError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">WindowsError</span></code></a>，现在它是 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 的别名。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>现在 <em>name</em> 形参可以是一个 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>。</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.WinDLL">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">WinDLL</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">DEFAULT_MODE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_errno</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_last_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">winmode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.WinDLL" title="Link to this definition">¶</a></dt>
<dd><p class="translated">这个类的实例代表已加载的共享库，这些库中的函数使用 <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> 调用约定，并且默认预期返回 <span class="c-expr sig sig-inline c"><span class="kt">int</span></span>。</p>
<div class="availability docutils container">
<p class="translated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>现在 <em>name</em> 形参可以是一个 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>。</p>
</div>
</dd></dl>

<p class="translated">调用共享库导出的函数之前，Python会释放 <a class="reference internal" href="../glossary.html#term-global-interpreter-lock"><span class="xref std std-term">global interpreter lock</span></a> ，并在调用后重新获取。</p>
<dl class="py class">
<dt class="sig sig-object py" id="ctypes.PyDLL">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">PyDLL</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">DEFAULT_MODE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">handle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.PyDLL" title="Link to this definition">¶</a></dt>
<dd><p class="translated">这个类实例的行为与 <a class="reference internal" href="#ctypes.CDLL" title="ctypes.CDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">CDLL</span></code></a> 类似，只不过 <em>不会</em> 在调用函数的时候释放 GIL 锁，且调用结束后会检查 Python 错误码。 如果错误码被设置，会抛出一个 Python 异常。</p>
<p class="translated">所以，它只在直接调用 Python C 接口函数的时候有用。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.12 版本发生变更: </span>现在 <em>name</em> 形参可以是一个 <a class="reference internal" href="../glossary.html#term-path-like-object"><span class="xref std std-term">path-like object</span></a>。</p>
</div>
</dd></dl>

<p class="translated">所有这些类均可通过附带至少一个参数即共享库的路径名来调用它们进行实例化。 如果你有一个对应已加载共享库的现有句柄，可以将其作为 <code class="docutils literal notranslate"><span class="pre">handle</span></code> 具名形参传入，否则会使用下层平台的 <code class="xref c c-func docutils literal notranslate"><span class="pre">dlopen()</span></code> 或 <code class="xref c c-func docutils literal notranslate"><span class="pre">LoadLibrary()</span></code> 函数将库加载到进程中，并获取对应的句柄。</p>
<p class="translated"><em>mode</em> 可以指定库加载方式。详情请参见  <em class="manpage"><a class="manpage reference external" href="https://manpages.debian.org/dlopen(3)">dlopen(3)</a></em> 手册页。 在 Windows 上， 会忽略 <em>mode</em> ，在 posix 系统上， 总是会加上 RTLD_NOW ，且无法配置。</p>
<p class="translated">当 <em>use_errno</em> 形参被设为真值时，将启用以安全方式访问系统 <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> 错误号的 ctypes 机制。 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 将维护一份系统 <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> 变量的线程局部副本；如果你调用设置了 <code class="docutils literal notranslate"><span class="pre">use_errno=True</span></code> 的外部函数那么 <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> 将在函数调用之前与 ctypes 私有副本互换，同样的情况也会在函数调用之后立即发生。</p>
<p class="untranslated">The function <a class="reference internal" href="#ctypes.get_errno" title="ctypes.get_errno"><code class="xref py py-func docutils literal notranslate"><span class="pre">ctypes.get_errno()</span></code></a> returns the value of the ctypes private
copy, and the function <a class="reference internal" href="#ctypes.set_errno" title="ctypes.set_errno"><code class="xref py py-func docutils literal notranslate"><span class="pre">ctypes.set_errno()</span></code></a> changes the ctypes private copy
to a new value and returns the former value.</p>
<p class="translated">当 <em>use_last_error</em> 形参设为真值时，为 Windows 错误代码也启用与由 <a class="reference internal" href="#ctypes.GetLastError" title="ctypes.GetLastError"><code class="xref py py-func docutils literal notranslate"><span class="pre">GetLastError()</span></code></a> 和 <code class="xref py py-func docutils literal notranslate"><span class="pre">SetLastError()</span></code> Windows API 函数管理相同的机制；<a class="reference internal" href="#ctypes.get_last_error" title="ctypes.get_last_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">ctypes.get_last_error()</span></code></a> 和 <a class="reference internal" href="#ctypes.set_last_error" title="ctypes.set_last_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">ctypes.set_last_error()</span></code></a> 会被用于请求和更改 Windows 错误代码的 ctypes 私有副本。</p>
<p class="translated"><em>winmode</em> 形参用于在 Windows 上指定库的加载方式（因为 <em>mode</em> 会被忽略）。 它接受任何对 Win32 API <code class="docutils literal notranslate"><span class="pre">LoadLibraryEx</span></code> 旗标形参来说合法的值。 当被省略时，默认使用表示最安全的 DLL 加载的旗标，这将避免 DLL 劫持等问题。 传入 DLL 的完整路径是确保正确加载库及其依赖的最安全的方式。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版本发生变更: </span>增加了  <em>winmode</em> 参数。</p>
</div>
<dl class="py data">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">RTLD_GLOBAL</span></span></dt>
<dd><p class="translated">用于 <em>mode</em> 参数的标识值。在此标识不可用的系统上，它被定义为整数0。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">RTLD_LOCAL</span></span></dt>
<dd><p class="untranslated">Flag to use as <em>mode</em> parameter.  On platforms where this is not available, it
is the same as <em>RTLD_GLOBAL</em>.</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">DEFAULT_MODE</span></span></dt>
<dd><p class="translated">加载动态链接库的默认模式。在 OSX 10.3 上，它是 <em>RTLD_GLOBAL</em> ，其余系统上是 <em>RTLD_LOCAL</em> 。</p>
</dd></dl>

<p class="translated">这些类的实例没有共用方法。动态链接库的导出函数可以通过属性或者索引的方式访问。注意，通过属性的方式访问会缓存这个函数，因而每次访问它时返回的都是同一个对象。另一方面，通过索引访问，每次都会返回一个新的对象:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes</span><span class="w"> </span><span class="kn">import</span> <span class="n">CDLL</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span> <span class="o">=</span> <span class="n">CDLL</span><span class="p">(</span><span class="s2">&quot;libc.so.6&quot;</span><span class="p">)</span>  <span class="c1"># 在 Linux</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="o">.</span><span class="n">time</span> <span class="o">==</span> <span class="n">libc</span><span class="o">.</span><span class="n">time</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">libc</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">libc</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
<span class="go">False</span>
</pre></div>
</div>
<p class="translated">还有下面这些属性可用，他们的名称以下划线开头，以避免和导出函数重名:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.PyDLL._handle">
<span class="sig-prename descclassname"><span class="pre">PyDLL.</span></span><span class="sig-name descname"><span class="pre">_handle</span></span><a class="headerlink" href="#ctypes.PyDLL._handle" title="Link to this definition">¶</a></dt>
<dd><p class="translated">用于访问库的系统句柄。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.PyDLL._name">
<span class="sig-prename descclassname"><span class="pre">PyDLL.</span></span><span class="sig-name descname"><span class="pre">_name</span></span><a class="headerlink" href="#ctypes.PyDLL._name" title="Link to this definition">¶</a></dt>
<dd><p class="translated">传入构造函数的库名称。</p>
</dd></dl>

<p class="translated">共享库也可以通过使用一个预制对象来加载，这种对象是 <a class="reference internal" href="#ctypes.LibraryLoader" title="ctypes.LibraryLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">LibraryLoader</span></code></a> 类的实例，具体做法是调用 <a class="reference internal" href="#ctypes.LibraryLoader.LoadLibrary" title="ctypes.LibraryLoader.LoadLibrary"><code class="xref py py-meth docutils literal notranslate"><span class="pre">LoadLibrary()</span></code></a> 方法，或是将库作为加载器实例的属性来提取。</p>
<dl class="py class">
<dt class="sig sig-object py" id="ctypes.LibraryLoader">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">LibraryLoader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dlltype</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.LibraryLoader" title="Link to this definition">¶</a></dt>
<dd><p class="translated">加载共享库的类。 <em>dlltype</em> 应当为 <a class="reference internal" href="#ctypes.CDLL" title="ctypes.CDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">CDLL</span></code></a>, <a class="reference internal" href="#ctypes.PyDLL" title="ctypes.PyDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">PyDLL</span></code></a>, <a class="reference internal" href="#ctypes.WinDLL" title="ctypes.WinDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">WinDLL</span></code></a> 或 <a class="reference internal" href="#ctypes.OleDLL" title="ctypes.OleDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">OleDLL</span></code></a> 类型之一。</p>
<p class="translated"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code> 具有特殊的行为：它允许通过一个作为库加载器实例的属性访问共享库来加载它。 访问结果会被缓存，因此每次重复的属性访问都会返回相同的库。</p>
<dl class="py method">
<dt class="sig sig-object py" id="ctypes.LibraryLoader.LoadLibrary">
<span class="sig-name descname"><span class="pre">LoadLibrary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.LibraryLoader.LoadLibrary" title="Link to this definition">¶</a></dt>
<dd><p class="translated">加载一个共享库到进程中并将其返回。 此方法总是返回一个新的库实例。</p>
</dd></dl>

</dd></dl>

<p class="translated">可用的预制库加载器有如下这些:</p>
<dl class="py data">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">cdll</span></span></dt>
<dd><p class="translated">创建 <a class="reference internal" href="#ctypes.CDLL" title="ctypes.CDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">CDLL</span></code></a> 实例。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">windll</span></span></dt>
<dd><p class="translated">创建 <a class="reference internal" href="#ctypes.WinDLL" title="ctypes.WinDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">WinDLL</span></code></a> 实例。</p>
<div class="availability docutils container">
<p class="translated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">oledll</span></span></dt>
<dd><p class="translated">创建 <a class="reference internal" href="#ctypes.OleDLL" title="ctypes.OleDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">OleDLL</span></code></a> 实例。</p>
<div class="availability docutils container">
<p class="translated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows</p>
</div>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">pydll</span></span></dt>
<dd><p class="translated">创建 <a class="reference internal" href="#ctypes.PyDLL" title="ctypes.PyDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">PyDLL</span></code></a> 实例。</p>
</dd></dl>

<p class="translated">要直接访问 C Python api，可以使用一个现成的 Python 共享库对象:</p>
<dl class="py data">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">pythonapi</span></span></dt>
<dd><p class="translated">一个将 Python C API 函数作为属性公开出来的 <a class="reference internal" href="#ctypes.PyDLL" title="ctypes.PyDLL"><code class="xref py py-class docutils literal notranslate"><span class="pre">PyDLL</span></code></a> 实例。 请注意所有这些函数都应返回 C <span class="c-expr sig sig-inline c"><span class="kt">int</span></span>，当然也并非总是如此，因此您必须分配正确的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> 属性才能使用这些函数。</p>
</dd></dl>

<p class="audit-hook translated">通过这些对象中的任何一个加载库都将引发一个 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.dlopen</span></code> 并附带字符串参数 <code class="docutils literal notranslate"><span class="pre">name</span></code>，即用于加载库的名称。</p>
<p class="audit-hook translated">在加载的库上访问一个函数将引发一个审计事件 <code class="docutils literal notranslate"><span class="pre">ctypes.dlsym</span></code> 并附带参数 <code class="docutils literal notranslate"><span class="pre">library</span></code> (库对象) 和 <code class="docutils literal notranslate"><span class="pre">name</span></code> (以字符串或整数表示的符号名称).</p>
<p class="audit-hook translated">在只有库句柄而非对象可用的情况下，访问函数会引发一个审计事件 <code class="docutils literal notranslate"><span class="pre">ctypes.dlsym/handle</span></code> 并附带参数 <code class="docutils literal notranslate"><span class="pre">handle</span></code> (原始库句柄) 和 <code class="docutils literal notranslate"><span class="pre">name</span></code>。</p>
</section>
<section id="foreign-functions">
<span id="ctypes-foreign-functions"></span><h3 class="translated">外部函数<a class="headerlink" href="#foreign-functions" title="Link to this heading">¶</a></h3>
<p class="translated">正如前一节的说明，外部函数可作为已加载共享库的属性来访问。 用此方式创建的函数对象默认接受任意数量的参数，接受任意 ctypes 数据实例作为参数，并且返回库加载器所指定的默认结果类型。</p>
<p class="translated">它们是私有局部类 <code class="xref py py-class docutils literal notranslate"><span class="pre">_FuncPtr</span></code> 的实例（未在 <code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code> 中暴露），该类继承自私有的 <a class="reference internal" href="#ctypes._CFuncPtr" title="ctypes._CFuncPtr"><code class="xref py py-class docutils literal notranslate"><span class="pre">_CFuncPtr</span></code></a> 类：</p>
<div class="translated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">ctypes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lib</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">CDLL</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">issubclass</span><span class="p">(</span><span class="n">lib</span><span class="o">.</span><span class="n">_FuncPtr</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">_CFuncPtr</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lib</span><span class="o">.</span><span class="n">_FuncPtr</span> <span class="ow">is</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">_CFuncPtr</span>
<span class="go">False</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="ctypes._CFuncPtr">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">_CFuncPtr</span></span><a class="headerlink" href="#ctypes._CFuncPtr" title="Link to this definition">¶</a></dt>
<dd><p class="translated">C 可调用外部函数的基类。</p>
<p class="translated">外部函数的实例也是兼容 C 的数据类型；它们代表 C 函数指针。</p>
<p class="translated">此行为可通过对外部函数对象的特殊属性赋值来自定义。</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes._CFuncPtr.restype">
<span class="sig-name descname"><span class="pre">restype</span></span><a class="headerlink" href="#ctypes._CFuncPtr.restype" title="Link to this definition">¶</a></dt>
<dd><p class="translated">分配一个 ctypes 类型来指定外部函数的结果类型。 使用 <code class="docutils literal notranslate"><span class="pre">None</span></code> 来表示 <span class="c-expr sig sig-inline c"><span class="kt">void</span></span>，即不返回任何结果的函数。</p>
<p class="translated">赋值为一个非 ctypes 类型的可调用 Python 对象也是可以的，在这种情况下函数应返回 C <span class="c-expr sig sig-inline c"><span class="kt">int</span></span>，并且该可调用对象将附带此整数被调用，以允许进一步的处理或错误检查。 这种用法已被弃用，为了更灵活地进行后续处理或错误检查请使用 ctypes 数据类型作为 <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> 并将 <a class="reference internal" href="#ctypes._CFuncPtr.errcheck" title="ctypes._CFuncPtr.errcheck"><code class="xref py py-attr docutils literal notranslate"><span class="pre">errcheck</span></code></a> 属性赋值为一个可调用对象。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes._CFuncPtr.argtypes">
<span class="sig-name descname"><span class="pre">argtypes</span></span><a class="headerlink" href="#ctypes._CFuncPtr.argtypes" title="Link to this definition">¶</a></dt>
<dd><p class="translated">赋值为一个 ctypes 类型的元组来指定函数所接受的参数类型。 使用 <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> 调用规范的函数只能附带与此元组长度相同数量的参数进行调用；使用 C 调用规范的函数还可接受额外的未指明参数。</p>
<p class="translated">当调用外部函数时，每个实际参数都会被传给 <a class="reference internal" href="#ctypes._CFuncPtr.argtypes" title="ctypes._CFuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a> 元组中条目的 <a class="reference internal" href="#ctypes._CData.from_param" title="ctypes._CData.from_param"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_param()</span></code></a> 类方法，该方法允许将实际参数适配为此外部函数所接受的对象。 例如，<a class="reference internal" href="#ctypes._CFuncPtr.argtypes" title="ctypes._CFuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a> 元组中的 <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a> 条目将使用 ctypes 转换规则把作为参数传入的字符串转换为字节串对象。</p>
<p class="translated">新特性：现在可以在 argtypes 中放入非 ctypes 类型的条目，但每个条目必须具有 <a class="reference internal" href="#ctypes._CData.from_param" title="ctypes._CData.from_param"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_param()</span></code></a> 方法用于返回一个可作为参数的值（整数、字符串、ctypes 实例）。 这样就允许定义可将将自定义对象适配为函数参数的适配器。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes._CFuncPtr.errcheck">
<span class="sig-name descname"><span class="pre">errcheck</span></span><a class="headerlink" href="#ctypes._CFuncPtr.errcheck" title="Link to this definition">¶</a></dt>
<dd><p class="translated">将一个 Python 函数或其他可调用对象赋值给此属性。 该可调用对象将附带三个及以上的参数被调用。</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">callable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arguments</span></span></em><span class="sig-paren">)</span></dt>
<dd><p class="translated"><em>result</em> 是外部函数返回的结果，由 <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> 属性指明。</p>
<p class="translated"><em>func</em> 是外部函数对象本身，这样就允许重新使用相同的可调用对象来对多个函数进行检查或后续处理。</p>
<p class="translated"><em>arguments</em> 是一个包含最初传递给函数调用的形参的元组，这样就允许对所用参数的行为进行特别处理。</p>
</dd></dl>

<p class="translated">此函数所返回的对象将会由外部函数调用返回，但它还可以在外部函数调用失败时检查结果并引发异常。</p>
</dd></dl>

</dd></dl>

<p class="audit-hook translated">在 Windows 上，当外部函数调用引发一个系统异常时（例如由于访问冲突），它将被捕获并被替换为适当的 Python 异常。 此外，还将引发一个审计事件 <code class="docutils literal notranslate"><span class="pre">ctypes.set_exception</span></code> 并附带参数 <code class="docutils literal notranslate"><span class="pre">code</span></code>，以允许审计钩子将原异常替换为它自己的异常。</p>
<p class="audit-hook translated">调用外部函数的某些方式以及本模块中的部分函数可能会引发一个审计事件 <code class="docutils literal notranslate"><span class="pre">ctypes.call_function</span></code>，并附带参数 <code class="docutils literal notranslate"><span class="pre">function</span> <span class="pre">pointer</span></code> 和 <code class="docutils literal notranslate"><span class="pre">arguments</span></code>。</p>
</section>
<section id="function-prototypes">
<span id="ctypes-function-prototypes"></span><h3 class="translated">函数原型<a class="headerlink" href="#function-prototypes" title="Link to this heading">¶</a></h3>
<p class="translated">外部函数也可通过实例化函数原型来创建。 函数原型类似于 C 中的函数原型；它们在不定义具体实现的情况下描述了一个函数（返回类型、参数类型、调用约定）。 工厂函数必须使用函数所需要的结果类型和参数类型来调用，并可被用作装饰器工厂函数，在此情况下可以通过 <code class="docutils literal notranslate"><span class="pre">&#64;wrapper</span></code> 语法应用于函数。 请参阅 <a class="reference internal" href="#ctypes-callback-functions"><span class="std std-ref">回调函数</span></a> 了解有关示例。</p>
<dl class="py function">
<dt class="sig sig-object py" id="ctypes.CFUNCTYPE">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">CFUNCTYPE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">restype</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">argtypes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_errno</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_last_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.CFUNCTYPE" title="Link to this definition">¶</a></dt>
<dd><p class="translated">返回的函数原型会创建使用标准 C 调用约定的函数。 该函数在调用过程中将释放 GIL。 如果 <em>use_errno</em> 设为真值，则在调用之前和之后系统 <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> 变量的 ctypes 私有副本会与真正的 <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> 值进行交换；<em>use_last_error</em> 会为 Windows 错误码执行同样的操作。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.WINFUNCTYPE">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">WINFUNCTYPE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">restype</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">argtypes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_errno</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_last_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.WINFUNCTYPE" title="Link to this definition">¶</a></dt>
<dd><p class="translated">返回的函数原型会创建使用 <code class="docutils literal notranslate"><span class="pre">stdcall</span></code> 调用约定的函数。 该函数在调用过程中将会释放 GIL。 <em>use_errno</em> 和 <em>use_last_error</em> 具有与上文相同的含义。</p>
<div class="availability docutils container">
<p class="translated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.PYFUNCTYPE">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">PYFUNCTYPE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">restype</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">argtypes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.PYFUNCTYPE" title="Link to this definition">¶</a></dt>
<dd><p class="translated">返回的函数原型会创建使用 Python 调用约定的函数。 该函数在调用过程中将 <em>不会</em> 释放 GIL。</p>
</dd></dl>

<p class="translated">这些工厂函数所创建的函数原型可通过不同的方式来实例化，具体取决于调用中的类型与数量:</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">prototype</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">address</span></span></em><span class="sig-paren">)</span></dt>
<dd><p class="translated">在指定地址上返回一个外部函数，地址值必须为整数。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">prototype</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">callable</span></span></em><span class="sig-paren">)</span></dt>
<dd><p class="translated">基于 Python <em>callable</em> 创建一个 C 可调用函数（回调函数）。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">prototype</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func_spec</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">paramflags</span></span></em><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p class="translated">返回由一个共享库导出的外部函数。 <em>func_spec</em> 必须为一个 2 元组 <code class="docutils literal notranslate"><span class="pre">(name_or_ordinal,</span> <span class="pre">library)</span></code>。 第一项是字符串形式的所导出函数名称，或小整数形式的所导出函数序号。 第二项是该共享库实例。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">prototype</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vtbl_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">paramflags</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">iid</span></span></em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span></dt>
<dd><p class="translated">返回将调用一个 COM 方法的外部函数。 <em>vtbl_index</em> 虚拟函数表中的索引。 <em>name</em> 是 COM 方法的名称。 <em>iid</em> 是可选的指向接口标识符的指针，它被用于扩展的错误报告。</p>
<p class="translated">如果未指定 <em>iid</em>，则当 COM 方法调用失败时会引发 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>。如果指定了 <em>iid</em>，则会改为引发 <a class="reference internal" href="#ctypes.COMError" title="ctypes.COMError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">COMError</span></code></a>。</p>
<p class="translated">COM 方法使用特殊的调用约定：除了在 <code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code> 元组中指定的形参，它们还要求一个指向 COM 接口的指针作为第一个参数。</p>
<div class="availability docutils container">
<p class="translated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows</p>
</div>
</dd></dl>

<p class="translated">可选的 <em>paramflags</em> 形参会创建相比上述特性具有更多功能的外部函数包装器。</p>
<p class="translated"><em>paramflags</em> 必须为一个与 <a class="reference internal" href="#ctypes._CFuncPtr.argtypes" title="ctypes._CFuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a> 长度相同的元组。.</p>
<p class="translated">此元组中的每一项都包含有关形参的更多信息，它必须为包含一个、两个或更多条目的元组。</p>
<p class="translated">第一项是包含形参指令旗标组合的整数。</p>
<blockquote>
<div><dl class="simple">
<dt class="translated">1</dt><dd><p class="translated">指定函数的一个输入形参。</p>
</dd>
<dt class="translated">2</dt><dd><p class="translated">输出形参。 外部函数会填入一个值。</p>
</dd>
<dt class="translated">4</dt><dd><p class="translated">默认为整数零值的输入形参。</p>
</dd>
</dl>
</div></blockquote>
<p class="translated">可选的第二项是字符串形式的形参名称。 如果指定此项，则可以使用该形参名称来调用外部函数。</p>
<p class="translated">可选的第三项是该形参的默认值。</p>
<p class="translated">下面的例子演示了如何包装 Windows 的 <code class="docutils literal notranslate"><span class="pre">MessageBoxW</span></code> 函数以使其支持默认形参和命名参数。 相应的 Windows 头文件的 C 声明是这样的:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">WINUSERAPI</span> <span class="nb">int</span> <span class="n">WINAPI</span>
<span class="n">MessageBoxW</span><span class="p">(</span>
    <span class="n">HWND</span> <span class="n">hWnd</span><span class="p">,</span>
    <span class="n">LPCWSTR</span> <span class="n">lpText</span><span class="p">,</span>
    <span class="n">LPCWSTR</span> <span class="n">lpCaption</span><span class="p">,</span>
    <span class="n">UINT</span> <span class="n">uType</span><span class="p">);</span>
</pre></div>
</div>
<p class="translated">这是使用 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 的包装:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes</span><span class="w"> </span><span class="kn">import</span> <span class="n">c_int</span><span class="p">,</span> <span class="n">WINFUNCTYPE</span><span class="p">,</span> <span class="n">windll</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes.wintypes</span><span class="w"> </span><span class="kn">import</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">LPCWSTR</span><span class="p">,</span> <span class="n">UINT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prototype</span> <span class="o">=</span> <span class="n">WINFUNCTYPE</span><span class="p">(</span><span class="n">c_int</span><span class="p">,</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">LPCWSTR</span><span class="p">,</span> <span class="n">LPCWSTR</span><span class="p">,</span> <span class="n">UINT</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">paramflags</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;hwnd&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;text&quot;</span><span class="p">,</span> <span class="s2">&quot;Hi&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;caption&quot;</span><span class="p">,</span> <span class="s2">&quot;Hello from ctypes&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;flags&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span> <span class="o">=</span> <span class="n">prototype</span><span class="p">((</span><span class="s2">&quot;MessageBoxW&quot;</span><span class="p">,</span> <span class="n">windll</span><span class="o">.</span><span class="n">user32</span><span class="p">),</span> <span class="n">paramflags</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">现在 <code class="docutils literal notranslate"><span class="pre">MessageBox</span></code> 外部函数可以通过以下方式来调用:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="s2">&quot;Spam, spam, spam&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MessageBox</span><span class="p">(</span><span class="n">flags</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s2">&quot;foo bar&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">第二个例子演示了输出形参。 这个 win32 <code class="docutils literal notranslate"><span class="pre">GetWindowRect</span></code> 函数通过将指定窗口的维度拷贝至调用者必须提供的 <code class="docutils literal notranslate"><span class="pre">RECT</span></code> 结构体来提取这些值。 这是相应的 C 声明:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">WINUSERAPI</span> <span class="n">BOOL</span> <span class="n">WINAPI</span>
<span class="n">GetWindowRect</span><span class="p">(</span>
     <span class="n">HWND</span> <span class="n">hWnd</span><span class="p">,</span>
     <span class="n">LPRECT</span> <span class="n">lpRect</span><span class="p">);</span>
</pre></div>
</div>
<p class="translated">这是使用 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 的包装:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes</span><span class="w"> </span><span class="kn">import</span> <span class="n">POINTER</span><span class="p">,</span> <span class="n">WINFUNCTYPE</span><span class="p">,</span> <span class="n">windll</span><span class="p">,</span> <span class="n">WinError</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes.wintypes</span><span class="w"> </span><span class="kn">import</span> <span class="n">BOOL</span><span class="p">,</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">RECT</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prototype</span> <span class="o">=</span> <span class="n">WINFUNCTYPE</span><span class="p">(</span><span class="n">BOOL</span><span class="p">,</span> <span class="n">HWND</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">RECT</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">paramflags</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;hwnd&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;lprect&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetWindowRect</span> <span class="o">=</span> <span class="n">prototype</span><span class="p">((</span><span class="s2">&quot;GetWindowRect&quot;</span><span class="p">,</span> <span class="n">windll</span><span class="o">.</span><span class="n">user32</span><span class="p">),</span> <span class="n">paramflags</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">带有输出形参的函数如果输出形参存在单一值则会自动返回该值，或是当输出形参存在多个值时返回包含这些值的元组，因此当 GetWindowRect 被调用时现在将返回一个 RECT 实例。</p>
<p class="translated">输出形参可以与 <a class="reference internal" href="#ctypes._CFuncPtr.errcheck" title="ctypes._CFuncPtr.errcheck"><code class="xref py py-attr docutils literal notranslate"><span class="pre">errcheck</span></code></a> 协议相结合以执行进一步的输出处理和错误检查。 Win32 <code class="docutils literal notranslate"><span class="pre">GetWindowRect</span></code> API 函数返回一个 <code class="docutils literal notranslate"><span class="pre">BOOL</span></code> 来表示成功或失败，因此该函数可以执行错误检查，并在 API 调用失败时引发异常:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">errcheck</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">raise</span> <span class="n">WinError</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">args</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetWindowRect</span><span class="o">.</span><span class="n">errcheck</span> <span class="o">=</span> <span class="n">errcheck</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p class="translated">如果 <a class="reference internal" href="#ctypes._CFuncPtr.errcheck" title="ctypes._CFuncPtr.errcheck"><code class="xref py py-attr docutils literal notranslate"><span class="pre">errcheck</span></code></a> 函数原封不动地返回它所接收的参数元组，则 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 会继续对输出形参执行正常处理。 如果你希望返回一个窗口坐标的元组而非 <code class="docutils literal notranslate"><span class="pre">RECT</span></code> 实例，你可以在函数中检索字段并返回它们，正常处理将不会再执行:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">errcheck</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">raise</span> <span class="n">WinError</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">rc</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">rc</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">bottom</span><span class="p">,</span> <span class="n">rc</span><span class="o">.</span><span class="n">right</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">GetWindowRect</span><span class="o">.</span><span class="n">errcheck</span> <span class="o">=</span> <span class="n">errcheck</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
</section>
<section id="utility-functions">
<span id="ctypes-utility-functions"></span><h3 class="translated">工具函数<a class="headerlink" href="#utility-functions" title="Link to this heading">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="ctypes.addressof">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">addressof</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.addressof" title="Link to this definition">¶</a></dt>
<dd><p class="translated">以整数形式返回内存缓冲区地址。 <em>obj</em> 必须为一个 ctypes 类型的实例。</p>
<p class="audit-hook translated">引发一个 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.addressof</span></code> 并附带参数 <code class="docutils literal notranslate"><span class="pre">obj</span></code>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.alignment">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">alignment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj_or_type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.alignment" title="Link to this definition">¶</a></dt>
<dd><p class="translated">返回一个 ctypes 类型的对齐要求。 <em>obj_or_type</em> 必须为一个 ctypes 类型或实例。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.byref">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">byref</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.byref" title="Link to this definition">¶</a></dt>
<dd><p class="translated">返回指向 <em>obj</em> 的轻量指针，该对象必须为一个 ctypes 类型的实例。 <em>offset</em> 默认值为零，且必须为一个将被添加到内部指针值的整数。</p>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">byref(obj,</span> <span class="pre">offset)</span></code> 对应于这段 C 代码:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="p">(((</span><span class="n">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">返回的对象只能被用作外部函数调用形参。 它的行为类似于 <code class="docutils literal notranslate"><span class="pre">pointer(obj)</span></code>，但构造起来要快很多。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.CopyComPointer">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">CopyComPointer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.CopyComPointer" title="Link to this definition">¶</a></dt>
<dd><p class="translated">将 COM 指针从 <em>src</em> 复制到 <em>dst</em>，并返回 Windows 特定的 <code class="xref c c-type docutils literal notranslate"><span class="pre">HRESULT</span></code> 值。</p>
<p class="translated">如果 <em>src</em> 不为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，则会调用其 <code class="docutils literal notranslate"><span class="pre">AddRef</span></code> 方法，从而增加引用计数。</p>
<p class="translated">相反，在赋值新值之前，<em>dst</em> 的引用计数不会被递减。除非 <em>dst</em> 为 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>，否则调用者有责任在必要时通过调用其 <code class="docutils literal notranslate"><span class="pre">Release</span></code> 方法来递减引用计数。</p>
<div class="availability docutils container">
<p class="translated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.cast">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">cast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.cast" title="Link to this definition">¶</a></dt>
<dd><p class="translated">此函数类似于 C 的强制转换运算符。 它返回一个 <em>type</em> 的新实例，该实例指向与 <em>obj</em> 相同的内存块。 <em>type</em> 必须为指针类型，而 <em>obj</em> 必须为可以被作为指针来解读的对象。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.create_string_buffer">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">create_string_buffer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">init</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.create_string_buffer" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">create_string_buffer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="sig-paren">)</span></dt>
<dd><p class="translated">此函数会创建一个可变的字符缓冲区。 返回的对象是一个 <a class="reference internal" href="#ctypes.c_char" title="ctypes.c_char"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char</span></code></a> 的 ctypes 数组。</p>
<p class="translated">如果给出了 <em>size</em> (并且不为 <code class="docutils literal notranslate"><span class="pre">None</span></code>)，则它必须是一个 <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>。 它指明所返回数组的大小。</p>
<p class="translated">如果给出了 <em>init</em> 参数，则它必须为 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>。 它会被用于初始化数组项。 不按此方式初始化的字节串将被设为零 (NUL)。</p>
<p class="translated">如果未给出 <em>size</em> (或者为 <code class="docutils literal notranslate"><span class="pre">None</span></code>)，缓冲区将设为比 <em>init</em> 大一个元素，实际就是增加一个 NUL 结束符。</p>
<p class="translated">如果同时给出两个参数，则 <em>size</em> 必须不小于 <code class="docutils literal notranslate"><span class="pre">len(init)</span></code>。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p class="translated">如果 <em>size</em> 等于 <code class="docutils literal notranslate"><span class="pre">len(init)</span></code>，则不会增加一个 NUL 结束符。 不可将这样的缓冲区视为 C 字符串。</p>
</div>
<p class="translated">例如：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="p">(</span><span class="n">create_string_buffer</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">b&#39;\x00\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="p">(</span><span class="n">create_string_buffer</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;ab&#39;</span><span class="p">))</span>
<span class="go">b&#39;ab\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="p">(</span><span class="n">create_string_buffer</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;ab&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">b&#39;ab&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="p">(</span><span class="n">create_string_buffer</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;ab&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="go">b&#39;ab\x00\x00&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="p">(</span><span class="n">create_string_buffer</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;abcdef&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">   </span><span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">byte string too long</span>
</pre></div>
</div>
<p class="audit-hook translated">引发一个 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.create_string_buffer</span></code> 并附带参数 <code class="docutils literal notranslate"><span class="pre">init</span></code>, <code class="docutils literal notranslate"><span class="pre">size</span></code>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.create_unicode_buffer">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">create_unicode_buffer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">init</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.create_unicode_buffer" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">create_unicode_buffer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="sig-paren">)</span></dt>
<dd><p class="translated">此函数会创建一个可变的 unicode 字符缓冲区。 返回的对象是一个 <a class="reference internal" href="#ctypes.c_wchar" title="ctypes.c_wchar"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_wchar</span></code></a> 的 ctypes 数组。</p>
<p class="translated">此函数接受与 <a class="reference internal" href="#ctypes.create_string_buffer" title="ctypes.create_string_buffer"><code class="xref py py-func docutils literal notranslate"><span class="pre">create_string_buffer()</span></code></a> 相同的参数但是 <em>init</em> 必须是一个字符串而 <em>size</em> 是对 <a class="reference internal" href="#ctypes.c_wchar" title="ctypes.c_wchar"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_wchar</span></code></a> 计数。</p>
<p class="audit-hook translated">引发一个 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.create_unicode_buffer</span></code> 并附带参数 <code class="docutils literal notranslate"><span class="pre">init</span></code>, <code class="docutils literal notranslate"><span class="pre">size</span></code>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.DllCanUnloadNow">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">DllCanUnloadNow</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.DllCanUnloadNow" title="Link to this definition">¶</a></dt>
<dd><p class="translated">此函数是一个允许使用 ctypes 实现进程内 COM 服务器的钩子。 它将由 _ctypes 扩展所导出的 DllCanUnloadNow 函数来调用。</p>
<div class="availability docutils container">
<p class="translated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.DllGetClassObject">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">DllGetClassObject</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.DllGetClassObject" title="Link to this definition">¶</a></dt>
<dd><p class="translated">此函数是一个允许使用 ctypes 实现进程内 COM 服务器的钩子。 它将由 <code class="docutils literal notranslate"><span class="pre">_ctypes</span></code> 扩展 DLL 所导出的 DllGetClassObject 函数来调用。</p>
<div class="availability docutils container">
<p class="translated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.util.find_library">
<span class="sig-prename descclassname"><span class="pre">ctypes.util.</span></span><span class="sig-name descname"><span class="pre">find_library</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.util.find_library" title="Link to this definition">¶</a></dt>
<dd><p class="translated">尝试寻找一个库并返回路径名称。 <em>name</em> 是库名称并且不带任何前缀如 <code class="docutils literal notranslate"><span class="pre">lib</span></code> 以及后缀如 <code class="docutils literal notranslate"><span class="pre">.so</span></code>，<code class="docutils literal notranslate"><span class="pre">.dylib</span></code> 或版本号（形式与 posix 链接器选项 <code class="xref std std-option docutils literal notranslate"><span class="pre">-l</span></code> 所用的一致）。 如果找不到库，则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<p class="translated">确切的功能取决于系统。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.util.find_msvcrt">
<span class="sig-prename descclassname"><span class="pre">ctypes.util.</span></span><span class="sig-name descname"><span class="pre">find_msvcrt</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.util.find_msvcrt" title="Link to this definition">¶</a></dt>
<dd><p class="translated">返回 Python 以及扩展模块所使用的 VC 运行时库的文件名。 如果库名称无法确定，则返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<p class="translated">如果你需要通过调用 <code class="docutils literal notranslate"><span class="pre">free(void</span> <span class="pre">*)</span></code> 来释放内存，例如某个扩展模块所分配的内存，重要的一点是你应当使用分配内存的库中的函数。</p>
<div class="availability docutils container">
<p class="translated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.util.dllist">
<span class="sig-prename descclassname"><span class="pre">ctypes.util.</span></span><span class="sig-name descname"><span class="pre">dllist</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.util.dllist" title="Link to this definition">¶</a></dt>
<dd><p class="translated">尝试提供当前进程中已加载的共享库的路径列表。这些路径未经过任何形式的标准化或处理。如果底层平台 API 失败，该函数可能会引发 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a>。确切功能因系统而异。</p>
<p class="translated">在大多数平台上，列表的第一个元素代表当前的可执行文件。它可能是空字符串。</p>
<div class="availability docutils container">
<p class="translated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows, macOS, iOS, glibc, BSD libc, musl</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.FormatError">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">FormatError</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">code</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.FormatError" title="Link to this definition">¶</a></dt>
<dd><p class="translated">返回错误代码 <em>code</em> 的文本描述。如果未指定错误代码，则通过调用 Windows API 函数 <a class="reference internal" href="#ctypes.GetLastError" title="ctypes.GetLastError"><code class="xref py py-func docutils literal notranslate"><span class="pre">GetLastError()</span></code></a> 使用最后一个错误代码。</p>
<div class="availability docutils container">
<p class="translated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.GetLastError">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">GetLastError</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.GetLastError" title="Link to this definition">¶</a></dt>
<dd><p class="translated">返回 Windows 在调用线程中设置的最近的错误码。 此函数会直接调用 Windows <code class="docutils literal notranslate"><span class="pre">GetLastError()</span></code> 函数，它并不返回错误码的 ctypes 私有副本。</p>
<div class="availability docutils container">
<p class="translated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.get_errno">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">get_errno</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.get_errno" title="Link to this definition">¶</a></dt>
<dd><p class="translated">返回调用线程中系统 <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> 变量的 ctypes 私有副本的当前值。</p>
<p class="audit-hook translated">引发一个不带参数的 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.get_errno</span></code>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.get_last_error">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">get_last_error</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.get_last_error" title="Link to this definition">¶</a></dt>
<dd><p class="translated">返回调用线程中系统 <code class="xref py py-data docutils literal notranslate"><span class="pre">LastError</span></code> 变量的 ctypes 私有副本的当前值。</p>
<div class="availability docutils container">
<p class="translated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows</p>
</div>
<p class="audit-hook translated">引发一个不带参数的 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.get_last_error</span></code>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.memmove">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">memmove</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.memmove" title="Link to this definition">¶</a></dt>
<dd><p class="translated">与标准 C memmove 库函数相同：将 <em>count</em> 个字节从 <em>src</em> 拷贝到 <em>dst</em>。 <em>dst</em> 和 <em>src</em> 必须为整数或可被转换为指针的 ctypes 实例。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.memset">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">memset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">count</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.memset" title="Link to this definition">¶</a></dt>
<dd><p class="translated">与标准 C memset 库函数相同：将位于地址 <em>dst</em> 的内存块用 <em>count</em> 个字节的 <em>c</em> 值填充。 <em>dst</em> 必须为指定地址的整数或 ctypes 实例。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.POINTER">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">POINTER</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span></em>, <em class="sig-param"><span class="positional-only-separator o"><abbr title="Positional-only parameter separator (PEP 570)"><span class="pre">/</span></abbr></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.POINTER" title="Link to this definition">¶</a></dt>
<dd><p class="translated">创建或返回一个 ctypes 指针类型。指针类型会在内部进行缓存和重用，因此重复调用此函数的成本较低。<em>type</em> 必须是一个 ctypes 类型。</p>
<div class="impl-detail compound">
<p class="translated">生成的指针类型会缓存到 <em>type</em> 的 <code class="docutils literal notranslate"><span class="pre">__pointer_type__</span></code> 属性中。可以在首次调用 <code class="docutils literal notranslate"><span class="pre">POINTER</span></code> 之前设置该属性，以指定自定义指针类型。但不建议这样做：在不依赖可能在未来 Python 版本中发生变化的实现细节的情况下，手动创建合适的指针类型非常困难。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.pointer">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">pointer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="positional-only-separator o"><abbr title="Positional-only parameter separator (PEP 570)"><span class="pre">/</span></abbr></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.pointer" title="Link to this definition">¶</a></dt>
<dd><p class="translated">创建一个新的指针实例，指向 <em>obj</em>。 返回的对象类型为 <code class="docutils literal notranslate"><span class="pre">POINTER(type(obj))</span></code>。</p>
<p class="translated">注意：如果你只是想向外部函数调用传递一个对象指针，你应当使用更为快速的 <code class="docutils literal notranslate"><span class="pre">byref(obj)</span></code>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.resize">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">resize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.resize" title="Link to this definition">¶</a></dt>
<dd><p class="translated">此函数可改变 <em>obj</em> 的内部内存缓冲区大小，其参数必须为 ctypes 类型的实例。 没有可能将缓冲区设为小于对象类型的本机大小值，该值由 <code class="docutils literal notranslate"><span class="pre">sizeof(type(obj))</span></code> 给出，但将缓冲区加大则是可能的。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.set_errno">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">set_errno</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.set_errno" title="Link to this definition">¶</a></dt>
<dd><p class="translated">设置调用线程中系统 <a class="reference internal" href="errno.html#module-errno" title="errno: Standard errno system symbols."><code class="xref py py-data docutils literal notranslate"><span class="pre">errno</span></code></a> 变量的 ctypes 私有副本的当前值为 <em>value</em> 并返回原来的值。</p>
<p class="audit-hook translated">引发一个 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.set_errno</span></code> 并附带参数 <code class="docutils literal notranslate"><span class="pre">errno</span></code>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.set_last_error">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">set_last_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.set_last_error" title="Link to this definition">¶</a></dt>
<dd><p class="translated">在调用线程中将系统 <code class="xref py py-data docutils literal notranslate"><span class="pre">LastError</span></code> 变量的 ctypes 私有副本的当前值设为 <em>value</em> 并返回之前的值。</p>
<div class="availability docutils container">
<p class="translated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows</p>
</div>
<p class="audit-hook translated">引发一个 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.set_last_error</span></code> 并附带参数 <code class="docutils literal notranslate"><span class="pre">error</span></code>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.sizeof">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">sizeof</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj_or_type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.sizeof" title="Link to this definition">¶</a></dt>
<dd><p class="translated">返回 ctypes 类型或实例的内存缓冲区以字节表示的大小。 其功能与 C <code class="docutils literal notranslate"><span class="pre">sizeof</span></code> 运算符相同。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.string_at">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">string_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ptr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.string_at" title="Link to this definition">¶</a></dt>
<dd><p class="translated">返回位于 <em>void *ptr</em> 的字节串。 如果指定了 <em>size</em>，它将被用作字节串的大小，否则将假定字节串以零值结尾。</p>
<p class="audit-hook translated">引发一个 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.string_at</span></code> 并附带参数 <code class="docutils literal notranslate"><span class="pre">ptr</span></code>, <code class="docutils literal notranslate"><span class="pre">size</span></code>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.WinError">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">WinError</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">code</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.WinError" title="Link to this definition">¶</a></dt>
<dd><p class="translated">创建一个 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 的实例。如果未指定 <em>code</em>，则会调用 <a class="reference internal" href="#ctypes.GetLastError" title="ctypes.GetLastError"><code class="xref py py-func docutils literal notranslate"><span class="pre">GetLastError()</span></code></a> 来确定错误代码。如果未指定 <em>descr</em>，则会调用 <a class="reference internal" href="#ctypes.FormatError" title="ctypes.FormatError"><code class="xref py py-func docutils literal notranslate"><span class="pre">FormatError()</span></code></a> 来获取错误的文本描述。</p>
<div class="availability docutils container">
<p class="translated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.3 版本发生变更: </span>过去会创建 <a class="reference internal" href="exceptions.html#WindowsError" title="WindowsError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">WindowsError</span></code></a> 的实例，现在它是 <a class="reference internal" href="exceptions.html#OSError" title="OSError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> 的别名。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.wstring_at">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">wstring_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ptr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.wstring_at" title="Link to this definition">¶</a></dt>
<dd><p class="translated">返回位于 <em>void *ptr</em> 的宽字符串。 如果指定了 <em>size</em>，它将被用作字符串的字符数量，否则将假定字符串以零值结尾。</p>
<p class="audit-hook translated">引发一个 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.wstring_at</span></code> 并附带参数 <code class="docutils literal notranslate"><span class="pre">ptr</span></code>, <code class="docutils literal notranslate"><span class="pre">size</span></code>。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.memoryview_at">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">memoryview_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ptr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">readonly</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.memoryview_at" title="Link to this definition">¶</a></dt>
<dd><p class="translated">返回一个长度为 <em>size</em> 的 <a class="reference internal" href="stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a> 对象，该对象引用从 <em>void *ptr</em> 开始的内存。</p>
<p class="translated">如果 <em>readonly</em> 为 True，返回的 <code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code> 对象将无法用于修改底层内存。（通过其他方式所做的更改仍会反映在返回的对象中。）</p>
<p class="translated">此函数与 <a class="reference internal" href="#ctypes.string_at" title="ctypes.string_at"><code class="xref py py-func docutils literal notranslate"><span class="pre">string_at()</span></code></a> 类似，主要区别在于它不会对指定内存进行复制。它是 <code class="docutils literal notranslate"><span class="pre">memoryview((c_byte</span> <span class="pre">*</span> <span class="pre">size).from_address(ptr))</span></code> 的语义等效替代方案，但效率更高。（虽然 <a class="reference internal" href="#ctypes._CData.from_address" title="ctypes._CData.from_address"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_address()</span></code></a> 只接受整数，但 <em>ptr</em> 也可以是 <a class="reference internal" href="#ctypes.POINTER" title="ctypes.POINTER"><code class="xref py py-class docutils literal notranslate"><span class="pre">ctypes.POINTER</span></code></a> 或 <a class="reference internal" href="#ctypes.byref" title="ctypes.byref"><code class="xref py py-func docutils literal notranslate"><span class="pre">byref()</span></code></a> 对象。）</p>
<p class="audit-hook translated" id="audit_event_ctypes_memoryview_at_0">引发一个 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.memoryview_at</span></code>，附带参数 <code class="docutils literal notranslate"><span class="pre">address</span></code>、<code class="docutils literal notranslate"><span class="pre">size</span></code>、<code class="docutils literal notranslate"><span class="pre">readonly</span></code>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

</section>
<section id="data-types">
<span id="ctypes-data-types"></span><h3 class="translated">数据类型<a class="headerlink" href="#data-types" title="Link to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="ctypes._CData">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">_CData</span></span><a class="headerlink" href="#ctypes._CData" title="Link to this definition">¶</a></dt>
<dd><p class="translated">这个非公有类是所有 ctypes 数据类型的共同基类。 另外，所有 ctypes 类型的实例都包含一个存放 C 兼容数据的内存块；该内存块的地址可由 <a class="reference internal" href="#ctypes.addressof" title="ctypes.addressof"><code class="xref py py-func docutils literal notranslate"><span class="pre">addressof()</span></code></a> 辅助函数返回。 还有一个实例变量被公开为 <a class="reference internal" href="#ctypes._CData._objects" title="ctypes._CData._objects"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_objects</span></code></a>；此变量包含其他在内存块包含指针的情况下需要保持存活的 Python 对象。</p>
<p class="translated">ctypes 数据类型的通用方法，它们都是类方法（严谨地说，它们是 <a class="reference internal" href="../glossary.html#term-metaclass"><span class="xref std std-term">metaclass</span></a> 的方法）:</p>
<dl class="py method">
<dt class="sig sig-object py" id="ctypes._CData.from_buffer">
<span class="sig-name descname"><span class="pre">from_buffer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.from_buffer" title="Link to this definition">¶</a></dt>
<dd><p class="translated">此方法返回一个共享 <em>source</em> 对象缓冲区的 ctypes 实例。 <em>source</em> 对象必须支持可写缓冲区接口。 可选的 <em>offset</em> 形参指定以字节表示的源缓冲区内偏移量；默认值为零。 如果源缓冲区不够大则会引发 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<p class="audit-hook translated">引发一个 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.cdata/buffer</span></code> 并附带参数 <code class="docutils literal notranslate"><span class="pre">pointer</span></code>, <code class="docutils literal notranslate"><span class="pre">size</span></code>, <code class="docutils literal notranslate"><span class="pre">offset</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ctypes._CData.from_buffer_copy">
<span class="sig-name descname"><span class="pre">from_buffer_copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.from_buffer_copy" title="Link to this definition">¶</a></dt>
<dd><p class="translated">此方法创建一个 ctypes 实例，从 <em>source</em> 对象缓冲区拷贝缓冲区，该对象必须是可读的。 可选的 <em>offset</em> 形参指定以字节表示的源缓冲区内偏移量；默认值为零。 如果源缓冲区不够大则会引发 <a class="reference internal" href="exceptions.html#ValueError" title="ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a>。</p>
<p class="audit-hook translated">引发一个 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.cdata/buffer</span></code> 并附带参数 <code class="docutils literal notranslate"><span class="pre">pointer</span></code>, <code class="docutils literal notranslate"><span class="pre">size</span></code>, <code class="docutils literal notranslate"><span class="pre">offset</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ctypes._CData.from_address">
<span class="sig-name descname"><span class="pre">from_address</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">address</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.from_address" title="Link to this definition">¶</a></dt>
<dd><p class="translated">此方法会使用 <em>address</em> 所指定的内存返回一个 ctypes 类型的实例，该参数必须为一个整数。</p>
<p class="audit-hook translated">这个方法以及其他间接调用了它的方法会引发一个 <a class="reference internal" href="sys.html#auditing"><span class="std std-ref">审计事件</span></a> <code class="docutils literal notranslate"><span class="pre">ctypes.cdata</span></code>，附带参数 <code class="docutils literal notranslate"><span class="pre">address</span></code>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ctypes._CData.from_param">
<span class="sig-name descname"><span class="pre">from_param</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.from_param" title="Link to this definition">¶</a></dt>
<dd><p class="translated">此方法会将 <em>obj</em> 适配为一个 ctypes 类型。 当该类型出现在外部函数的 <a class="reference internal" href="#ctypes._CFuncPtr.argtypes" title="ctypes._CFuncPtr.argtypes"><code class="xref py py-attr docutils literal notranslate"><span class="pre">argtypes</span></code></a> 元组中时它将会被调用并传入在外部函数中使用的实际对象；它必须返回一个可被用作函数调用形参的对象。</p>
<p class="translated">所有 ctypes 数据类型都带有这个类方法的默认实现，它通常会返回 <em>obj</em>，如果该对象是此类型的实例的话。 某些类型也能接受其他对象。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ctypes._CData.in_dll">
<span class="sig-name descname"><span class="pre">in_dll</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">library</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes._CData.in_dll" title="Link to this definition">¶</a></dt>
<dd><p class="translated">此方法返回一个由共享库导出的 ctypes 类型。 <em>name</em> 为导出数据的符号名称，<em>library</em> 为所加载的共享库。</p>
</dd></dl>

<p class="translated">ctypes 数据类型的常见类变量：</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes._CData.__pointer_type__">
<span class="sig-name descname"><span class="pre">__pointer_type__</span></span><a class="headerlink" href="#ctypes._CData.__pointer_type__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">通过为相应的 ctypes 数据类型调用 <a class="reference internal" href="#ctypes.POINTER" title="ctypes.POINTER"><code class="xref py py-func docutils literal notranslate"><span class="pre">POINTER()</span></code></a> 所创建的指针类型。如果尚未创建指针类型，则该属性不存在。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

<p class="translated">ctypes 数据类型的常见实例变量:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes._CData._b_base_">
<span class="sig-name descname"><span class="pre">_b_base_</span></span><a class="headerlink" href="#ctypes._CData._b_base_" title="Link to this definition">¶</a></dt>
<dd><p class="translated">有时 ctypes 数据实例并不拥有它们所包含的内存块，它们只是共享了某个基对象的部分内存块。 <a class="reference internal" href="#ctypes._CData._b_base_" title="ctypes._CData._b_base_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_b_base_</span></code></a> 只读成员是拥有内存块的根 ctypes 对象。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes._CData._b_needsfree_">
<span class="sig-name descname"><span class="pre">_b_needsfree_</span></span><a class="headerlink" href="#ctypes._CData._b_needsfree_" title="Link to this definition">¶</a></dt>
<dd><p class="translated">这个只读变量在 ctypes 数据实例自身已分配了内存块时为真值，否则为假值。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes._CData._objects">
<span class="sig-name descname"><span class="pre">_objects</span></span><a class="headerlink" href="#ctypes._CData._objects" title="Link to this definition">¶</a></dt>
<dd><p class="translated">这个成员或者为 <code class="docutils literal notranslate"><span class="pre">None</span></code>，或者为一个包含需要保持存活以使内存块的内存保持有效的 Python 对象的字典。 这个对象只是出于调试目的而对外公开；绝对不要修改此字典的内容。</p>
</dd></dl>

</dd></dl>

</section>
<section id="ctypes-fundamental-data-types-2">
<span id="id1"></span><h3 class="translated">基础数据类型<a class="headerlink" href="#ctypes-fundamental-data-types-2" title="Link to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="ctypes._SimpleCData">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">_SimpleCData</span></span><a class="headerlink" href="#ctypes._SimpleCData" title="Link to this definition">¶</a></dt>
<dd><p class="translated">这个非公有类是所有基本 ctypes 数据类型的基类。 它在这里被提及是因为它包含基本 ctypes 数据类型共有的属性。 <a class="reference internal" href="#ctypes._SimpleCData" title="ctypes._SimpleCData"><code class="xref py py-class docutils literal notranslate"><span class="pre">_SimpleCData</span></code></a> 是 <a class="reference internal" href="#ctypes._CData" title="ctypes._CData"><code class="xref py py-class docutils literal notranslate"><span class="pre">_CData</span></code></a> 的子类，因此继承了其方法和属性。 非指针及不包含指针的 ctypes 数据类型现在将可以被封存。</p>
<p class="translated">实例拥有一个属性:</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes._SimpleCData.value">
<span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#ctypes._SimpleCData.value" title="Link to this definition">¶</a></dt>
<dd><p class="translated">这个属性包含实例的实际值。 对于整数和指针类型，它是一个整数，对于字符类型，它是一个单字符字符串对象或字符串，对于字符指针类型，它是一个 Python 字节串对象或字符串。</p>
<p class="translated">当从 ctypes 实例提取 <code class="docutils literal notranslate"><span class="pre">value</span></code> 属性时，通常每次会返回一个新的对象。 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 并 <em>没有</em> 实现原始对象返回，它总是会构造一个新的对象。 所有其他 ctypes 对象实例也同样如此。</p>
</dd></dl>

</dd></dl>

<p class="translated">当作为外部函数调用结果，或者举例来说，作为结构字段成员或数组条目被提取时，基本数据类型会被透明与转换为原生 Python 类型。 换句话说，如果某个外部函数的 <a class="reference internal" href="#ctypes._CFuncPtr.restype" title="ctypes._CFuncPtr.restype"><code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code></a> 是 <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a>，那么你将总是得到一个 Python 字节串对象，而 <em>不是</em> 一个 <a class="reference internal" href="#ctypes.c_char_p" title="ctypes.c_char_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_char_p</span></code></a> 实例。</p>
<p class="translated">基本数据类型的子类 <em>不会</em> 继承这种行为。 因此，如果一个外部函数的 <code class="xref py py-attr docutils literal notranslate"><span class="pre">restype</span></code> 是 <a class="reference internal" href="#ctypes.c_void_p" title="ctypes.c_void_p"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_void_p</span></code></a> 的子类，则你将从函数调用得到一个该子类的实例。 当然，你可以通过访问 <code class="docutils literal notranslate"><span class="pre">value</span></code> 属性来获取指针的值。</p>
<p class="translated">这些是基本 ctypes 数据类型:</p>
<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_byte">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_byte</span></span><a class="headerlink" href="#ctypes.c_byte" title="Link to this definition">¶</a></dt>
<dd><p class="translated">代表 C <span class="c-expr sig sig-inline c"><span class="kt">signed</span><span class="w"> </span><span class="kt">char</span></span> 数据类型，并将值解读为一个小整数。 该构造器接受一个可选的整数初始值；不会执行溢出检查。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_char">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_char</span></span><a class="headerlink" href="#ctypes.c_char" title="Link to this definition">¶</a></dt>
<dd><p class="translated">代表 C <span class="c-expr sig sig-inline c"><span class="kt">char</span></span> 数据类型，并将值解读为单个字符。 该构造器接受一个可选的字符串初始值，字符串的长度必须恰好为一个字符。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_char_p">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_char_p</span></span><a class="headerlink" href="#ctypes.c_char_p" title="Link to this definition">¶</a></dt>
<dd><p class="translated">当指向一个以零为结束符的字符串时代表 C <span class="c-expr sig sig-inline c"><span class="kt">char</span><span class="p">*</span></span> 数据类型。 对于通用字符指针来说也可能指向二进制数据，必须要使用 <code class="docutils literal notranslate"><span class="pre">POINTER(c_char)</span></code>。 该构造器接受一个整数地址，或者一个字节串对象。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_double">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_double</span></span><a class="headerlink" href="#ctypes.c_double" title="Link to this definition">¶</a></dt>
<dd><p class="translated">代表 C <span class="c-expr sig sig-inline c"><span class="kt">double</span></span> 数据类型。 该构造器接受一个可选的浮点数初始值。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_longdouble">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_longdouble</span></span><a class="headerlink" href="#ctypes.c_longdouble" title="Link to this definition">¶</a></dt>
<dd><p class="translated">代表 C <span class="c-expr sig sig-inline c"><span class="kt">long</span><span class="w"> </span><span class="kt">double</span></span> 数据类型。 该构造器接受一个可选的浮点数初始值。 在 <code class="docutils literal notranslate"><span class="pre">sizeof(long</span> <span class="pre">double)</span> <span class="pre">==</span> <span class="pre">sizeof(double)</span></code> 的平台上它是 <a class="reference internal" href="#ctypes.c_double" title="ctypes.c_double"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_double</span></code></a> 的一个别名。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_float">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_float</span></span><a class="headerlink" href="#ctypes.c_float" title="Link to this definition">¶</a></dt>
<dd><p class="translated">代表 C <span class="c-expr sig sig-inline c"><span class="kt">float</span></span> 数据类型。 该构造器接受一个可选的浮点数初始值。datatype.  The constructor accepts an optional float initializer.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_double_complex">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_double_complex</span></span><a class="headerlink" href="#ctypes.c_double_complex" title="Link to this definition">¶</a></dt>
<dd><p class="translated">代表 C 语言中的 <span class="c-expr sig sig-inline c"><span class="kt">double</span><span class="w"> </span><span class="kt">complex</span></span> 数据类型（如果可用）。该构造器接受一个可选的 <a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a> 初始化器。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_float_complex">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_float_complex</span></span><a class="headerlink" href="#ctypes.c_float_complex" title="Link to this definition">¶</a></dt>
<dd><p class="translated">代表 C 语言中的 <span class="c-expr sig sig-inline c"><span class="kt">float</span><span class="w"> </span><span class="kt">complex</span></span> 数据类型（如果可用）。该构造器接受一个可选的 <a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a> 初始化器。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_longdouble_complex">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_longdouble_complex</span></span><a class="headerlink" href="#ctypes.c_longdouble_complex" title="Link to this definition">¶</a></dt>
<dd><p class="translated">代表 C 语言中的 <span class="c-expr sig sig-inline c"><span class="kt">long</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="kt">complex</span></span> 数据类型（如果可用）。该构造器接受一个可选的 <a class="reference internal" href="functions.html#complex" title="complex"><code class="xref py py-class docutils literal notranslate"><span class="pre">complex</span></code></a> 初始化器。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_int">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_int</span></span><a class="headerlink" href="#ctypes.c_int" title="Link to this definition">¶</a></dt>
<dd><p class="translated">代表 C <span class="c-expr sig sig-inline c"><span class="kt">signed</span><span class="w"> </span><span class="kt">int</span></span> 数据类型。 该构造器接受一个可选的整数初始值；不会执行溢出检查。 在 <code class="docutils literal notranslate"><span class="pre">sizeof(int)</span> <span class="pre">==</span> <span class="pre">sizeof(long)</span></code> 的平台上它是 <a class="reference internal" href="#ctypes.c_long" title="ctypes.c_long"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_long</span></code></a> 的一个别名。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_int8">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_int8</span></span><a class="headerlink" href="#ctypes.c_int8" title="Link to this definition">¶</a></dt>
<dd><p class="translated">代表 C 8 位 <span class="c-expr sig sig-inline c"><span class="kt">signed</span><span class="w"> </span><span class="kt">int</span></span> 数据类型。 它是 <a class="reference internal" href="#ctypes.c_byte" title="ctypes.c_byte"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_byte</span></code></a> 的一个别名。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_int16">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_int16</span></span><a class="headerlink" href="#ctypes.c_int16" title="Link to this definition">¶</a></dt>
<dd><p class="translated">代表 C 16 位 <span class="c-expr sig sig-inline c"><span class="kt">signed</span><span class="w"> </span><span class="kt">int</span></span> 数据类型。 通常是 <a class="reference internal" href="#ctypes.c_short" title="ctypes.c_short"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_short</span></code></a> 的一个别名。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_int32">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_int32</span></span><a class="headerlink" href="#ctypes.c_int32" title="Link to this definition">¶</a></dt>
<dd><p class="translated">代表 C 32 位 <span class="c-expr sig sig-inline c"><span class="kt">signed</span><span class="w"> </span><span class="kt">int</span></span> 数据类型。 通常是 <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a> 的一个别名。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_int64">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_int64</span></span><a class="headerlink" href="#ctypes.c_int64" title="Link to this definition">¶</a></dt>
<dd><p class="translated">代表 C 64 位 <span class="c-expr sig sig-inline c"><span class="kt">signed</span><span class="w"> </span><span class="kt">int</span></span> 数据类型。 通常是 <a class="reference internal" href="#ctypes.c_longlong" title="ctypes.c_longlong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_longlong</span></code></a> 的一个别名。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_long">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_long</span></span><a class="headerlink" href="#ctypes.c_long" title="Link to this definition">¶</a></dt>
<dd><p class="translated">代表 C <span class="c-expr sig sig-inline c"><span class="kt">signed</span><span class="w"> </span><span class="kt">long</span></span> 数据类型。 该构造器接受一个可选的整数初始值；不会执行溢出检查。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_longlong">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_longlong</span></span><a class="headerlink" href="#ctypes.c_longlong" title="Link to this definition">¶</a></dt>
<dd><p class="translated">代表 C <span class="c-expr sig sig-inline c"><span class="kt">signed</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span> 数据类型。 该构造器接受一个可选的整数初始值；不会执行溢出检查。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_short">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_short</span></span><a class="headerlink" href="#ctypes.c_short" title="Link to this definition">¶</a></dt>
<dd><p class="translated">代表 C <span class="c-expr sig sig-inline c"><span class="kt">signed</span><span class="w"> </span><span class="kt">short</span></span> 数据类型。 该构造器接受一个可选的整数初始值；不会执行溢出检查。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_size_t">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_size_t</span></span><a class="headerlink" href="#ctypes.c_size_t" title="Link to this definition">¶</a></dt>
<dd><p class="translated">代表 C <code class="xref c c-type docutils literal notranslate"><span class="pre">size_t</span></code> 数据类型。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_ssize_t">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_ssize_t</span></span><a class="headerlink" href="#ctypes.c_ssize_t" title="Link to this definition">¶</a></dt>
<dd><p class="translated">代表 C <code class="xref c c-type docutils literal notranslate"><span class="pre">ssize_t</span></code> 数据类型。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.2.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_time_t">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_time_t</span></span><a class="headerlink" href="#ctypes.c_time_t" title="Link to this definition">¶</a></dt>
<dd><p class="translated">代表 C <code class="xref c c-type docutils literal notranslate"><span class="pre">time_t</span></code> 数据类型。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.12.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_ubyte">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_ubyte</span></span><a class="headerlink" href="#ctypes.c_ubyte" title="Link to this definition">¶</a></dt>
<dd><p class="translated">代表 C <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span></span> 数据类型，它将值解读为一个小整数。 该构造器接受一个可选的整数初始值；不会执行溢出检查。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_uint">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_uint</span></span><a class="headerlink" href="#ctypes.c_uint" title="Link to this definition">¶</a></dt>
<dd><p class="translated">代表 C <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span></span> 数据类型。 该构造器接受一个可选的整数初始值；不会执行溢出检查。 在 <code class="docutils literal notranslate"><span class="pre">sizeof(int)</span> <span class="pre">==</span> <span class="pre">sizeof(long)</span></code> 的平台上它是 <a class="reference internal" href="#ctypes.c_ulong" title="ctypes.c_ulong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ulong</span></code></a> 的一个别名。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_uint8">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_uint8</span></span><a class="headerlink" href="#ctypes.c_uint8" title="Link to this definition">¶</a></dt>
<dd><p class="translated">代表 C 8 位 <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span></span> 数据类型。 它是 <a class="reference internal" href="#ctypes.c_ubyte" title="ctypes.c_ubyte"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ubyte</span></code></a> 的一个别名。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_uint16">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_uint16</span></span><a class="headerlink" href="#ctypes.c_uint16" title="Link to this definition">¶</a></dt>
<dd><p class="translated">代表 C 16 位 <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span></span> 数据类型。 通常是 <a class="reference internal" href="#ctypes.c_ushort" title="ctypes.c_ushort"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ushort</span></code></a> 的一个别名。.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_uint32">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_uint32</span></span><a class="headerlink" href="#ctypes.c_uint32" title="Link to this definition">¶</a></dt>
<dd><p class="translated">代表 C 32 位 <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span></span> 数据类型。 通常是 <a class="reference internal" href="#ctypes.c_uint" title="ctypes.c_uint"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_uint</span></code></a> 的一个别名。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_uint64">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_uint64</span></span><a class="headerlink" href="#ctypes.c_uint64" title="Link to this definition">¶</a></dt>
<dd><p class="translated">代表 C 64 位 <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span></span> 数据类型。 通常是 <a class="reference internal" href="#ctypes.c_ulonglong" title="ctypes.c_ulonglong"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_ulonglong</span></code></a> 的一个别名。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_ulong">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_ulong</span></span><a class="headerlink" href="#ctypes.c_ulong" title="Link to this definition">¶</a></dt>
<dd><p class="translated">代表 C <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span></span> 数据类型。 该构造器接受一个可选的整数初始值；不会执行溢出检查。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_ulonglong">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_ulonglong</span></span><a class="headerlink" href="#ctypes.c_ulonglong" title="Link to this definition">¶</a></dt>
<dd><p class="translated">代表 C <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="kt">long</span></span> 数据类型。 该构造器接受一个可选的整数初始值；不会执行溢出检查。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_ushort">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_ushort</span></span><a class="headerlink" href="#ctypes.c_ushort" title="Link to this definition">¶</a></dt>
<dd><p class="translated">代表 C <span class="c-expr sig sig-inline c"><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span></span> 数据类型。 该构造器接受一个可选的整数初始值；不会执行溢出检查。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_void_p">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_void_p</span></span><a class="headerlink" href="#ctypes.c_void_p" title="Link to this definition">¶</a></dt>
<dd><p class="translated">代表 C <span class="c-expr sig sig-inline c"><span class="kt">void</span><span class="p">*</span></span> 类型。 该值被表示为整数形式。 该构造器接受一个可选的整数初始值。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_wchar">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_wchar</span></span><a class="headerlink" href="#ctypes.c_wchar" title="Link to this definition">¶</a></dt>
<dd><p class="translated">代表 C <code class="xref c c-type docutils literal notranslate"><span class="pre">wchar_t</span></code> 数据类型，并将值解读为一单个字符的 unicode 字符串。 该构造器接受一个可选的字符串初始化器，字符串的长度必须恰好为一个字符。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_wchar_p">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_wchar_p</span></span><a class="headerlink" href="#ctypes.c_wchar_p" title="Link to this definition">¶</a></dt>
<dd><p class="translated">代表 C <span class="c-expr sig sig-inline c"><span class="n">wchar_t</span><span class="p">*</span></span> 数据类型，它必须为指向以零为续签符的宽字符串的指针。 该构造器接受一个整数地址，或一个字符串。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.c_bool">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">c_bool</span></span><a class="headerlink" href="#ctypes.c_bool" title="Link to this definition">¶</a></dt>
<dd><p class="translated">代表 C <span class="c-expr sig sig-inline c"><span class="kt">bool</span></span> 数据类型 (更准确地说，是 C99 <span class="c-expr sig sig-inline c"><span class="kt">_Bool</span></span>)。 它的值可以为 <code class="docutils literal notranslate"><span class="pre">True</span></code> 或 <code class="docutils literal notranslate"><span class="pre">False</span></code>，并且该构造器接受任何具有逻辑值的对象。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.HRESULT">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">HRESULT</span></span><a class="headerlink" href="#ctypes.HRESULT" title="Link to this definition">¶</a></dt>
<dd><p class="translated">代表一个 <code class="xref c c-type docutils literal notranslate"><span class="pre">HRESULT</span></code> 值，它包含某个函数或方法调用的成功或错误信息。</p>
<div class="availability docutils container">
<p class="translated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.py_object">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">py_object</span></span><a class="headerlink" href="#ctypes.py_object" title="Link to this definition">¶</a></dt>
<dd><p class="translated">代表 C <span class="c-expr sig sig-inline c"><a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span> 数据类型。 不带参数地调用此构造器将创建一个 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> <span class="c-expr sig sig-inline c"><a class="reference internal" href="../c-api/structures.html#c.PyObject" title="PyObject"><span class="n">PyObject</span></a><span class="p">*</span></span> 指针。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.14 版本发生变更: </span><code class="xref py py-class docutils literal notranslate"><span class="pre">py_object</span></code> 现在是一种 <a class="reference internal" href="../glossary.html#term-generic-type"><span class="xref std std-term">generic type</span></a>。</p>
</div>
</dd></dl>

<p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes.wintypes</span></code> 模块提供了其他许多 Windows 专属的数据类型，例如 <code class="xref c c-type docutils literal notranslate"><span class="pre">HWND</span></code>, <code class="xref c c-type docutils literal notranslate"><span class="pre">WPARAM</span></code> 或 <code class="xref c c-type docutils literal notranslate"><span class="pre">DWORD</span></code>。 还定义了一些有用的结构体如 <code class="xref c c-type docutils literal notranslate"><span class="pre">MSG</span></code> 或 <code class="xref c c-type docutils literal notranslate"><span class="pre">RECT</span></code>。</p>
</section>
<section id="structured-data-types">
<span id="ctypes-structured-data-types"></span><h3 class="translated">结构化数据类型<a class="headerlink" href="#structured-data-types" title="Link to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="ctypes.Union">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">Union</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.Union" title="Link to this definition">¶</a></dt>
<dd><p class="translated">本机字节序的联合所对应的抽象基类。</p>
<p class="translated">联合与结构体共享共同的属性和行为；详情请参见 <a class="reference internal" href="#ctypes.Structure" title="ctypes.Structure"><code class="xref py py-class docutils literal notranslate"><span class="pre">Structure</span></code></a> 的文档。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.BigEndianUnion">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">BigEndianUnion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.BigEndianUnion" title="Link to this definition">¶</a></dt>
<dd><p class="translated"><em>大端</em> 字节序的联合所对应的抽象基类。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.LittleEndianUnion">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">LittleEndianUnion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.LittleEndianUnion" title="Link to this definition">¶</a></dt>
<dd><p class="translated"><em>小端</em> 字节序的联合所对应的抽象基类。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.11.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.BigEndianStructure">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">BigEndianStructure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.BigEndianStructure" title="Link to this definition">¶</a></dt>
<dd><p class="translated"><em>大端</em> 字节序的结构体所对应的抽象基类。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.LittleEndianStructure">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">LittleEndianStructure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.LittleEndianStructure" title="Link to this definition">¶</a></dt>
<dd><p class="translated"><em>小端</em> 字节序的结构体所对应的抽象基类。</p>
</dd></dl>

<p class="translated">非本机字节序的结构体和联合不能包含指针类型字段，或任何其他包含指针类型字段的数据类型。</p>
<dl class="py class">
<dt class="sig sig-object py" id="ctypes.Structure">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">Structure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.Structure" title="Link to this definition">¶</a></dt>
<dd><p class="translated"><em>本机</em> 字节序的结构体所对应的抽象基类。</p>
<p class="translated">实际的结构体和联合类型必须通过子类化这些类型之一来创建，并且至少要定义一个 <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> 类变量。 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 将创建 <a class="reference internal" href="../glossary.html#term-descriptor"><span class="xref std std-term">descriptor</span></a>，它允许通过直接属性访问来读取和写入字段。 这些是</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.Structure._fields_">
<span class="sig-name descname"><span class="pre">_fields_</span></span><a class="headerlink" href="#ctypes.Structure._fields_" title="Link to this definition">¶</a></dt>
<dd><p class="translated">一个定义结构体字段的序列。 其中的条目必须为 2 元组或 3 元组。 元组的第一项是字段名称，第二项指明字段类型；它可以是任何 ctypes 数据类型。</p>
<p class="translated">对于整数类型字段例如 <a class="reference internal" href="#ctypes.c_int" title="ctypes.c_int"><code class="xref py py-class docutils literal notranslate"><span class="pre">c_int</span></code></a>，可以给定第三个可选项。 它必须是一个定义字段比特位宽度的小正整数。</p>
<p class="translated">字段名称在一个结构体或联合中必须唯一。 不会检查这个唯一性，但当名称出现重复时将只有一个字段可被访问。</p>
<p class="translated">可以在定义 Structure 子类的类语句 <em>之后</em> 再定义 <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> 类变量，这将允许创建直接或间接引用其自身的数据类型:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">List</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="n">List</span><span class="o">.</span><span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;pnext&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">List</span><span class="p">)),</span>
                 <span class="o">...</span>
                <span class="p">]</span>
</pre></div>
</div>
<p class="translated">类变量 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code> 只能设置一次。后续的赋值操作将会引发 <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>。</p>
<p class="translated">此外，类变量 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code> 必须在结构体或联合类型首次使用前定义：包括创建实例或子类、对其调用 <a class="reference internal" href="#ctypes.sizeof" title="ctypes.sizeof"><code class="xref py py-func docutils literal notranslate"><span class="pre">sizeof()</span></code></a> 等情况。后续对 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code> 的赋值会引发 <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>。如果在上述使用场景前未设置 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code>，则该结构体或联合将没有自身的字段，就如同 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code> 为空一样。</p>
<p class="translated">结构体类型的子子类会继承基类的字段，再加上子子类中定义的 <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a>，如果有的话。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.Structure._pack_">
<span class="sig-name descname"><span class="pre">_pack_</span></span><a class="headerlink" href="#ctypes.Structure._pack_" title="Link to this definition">¶</a></dt>
<dd><p class="translated">一个可选的小整数，它允许重写实例中结构体字段的对齐值。</p>
<p class="translated">这仅针对与 MSVC 兼容的内存布局实现 (参见 <a class="reference internal" href="#ctypes.Structure._layout_" title="ctypes.Structure._layout_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_layout_</span></code></a>)。</p>
<p class="translated">将 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_pack_</span></code> 设为 0 与完全不设置它是一样的。 在其他情况下，该值必须为正的二的乘方。 其效果于 C 中的 <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">pack(N)</span></code> 等价，区别在于 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 可能允许比编译器所接受的更大的 <em>n</em> 值。</p>
<p class="translated">当为 <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> 赋值时，<code class="xref py py-attr docutils literal notranslate"><span class="pre">_pack_</span></code> 必须已被定义，否则它将不起作用。</p>
<div class="deprecated-removed">
<p><span class="versionmodified deprecated">Deprecated since version 3.14, will be removed in version 3.19: </span>由于历史原因，如果 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_pack_</span></code> 为非零值，默认情况下将使用与 MSVC 兼容的布局。在非 Windows 平台上，这一默认行为已被弃用，并计划在 Python 3.19 中变为错误。如果确实需要此行为，请显式将 <a class="reference internal" href="#ctypes.Structure._layout_" title="ctypes.Structure._layout_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_layout_</span></code></a> 设置为 <code class="docutils literal notranslate"><span class="pre">'ms'</span></code>。</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.Structure._align_">
<span class="sig-name descname"><span class="pre">_align_</span></span><a class="headerlink" href="#ctypes.Structure._align_" title="Link to this definition">¶</a></dt>
<dd><p class="translated">一个可选的小整数，它允许增加针对内存执行打包或解包时的对齐值。</p>
<p class="translated">该值必须不为负数。 其效果与 GCC 中的 <code class="docutils literal notranslate"><span class="pre">__attribute__((aligned(N)))</span></code> 或 MSVC 中的 <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">align(N)</span></code> 等价，区别在于 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 可能允许编译器会拒绝的值。</p>
<p class="translated"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_align_</span></code> 只能 <em>增加</em> 一个结构体要求的对齐值。 将其设为 0 或 1 将没有任何效果。</p>
<p class="translated">不建议使用不为二进乘方的值并可能导致意外的行为。</p>
<p class="translated">当为 <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> 赋值时 <code class="xref py py-attr docutils literal notranslate"><span class="pre">_align_</span></code> 必须已被定义，否则它将不起作用。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.13.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.Structure._layout_">
<span class="sig-name descname"><span class="pre">_layout_</span></span><a class="headerlink" href="#ctypes.Structure._layout_" title="Link to this definition">¶</a></dt>
<dd><p class="translated">一个可选字符串，用于指定结构体/联合的布局。目前它可以设置为：</p>
<ul class="simple">
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">&quot;ms&quot;</span></code>：微软编译器（MSVC）所使用的布局。在 GCC 和 Clang 上，可以通过 <code class="docutils literal notranslate"><span class="pre">__attribute__((ms_struct))</span></code> 来选择此布局。</p></li>
<li><p class="translated"><code class="docutils literal notranslate"><span class="pre">&quot;gcc-sysv&quot;</span></code>：GCC 在 System V 或“类 SysV”数据模型中使用的布局，适用于 Linux 和 macOS 系统。采用此布局时，<a class="reference internal" href="#ctypes.Structure._pack_" title="ctypes.Structure._pack_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_pack_</span></code></a> 必须保持未设置状态或设为零。</p></li>
</ul>
<p class="translated">如果未显式设置，<code class="docutils literal notranslate"><span class="pre">ctypes</span></code> 将使用与平台约定相匹配的默认值。此默认值可能会在未来的 Python 版本中发生变化（例如，当新平台获得官方支持时，或者当发现相似平台之间存在差异时）。目前，默认值如下：</p>
<ul class="simple">
<li><p class="translated">在Windows平台上： <code class="docutils literal notranslate"><span class="pre">&quot;ms&quot;</span></code></p></li>
<li><p class="translated">当指定了 <a class="reference internal" href="#ctypes.Structure._pack_" title="ctypes.Structure._pack_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_pack_</span></code></a> 时：<code class="docutils literal notranslate"><span class="pre">&quot;ms&quot;</span></code>。（此行为已弃用，详见 <a class="reference internal" href="#ctypes.Structure._pack_" title="ctypes.Structure._pack_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_pack_</span></code></a> 的文档。）</p></li>
<li><p class="translated">在非Windows平台上：<code class="docutils literal notranslate"><span class="pre">&quot;gcc-sysv&quot;</span></code></p></li>
</ul>
<p class="translated">在为 <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> 赋值时，<code class="xref py py-attr docutils literal notranslate"><span class="pre">_layout_</span></code> 必须已被定义，否则它将不起作用。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.Structure._anonymous_">
<span class="sig-name descname"><span class="pre">_anonymous_</span></span><a class="headerlink" href="#ctypes.Structure._anonymous_" title="Link to this definition">¶</a></dt>
<dd><p class="translated">一个可选的序列，它会列出未命名（匿名）字段的名称。 当 <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> 被赋值时必须已经定义了 <a class="reference internal" href="#ctypes.Structure._anonymous_" title="ctypes.Structure._anonymous_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_anonymous_</span></code></a>，否则它将没有效果。</p>
<p class="translated">在此变量中列出的字段必须为结构体或联合类型字段。 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 将在结构体类型中创建描述器以允许直接访问嵌套字段，而无需创建对应的结构体或联合字段。</p>
<p class="translated">以下是一个示例类型（Windows）:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">_U</span><span class="p">(</span><span class="n">Union</span><span class="p">):</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;lptdesc&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">TYPEDESC</span><span class="p">)),</span>
                <span class="p">(</span><span class="s2">&quot;lpadesc&quot;</span><span class="p">,</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">ARRAYDESC</span><span class="p">)),</span>
                <span class="p">(</span><span class="s2">&quot;hreftype&quot;</span><span class="p">,</span> <span class="n">HREFTYPE</span><span class="p">)]</span>

<span class="k">class</span><span class="w"> </span><span class="nc">TYPEDESC</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
    <span class="n">_anonymous_</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;u&quot;</span><span class="p">,)</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;u&quot;</span><span class="p">,</span> <span class="n">_U</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;vt&quot;</span><span class="p">,</span> <span class="n">VARTYPE</span><span class="p">)]</span>
</pre></div>
</div>
<p class="translated"><code class="docutils literal notranslate"><span class="pre">TYPEDESC</span></code> 结构体描述了一个 COM 数据类型，<code class="docutils literal notranslate"><span class="pre">vt</span></code> 字段指明哪个联合字段是有效的。 由于 <code class="docutils literal notranslate"><span class="pre">u</span></code> 字段被定义为匿名字段，现在可以直接从 TYPEDESC 实例访问成员。 <code class="docutils literal notranslate"><span class="pre">td.lptdesc</span></code> 和 <code class="docutils literal notranslate"><span class="pre">td.u.lptdesc</span></code> 是等价的，但前者速度更快，因为它不需要创建临时的联合实例:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">td</span> <span class="o">=</span> <span class="n">TYPEDESC</span><span class="p">()</span>
<span class="n">td</span><span class="o">.</span><span class="n">vt</span> <span class="o">=</span> <span class="n">VT_PTR</span>
<span class="n">td</span><span class="o">.</span><span class="n">lptdesc</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">some_type</span><span class="p">)</span>
<span class="n">td</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">lptdesc</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">some_type</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<p class="translated">可以定义结构体的子类，它们会继承基类的字段。 如果子类定义具有单独的 <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> 变量，在其中指定的字段会被添加到基类的字段中。</p>
<p class="translated">结构体和联合的构造器均可接受位置和关键字参数。 位置参数用于按照 <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> 中的出现顺序来初始化成员字段。 构造器中的关键字参数会被解读为属性赋值，因此它们将以相应的名称来初始化 <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a>，或为不存在于 <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> 中的名称创建新的属性。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes.CField">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">CField</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.CField" title="Link to this definition">¶</a></dt>
<dd><p class="translated">结构体（<a class="reference internal" href="#ctypes.Structure" title="ctypes.Structure"><code class="xref py py-class docutils literal notranslate"><span class="pre">Structure</span></code></a>）和联合（<a class="reference internal" href="#ctypes.Union" title="ctypes.Union"><code class="xref py py-class docutils literal notranslate"><span class="pre">Union</span></code></a>）字段的描述符。例如：</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">Color</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">(</span>
<span class="gp">... </span>        <span class="p">(</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">c_uint8</span><span class="p">),</span>
<span class="gp">... </span>        <span class="p">(</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">c_uint8</span><span class="p">),</span>
<span class="gp">... </span>        <span class="p">(</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">c_uint8</span><span class="p">),</span>
<span class="gp">... </span>        <span class="p">(</span><span class="s1">&#39;intense&#39;</span><span class="p">,</span> <span class="n">c_bool</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span>        <span class="p">(</span><span class="s1">&#39;blinking&#39;</span><span class="p">,</span> <span class="n">c_bool</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span>   <span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="o">.</span><span class="n">red</span>
<span class="go">&lt;ctypes.CField &#39;red&#39; type=c_ubyte, ofs=0, size=1&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="o">.</span><span class="n">green</span><span class="o">.</span><span class="n">type</span>
<span class="go">&lt;class &#39;ctypes.c_ubyte&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="o">.</span><span class="n">blue</span><span class="o">.</span><span class="n">byte_offset</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="o">.</span><span class="n">intense</span>
<span class="go">&lt;ctypes.CField &#39;intense&#39; type=c_bool, ofs=3, bit_size=1, bit_offset=0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="o">.</span><span class="n">blinking</span><span class="o">.</span><span class="n">bit_offset</span>
<span class="go">1</span>
</pre></div>
</div>
<p class="translated">所有属性均为只读。</p>
<p class="translated"><code class="xref py py-class docutils literal notranslate"><span class="pre">CField</span></code> 对象通过 <a class="reference internal" href="#ctypes.Structure._fields_" title="ctypes.Structure._fields_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_fields_</span></code></a> 创建；请勿直接实例化该类。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14: </span>以前，描述符只有 <code class="docutils literal notranslate"><span class="pre">offset</span></code> 和 <code class="docutils literal notranslate"><span class="pre">size</span></code> 属性以及一个可读的字符串表示形式；<code class="xref py py-class docutils literal notranslate"><span class="pre">CField</span></code> 类无法直接使用。</p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.CField.name">
<span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#ctypes.CField.name" title="Link to this definition">¶</a></dt>
<dd><p class="translated">字段的名称，为字符串形式。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.CField.type">
<span class="sig-name descname"><span class="pre">type</span></span><a class="headerlink" href="#ctypes.CField.type" title="Link to this definition">¶</a></dt>
<dd><p class="translated">字段的类型，为一个 <a class="reference internal" href="#ctypes-data-types"><span class="std std-ref">ctypes 类</span></a>。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.CField.offset">
<span class="sig-name descname"><span class="pre">offset</span></span><a class="headerlink" href="#ctypes.CField.offset" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="ctypes.CField.byte_offset">
<span class="sig-name descname"><span class="pre">byte_offset</span></span><a class="headerlink" href="#ctypes.CField.byte_offset" title="Link to this definition">¶</a></dt>
<dd><p class="translated">字段的偏移量，以字节为单位。</p>
<p class="translated">对于位域，这是基础字节对齐的 <em>存储单元</em> 的偏移量；详见 <a class="reference internal" href="#ctypes.CField.bit_offset" title="ctypes.CField.bit_offset"><code class="xref py py-attr docutils literal notranslate"><span class="pre">bit_offset</span></code></a>。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.CField.byte_size">
<span class="sig-name descname"><span class="pre">byte_size</span></span><a class="headerlink" href="#ctypes.CField.byte_size" title="Link to this definition">¶</a></dt>
<dd><p class="translated">字段的大小，以字节为单位。</p>
<p class="translated">对于位域，这是基础 <em>存储单元</em> 的大小。通常，它与位域类型的大小相同。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.CField.size">
<span class="sig-name descname"><span class="pre">size</span></span><a class="headerlink" href="#ctypes.CField.size" title="Link to this definition">¶</a></dt>
<dd><p class="translated">对于非位域，与 <a class="reference internal" href="#ctypes.CField.byte_size" title="ctypes.CField.byte_size"><code class="xref py py-attr docutils literal notranslate"><span class="pre">byte_size</span></code></a> 等效。</p>
<p class="translated">对于位域，该属性包含一个向后兼容的位打包值，它结合了 <a class="reference internal" href="#ctypes.CField.bit_size" title="ctypes.CField.bit_size"><code class="xref py py-attr docutils literal notranslate"><span class="pre">bit_size</span></code></a> 和 <a class="reference internal" href="#ctypes.CField.bit_offset" title="ctypes.CField.bit_offset"><code class="xref py py-attr docutils literal notranslate"><span class="pre">bit_offset</span></code></a>。建议优先使用这两个显式属性。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.CField.is_bitfield">
<span class="sig-name descname"><span class="pre">is_bitfield</span></span><a class="headerlink" href="#ctypes.CField.is_bitfield" title="Link to this definition">¶</a></dt>
<dd><p class="translated">如果这是位域，则为 True。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.CField.bit_offset">
<span class="sig-name descname"><span class="pre">bit_offset</span></span><a class="headerlink" href="#ctypes.CField.bit_offset" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py" id="ctypes.CField.bit_size">
<span class="sig-name descname"><span class="pre">bit_size</span></span><a class="headerlink" href="#ctypes.CField.bit_size" title="Link to this definition">¶</a></dt>
<dd><p class="translated">位域在其 <em>存储单元</em> 内的位置，即位于从 <a class="reference internal" href="#ctypes.CField.byte_offset" title="ctypes.CField.byte_offset"><code class="xref py py-attr docutils literal notranslate"><span class="pre">byte_offset</span></code></a> 开始的 <a class="reference internal" href="#ctypes.CField.byte_size" title="ctypes.CField.byte_size"><code class="xref py py-attr docutils literal notranslate"><span class="pre">byte_size</span></code></a> 字节内存范围内。</p>
<p class="translated">要获取位域的值，请先将存储单元作为整数读取，然后按 <code class="xref py py-attr docutils literal notranslate"><span class="pre">bit_offset</span></code> 进行 <a class="reference internal" href="../reference/expressions.html#shifting"><span class="std std-ref">左移</span></a> 操作，并取结果的最低 <code class="xref py py-attr docutils literal notranslate"><span class="pre">bit_size</span></code> 位。</p>
<p class="translated">对于非位域，<code class="xref py py-attr docutils literal notranslate"><span class="pre">bit_offset</span></code> 为零，且 <code class="xref py py-attr docutils literal notranslate"><span class="pre">bit_size</span></code> 等于 <code class="docutils literal notranslate"><span class="pre">byte_size</span> <span class="pre">*</span> <span class="pre">8</span></code>。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.CField.is_anonymous">
<span class="sig-name descname"><span class="pre">is_anonymous</span></span><a class="headerlink" href="#ctypes.CField.is_anonymous" title="Link to this definition">¶</a></dt>
<dd><p class="translated">如果此字段是匿名的（即它包含应合并到所属结构体或联合中的嵌套子字段），则为 True。</p>
</dd></dl>

</dd></dl>

</section>
<section id="arrays-and-pointers">
<span id="ctypes-arrays-pointers"></span><h3 class="translated">数组与指针<a class="headerlink" href="#arrays-and-pointers" title="Link to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="ctypes.Array">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">Array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.Array" title="Link to this definition">¶</a></dt>
<dd><p class="translated">数组的抽象基类。</p>
<p class="translated">创建实体数组类型的推荐方式是通过将任意 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 数据类型与一个非负整数相乘。 作为替代方式，你也可以子类化这个类型并定义 <a class="reference internal" href="#ctypes.Array._length_" title="ctypes.Array._length_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_length_</span></code></a> 和 <a class="reference internal" href="#ctypes.Array._type_" title="ctypes.Array._type_"><code class="xref py py-attr docutils literal notranslate"><span class="pre">_type_</span></code></a> 类变量。 数组元素可使用标准的抽取和切片操作来进行读写；对于切片读取，结果对象本身 <em>不是</em> 一个 <a class="reference internal" href="#ctypes.Array" title="ctypes.Array"><code class="xref py py-class docutils literal notranslate"><span class="pre">Array</span></code></a>。</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.Array._length_">
<span class="sig-name descname"><span class="pre">_length_</span></span><a class="headerlink" href="#ctypes.Array._length_" title="Link to this definition">¶</a></dt>
<dd><p class="translated">一个指明数组中元素数量的正整数。 超出范围的抽取会导致 <a class="reference internal" href="exceptions.html#IndexError" title="IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a>。 该值将由 <a class="reference internal" href="functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> 返回。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.Array._type_">
<span class="sig-name descname"><span class="pre">_type_</span></span><a class="headerlink" href="#ctypes.Array._type_" title="Link to this definition">¶</a></dt>
<dd><p class="translated">指明数组中每个元素的类型。</p>
</dd></dl>

<p class="translated">Array 子类构造器可接受位置参数，用来按顺序初始化元素。</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ctypes.ARRAY">
<span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">ARRAY</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.ARRAY" title="Link to this definition">¶</a></dt>
<dd><p class="translated">创建一个数组。 等价于 <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">*</span> <span class="pre">length</span></code>，其中 <em>type</em> 是一个 <a class="reference internal" href="#module-ctypes" title="ctypes: A foreign function library for Python."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code></a> 数据类型而 <em>length</em> 是一个整数。</p>
<p class="translated">该函数已被 <a class="reference internal" href="../glossary.html#term-soft-deprecated"><span class="xref std std-term">soft deprecated</span></a> 而应改用乘法。 尚无移除它的计划。</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ctypes._Pointer">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">_Pointer</span></span><a class="headerlink" href="#ctypes._Pointer" title="Link to this definition">¶</a></dt>
<dd><p class="translated">私有对象，指针的抽象基类。</p>
<p class="translated">实际的指针类型是通过调用 <a class="reference internal" href="#ctypes.POINTER" title="ctypes.POINTER"><code class="xref py py-func docutils literal notranslate"><span class="pre">POINTER()</span></code></a> 并附带其将指向的类型来创建的；这会由 <a class="reference internal" href="#ctypes.pointer" title="ctypes.pointer"><code class="xref py py-func docutils literal notranslate"><span class="pre">pointer()</span></code></a> 自动完成。</p>
<p class="translated">如果一个指针指向的是数组，则其元素可使用标准的抽取和切片方式来读写。 指针对象没有长度，因此 <a class="reference internal" href="functions.html#len" title="len"><code class="xref py py-func docutils literal notranslate"><span class="pre">len()</span></code></a> 将引发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。 抽取负值将会从指针 <em>之前</em> 的内存中读取（与 C 一样），并且超出范围的抽取将可能因非法访问而导致崩溃（视你的运气而定）。</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes._Pointer._type_">
<span class="sig-name descname"><span class="pre">_type_</span></span><a class="headerlink" href="#ctypes._Pointer._type_" title="Link to this definition">¶</a></dt>
<dd><p class="translated">指明所指向的类型。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes._Pointer.contents">
<span class="sig-name descname"><span class="pre">contents</span></span><a class="headerlink" href="#ctypes._Pointer.contents" title="Link to this definition">¶</a></dt>
<dd><p class="translated">返回指针所指向的对象。 对此属性赋值会使指针改为指向所赋值的对象。</p>
</dd></dl>

</dd></dl>

</section>
<section id="exceptions">
<span id="ctypes-exceptions"></span><h3 class="translated">异常<a class="headerlink" href="#exceptions" title="Link to this heading">¶</a></h3>
<dl class="py exception">
<dt class="sig sig-object py" id="ctypes.ArgumentError">
<em class="property"><span class="k"><span class="pre">exception</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">ArgumentError</span></span><a class="headerlink" href="#ctypes.ArgumentError" title="Link to this definition">¶</a></dt>
<dd><p class="translated">此异常会在外部函数无法对某个传入参数执行转换时被引发。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="ctypes.COMError">
<em class="property"><span class="k"><span class="pre">exception</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ctypes.</span></span><span class="sig-name descname"><span class="pre">COMError</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hresult</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">text</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">details</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ctypes.COMError" title="Link to this definition">¶</a></dt>
<dd><p class="translated">当 COM 方法调用失败时，会引发此异常。</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.COMError.hresult">
<span class="sig-name descname"><span class="pre">hresult</span></span><a class="headerlink" href="#ctypes.COMError.hresult" title="Link to this definition">¶</a></dt>
<dd><p class="translated">表示错误代码的整数值。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.COMError.text">
<span class="sig-name descname"><span class="pre">text</span></span><a class="headerlink" href="#ctypes.COMError.text" title="Link to this definition">¶</a></dt>
<dd><p class="translated">错误消息。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ctypes.COMError.details">
<span class="sig-name descname"><span class="pre">details</span></span><a class="headerlink" href="#ctypes.COMError.details" title="Link to this definition">¶</a></dt>
<dd><p class="translated">5元组``(descr, source, helpfile, helpcontext, progid)``。</p>
<p class="translated"><em>descr</em> 是文本描述。<em>source</em> 是引发错误的类或应用程序所对应的依赖于语言的 <code class="docutils literal notranslate"><span class="pre">ProgID</span></code>。<em>helpfile</em> 是帮助文件的路径。<em>helpcontext</em> 是帮助上下文标识符。<em>progid</em> 是定义该错误的接口的 <code class="docutils literal notranslate"><span class="pre">ProgID</span></code>。</p>
</dd></dl>

<div class="availability docutils container">
<p class="translated"><a class="reference internal" href="intro.html#availability"><span class="std std-ref">Availability</span></a>: Windows</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code> --- Python 的外部函数库</a><ul>
<li><a class="reference internal" href="#ctypes-tutorial">ctypes 教程</a><ul>
<li><a class="reference internal" href="#loading-dynamic-link-libraries">载入动态连接库</a></li>
<li><a class="reference internal" href="#accessing-functions-from-loaded-dlls">操作导入的动态链接库中的函数</a></li>
<li><a class="reference internal" href="#calling-functions">调用函数</a></li>
<li><a class="reference internal" href="#fundamental-data-types">基础数据类型</a></li>
<li><a class="reference internal" href="#calling-functions-continued">调用函数，继续</a></li>
<li><a class="reference internal" href="#calling-variadic-functions">调用可变函数</a></li>
<li><a class="reference internal" href="#calling-functions-with-your-own-custom-data-types">使用自定义的数据类型调用函数</a></li>
<li><a class="reference internal" href="#specifying-the-required-argument-types-function-prototypes">指定必选参数的类型(函数原型)</a></li>
<li><a class="reference internal" href="#return-types">返回类型</a></li>
<li><a class="reference internal" href="#passing-pointers-or-passing-parameters-by-reference">传递指针（或以引用方式传递形参）</a></li>
<li><a class="reference internal" href="#structures-and-unions">结构体和联合</a></li>
<li><a class="reference internal" href="#structure-union-layout-alignment-and-byte-order">结构/联合布局、对齐和字节顺序</a></li>
<li><a class="reference internal" href="#bit-fields-in-structures-and-unions">结构体和联合中的位域</a></li>
<li><a class="reference internal" href="#arrays">数组</a></li>
<li><a class="reference internal" href="#pointers">指针</a></li>
<li><a class="reference internal" href="#thread-safety-without-the-gil">没有 GIL 时的线程安全性</a></li>
<li><a class="reference internal" href="#type-conversions">类型转换</a></li>
<li><a class="reference internal" href="#incomplete-types">不完整类型</a></li>
<li><a class="reference internal" href="#callback-functions">回调函数</a></li>
<li><a class="reference internal" href="#accessing-values-exported-from-dlls">访问 dll 的导出变量</a></li>
<li><a class="reference internal" href="#surprises">意外</a></li>
<li><a class="reference internal" href="#variable-sized-data-types">变长数据类型</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ctypes-reference">ctypes 参考手册</a><ul>
<li><a class="reference internal" href="#finding-shared-libraries">寻找动态链接库</a></li>
<li><a class="reference internal" href="#listing-loaded-shared-libraries">列出已加载的共享库</a></li>
<li><a class="reference internal" href="#loading-shared-libraries">加载共享库</a></li>
<li><a class="reference internal" href="#foreign-functions">外部函数</a></li>
<li><a class="reference internal" href="#function-prototypes">函数原型</a></li>
<li><a class="reference internal" href="#utility-functions">工具函数</a></li>
<li><a class="reference internal" href="#data-types">数据类型</a></li>
<li><a class="reference internal" href="#ctypes-fundamental-data-types-2">基础数据类型</a></li>
<li><a class="reference internal" href="#structured-data-types">结构化数据类型</a></li>
<li><a class="reference internal" href="#arrays-and-pointers">数组与指针</a></li>
<li><a class="reference internal" href="#exceptions">异常</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一主题</h4>
    <p class="topless"><a href="errno.html"
                          title="上一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">errno</span></code> --- 标准 errno 系统符号</a></p>
  </div>
  <div>
    <h4>下一主题</h4>
    <p class="topless"><a href="cmdlinelibs.html"
                          title="下一章">命令行界面库</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">报告代码错误</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/ctypes.rst?plain=1"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="折叠边栏">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="cmdlinelibs.html" title="命令行界面库"
             >下一页</a> |</li>
        <li class="right" >
          <a href="errno.html" title="errno --- 标准 errno 系统符号"
             >上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.14.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="allos.html" >通用操作系统服务</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">ctypes</span></code> --- Python 的外部函数库</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q" id="search-box">
          <input type="submit" value="转到">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    主题
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>自动</option>
        <option value="light">明亮</option>
        <option value="dark">黑暗</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版权</a> 2001 Python Software Foundation.
    <br>
    本页面采用 Python 软件基金会许可证第 2 版授权。
    <br>
    文档中的示例、代码片段及其他代码内容额外采用零条款 BSD 许可证授权。
    <br>
    
      更多信息请参阅《<a href="/license.html"> 历史与许可 </a>》。<br>
    
    
    <br>

    Python 软件基金会是一家非营利性公司。
<a href="https://www.python.org/psf/donations/">请进行捐赠。</a>
<br>
    <br>
      最后更新于11月 25, 2025 (07:24 UTC) 。
    
      <a href="/bugs.html">发现了错误</a>？
    
    <br>

    使用<a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3 创建。
    </div>

  </body>
</html>
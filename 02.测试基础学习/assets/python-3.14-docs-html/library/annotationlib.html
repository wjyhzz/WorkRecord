<!DOCTYPE html>

<html lang="zh-CN" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="annotationlib --- 用于内省标记的功能" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://docs.python.org/3/library/annotationlib.html" />
<meta property="og:site_name" content="Python documentation" />
<meta property="og:description" content="源代码: Lib/annotationlib.py annotationlib 模块提供了用于在模块、类和函数上内省 标记 的工具。 类型注解是 延迟求值 的，并且通常包含对在注解创建时尚未定义的对象的前向引用。这个模块提供了一组底层工具，即使在存在前向引用和其他极端情况时，也能以可靠的方式获取注解。 该模块支持以三种主要格式（见 Format ）检索注解，每种格式适用于不同的使用场景： V..." />
<meta property="og:image:width" content="1146" />
<meta property="og:image:height" content="600" />
<meta property="og:image" content="https://docs.python.org/3.14/zh-cn/_images/social_previews/summary_library_annotationlib_73b418f1.png" />
<meta property="og:image:alt" content="源代码: Lib/annotationlib.py annotationlib 模块提供了用于在模块、类和函数上内省 标记 的工具。 类型注解是 延迟求值 的，并且通常包含对在注解创建时尚未定义的对象的前向引用。这个模块提供了一组底层工具，即使在存在前向引用和其他极端情况时，也能以可靠的方式获取注解。 该模块支持以三种主要格式（见 Format ）检索注解，每种格式适用于不同的使用场景： V..." />
<meta name="description" content="源代码: Lib/annotationlib.py annotationlib 模块提供了用于在模块、类和函数上内省 标记 的工具。 类型注解是 延迟求值 的，并且通常包含对在注解创建时尚未定义的对象的前向引用。这个模块提供了一组底层工具，即使在存在前向引用和其他极端情况时，也能以可靠的方式获取注解。 该模块支持以三种主要格式（见 Format ）检索注解，每种格式适用于不同的使用场景： V..." />
<meta name="twitter:card" content="summary_large_image" />
<meta name="theme-color" content="#3776ab">

    <title>annotationlib --- 用于内省标记的功能 &#8212; Python 3.14.0 文档</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=234b1a7c" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=8cd84f99" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=5349f25f" />
    
    <script src="../_static/documentation_options.js?v=a595ec0e"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=beaddf03"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.14.0 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于此文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权" href="../copyright.html" />
    <link rel="next" title="site --- 站点专属的配置钩子" href="site.html" />
    <link rel="prev" title="inspect --- 检查当前对象" href="inspect.html" />
    
      
      <script defer file-types="bz2,epub,zip" data-domain="docs.python.org" src="https://analytics.python.org/js/script.file-downloads.outbound-links.js"></script>
      
      <link rel="canonical" href="https://docs.python.org/3/library/annotationlib.html">
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg">
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="菜单">
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo">
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q">
                <input type="submit" value="转到">
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    主题
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>自动</option>
        <option value="light">明亮</option>
        <option value="dark">黑暗</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">annotationlib</span></code> --- 用于内省标记的功能</a><ul>
<li><a class="reference internal" href="#annotation-semantics">注解语义（Annotation semantics）</a></li>
<li><a class="reference internal" href="#classes">类</a></li>
<li><a class="reference internal" href="#functions">函数</a></li>
<li><a class="reference internal" href="#recipes">例程</a><ul>
<li><a class="reference internal" href="#using-annotations-in-a-metaclass">在元类中使用注解</a></li>
</ul>
</li>
<li><a class="reference internal" href="#limitations-of-the-string-format"><code class="docutils literal notranslate"><span class="pre">STRING</span></code> 格式的局限性</a></li>
<li><a class="reference internal" href="#limitations-of-the-forwardref-format"><code class="docutils literal notranslate"><span class="pre">FORWARDREF</span></code> 格式的局限性</a></li>
<li><a class="reference internal" href="#security-implications-of-introspecting-annotations">内省标注的安全意义</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一主题</h4>
    <p class="topless"><a href="inspect.html"
                          title="上一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect</span></code> --- 检查当前对象</a></p>
  </div>
  <div>
    <h4>下一主题</h4>
    <p class="topless"><a href="site.html"
                          title="下一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code> --- 站点专属的配置钩子</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">报告代码错误</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/annotationlib.rst?plain=1"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="site.html" title="site --- 站点专属的配置钩子"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="inspect.html" title="inspect --- 检查当前对象"
             accesskey="P">上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.14.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="python.html" accesskey="U">Python 运行时服务</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">annotationlib</span></code> --- 用于内省标记的功能</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q" id="search-box">
          <input type="submit" value="转到">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    主题
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>自动</option>
        <option value="light">明亮</option>
        <option value="dark">黑暗</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-annotationlib">
<span id="annotationlib-functionality-for-introspecting-annotations"></span><h1 class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">annotationlib</span></code> --- 用于内省标记的功能<a class="headerlink" href="#module-annotationlib" title="Link to this heading">¶</a></h1>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
<p class="translated"><strong>源代码:</strong> <a class="extlink-source reference external" href="https://github.com/python/cpython/tree/3.14/Lib/annotationlib.py">Lib/annotationlib.py</a></p>
<hr class="docutils" />
<p class="translated"><code class="xref py py-mod docutils literal notranslate"><span class="pre">annotationlib</span></code> 模块提供了用于在模块、类和函数上内省 <a class="reference internal" href="../glossary.html#term-annotation"><span class="xref std std-term">标记</span></a> 的工具。</p>
<p class="translated">类型注解是 <a class="reference internal" href="../reference/executionmodel.html#lazy-evaluation"><span class="std std-ref">延迟求值</span></a> 的，并且通常包含对在注解创建时尚未定义的对象的前向引用。这个模块提供了一组底层工具，即使在存在前向引用和其他极端情况时，也能以可靠的方式获取注解。</p>
<p class="translated">该模块支持以三种主要格式（见 <a class="reference internal" href="#annotationlib.Format" title="annotationlib.Format"><code class="xref py py-class docutils literal notranslate"><span class="pre">Format</span></code></a>）检索注解，每种格式适用于不同的使用场景：</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="#annotationlib.Format.VALUE" title="annotationlib.Format.VALUE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">VALUE</span></code></a> 会对注解进行求值并返回其值。这种格式使用起来最直接，但可能会引发错误，例如当注解中包含对未定义名称的引用时。</p></li>
<li><p class="translated"><a class="reference internal" href="#annotationlib.Format.FORWARDREF" title="annotationlib.Format.FORWARDREF"><code class="xref py py-attr docutils literal notranslate"><span class="pre">FORWARDREF</span></code></a> 会为无法解析的注解返回 <a class="reference internal" href="#annotationlib.ForwardRef" title="annotationlib.ForwardRef"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForwardRef</span></code></a> 对象，允许你在不求值注解的情况下检查它们。当你需要处理可能包含未解析前向引用的注解时，这种格式非常有用。</p></li>
<li><p class="translated"><a class="reference internal" href="#annotationlib.Format.STRING" title="annotationlib.Format.STRING"><code class="xref py py-attr docutils literal notranslate"><span class="pre">STRING</span></code></a> 会将注解以字符串形式返回，类似于其在源代码文件中的呈现方式。这对于希望以可读方式展示注解的文档生成器非常有用。</p></li>
</ul>
<p class="translated"><a class="reference internal" href="#annotationlib.get_annotations" title="annotationlib.get_annotations"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_annotations()</span></code></a> 函数是检索注解的主要入口点。给定一个函数、类或模块，它会以请求的格式返回注解字典。此模块还提供了直接处理用于求值注解的 <a class="reference internal" href="../glossary.html#term-annotate-function"><span class="xref std std-term">annotate function</span></a> ，例如 <a class="reference internal" href="#annotationlib.get_annotate_from_class_namespace" title="annotationlib.get_annotate_from_class_namespace"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_annotate_from_class_namespace()</span></code></a> 和 <a class="reference internal" href="#annotationlib.call_annotate_function" title="annotationlib.call_annotate_function"><code class="xref py py-func docutils literal notranslate"><span class="pre">call_annotate_function()</span></code></a>，以及用于处理 <a class="reference internal" href="../glossary.html#term-evaluate-function"><span class="xref std std-term">求值函数</span></a> 的 <a class="reference internal" href="#annotationlib.call_evaluate_function" title="annotationlib.call_evaluate_function"><code class="xref py py-func docutils literal notranslate"><span class="pre">call_evaluate_function()</span></code></a> 函数。</p>
<div class="admonition caution">
<p class="admonition-title">小心</p>
<p class="translated">此模块中的大多数功能都可执行任意代码；请参阅 <a class="reference internal" href="#annotationlib-security"><span class="std std-ref">安全章节</span></a> 了解详情。</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p class="translated"><span class="target" id="index-26"></span><a class="pep reference external" href="https://peps.python.org/pep-0649/"><strong>PEP 649</strong></a> 提出了 Python 中注解工作方式的当前模型。</p>
<p class="translated"><span class="target" id="index-27"></span><a class="pep reference external" href="https://peps.python.org/pep-0749/"><strong>PEP 749</strong></a> 在 <span class="target" id="index-28"></span><a class="pep reference external" href="https://peps.python.org/pep-0649/"><strong>PEP 649</strong></a> 的基础上进行了多方面扩展，并引入了 <code class="xref py py-mod docutils literal notranslate"><span class="pre">annotationlib</span></code> 模块。</p>
<p class="translated"><a class="reference internal" href="../howto/annotations.html#annotations-howto"><span class="std std-ref">注解最佳实践</span></a> 提供了使用注解的最佳实践指南。</p>
<p class="translated"><a class="extlink-pypi reference external" href="https://pypi.org/project/typing-extensions/">typing-extensions</a> 提供了 <a class="reference internal" href="#annotationlib.get_annotations" title="annotationlib.get_annotations"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_annotations()</span></code></a> 的向后移植版本，可在早期 Python 版本上使用。</p>
</div>
<section id="annotation-semantics">
<h2 class="translated">注解语义（Annotation semantics）<a class="headerlink" href="#annotation-semantics" title="Link to this heading">¶</a></h2>
<p class="translated">在 Python 3 的发展历程中，注解的求值方式发生了多次变化，目前仍依赖于 <a class="reference internal" href="../reference/simple_stmts.html#future"><span class="std std-ref">future import</span></a>。注解的执行模型主要有以下几种：</p>
<ul class="simple">
<li><p class="translated"><em>标准语义</em> (Python 3.0 至 3.13 的默认行为；参见 <span class="target" id="index-29"></span><a class="pep reference external" href="https://peps.python.org/pep-3107/"><strong>PEP 3107</strong></a> 和 <span class="target" id="index-30"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a>)：注解会在源代码中被遇到时立即求值。</p></li>
<li><p class="translated"><em>字符串化注解</em> (在 Python 3.7 及更高版本中使用 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">annotations</span></code> 启用；参见 <span class="target" id="index-31"></span><a class="pep reference external" href="https://peps.python.org/pep-0563/"><strong>PEP 563</strong></a>)：注解仅以字符串形式存储。</p></li>
<li><p class="translated"><em>延迟求值</em> (Python 3.14 及更高版本的默认行为；参见 <span class="target" id="index-32"></span><a class="pep reference external" href="https://peps.python.org/pep-0649/"><strong>PEP 649</strong></a> 和 <span class="target" id="index-33"></span><a class="pep reference external" href="https://peps.python.org/pep-0749/"><strong>PEP 749</strong></a>)：注解会延迟求值，仅在被访问时才会进行。</p></li>
</ul>
<p class="translated">举个例子，考虑以下程序:</p>
<div class="translated highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Cls</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Cls</span><span class="p">:</span> <span class="k">pass</span>

<span class="nb">print</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="vm">__annotations__</span><span class="p">)</span>
</pre></div>
</div>
<p class="translated">其行为如下：</p>
<ul class="simple">
<li><p class="translated">在标准语义（Python 3.13 及更早版本）下，程序会在定义 <code class="docutils literal notranslate"><span class="pre">func</span></code> 的行抛出 <a class="reference internal" href="exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a>，因为此时 <code class="docutils literal notranslate"><span class="pre">Cls</span></code> 是一个未定义的名称。</p></li>
<li><p class="translated">在字符串化注解（使用 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">annotations</span></code>）下，程序会打印 <code class="docutils literal notranslate"><span class="pre">{'a':</span> <span class="pre">'Cls',</span> <span class="pre">'return':</span> <span class="pre">'None'}</span></code>。</p></li>
<li><p class="translated">在延迟求值（Python 3.14 及更高版本）下，程序会打印 <code class="docutils literal notranslate"><span class="pre">{'a':</span> <span class="pre">&lt;class</span> <span class="pre">'Cls'&gt;,</span> <span class="pre">'return':</span> <span class="pre">None}</span></code>。</p></li>
</ul>
<p class="translated">当 Python 3.0 通过 <span class="target" id="index-34"></span><a class="pep reference external" href="https://peps.python.org/pep-3107/"><strong>PEP 3107</strong></a> 首次引入函数注解时，采用标准语义是因为这是实现注解最简单、最直观的方式。Python 3.6 通过 <span class="target" id="index-35"></span><a class="pep reference external" href="https://peps.python.org/pep-0526/"><strong>PEP 526</strong></a> 引入变量注解时，也使用了相同的执行模型。然而，标准语义在将注解用作类型提示时会引发问题，例如在遇到注解时需要引用尚未定义的名称。此外，在模块导入时执行注解还存在性能问题。因此，Python 3.7 通过 <span class="target" id="index-36"></span><a class="pep reference external" href="https://peps.python.org/pep-0563/"><strong>PEP 563</strong></a> 引入了使用 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">annotations</span></code> 语法将注解存储为字符串的功能。当时的计划是最终将这种行为设为默认，但出现了一个问题：对于在运行时内省注解的人来说，字符串化注解更难处理。另一个提案 <span class="target" id="index-37"></span><a class="pep reference external" href="https://peps.python.org/pep-0649/"><strong>PEP 649</strong></a> 引入了第三种执行模型——延迟求值，并在 Python 3.14 中实现。如果存在 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">annotations</span></code>，仍然会使用字符串化注解，但这种行为最终会被移除。</p>
</section>
<section id="classes">
<h2 class="translated">类<a class="headerlink" href="#classes" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="annotationlib.Format">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">annotationlib.</span></span><span class="sig-name descname"><span class="pre">Format</span></span><a class="headerlink" href="#annotationlib.Format" title="Link to this definition">¶</a></dt>
<dd><p class="translated">一个 <a class="reference internal" href="enum.html#enum.IntEnum" title="enum.IntEnum"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntEnum</span></code></a> 枚举类，用于描述注解可以返回的格式。该枚举的成员或其等效整数值可传递给 <a class="reference internal" href="#annotationlib.get_annotations" title="annotationlib.get_annotations"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_annotations()</span></code></a> 以及本模块中的其他函数，也可传递给 <a class="reference internal" href="../reference/datamodel.html#object.__annotate__" title="object.__annotate__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotate__</span></code></a> 函数。</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="annotationlib.Format.VALUE">
<span class="sig-name descname"><span class="pre">VALUE</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1</span></em><a class="headerlink" href="#annotationlib.Format.VALUE" title="Link to this definition">¶</a></dt>
<dd><p class="translated">值是对注解表达式求值的结果。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="annotationlib.Format.VALUE_WITH_FAKE_GLOBALS">
<span class="sig-name descname"><span class="pre">VALUE_WITH_FAKE_GLOBALS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">2</span></em><a class="headerlink" href="#annotationlib.Format.VALUE_WITH_FAKE_GLOBALS" title="Link to this definition">¶</a></dt>
<dd><p class="translated">特殊值，用于表示注解函数正在具有伪全局变量的特殊环境中求值。当传递此值时，注解函数应返回与 <a class="reference internal" href="#annotationlib.Format.VALUE" title="annotationlib.Format.VALUE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Format.VALUE</span></code></a> 格式相同的值，或者抛出 <a class="reference internal" href="exceptions.html#NotImplementedError" title="NotImplementedError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NotImplementedError</span></code></a> 以表示它们不支持在此环境中执行。此格式仅在内部使用，不应传递给本模块中的函数。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="annotationlib.Format.FORWARDREF">
<span class="sig-name descname"><span class="pre">FORWARDREF</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">3</span></em><a class="headerlink" href="#annotationlib.Format.FORWARDREF" title="Link to this definition">¶</a></dt>
<dd><p class="translated">对于已定义的值，使用真实的注解值（按照 <a class="reference internal" href="#annotationlib.Format.VALUE" title="annotationlib.Format.VALUE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Format.VALUE</span></code></a> 格式）；对于未定义的值，使用 <a class="reference internal" href="#annotationlib.ForwardRef" title="annotationlib.ForwardRef"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForwardRef</span></code></a> 代理。真实对象可能包含对 <a class="reference internal" href="#annotationlib.ForwardRef" title="annotationlib.ForwardRef"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForwardRef</span></code></a> 代理对象的引用。</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="annotationlib.Format.STRING">
<span class="sig-name descname"><span class="pre">STRING</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">4</span></em><a class="headerlink" href="#annotationlib.Format.STRING" title="Link to this definition">¶</a></dt>
<dd><p class="translated">值是注解在源代码中显示的文本字符串，可能经过包括但不限于空白符规范化和常数值优化的修改。</p>
<p class="translated">这些字符串的确切值可能在未来的Python版本中发生变化。</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="annotationlib.ForwardRef">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">annotationlib.</span></span><span class="sig-name descname"><span class="pre">ForwardRef</span></span><a class="headerlink" href="#annotationlib.ForwardRef" title="Link to this definition">¶</a></dt>
<dd><p class="translated">用于注解中前向引用的代理对象。</p>
<p class="translated">当使用 <a class="reference internal" href="#annotationlib.Format.FORWARDREF" title="annotationlib.Format.FORWARDREF"><code class="xref py py-attr docutils literal notranslate"><span class="pre">FORWARDREF</span></code></a> 格式且注解包含无法解析的名称时，将返回此类的实例。这种情况通常发生在注解中使用前向引用时，例如在类定义之前引用该类。</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="annotationlib.ForwardRef.__forward_arg__">
<span class="sig-name descname"><span class="pre">__forward_arg__</span></span><a class="headerlink" href="#annotationlib.ForwardRef.__forward_arg__" title="Link to this definition">¶</a></dt>
<dd><p class="translated">一个包含生成 <a class="reference internal" href="#annotationlib.ForwardRef" title="annotationlib.ForwardRef"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForwardRef</span></code></a> 所执行代码的字符串。该字符串可能与原始源代码不完全等同。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="annotationlib.ForwardRef.evaluate">
<span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">owner</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">globals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">locals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Format.VALUE</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#annotationlib.ForwardRef.evaluate" title="Link to this definition">¶</a></dt>
<dd><p class="translated">对前向引用进行求值，返回其值。</p>
<p class="translated">如果 <em>format</em> 参数为 <a class="reference internal" href="#annotationlib.Format.VALUE" title="annotationlib.Format.VALUE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">VALUE</span></code></a> (默认值)，当此方法遇到无法解析的前向引用名称时，可能会抛出 <a class="reference internal" href="exceptions.html#NameError" title="NameError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NameError</span></code></a> 等异常。该方法的参数可用于为那些原本未定义的名称提供绑定。如果 <em>format</em> 参数为 <a class="reference internal" href="#annotationlib.Format.FORWARDREF" title="annotationlib.Format.FORWARDREF"><code class="xref py py-attr docutils literal notranslate"><span class="pre">FORWARDREF</span></code></a>，此方法绝不会抛出异常，但可能会返回一个 <a class="reference internal" href="#annotationlib.ForwardRef" title="annotationlib.ForwardRef"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForwardRef</span></code></a> 实例。 例如，当前向引用对象包含代码 <code class="docutils literal notranslate"><span class="pre">list[undefined]</span></code>，其中 <code class="docutils literal notranslate"><span class="pre">undefined</span></code> 是一个未定义的名称，使用 <a class="reference internal" href="#annotationlib.Format.FORWARDREF" title="annotationlib.Format.FORWARDREF"><code class="xref py py-attr docutils literal notranslate"><span class="pre">FORWARDREF</span></code></a> 格式对其求值将返回 <code class="docutils literal notranslate"><span class="pre">list[ForwardRef('undefined')]</span></code>。 如果 <em>format</em> 参数为 <a class="reference internal" href="#annotationlib.Format.STRING" title="annotationlib.Format.STRING"><code class="xref py py-attr docutils literal notranslate"><span class="pre">STRING</span></code></a>，此方法将返回 <a class="reference internal" href="#annotationlib.ForwardRef.__forward_arg__" title="annotationlib.ForwardRef.__forward_arg__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__forward_arg__</span></code></a>。</p>
<p class="translated"><em>owner</em> 形参提供了向此方法传递作用域信息的首选机制。<a class="reference internal" href="#annotationlib.ForwardRef" title="annotationlib.ForwardRef"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForwardRef</span></code></a> 的所有者是包含该 <a class="reference internal" href="#annotationlib.ForwardRef" title="annotationlib.ForwardRef"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForwardRef</span></code></a> 所源自的注解的对象，例如模块对象、类型对象或函数对象。</p>
<p class="translated"><em>globals</em>、<em>locals</em> 和 <em>type_params</em> 形参提供了一种更精确的机制，用于影响在求值 <a class="reference internal" href="#annotationlib.ForwardRef" title="annotationlib.ForwardRef"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForwardRef</span></code></a> 时可用的名称。<em>globals</em> 和 <em>locals</em> 会传递给 <a class="reference internal" href="functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a>，表示求值该名称时的全局和局部命名空间。<em>type_params</em> 参数与使用原生语法创建的 <a class="reference internal" href="../reference/compound_stmts.html#generic-classes"><span class="std std-ref">泛型类</span></a> 和 <a class="reference internal" href="../reference/compound_stmts.html#generic-functions"><span class="std std-ref">函数</span></a> 对象相关。它是一个 <a class="reference internal" href="../reference/compound_stmts.html#type-params"><span class="std std-ref">类型形参</span></a> 元组，表示在求值前向引用时的作用域内的类型参数。例如，如果要对从泛型类 <code class="docutils literal notranslate"><span class="pre">C</span></code> 的类命名空间中的注解获取的 <a class="reference internal" href="#annotationlib.ForwardRef" title="annotationlib.ForwardRef"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForwardRef</span></code></a> 进行求值，<em>type_params</em> 应设置为 <code class="docutils literal notranslate"><span class="pre">C.__type_params__</span></code>。</p>
<p class="translated">由 <a class="reference internal" href="#annotationlib.get_annotations" title="annotationlib.get_annotations"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_annotations()</span></code></a> 返回的 <a class="reference internal" href="#annotationlib.ForwardRef" title="annotationlib.ForwardRef"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForwardRef</span></code></a> 实例会保留其来源作用域的信息，因此调用此方法时无需传递额外参数即可对这些对象进行求值。而通过其他方式创建的 <a class="reference internal" href="#annotationlib.ForwardRef" title="annotationlib.ForwardRef"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForwardRef</span></code></a> 实例可能不包含任何作用域信息，因此可能需要向此方法传递参数才能成功对其进行求值。</p>
<p class="translated">如果未提供 <em>owner</em>、<em>globals</em>、<em>locals</em> 或 <em>type_params</em> 参数，并且 <a class="reference internal" href="#annotationlib.ForwardRef" title="annotationlib.ForwardRef"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForwardRef</span></code></a> 不包含其来源信息，则会使用空的全局和局部字典。</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

</section>
<section id="functions">
<h2 class="translated">函数<a class="headerlink" href="#functions" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="annotationlib.annotations_to_string">
<span class="sig-prename descclassname"><span class="pre">annotationlib.</span></span><span class="sig-name descname"><span class="pre">annotations_to_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">annotations</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#annotationlib.annotations_to_string" title="Link to this definition">¶</a></dt>
<dd><p class="translated">将包含运行时值的注解字典转换为仅包含字符串的字典。如果值已经是字符串，则保持不变；否则，使用 <a class="reference internal" href="#annotationlib.type_repr" title="annotationlib.type_repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">type_repr()</span></code></a> 进行转换。这是为用户提供的注解函数提供的辅助工具，这些函数支持 <a class="reference internal" href="#annotationlib.Format.STRING" title="annotationlib.Format.STRING"><code class="xref py py-attr docutils literal notranslate"><span class="pre">STRING</span></code></a> 格式，但无法访问创建注解的代码。</p>
<p class="translated">例如，这用于为通过函数式语法创建的 <a class="reference internal" href="typing.html#typing.TypedDict" title="typing.TypedDict"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.TypedDict</span></code></a> 类实现 <a class="reference internal" href="#annotationlib.Format.STRING" title="annotationlib.Format.STRING"><code class="xref py py-attr docutils literal notranslate"><span class="pre">STRING</span></code></a> 格式：</p>
<div class="translated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypedDict</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Movie</span> <span class="o">=</span> <span class="n">TypedDict</span><span class="p">(</span><span class="s2">&quot;movie&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="s2">&quot;year&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_annotations</span><span class="p">(</span><span class="n">Movie</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">Format</span><span class="o">.</span><span class="n">STRING</span><span class="p">)</span>
<span class="go">{&#39;name&#39;: &#39;str&#39;, &#39;year&#39;: &#39;int&#39;}</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="annotationlib.call_annotate_function">
<span class="sig-prename descclassname"><span class="pre">annotationlib.</span></span><span class="sig-name descname"><span class="pre">call_annotate_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">annotate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">owner</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#annotationlib.call_annotate_function" title="Link to this definition">¶</a></dt>
<dd><p class="translated">使用给定的 <em>format</em> (<a class="reference internal" href="#annotationlib.Format" title="annotationlib.Format"><code class="xref py py-class docutils literal notranslate"><span class="pre">Format</span></code></a> 枚举的成员) 调用 <a class="reference internal" href="../glossary.html#term-annotate-function"><span class="xref std std-term">annotate function</span></a> <em>annotate</em>，并返回该函数生成的注解字典。</p>
<p class="translated">之所以需要这个辅助函数，是因为编译器为函数、类和模块生成的注解函数在直接调用时仅支持 <a class="reference internal" href="#annotationlib.Format.VALUE" title="annotationlib.Format.VALUE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">VALUE</span></code></a> 格式。为了支持其他格式，此函数会在一个特殊环境中调用注解函数，使其能够生成其他格式的注解。在实现需要在类构建过程中部分求值注解的功能时，这是一个有用的构建块。</p>
<p class="translated"><em>owner</em> 是拥有注解函数的对象，通常是函数、类或模块。如果提供了该参数，它会在 <a class="reference internal" href="#annotationlib.Format.FORWARDREF" title="annotationlib.Format.FORWARDREF"><code class="xref py py-attr docutils literal notranslate"><span class="pre">FORWARDREF</span></code></a> 格式中用于生成一个携带更多信息的 <a class="reference internal" href="#annotationlib.ForwardRef" title="annotationlib.ForwardRef"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForwardRef</span></code></a> 对象。</p>
<div class="admonition seealso">
<p class="admonition-title">参见</p>
<p class="translated"><span class="target" id="index-38"></span><a class="pep reference external" href="https://peps.python.org/pep-0649/#the-stringizer-and-the-fake-globals-environment"><strong>PEP 649</strong></a> 中包含了对此函数所使用的实现技术的解释。</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="annotationlib.call_evaluate_function">
<span class="sig-prename descclassname"><span class="pre">annotationlib.</span></span><span class="sig-name descname"><span class="pre">call_evaluate_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">evaluate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">owner</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#annotationlib.call_evaluate_function" title="Link to this definition">¶</a></dt>
<dd><p class="translated">使用给定的 <em>format</em> (<a class="reference internal" href="#annotationlib.Format" title="annotationlib.Format"><code class="xref py py-class docutils literal notranslate"><span class="pre">Format</span></code></a> 枚举的成员) 调用 <a class="reference internal" href="../glossary.html#term-evaluate-function"><span class="xref std std-term">evaluate function</span></a> <em>evaluate</em>，并返回该函数生成的值。 这与 <a class="reference internal" href="#annotationlib.call_annotate_function" title="annotationlib.call_annotate_function"><code class="xref py py-func docutils literal notranslate"><span class="pre">call_annotate_function()</span></code></a> 类似，但后者始终返回一个将字符串映射到注解的字典，而此函数返回单个值。</p>
<p class="translated">此功能旨在与为类型别名和类型参数相关的延迟求值元素生成的求值函数一起使用：</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="typing.html#typing.TypeAliasType.evaluate_value" title="typing.TypeAliasType.evaluate_value"><code class="xref py py-meth docutils literal notranslate"><span class="pre">typing.TypeAliasType.evaluate_value()</span></code></a>，类型别名的值</p></li>
<li><p class="translated"><a class="reference internal" href="typing.html#typing.TypeVar.evaluate_bound" title="typing.TypeVar.evaluate_bound"><code class="xref py py-meth docutils literal notranslate"><span class="pre">typing.TypeVar.evaluate_bound()</span></code></a>，类型变量的边界</p></li>
<li><p class="translated"><a class="reference internal" href="typing.html#typing.TypeVar.evaluate_constraints" title="typing.TypeVar.evaluate_constraints"><code class="xref py py-meth docutils literal notranslate"><span class="pre">typing.TypeVar.evaluate_constraints()</span></code></a>，类型变量的约束</p></li>
<li><p class="translated"><a class="reference internal" href="typing.html#typing.TypeVar.evaluate_default" title="typing.TypeVar.evaluate_default"><code class="xref py py-meth docutils literal notranslate"><span class="pre">typing.TypeVar.evaluate_default()</span></code></a>，类型变量的默认值</p></li>
<li><p class="translated"><a class="reference internal" href="typing.html#typing.ParamSpec.evaluate_default" title="typing.ParamSpec.evaluate_default"><code class="xref py py-meth docutils literal notranslate"><span class="pre">typing.ParamSpec.evaluate_default()</span></code></a>，形参规格的默认值</p></li>
<li><p class="translated"><a class="reference internal" href="typing.html#typing.TypeVarTuple.evaluate_default" title="typing.TypeVarTuple.evaluate_default"><code class="xref py py-meth docutils literal notranslate"><span class="pre">typing.TypeVarTuple.evaluate_default()</span></code></a>，类型变量元组的默认值</p></li>
</ul>
<p class="translated"><em>owner</em> 是拥有求值函数的对象，例如类型别名或类型变量对象。</p>
<p class="translated"><em>format</em> 可用于控制返回值的格式：</p>
<div class="translated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span> <span class="n">Alias</span> <span class="o">=</span> <span class="n">undefined</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">call_evaluate_function</span><span class="p">(</span><span class="n">Alias</span><span class="o">.</span><span class="n">evaluate_value</span><span class="p">,</span> <span class="n">Format</span><span class="o">.</span><span class="n">VALUE</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NameError</span>: <span class="n">name &#39;undefined&#39; is not defined</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">call_evaluate_function</span><span class="p">(</span><span class="n">Alias</span><span class="o">.</span><span class="n">evaluate_value</span><span class="p">,</span> <span class="n">Format</span><span class="o">.</span><span class="n">FORWARDREF</span><span class="p">)</span>
<span class="go">ForwardRef(&#39;undefined&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">call_evaluate_function</span><span class="p">(</span><span class="n">Alias</span><span class="o">.</span><span class="n">evaluate_value</span><span class="p">,</span> <span class="n">Format</span><span class="o">.</span><span class="n">STRING</span><span class="p">)</span>
<span class="go">&#39;undefined&#39;</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="annotationlib.get_annotate_from_class_namespace">
<span class="sig-prename descclassname"><span class="pre">annotationlib.</span></span><span class="sig-name descname"><span class="pre">get_annotate_from_class_namespace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">namespace</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#annotationlib.get_annotate_from_class_namespace" title="Link to this definition">¶</a></dt>
<dd><p class="translated">从类命名空间字典 <em>namespace</em> 中检索 <a class="reference internal" href="../glossary.html#term-annotate-function"><span class="xref std std-term">annotate function</span></a>。 如果命名空间中不包含注解函数，则返回 <code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code>。这在类完全创建之前（例如在元类中）特别有用；类创建后，可以通过 <code class="docutils literal notranslate"><span class="pre">cls.__annotate__</span></code> 检索注解函数。有关在元类中使用此函数的示例，请参阅 <a class="reference internal" href="#annotationlib-metaclass"><span class="std std-ref">下文</span></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="annotationlib.get_annotations">
<span class="sig-prename descclassname"><span class="pre">annotationlib.</span></span><span class="sig-name descname"><span class="pre">get_annotations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">globals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">locals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eval_str</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">Format.VALUE</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#annotationlib.get_annotations" title="Link to this definition">¶</a></dt>
<dd><p class="translated">计算一个对象的标注字典。</p>
<p class="translated"><em>obj</em> 可以是可调用对象、类、模块或其他具有 <a class="reference internal" href="../reference/datamodel.html#object.__annotate__" title="object.__annotate__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotate__</span></code></a> 或 <a class="reference internal" href="../reference/datamodel.html#object.__annotations__" title="object.__annotations__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code></a> 属性的对象。传递任何其他对象会引发 <a class="reference internal" href="exceptions.html#TypeError" title="TypeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>。</p>
<p class="translated"><em>format</em> 形参控制注解的返回格式，必须是 <a class="reference internal" href="#annotationlib.Format" title="annotationlib.Format"><code class="xref py py-class docutils literal notranslate"><span class="pre">Format</span></code></a> 枚举的成员或其整数值。不同格式的工作方式如下：</p>
<ul class="simple">
<li><p class="translated">VALUE: 首先尝试使用 <code class="xref py py-attr docutils literal notranslate"><span class="pre">object.__annotations__</span></code>；如果该属性不存在，则调用 <code class="xref py py-attr docutils literal notranslate"><span class="pre">object.__annotate__</span></code> 函数（如果存在）。</p></li>
<li><p class="translated">FORWARDREF: 如果 <code class="xref py py-attr docutils literal notranslate"><span class="pre">object.__annotations__</span></code> 存在且可以成功求值，则使用它；否则，调用 <code class="xref py py-attr docutils literal notranslate"><span class="pre">object.__annotate__</span></code> 函数。如果该函数也不存在，则再次尝试使用 <code class="xref py py-attr docutils literal notranslate"><span class="pre">object.__annotations__</span></code>，并重新引发访问它时发生的任何错误。</p>
<ul>
<li><p class="translated">当调用 <code class="xref py py-attr docutils literal notranslate"><span class="pre">object.__annotate__</span></code> 时它会先附带 <a class="reference internal" href="#annotationlib.Format.FORWARDREF" title="annotationlib.Format.FORWARDREF"><code class="xref py py-attr docutils literal notranslate"><span class="pre">FORWARDREF</span></code></a> 被调用。 如果该属性未被实现，它将再检查 <a class="reference internal" href="#annotationlib.Format.VALUE_WITH_FAKE_GLOBALS" title="annotationlib.Format.VALUE_WITH_FAKE_GLOBALS"><code class="xref py py-attr docutils literal notranslate"><span class="pre">VALUE_WITH_FAKE_GLOBALS</span></code></a> 是否受到支持并在伪全局环境中使用它。 如果这些格式均不受支持，它将回退到使用 <a class="reference internal" href="#annotationlib.Format.VALUE" title="annotationlib.Format.VALUE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">VALUE</span></code></a>。 如果 <a class="reference internal" href="#annotationlib.Format.VALUE" title="annotationlib.Format.VALUE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">VALUE</span></code></a> 失败，来自该调用的错误将被引发。</p></li>
</ul>
</li>
<li><p class="translated">STRING: 如果 <code class="xref py py-attr docutils literal notranslate"><span class="pre">object.__annotate__</span></code> 存在，则首先调用它；否则，使用 <code class="xref py py-attr docutils literal notranslate"><span class="pre">object.__annotations__</span></code> 并使用 <a class="reference internal" href="#annotationlib.annotations_to_string" title="annotationlib.annotations_to_string"><code class="xref py py-func docutils literal notranslate"><span class="pre">annotations_to_string()</span></code></a> 进行字符串化。</p>
<ul>
<li><p class="translated">当调用 <code class="xref py py-attr docutils literal notranslate"><span class="pre">object.__annotate__</span></code> 时它会先附带 <a class="reference internal" href="#annotationlib.Format.STRING" title="annotationlib.Format.STRING"><code class="xref py py-attr docutils literal notranslate"><span class="pre">STRING</span></code></a> 被调用。 如果该属性未被实现，它将再检查 <a class="reference internal" href="#annotationlib.Format.VALUE_WITH_FAKE_GLOBALS" title="annotationlib.Format.VALUE_WITH_FAKE_GLOBALS"><code class="xref py py-attr docutils literal notranslate"><span class="pre">VALUE_WITH_FAKE_GLOBALS</span></code></a> 是否受到支持并在伪全局环境中使用它。 如果这些格式均不受支持，它将回退到使用 <a class="reference internal" href="#annotationlib.Format.VALUE" title="annotationlib.Format.VALUE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">VALUE</span></code></a> 并附带使用 <a class="reference internal" href="#annotationlib.annotations_to_string" title="annotationlib.annotations_to_string"><code class="xref py py-func docutils literal notranslate"><span class="pre">annotations_to_string()</span></code></a> 转换后的结果。 如果 <a class="reference internal" href="#annotationlib.Format.VALUE" title="annotationlib.Format.VALUE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">VALUE</span></code></a> 失败，来自该调用的错误将被引发。</p></li>
</ul>
</li>
</ul>
<p class="translated">返回一个字典。<code class="xref py py-func docutils literal notranslate"><span class="pre">get_annotations()</span></code> 每次调用时都会返回一个新字典；对同一对象调用两次会返回两个不同但相等的字典。</p>
<p class="translated">该函数帮助你处理若干细节：</p>
<ul class="simple">
<li><p class="translated">如果 <em>eval_str</em> 为 True，则会使用 <a class="reference internal" href="functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 对 <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code> 类型的值进行反字符串化处理。这旨在配合字符串化的注解使用（如 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">annotations</span></code>）。将 <em>eval_str</em> 与 <a class="reference internal" href="#annotationlib.Format.VALUE" title="annotationlib.Format.VALUE"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Format.VALUE</span></code></a> 以外的格式一起设为 True 是错误的。</p></li>
<li><p class="translated">如果 <em>obj</em> 不包含一个标注字典，返回一个空字典。（函数和方法永远包含一个标注字典；类、模块和其他类型的可调用对象则可能没有。）</p></li>
<li><p class="translated">忽略类上的继承注解以及元类上的注解。如果类没有自己的注解字典，则返回空字典。</p></li>
<li><p class="translated">因安全原因，所有对于对象成员和字典值的访问将通过 <code class="docutils literal notranslate"><span class="pre">getattr()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">dict.get()</span></code> 完成。</p></li>
</ul>
<p class="translated"><em>eval_str</em> 控制是否将 <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code> 类型的值替换为对这些值调用 <a class="reference internal" href="functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 的结果：</p>
<ul class="simple">
<li><p class="translated">如果 eval_str 为 true，则会对 <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code> 类型的值调用 <a class="reference internal" href="functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a>。（注意 <code class="xref py py-func docutils literal notranslate"><span class="pre">get_annotations()</span></code> 不会捕获异常；如果 <a class="reference internal" href="functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 引发异常，它将使堆栈展开到 <code class="xref py py-func docutils literal notranslate"><span class="pre">get_annotations()</span></code> 调用之外。）</p></li>
<li><p class="translated">如果 <em>eval_str</em> 为 false（默认值），则 <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code> 类型的值保持不变。</p></li>
</ul>
<p class="translated"><em>globals</em> 和 <em>locals</em> 会被传递给 <a class="reference internal" href="functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a>；更多信息请参阅 <a class="reference internal" href="functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> 的文档。如果 <em>globals</em> 或 <em>locals</em> 为 <code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code>，此函数可能会根据 <code class="docutils literal notranslate"><span class="pre">type(obj)</span></code> 用特定于上下文的默认值替换该值：</p>
<ul class="simple">
<li><p class="translated">如果 <em>obj</em> 是一个模块，<em>globals</em> 默认使用 <code class="docutils literal notranslate"><span class="pre">obj.__dict__</span></code>。</p></li>
<li><p class="translated">如果 <em>obj</em> 是一个类，<em>globals</em> 默认使用 <code class="docutils literal notranslate"><span class="pre">sys.modules[obj.__module__].__dict__</span></code>，而 <em>locals</em> 默认使用 <em>obj</em> 类的命名空间。</p></li>
<li><p class="translated">如果 <em>obj</em> 是一个可调用对象，<em>globals</em> 默认使用 <a class="reference internal" href="../reference/datamodel.html#function.__globals__" title="function.__globals__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">obj.__globals__</span></code></a>，不过如果 <em>obj</em> 是一个包装函数（使用 <a class="reference internal" href="functools.html#functools.update_wrapper" title="functools.update_wrapper"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.update_wrapper()</span></code></a>）或 <a class="reference internal" href="functools.html#functools.partial" title="functools.partial"><code class="xref py py-class docutils literal notranslate"><span class="pre">functools.partial</span></code></a> 对象，则会对其进行解包，直到找到一个未被包装的函数为止。</p></li>
</ul>
<p class="translated">调用 <code class="xref py py-func docutils literal notranslate"><span class="pre">get_annotations()</span></code> 是访问任何对象的注解字典的最佳实践。有关注解最佳实践的更多信息，请参阅 <a class="reference internal" href="../howto/annotations.html#annotations-howto"><span class="std std-ref">注解最佳实践</span></a>。</p>
<div class="translated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_annotations</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">{&#39;a&#39;: &lt;class &#39;int&#39;&gt;, &#39;b&#39;: &lt;class &#39;str&#39;&gt;, &#39;return&#39;: &lt;class &#39;float&#39;&gt;}</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="annotationlib.type_repr">
<span class="sig-prename descclassname"><span class="pre">annotationlib.</span></span><span class="sig-name descname"><span class="pre">type_repr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#annotationlib.type_repr" title="Link to this definition">¶</a></dt>
<dd><p class="translated">将任意 Python 值转换为适合 <a class="reference internal" href="#annotationlib.Format.STRING" title="annotationlib.Format.STRING"><code class="xref py py-attr docutils literal notranslate"><span class="pre">STRING</span></code></a> 格式使用的形式。对于大多数对象，这会调用 <a class="reference internal" href="functions.html#repr" title="repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">repr()</span></code></a>，但对某些对象（如类型对象）有特殊处理。</p>
<p class="translated">这旨在作为用户提供的注解函数的辅助工具，这些函数支持 <a class="reference internal" href="#annotationlib.Format.STRING" title="annotationlib.Format.STRING"><code class="xref py py-attr docutils literal notranslate"><span class="pre">STRING</span></code></a> 格式，但无法访问创建注解的代码。它还可以用于为包含在注解中常见的值的其他对象提供用户友好的字符串表示。</p>
<div class="versionadded">
<p><span class="versionmodified added">Added in version 3.14.</span></p>
</div>
</dd></dl>

</section>
<section id="recipes">
<h2 class="translated">例程<a class="headerlink" href="#recipes" title="Link to this heading">¶</a></h2>
<section id="using-annotations-in-a-metaclass">
<span id="annotationlib-metaclass"></span><h3 class="translated">在元类中使用注解<a class="headerlink" href="#using-annotations-in-a-metaclass" title="Link to this heading">¶</a></h3>
<p class="translated"><a class="reference internal" href="../reference/datamodel.html#metaclasses"><span class="std std-ref">元类</span></a> 可能需要在类创建过程中检查甚至修改类体中的注解。实现这一需求需要从类命名空间字典中获取注解。对于使用 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">annotations</span></code> 创建的类，注解会存储在字典的 <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> 键中。而对于其他带有注解的类，可以通过 <a class="reference internal" href="#annotationlib.get_annotate_from_class_namespace" title="annotationlib.get_annotate_from_class_namespace"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_annotate_from_class_namespace()</span></code></a> 获取注释函数，再使用 <a class="reference internal" href="#annotationlib.call_annotate_function" title="annotationlib.call_annotate_function"><code class="xref py py-func docutils literal notranslate"><span class="pre">call_annotate_function()</span></code></a> 调用该函数来获取注解。通常建议优先使用 <a class="reference internal" href="#annotationlib.Format.FORWARDREF" title="annotationlib.Format.FORWARDREF"><code class="xref py py-attr docutils literal notranslate"><span class="pre">FORWARDREF</span></code></a> 格式，因为这种格式允许注解引用在类创建时尚未解析的名称。</p>
<p class="translated">要修改注解，最好创建一个包装注解函数，该函数调用原始注解函数，进行必要的调整，并返回结果。</p>
<p class="translated">下面是一个元类的示例，该元类从类中过滤掉所有 <a class="reference internal" href="typing.html#typing.ClassVar" title="typing.ClassVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">typing.ClassVar</span></code></a> 注解，并将它们放入单独的属性中：</p>
<div class="translated highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">annotationlib</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">typing</span>

<span class="k">class</span><span class="w"> </span><span class="nc">ClassVarSeparator</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
   <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="n">mcls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
      <span class="k">if</span> <span class="s2">&quot;__annotations__&quot;</span> <span class="ow">in</span> <span class="n">ns</span><span class="p">:</span>  <span class="c1"># from __future__ import annotations</span>
         <span class="n">annotations</span> <span class="o">=</span> <span class="n">ns</span><span class="p">[</span><span class="s2">&quot;__annotations__&quot;</span><span class="p">]</span>
         <span class="n">classvar_keys</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">key</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">annotations</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="c1"># 为了简单起见，可以使用字符串比较；更稳健的解决方案</span>
            <span class="c1">#  可以使用 annotationlib.ForwardRef.evaluate。</span>
            <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;ClassVar&quot;</span><span class="p">)</span>
         <span class="p">}</span>
         <span class="n">classvars</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">annotations</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">classvar_keys</span><span class="p">}</span>
         <span class="n">ns</span><span class="p">[</span><span class="s2">&quot;__annotations__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">key</span><span class="p">:</span> <span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">annotations</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">classvar_keys</span>
         <span class="p">}</span>
         <span class="n">wrapped_annotate</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="k">elif</span> <span class="n">annotate</span> <span class="o">:=</span> <span class="n">annotationlib</span><span class="o">.</span><span class="n">get_annotate_from_class_namespace</span><span class="p">(</span><span class="n">ns</span><span class="p">):</span>
         <span class="n">annotations</span> <span class="o">=</span> <span class="n">annotationlib</span><span class="o">.</span><span class="n">call_annotate_function</span><span class="p">(</span>
            <span class="n">annotate</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">annotationlib</span><span class="o">.</span><span class="n">Format</span><span class="o">.</span><span class="n">FORWARDREF</span>
         <span class="p">)</span>
         <span class="n">classvar_keys</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">key</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">annotations</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">typing</span><span class="o">.</span><span class="n">get_origin</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">is</span> <span class="n">typing</span><span class="o">.</span><span class="n">ClassVar</span>
         <span class="p">}</span>
         <span class="n">classvars</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">annotations</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">classvar_keys</span><span class="p">}</span>

         <span class="k">def</span><span class="w"> </span><span class="nf">wrapped_annotate</span><span class="p">(</span><span class="nb">format</span><span class="p">):</span>
            <span class="n">annos</span> <span class="o">=</span> <span class="n">annotationlib</span><span class="o">.</span><span class="n">call_annotate_function</span><span class="p">(</span><span class="n">annotate</span><span class="p">,</span> <span class="nb">format</span><span class="p">,</span> <span class="n">owner</span><span class="o">=</span><span class="n">typ</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">annos</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">classvar_keys</span><span class="p">}</span>

      <span class="k">else</span><span class="p">:</span>  <span class="c1"># 没有注解</span>
         <span class="n">classvars</span> <span class="o">=</span> <span class="p">{}</span>
         <span class="n">wrapped_annotate</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="n">typ</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">mcls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">ns</span><span class="p">)</span>

      <span class="k">if</span> <span class="n">wrapped_annotate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
         <span class="c1"># 将原始的 __annotate__ 函数用一个包装器包裹起来，该包装器会移除 ClassVars。</span>
         <span class="n">typ</span><span class="o">.</span><span class="n">__annotate__</span> <span class="o">=</span> <span class="n">wrapped_annotate</span>
      <span class="n">typ</span><span class="o">.</span><span class="n">classvars</span> <span class="o">=</span> <span class="n">classvars</span>  <span class="c1"># 将 ClassVars 存储在一个单独的属性中。</span>
      <span class="k">return</span> <span class="n">typ</span>
</pre></div>
</div>
</section>
</section>
<section id="limitations-of-the-string-format">
<h2 class="translated"><code class="docutils literal notranslate"><span class="pre">STRING</span></code> 格式的局限性<a class="headerlink" href="#limitations-of-the-string-format" title="Link to this heading">¶</a></h2>
<p class="translated"><a class="reference internal" href="#annotationlib.Format.STRING" title="annotationlib.Format.STRING"><code class="xref py py-attr docutils literal notranslate"><span class="pre">STRING</span></code></a> 格式的设计初衷是尽可能还原注解的源代码形式，但由于采用的实现策略限制，它并不总能精确恢复原始的源代码。</p>
<p class="translated">首先，字符串化器显然无法恢复编译后代码中不存在的任何信息，包括注释、空白符、括号结构以及被编译器简化的操作。</p>
<p class="translated">其次，字符串化器几乎可以拦截所有涉及在某个作用域中查找名称的操作，但它无法拦截完全基于常量的操作。由此推论，这也意味着在不可信代码上请求 <code class="docutils literal notranslate"><span class="pre">STRING</span></code> 格式是不安全的：Python功能强大，即使没有访问任何全局变量或内置函数，也有可能实现任意代码执行。例如：</p>
<div class="translated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">__base__</span><span class="o">.</span><span class="n">__subclasses__</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="fm">__init__</span><span class="o">.</span><span class="n">__builtins__</span><span class="p">[</span><span class="s2">&quot;print&quot;</span><span class="p">](</span><span class="s2">&quot;Hello world&quot;</span><span class="p">)):</span> <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">annotationlib</span><span class="o">.</span><span class="n">get_annotations</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">annotationlib</span><span class="o">.</span><span class="n">Format</span><span class="o">.</span><span class="n">STRING</span><span class="p">)</span>
<span class="go">Hello world</span>
<span class="go">{&#39;x&#39;: &#39;None&#39;}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p class="translated">此特定示例在撰写本文时能够正常工作，但它依赖于实现细节，并不能保证在未来版本中仍然有效。</p>
</div>
<p class="translated">在Python中存在的各种表达式中，由 <a class="reference internal" href="ast.html#module-ast" title="ast: Abstract Syntax Tree classes and manipulation."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ast</span></code></a> 模块表示，有些表达式是被支持的，这意味着 <code class="docutils literal notranslate"><span class="pre">STRING</span></code> 格式通常可以恢复原始源代码；而另一些表达式则不被支持，这可能导致输出不正确或产生错误。</p>
<p class="translated">以下类型是受支持的（有些带有额外说明）：</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="ast.html#ast.BinOp" title="ast.BinOp"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.BinOp</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="ast.html#ast.UnaryOp" title="ast.UnaryOp"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.UnaryOp</span></code></a></p>
<ul>
<li><p class="translated"><a class="reference internal" href="ast.html#ast.Invert" title="ast.Invert"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Invert</span></code></a> (<code class="docutils literal notranslate"><span class="pre">~</span></code>), <a class="reference internal" href="ast.html#ast.UAdd" title="ast.UAdd"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.UAdd</span></code></a> (<code class="docutils literal notranslate"><span class="pre">+</span></code>) 和 <a class="reference internal" href="ast.html#ast.USub" title="ast.USub"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.USub</span></code></a> (<code class="docutils literal notranslate"><span class="pre">-</span></code>) 受支持</p></li>
<li><p class="translated"><a class="reference internal" href="ast.html#ast.Not" title="ast.Not"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Not</span></code></a> (<code class="docutils literal notranslate"><span class="pre">not</span></code>) 不受支持</p></li>
</ul>
</li>
<li><p class="translated"><a class="reference internal" href="ast.html#ast.Dict" title="ast.Dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Dict</span></code></a> (当使用 <code class="docutils literal notranslate"><span class="pre">**</span></code> 解包时除外)</p></li>
<li><p class="translated"><a class="reference internal" href="ast.html#ast.Set" title="ast.Set"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Set</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="ast.html#ast.Compare" title="ast.Compare"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Compare</span></code></a></p>
<ul>
<li><p class="translated"><a class="reference internal" href="ast.html#ast.Eq" title="ast.Eq"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Eq</span></code></a> 和 <a class="reference internal" href="ast.html#ast.NotEq" title="ast.NotEq"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.NotEq</span></code></a> 受支持</p></li>
<li><p class="translated"><a class="reference internal" href="ast.html#ast.Lt" title="ast.Lt"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Lt</span></code></a>, <a class="reference internal" href="ast.html#ast.LtE" title="ast.LtE"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.LtE</span></code></a>, <a class="reference internal" href="ast.html#ast.Gt" title="ast.Gt"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Gt</span></code></a> 和 <a class="reference internal" href="ast.html#ast.GtE" title="ast.GtE"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.GtE</span></code></a> 受支持，但操作数可能被交换</p></li>
<li><p class="translated"><a class="reference internal" href="ast.html#ast.Is" title="ast.Is"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Is</span></code></a>, <a class="reference internal" href="ast.html#ast.IsNot" title="ast.IsNot"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.IsNot</span></code></a>, <a class="reference internal" href="ast.html#ast.In" title="ast.In"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.In</span></code></a> 和 <a class="reference internal" href="ast.html#ast.NotIn" title="ast.NotIn"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.NotIn</span></code></a> 不受支持</p></li>
</ul>
</li>
<li><p class="translated"><a class="reference internal" href="ast.html#ast.Call" title="ast.Call"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Call</span></code></a> (当使用 <code class="docutils literal notranslate"><span class="pre">**</span></code> 解包时除外)</p></li>
<li><p class="translated"><a class="reference internal" href="ast.html#ast.Constant" title="ast.Constant"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Constant</span></code></a> (但不是常量的准确表示形式；例如，字符串形式的转义序列会丢失；十六进制数字会被转换为十进制)</p></li>
<li><p class="translated"><a class="reference internal" href="ast.html#ast.Attribute" title="ast.Attribute"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Attribute</span></code></a> (假定其值不为常量)</p></li>
<li><p class="translated"><a class="reference internal" href="ast.html#ast.Subscript" title="ast.Subscript"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Subscript</span></code></a> (假定其值不为常量)</p></li>
<li><p class="translated"><a class="reference internal" href="ast.html#ast.Starred" title="ast.Starred"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Starred</span></code></a> (<code class="docutils literal notranslate"><span class="pre">*</span></code> 解包)</p></li>
<li><p class="translated"><a class="reference internal" href="ast.html#ast.Name" title="ast.Name"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Name</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="ast.html#ast.List" title="ast.List"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.List</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="ast.html#ast.Tuple" title="ast.Tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Tuple</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="ast.html#ast.Slice" title="ast.Slice"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Slice</span></code></a></p></li>
</ul>
<p class="translated">以下表达式不被支持，但当字符串化器遇到它们时会抛出一个具有信息性的错误：</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="ast.html#ast.FormattedValue" title="ast.FormattedValue"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.FormattedValue</span></code></a> (f-字符串；如果使用了如 <code class="docutils literal notranslate"><span class="pre">!r</span></code> 这样的转换说明符，则不会检测到错误)</p></li>
<li><p class="translated"><a class="reference internal" href="ast.html#ast.JoinedStr" title="ast.JoinedStr"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.JoinedStr</span></code></a> (f-字符串)</p></li>
</ul>
<p class="translated">以下表达式不被支持，且会导致输出不正确：</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="ast.html#ast.BoolOp" title="ast.BoolOp"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.BoolOp</span></code></a> (<code class="docutils literal notranslate"><span class="pre">and</span></code> 和 <code class="docutils literal notranslate"><span class="pre">or</span></code>)</p></li>
<li><p class="translated"><a class="reference internal" href="ast.html#ast.IfExp" title="ast.IfExp"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.IfExp</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="ast.html#ast.Lambda" title="ast.Lambda"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Lambda</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="ast.html#ast.ListComp" title="ast.ListComp"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.ListComp</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="ast.html#ast.SetComp" title="ast.SetComp"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.SetComp</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="ast.html#ast.DictComp" title="ast.DictComp"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.DictComp</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="ast.html#ast.GeneratorExp" title="ast.GeneratorExp"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.GeneratorExp</span></code></a></p></li>
</ul>
<p class="translated">以下内容在注解作用域中不被允许，因此不予考虑：</p>
<ul class="simple">
<li><p class="translated"><a class="reference internal" href="ast.html#ast.NamedExpr" title="ast.NamedExpr"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.NamedExpr</span></code></a> (<code class="docutils literal notranslate"><span class="pre">:=</span></code>)</p></li>
<li><p class="translated"><a class="reference internal" href="ast.html#ast.Await" title="ast.Await"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Await</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="ast.html#ast.Yield" title="ast.Yield"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.Yield</span></code></a></p></li>
<li><p class="translated"><a class="reference internal" href="ast.html#ast.YieldFrom" title="ast.YieldFrom"><code class="xref py py-class docutils literal notranslate"><span class="pre">ast.YieldFrom</span></code></a></p></li>
</ul>
</section>
<section id="limitations-of-the-forwardref-format">
<h2 class="translated"><code class="docutils literal notranslate"><span class="pre">FORWARDREF</span></code> 格式的局限性<a class="headerlink" href="#limitations-of-the-forwardref-format" title="Link to this heading">¶</a></h2>
<p class="translated"><a class="reference internal" href="#annotationlib.Format.FORWARDREF" title="annotationlib.Format.FORWARDREF"><code class="xref py py-attr docutils literal notranslate"><span class="pre">FORWARDREF</span></code></a> 格式旨在尽可能生成实际值，对于无法解析的内容则用 <a class="reference internal" href="#annotationlib.ForwardRef" title="annotationlib.ForwardRef"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForwardRef</span></code></a> 对象替代。该格式受到的限制与 <a class="reference internal" href="#annotationlib.Format.STRING" title="annotationlib.Format.STRING"><code class="xref py py-attr docutils literal notranslate"><span class="pre">STRING</span></code></a> 格式基本相同：当使用 <a class="reference internal" href="#annotationlib.Format.FORWARDREF" title="annotationlib.Format.FORWARDREF"><code class="xref py py-attr docutils literal notranslate"><span class="pre">FORWARDREF</span></code></a> 格式求值时，若注解包含对字面值的操作或使用了不支持的表达式类型，可能会引发异常。</p>
<p class="translated">以下是使用不支持的表达式时的行为示例：</p>
<div class="translated highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">annotationlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_annotations</span><span class="p">,</span> <span class="n">Format</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">zerodiv</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span><span class="p">):</span> <span class="o">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_annotations</span><span class="p">(</span><span class="n">zerodiv</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">Format</span><span class="o">.</span><span class="n">STRING</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">ZeroDivisionError</span>: <span class="n">division by zero</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_annotations</span><span class="p">(</span><span class="n">zerodiv</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">Format</span><span class="o">.</span><span class="n">FORWARDREF</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">ZeroDivisionError</span>: <span class="n">division by zero</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">ifexp</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">y</span> <span class="k">else</span> <span class="mi">0</span><span class="p">):</span> <span class="o">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_annotations</span><span class="p">(</span><span class="n">ifexp</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">Format</span><span class="o">.</span><span class="n">STRING</span><span class="p">)</span>
<span class="go">{&#39;x&#39;: &#39;1&#39;}</span>
</pre></div>
</div>
</section>
<section id="security-implications-of-introspecting-annotations">
<span id="annotationlib-security"></span><h2 class="translated">内省标注的安全意义<a class="headerlink" href="#security-implications-of-introspecting-annotations" title="Link to this heading">¶</a></h2>
<p class="translated">本模块的大部分功能涉及执行与注解相关的代码，这些代码可能执行任意操作。例如，<a class="reference internal" href="#annotationlib.get_annotations" title="annotationlib.get_annotations"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_annotations()</span></code></a> 可能调用任意的 <a class="reference internal" href="../glossary.html#term-annotate-function"><span class="xref std std-term">annotate function</span></a>，而 <a class="reference internal" href="#annotationlib.ForwardRef.evaluate" title="annotationlib.ForwardRef.evaluate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ForwardRef.evaluate()</span></code></a> 可能对任意字符串调用 <a class="reference internal" href="functions.html#eval" title="eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a>。注解中包含的代码可能进行任意的系统调用、进入无限循环或执行任何其他操作。对于任何访问 <a class="reference internal" href="../reference/datamodel.html#object.__annotations__" title="object.__annotations__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__annotations__</span></code></a> 属性的操作，以及 <a class="reference internal" href="typing.html#module-typing" title="typing: Support for type hints (see :pep:`484`)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">typing</span></code></a> 模块中处理注解的各种函数（如 <a class="reference internal" href="typing.html#typing.get_type_hints" title="typing.get_type_hints"><code class="xref py py-func docutils literal notranslate"><span class="pre">typing.get_type_hints()</span></code></a>）也是如此。</p>
<p class="translated">由此产生的任何安全问题同样适用于导入可能包含不受信任注解的代码后立即执行的情况：导入代码始终可能导致执行任意操作。然而，接受来自不受信任来源的字符串或其他输入并将其传递给任何用于内省注解的 API 是不安全的，例如通过编辑 <code class="docutils literal notranslate"><span class="pre">__annotations__</span></code> 字典或直接创建 <a class="reference internal" href="#annotationlib.ForwardRef" title="annotationlib.ForwardRef"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForwardRef</span></code></a> 对象。</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目录</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">annotationlib</span></code> --- 用于内省标记的功能</a><ul>
<li><a class="reference internal" href="#annotation-semantics">注解语义（Annotation semantics）</a></li>
<li><a class="reference internal" href="#classes">类</a></li>
<li><a class="reference internal" href="#functions">函数</a></li>
<li><a class="reference internal" href="#recipes">例程</a><ul>
<li><a class="reference internal" href="#using-annotations-in-a-metaclass">在元类中使用注解</a></li>
</ul>
</li>
<li><a class="reference internal" href="#limitations-of-the-string-format"><code class="docutils literal notranslate"><span class="pre">STRING</span></code> 格式的局限性</a></li>
<li><a class="reference internal" href="#limitations-of-the-forwardref-format"><code class="docutils literal notranslate"><span class="pre">FORWARDREF</span></code> 格式的局限性</a></li>
<li><a class="reference internal" href="#security-implications-of-introspecting-annotations">内省标注的安全意义</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上一主题</h4>
    <p class="topless"><a href="inspect.html"
                          title="上一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">inspect</span></code> --- 检查当前对象</a></p>
  </div>
  <div>
    <h4>下一主题</h4>
    <p class="topless"><a href="site.html"
                          title="下一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">site</span></code> --- 站点专属的配置钩子</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>当前页</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">报告代码错误</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/annotationlib.rst?plain=1"
            rel="nofollow">显示源码
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="折叠边栏">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="site.html" title="site --- 站点专属的配置钩子"
             >下一页</a> |</li>
        <li class="right" >
          <a href="inspect.html" title="inspect --- 检查当前对象"
             >上一页</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.14.0 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 标准库</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="python.html" >Python 运行时服务</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">annotationlib</span></code> --- 用于内省标记的功能</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" aria-label="快速搜索" type="search" name="q" id="search-box">
          <input type="submit" value="转到">
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    主题
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>自动</option>
        <option value="light">明亮</option>
        <option value="dark">黑暗</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版权</a> 2001 Python Software Foundation.
    <br>
    本页面采用 Python 软件基金会许可证第 2 版授权。
    <br>
    文档中的示例、代码片段及其他代码内容额外采用零条款 BSD 许可证授权。
    <br>
    
      更多信息请参阅《<a href="/license.html"> 历史与许可 </a>》。<br>
    
    
    <br>

    Python 软件基金会是一家非营利性公司。
<a href="https://www.python.org/psf/donations/">请进行捐赠。</a>
<br>
    <br>
      最后更新于11月 25, 2025 (07:24 UTC) 。
    
      <a href="/bugs.html">发现了错误</a>？
    
    <br>

    使用<a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3 创建。
    </div>

  </body>
</html>